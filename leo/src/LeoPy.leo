<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="3538" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="19" left="426" height="872" width="836"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh> Diary</vh>
<v t="T2"><vh>October 2003</vh>
<v t="T3"><vh>10/21 Fixed bug in putLeadInSentinel</vh></v>
<v t="T4"><vh>10/20 Fixed name.replace bug in leoFileCommands (4.0.1 code base)</vh></v>
<v t="T5"><vh>10/16</vh>
<v t="T6"><vh>Created app.forceShutdown</vh></v>
<v t="T7"><vh>Fixed more bugs in undoReplace: all undo tests now pass</vh></v>
</v>
<v t="T8"><vh>10/15</vh>
<v t="T9"><vh>Added several plugins and scripts to leoPlugins.leo</vh></v>
<v t="T10"><vh>Removed "invalid @lineending directive" warning</vh></v>
<v t="T11"><vh>Added support so plugins can force Leo to quit during startup</vh></v>
<v t="T12"><vh>Fixed bug in removeSentinelsCommand</vh></v>
<v t="T13"><vh>Improved Go To Line Number command</vh></v>
<v t="T14"><vh>Improved confusing error message from Go To Line Number command</vh></v>
</v>
<v t="T15"><vh>10/14</vh>
<v t="T16"><vh>Added redirect_execute_script_output_to_log_pane setting</vh></v>
<v t="T17"><vh>Speed up clone operation by calling initAllCloneBitsInTree</vh></v>
<v t="T18"><vh>Several undo changes &amp; bug fixes</vh></v>
</v>
<v t="T19"><vh>10/13 Released 4.0 beta 4</vh></v>
<v t="T20"><vh>10/10</vh>
<v t="T21"><vh>Added var or const prefixes when importing elisp</vh></v>
<v t="T22"><vh>Added support for elisp colorising</vh></v>
<v t="T23"><vh>Fixed bug in c.clone</vh></v>
<v t="T24"><vh>Created hint messages for Extract Section &amp; Extract Section Names commands</vh></v>
<v t="T25"><vh>changed string.letters to string.ascii_letters throughout</vh></v>
<v t="T26"><vh>Fixed bug in bracket scanner</vh></v>
</v>
<v t="T27"><vh>10/9 Released 4.0 beta 3</vh>
<v t="T28"><vh>Added support for importing elisp (.el) files</vh></v>
<v t="T29"><vh>Force a complete recolor after any cut/paste or corresponding undo/redo</vh></v>
<v t="T30"><vh>Improved 4.0 version of Go To Line Number command</vh></v>
<v t="T31"><vh>Released 4.0 beta 3</vh></v>
</v>
<v t="T32"><vh>10/8</vh>
<v t="T33"><vh>Fixed long-standing clone-mark bug</vh></v>
<v t="T34"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="T35"><vh>Fixed bug in gui destroy logic</vh></v>
<v t="T36"><vh>Changed c.frame.mFileName to c.mFileName in plugins.leo</vh></v>
</v>
<v t="T37"><vh>10/7</vh>
<v t="T38"><vh>Fixed crash in sentinelName</vh></v>
<v t="T39"><vh>Added __setattr__ method to leoProxy class</vh></v>
<v t="T40"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
<v t="T41"><vh>Cleaned up version code and added build number to signon</vh></v>
</v>
<v t="T42"><vh>10/6</vh>
<v t="T43"><vh>Converted the code to use newLeoCommanderAndFrame</vh></v>
<v t="T44"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
<v t="T45"><vh>10/3 Released 4.0 beta 2</vh>
<v t="T46"><vh>Released 4.0 beta 2</vh></v>
<v t="T47"><vh>Fixed problem setting loadDir in startup logic</vh></v>
</v>
<v t="T48"><vh>10/2</vh>
<v t="T49"><vh>Still problems making Read @file Nodes undoable</vh></v>
<v t="T50"><vh>Import Derived File command is now undoable</vh></v>
<v t="T51"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="T52"><vh>Fixed bugs involving find params</vh></v>
<v t="T53"><vh>Fixed Python Import bug</vh></v>
</v>
<v t="T54"><vh>10/1</vh>
<v t="T55"><vh>Added support for two new settings affecting drags</vh></v>
<v t="T56"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="T57"><vh>Fixed Go To Outline command so it doesn't crash: More work needed.</vh></v>
<v t="T58"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="T59"><vh>Fixed @rawfile write problem</vh></v>
</v>
</v>
<v t="T60"><vh>Sept 2003</vh>
<v t="T61"><vh>9/30</vh>
<v t="T62"><vh>Removed unused v arg from writeOld/NewDerivedFiles</vh></v>
<v t="T63"><vh>Removed unused nosentinels arg from writeNewDerivedFiles</vh></v>
<v t="T64"><vh>Removed putLeadingNewlineFlag arg from putSentinel</vh></v>
<v t="T65"><vh>Renamed new scanText to scanText4</vh></v>
<v t="T66"><vh>Removed many Pychecker warnings</vh>
<v t="T67"><vh>Details</vh></v>
</v>
<v t="T68"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="T69"><vh>Created leoProxy class and simplified the code</vh></v>
</v>
<v t="T70"><vh>9/29</vh>
<v t="T71"><vh>A "gotcha" re using global app var</vh></v>
<v t="T72"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="T73"><vh>Fixed several more unicode bugs</vh></v>
<v t="T74"><vh>Removed setApp function</vh></v>
</v>
<v t="T75"><vh>9/28</vh>
<v t="T76"><vh>Added many calls to toUnicode.  Marked with 9/28/03</vh></v>
<v t="T77"><vh>trace now always prints arguments.</vh></v>
<v t="T78"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
</v>
<v t="T79"><vh>9/27 </vh>
<v t="T80"><vh>Defined dialog and icons routines in tkinterGui and leoGui</vh></v>
<v t="T81"><vh>Defined focus routines in tkinterGui and leoGui</vh></v>
<v t="T82"><vh>Replaced app.runMainLoop with app.gui.runMainLoop</vh></v>
<v t="T83"><vh>Created leoGui base class for tkinterGui class</vh></v>
<v t="T84"><vh>Moved all gui startup logic into tkingerGui class</vh></v>
</v>
<v t="T85"><vh>9/26 4.0 beta 1 released</vh>
<v t="T86"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
<v t="T87"><vh>9/22</vh>
<v t="T88"><vh>Changed leoConfig.txt so we write 3.x derived files if leoConfig.txt does not exist</vh></v>
<v t="T89"><vh>writeAll and writeMissing now return a count of the written files</vh></v>
<v t="T90"><vh>getLeoFile computes joinLists before reading derived files</vh></v>
<v t="T91"><vh>Fixed putCode so @raw test passes</vh></v>
<v t="T92"><vh>4.x code passes @delims test</vh></v>
</v>
<v t="T93"><vh>9/21</vh>
<v t="T94"><vh>Import derived file command now works for both 3.x and 4.x files</vh></v>
<v t="T95"><vh>Test @file-nosent</vh></v>
<v t="T96"><vh>Enclosed top-level read/write code in try/except</vh></v>
<v t="T97"><vh>findChild now handles bad tnodeList indices without crashing</vh></v>
<v t="T98"><vh>Fixed bugs in @+doc and @+at sentinels.</vh></v>
<v t="T99"><vh>Removed Write 3.x Outline command</vh></v>
<v t="T100"><vh>Auto-save on Write 3.x derived files.</vh></v>
<v t="T101"><vh>Put section references only if not in raw mode</vh></v>
</v>
<v t="T102"><vh>9/20 4.0 code works &amp; integrated with LeoPy.leo !!</vh>
<v t="T103"><vh>Started merging of plugin code with leoAtFile.py</vh></v>
<v t="T104"><vh>Fixed problems with @doc parts</vh></v>
<v t="T105"><vh>Write @file Nodes does auto-save if we are writing new-format files</vh></v>
<v t="T106"><vh>Changed Wirte 3.x/4x Derived File so they write multiple files</vh></v>
<v t="T107"><vh>Fixed @last bug by using same code as in 3.x</vh></v>
<v t="T108"><vh>Write 4.x Derived File command auto-saves outline</vh></v>
<v t="T109"><vh>Fixed (?) @last newline bug</vh></v>
<v t="T110"><vh>Removed all using_gnx ivars</vh></v>
<v t="T111"><vh>Write code now clears tnodeList attribute before writing</vh></v>
<v t="T112"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="T113"><vh>Removed app.use_gnx ivar</vh></v>
<v t="T114"><vh>Set using_gnx in top_df.write_all</vh></v>
<v t="T115"><vh>Created top_df.oldWrite and top_df.newWrite</vh></v>
<v t="T116"><vh>Added test for unvisited nodes in read logic</vh></v>
</v>
<v t="T117"><vh>9/19</vh>
<v t="T118"><vh>Major reorganization of leoAtFile.py</vh></v>
<v t="T119"><vh>Moved code from leoPlugins.leo to LeoPy.leo</vh></v>
<v t="T120"><vh>Tested splitting very long doc words.</vh></v>
<v t="T121"><vh>Removed @ws stuff</vh></v>
<v t="T122"><vh>Fixed bug related to @last</vh></v>
<v t="T123"><vh>Added Write 3.x Format Derived File command.</vh></v>
<v t="T124"><vh>Added Clear Recent Files command</vh></v>
<v t="T125"><vh>Added write_old_format_derived_files option</vh></v>
<v t="T126"><vh>Removed @ws stuff</vh></v>
</v>
<v t="T127"><vh>9/18</vh>
<v t="T128"><vh>Fixed some (all?) problems with tnodeList</vh></v>
<v t="T129"><vh>All files now pass the file-compare (semantic test)</vh></v>
<v t="T130"><vh>Fixed @others bug</vh></v>
</v>
<v t="T131"><vh>9/17</vh>
<v t="T132"><vh>Wrote compare script</vh></v>
<v t="T133"><vh>Wrote Import Derived File command</vh></v>
</v>
<v t="T134"><vh>9/16</vh>
<v t="T135"><vh>Changed how @ws sentinel works</vh></v>
<v t="T136"><vh>Properly indent @nl sentinels</vh></v>
<v t="T137"><vh>Fixed bugs in putting doc parts</vh></v>
<v t="T138"><vh>Fixed bugs in readLastDocLine</vh></v>
</v>
<v t="T139"><vh>9/14</vh>
<v t="T140"><vh>Added ignoreOldSentinel to warn about 3.x sentinels</vh></v>
<v t="T141"><vh>Milestone: first successful use of hidden machinery</vh></v>
<v t="T142"><vh>Added support for tnodeList tag in fileCommands.getVnode</vh></v>
<v t="T143"><vh>Rewrote createChild and renamed it to findChild</vh></v>
<v t="T144"><vh>Added check to see whether read is the same as the write.</vh></v>
<v t="T145"><vh>Added support for tnodeList</vh></v>
</v>
<v t="T146"><vh>9/13 work on 4.0 read code</vh></v>
</v>
</v>
<v t="T147"><vh> Notes</vh>
<v t="T148"><vh>Annoucnements</vh>
<v t="T149"><vh>Quote of the month</vh></v>
<v t="T150"><vh>FAQ for comp.prog.literate</vh></v>
<v t="T151"><vh>3.x announcements</vh>
<v t="T152"><vh>ANN to comp.lang.python: ANN: Leo 3.3 outlining editor</vh></v>
<v t="T153"><vh>ANN: Leo 3.5 (and 3.4) outlining editor</vh></v>
<v t="T154"><vh>ANN: Leo 3.6 outlining editor</vh></v>
<v t="T155"><vh>ANN: Leo 3.7 outlining editor</vh></v>
<v t="T156"><vh>ANN: Leo 3.8 outlining editor</vh></v>
<v t="T157"><vh>ANN: Leo 3.9 outlining editor</vh></v>
<v t="T158"><vh>ANN: Leo 3.10 outlining editor</vh></v>
<v t="T159"><vh>ANN: Leo 3.11b1 outlining editor</vh></v>
<v t="T160"><vh>ANN: Leo 3.11b3 outlining editor</vh></v>
<v t="T161"><vh>ANN: Leo 3.11b4 outlining editor</vh></v>
<v t="T162"><vh>ANN: Leo 3.11 outlining editor</vh></v>
<v t="T163"><vh>ANN: Leo 3.11.1 outlining editor</vh></v>
<v t="T164"><vh>ANN: Leo 3.12 outlining editor</vh></v>
<v t="T165"><vh>ANN: Leo 3.12 outlining editor (c.l.py)</vh></v>
</v>
<v t="T166"><vh>4.x announcements</vh>
<v t="T167"><vh>ANN: Leo 4.0 beta 1 outlining editor</vh></v>
<v t="T168"><vh>ANN: Leo 4.0 beta 2 outlining editor</vh></v>
<v t="T169"><vh>ANN: Leo 4.0 beta 3 outlining editor</vh></v>
<v t="T170"><vh>ANN: Leo 4.0 beta 4 outlining editor</vh></v>
</v>
<v t="T171"><vh>ANN: Leo 4.0 final: An outlining editor</vh></v>
</v>
<v t="T172"><vh>Distribution checklist</vh>
<v t="T173"><vh>Places to announce Leo</vh></v>
</v>
<v t="T174"><vh>How to...</vh>
<v t="T175"><vh>How to add and remove files from CVS repository</vh></v>
<v t="T176" a="C"><vh>How to add support for a new language</vh>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="T178" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt; frame</vh></v>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
<v t="T180" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="T181"><vh>&lt;&lt; actionscript keywords &gt;&gt;</vh></v>
<v t="T182"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T183"><vh>&lt;&lt; elisp keywords&gt;&gt;</vh></v>
<v t="T184"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T185"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T186"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T187"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T188"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T189"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
<v t="T190"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T191"><vh>&lt;&lt; rebol keywords &gt;&gt;</vh></v>
<v t="T192"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
</v>
</v>
<v t="T193"><vh>How to export syntax colored code preserving colors</vh></v>
<v t="T194"><vh>How to Increase environment space</vh></v>
<v t="T195"><vh>How to remove cursed newlines: use binary mode</vh>
<v t="T196"><vh>The solution</vh></v>
<v t="T197"><vh>cursed newline answer</vh></v>
<v t="T198"><vh>cursed newline answer 2</vh></v>
</v>
<v t="T199"><vh>How to run Pychecker</vh></v>
<v t="T200"><vh>How to use CVS branches</vh></v>
</v>
<v t="T201"><vh>Leo and CVS</vh>
<v t="T202"><vh>Initial post by Steven Schaefer</vh></v>
</v>
<v t="T203"><vh>Milestones</vh>
<v t="T204"><vh>02/03/02 Leo 0.08 released</vh></v>
<v t="T205"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="T206"><vh>12/16/01 Leo becomes functional</vh></v>
<v t="T207"><vh>12/13/01 Syntax coloring works</vh></v>
<v t="T208"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="T209"><vh>12/05/01 Tree works with Tkinter</vh></v>
<v t="T210"><vh>11/10/01 ** began conversion to tk</vh></v>
<v t="T211"><vh>10/26/01 First successful read of .leo file w/ @file nodes</vh></v>
<v t="T212"><vh>9/29/01 c2py: Totally in love with Python</vh></v>
<v t="T213"><vh>ca. 9/1/01 began work on wxPython version of Leo</vh></v>
</v>
<v t="T214"><vh>Promo</vh>
<v t="T215"><vh>Argument: what is Leo?</vh></v>
</v>
<v t="T216"><vh>Pychecker report for 3.11</vh></v>
<v t="T217"><vh>Python Notes &amp; HowTo's...</vh>
<v t="T218"><vh>What's new for each version:</vh>
<v t="T219"><vh>@url http://www.python.org/2.3/highlights.html</vh></v>
<v t="T220"><vh>@url http://www.amk.ca/python/2.1/</vh></v>
<v t="T221"><vh>@url http://www.amk.ca/python/2.0/</vh></v>
</v>
<v t="T222"><vh>Default values &amp; keyword arguments</vh></v>
<v t="T223"><vh>How to call any Python method from the C API</vh></v>
<v t="T224"><vh>How to run Python programs easily on NT,2K,XP</vh>
<v t="T225"><vh>setting the PATHEXT env var</vh></v>
<v t="T226"><vh>Yet another Python .bat wrapper</vh></v>
</v>
</v>
<v t="T227"><vh>Tests</vh>
<v t="T228"><vh>tuple unpacking test</vh></v>
</v>
<v t="T229"><vh>Unused code</vh>
<v t="T230"><vh>app</vh></v>
<v t="T231"><vh>app.setLeoID (not used)</vh>
<v t="T232"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
<v t="T233"><vh>&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="T234"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="T235"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
<v t="T236"><vh>Batch Files</vh>
<v t="T237"><vh>@silentfile bdist.bat</vh></v>
<v t="T238"><vh>@silentfile go.bat</vh></v>
<v t="T239"><vh>@silentfile help.bat</vh></v>
<v t="T240"><vh>@silentfile sdist.bat</vh></v>
</v>
<v t="T241"><vh>Destroy and __del__ methods</vh>
<v t="T242"><vh>(Remove all __del__ methods !!)</vh>
<v t="T243"><vh>Background</vh></v>
<v t="T244"><vh>c.__del__</vh></v>
<v t="T245"><vh>frame.__del__</vh></v>
<v t="T246"><vh>t.__del__</vh></v>
<v t="T247"><vh>v.__del__</vh></v>
<v t="T248"><vh>tree.__del__</vh></v>
</v>
<v t="T249"><vh>(Unused Destroy routines)</vh>
<v t="T250"><vh>atFile.destroy</vh></v>
<v t="T251"><vh>c.destroy</vh></v>
<v t="T252"><vh>color.destroy</vh></v>
<v t="T253"><vh>frame.destroy</vh></v>
<v t="T254"><vh>import.destroy</vh></v>
<v t="T255"><vh>leoFileCommands.destroy</vh></v>
<v t="T256"><vh>t.destroy</vh></v>
<v t="T257"><vh>tangle.destroy</vh></v>
<v t="T258"><vh>tree.destroy</vh></v>
<v t="T259"><vh>undo.destroy</vh></v>
<v t="T260"><vh>v.destroy</vh></v>
<v t="T261"><vh>&lt;&lt; destroy all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
</v>
<v t="T262"><vh>OnInsertGraphicFile</vh></v>
<v t="T263"><vh>Scripts</vh>
<v t="T264"><vh>Example scripts from scripts menu</vh>
<v t="T265"><vh>show_cwd</vh></v>
<v t="T266"><vh>importPythonFiles</vh></v>
<v t="T267"><vh>importCwebFiles</vh></v>
</v>
<v t="T268"><vh>Experimental distribution script</vh>
<v t="T269"><vh> Test</vh></v>
<v t="T270"><vh>@file distributeLeo.py</vh>
<v t="T271"><vh>__init__</vh></v>
<v t="T272"><vh>check</vh></v>
<v t="T273"><vh>copyFile</vh></v>
<v t="T274"><vh>create</vh></v>
<v t="T275"><vh>createDir</vh></v>
<v t="T276"><vh>createDistributionFolders</vh></v>
<v t="T277"><vh>createFileLists</vh></v>
<v t="T278"><vh>createZipFile</vh></v>
<v t="T279"><vh>createTarGZFile</vh></v>
<v t="T280"><vh>removeDir</vh></v>
</v>
</v>
</v>
<v t="T281"><vh>test of Python's parser module</vh></v>
</v>
<v t="T282"><vh>URL's</vh>
<v t="T283"><vh>@url file:../test/test.leo RUN TEST FILE</vh></v>
<v t="T284"><vh>@url http://subversion.tigris.org/  SVN</vh></v>
<v t="T285"><vh>Twisted url's</vh>
<v t="T286"><vh>@url http://www-106.ibm.com/developerworks/linux/library/l-twist1.html</vh></v>
<v t="T287"><vh>@url http://www-106.ibm.com/developerworks/linux/library/l-twist2.html</vh></v>
<v t="T288"><vh>@url http://www-106.ibm.com/developerworks/linux/library/l-twist3.html</vh></v>
</v>
</v>
<v t="T289"><vh>Zope &amp; collaboration info</vh>
<v t="T290"><vh>Kent Tenny Notes</vh></v>
<v t="T291"><vh>url's</vh>
<v t="T292"><vh>@url http://24.243.129.68:8080/members/sandbox</vh></v>
<v t="T293"><vh>@url http://www.zopelabs.com/cookbook</vh></v>
<v t="T294"><vh>@url http://zwiki.org/FrontPage  Zope implementation of wiki</vh></v>
</v>
<v t="T295"><vh>Collaboration &amp; Sharing</vh>
<v t="T296"><vh>From Rodrigo</vh></v>
</v>
<v t="T297"><vh>Zope</vh>
<v t="T298"><vh>From Rodrigo re: Zope.</vh></v>
<v t="T299"><vh>Clarification from Kent Tenny</vh></v>
<v t="T300"><vh>From Rodrigo re: ip</vh></v>
<v t="T301"><vh>Other servers</vh></v>
<v t="T302"><vh>Is my ip public?</vh></v>
<v t="T303"><vh>Back ends for storing/retrieving nodes: Paul Paterson</vh></v>
<v t="T304"><vh>From Paul Paterson</vh></v>
</v>
<v t="T305"><vh>Jabber</vh></v>
</v>
</v>
<v t="T306"><vh> To do...</vh>
<v t="T307"><vh>To do right after 4.0 final</vh>
<v t="T308"><vh>(4.1 reorg)</vh>
<v t="T309"><vh>To do</vh></v>
<v t="T310"><vh>@file leoTkinterFrame.py</vh></v>
<v t="T311"><vh>@file leoTkinterTree.py</vh></v>
<v t="T312"><vh>new leoFrame.py</vh>
<v t="T313"><vh>class leoBody</vh></v>
<v t="T314"><vh>class leoFrame</vh></v>
<v t="T315"><vh>class leoLog</vh></v>
</v>
</v>
<v t="T316"><vh>Cleanup Pychecker stuff</vh></v>
<v t="T317"><vh>Cleanup encoding params</vh></v>
<v t="T318"><vh>Cleanup undo logic</vh></v>
<v t="T319"><vh>Gui stuff (after 4.0 final)</vh></v>
</v>
<v t="T320"><vh>  Schedule</vh></v>
<v t="T321"><vh> Help wanted</vh>
<v t="T322"><vh>Add more unit tests to leoTests.py</vh></v>
<v t="T323" a="C"><vh>Better configuration &amp; settings</vh>
<v t="T324"><vh>Add settings menu</vh>
<v t="T325"><vh>Notes</vh></v>
<v t="T326"><vh>Cleanup prefs code?</vh></v>
</v>
<v t="T327"><vh>multiple copies of leoConfig.txt</vh>
<v t="T328"><vh>Different fonts for Linux/Mac</vh></v>
</v>
<v t="T329"><vh>Clear Recent Files command?</vh></v>
</v>
<v t="T330" a="C"><vh>Resolve Conflicts command</vh>
<v t="T331"><vh>Jonathon 1</vh></v>
<v t="T332"><vh>Jonathan 2</vh></v>
<v t="T333"><vh>Gil 1</vh></v>
<v t="T334"><vh>Gil 2</vh></v>
</v>
</v>
<v t="T335"><vh> Known bugs: can't be fixed</vh>
<v t="T336"><vh>Linux-only Bugs</vh>
<v t="T337"><vh>Possible webbrowser bug</vh></v>
<v t="T338"><vh>Fix horiz scrollbar bug when tiling horizontally</vh></v>
<v t="T339"><vh>Control-V doesn't work on Linux</vh></v>
</v>
<v t="T340"><vh>Tk bugs</vh>
<v t="T341"><vh>Caps lock affects keyboard shortcuts on Windows</vh></v>
<v t="T342"><vh>Tree problems</vh></v>
<v t="T343"><vh>Control-T can't be overridden in canvas text.</vh></v>
<v t="T344"><vh>(Alt-ctrl = Alt)</vh></v>
<v t="T345"><vh>Report Tk bugs</vh>
<v t="T346"><vh>Tk code</vh>
<v t="T347"><vh>@file c:/prog/test/leoSplitter.tcl</vh>
<v t="T348"><vh>go</vh></v>
<v t="T349"><vh>createLeo</vh></v>
<v t="T350"><vh>createMenus</vh></v>
<v t="T351"><vh>createSplitter</vh>
<v t="T352"><vh>createSplitter</vh></v>
<v t="T353"><vh>onGrabSplitterBar</vh></v>
<v t="T354"><vh>onDropSplitterBar</vh></v>
<v t="T355"><vh>onDragSplitterBar</vh></v>
<v t="T356"><vh>divideSplitter</vh></v>
</v>
<v t="T357"><vh>createFindPanel</vh>
<v t="T358"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T359"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T360"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T361"><vh>createPrefsPanel</vh>
<v t="T362"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T363"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T364"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
<v t="T365"><vh>createColorPanel</vh></v>
<v t="T366"><vh>createFontPanel</vh>
<v t="T367"><vh>&lt;&lt; create family pane &gt;&gt;</vh></v>
<v t="T368"><vh>&lt;&lt; create style pane &gt;&gt;</vh></v>
<v t="T369"><vh>&lt;&lt; create buttons &gt;&gt;</vh></v>
<v t="T370"><vh>&lt;&lt; create size pane &gt;&gt;</vh></v>
<v t="T371"><vh>&lt;&lt; create sample pane &gt;&gt;</vh></v>
</v>
<v t="T372"><vh>dkffontCreateFontPanel</vh>
<v t="T373"><vh>get_accel</vh></v>
<v t="T374"><vh>get_gap</vh></v>
<v t="T375"><vh>list_families</vh></v>
</v>
<v t="T376"><vh>createComparePanel</vh></v>
<v t="T377"><vh>createWindowWithCursor</vh></v>
<v t="T378"><vh>createWindowWithIcon</vh></v>
<v t="T379"><vh>myFrame</vh></v>
<v t="T380"><vh>tk labeled frames</vh></v>
</v>
<v t="T381"><vh>tkBugs.tcl</vh>
<v t="T382"><vh>@file c:/prog/test/tkBugs.tcl</vh>
<v t="T383"><vh>canvasBug</vh></v>
<v t="T384"><vh>bindBug</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T385"><vh>Bugs: can't recreate</vh>
<v t="T386"><vh>(Uppercase bug) (Can't recreate)</vh>
<v t="T387"><vh>Report (I can't recreate this)</vh></v>
</v>
</v>
<v t="T388"><vh>Put the setup stuff in the dist folder where they belong</vh></v>
</v>
<v t="T389"><vh> Things I'd like to see...</vh>
<v t="T390"><vh>Script based find-replace</vh></v>
<v t="T391"><vh>HTML rendering in standard Tk Text widget</vh></v>
<v t="T392"><vh>Leo in Emacs</vh></v>
</v>
<v t="T393"><vh>1. Major improvements</vh>
<v t="T394"><vh>Complete new Find/Change panel</vh>
<v t="T395"><vh>(Add script options to find/change dialog)</vh></v>
<v t="T396"><vh>Script search/script find options</vh></v>
<v t="T397"><vh>Search selected text only</vh></v>
</v>
<v t="T398"><vh>(leoGui)</vh>
<v t="T399"><vh>To do</vh>
<v t="T400"><vh>Notes</vh></v>
</v>
<v t="T401" a="C"><vh>run &amp; allies</vh>
<v t="T402"><vh>isValidPython</vh></v>
<v t="T403"><vh>computeLoadDir</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
</v>
<v t="T405"><vh>Reference code</vh>
<v t="T406"><vh>leoColor</vh>
<v t="T407"><vh>colorPanel</vh>
<v t="T408" a="C"><vh>run</vh>
<v t="T409"><vh>&lt;&lt; create color panel &gt;&gt;</vh></v>
</v>
</v>
<v t="T410"><vh>colorNamePanel</vh>
<v t="T411" a="C"><vh>run</vh>
<v t="T412"><vh>&lt;&lt; create color name panel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T413"><vh>leoCommands</vh>
<v t="T414" a="C"><vh>Edit Body Text</vh>
<v t="T415" a="C"><vh>convertAllBlanks</vh></v>
<v t="T416" a="C"><vh>convertAllTabs</vh></v>
<v t="T417"><vh>convertBlanks</vh></v>
<v t="T418"><vh>convertTabs</vh></v>
<v t="T419"><vh>createLastChildNode</vh></v>
<v t="T420"><vh>dedentBody</vh></v>
<v t="T421" a="C"><vh>extract</vh>
<v t="T422"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T427" a="C"><vh>getBodyLines</vh></v>
<v t="T428"><vh>getBodySelection</vh></v>
<v t="T429"><vh>indentBody</vh></v>
<v t="T430"><vh>reformatParagraph</vh>
<v t="T431"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T432"><vh>updateBodyPane (handles undo)</vh></v>
</v>
</v>
<v t="T433"><vh>leoCompare</vh>
<v t="T434" a="C"><vh>comparePanel.__init__</vh></v>
<v t="T435" a="C"><vh>run</vh>
<v t="T436"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T437"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="T438"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="T439"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="T442"><vh>leoDialog</vh>
<v t="T443" a="C"><vh> class leoDialog</vh>
<v t="T444"><vh>__init__ (leoDialog)</vh></v>
<v t="T445"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="T446"><vh>center</vh></v>
<v t="T447"><vh>createButtons</vh></v>
<v t="T448"><vh>createMessageFrame</vh></v>
<v t="T449"><vh>createTopFrame</vh></v>
<v t="T450"><vh>run</vh></v>
</v>
<v t="T451"><vh>createFrame and addStdButtons of all subclasses</vh></v>
</v>
<v t="T452"><vh>leoFind</vh>
<v t="T453" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T454"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
</v>
<v t="T455" a="C"><vh>find.createFrame</vh>
<v t="T456"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="T459"><vh>leoFont</vh>
<v t="T460" a="C"><vh>Birth &amp; Death</vh>
<v t="T461"><vh>fontPanel.__init__</vh></v>
<v t="T462"><vh>create_outer</vh>
<v t="T463"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; create the font pane &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; create the checkboxes &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; create the buttons &gt;&gt;</vh></v>
</v>
<v t="T467"><vh>finishCreate</vh></v>
</v>
<v t="T468" a="C"><vh>Helpers</vh>
<v t="T469"><vh>getActiveFont</vh></v>
<v t="T470"><vh>getFontSettings</vh></v>
<v t="T471"><vh>getImpliedFont</vh></v>
<v t="T472"><vh>hide</vh></v>
<v t="T473"><vh>revertIvars</vh></v>
<v t="T474"><vh>run</vh></v>
<v t="T475"><vh>setRevertVars</vh></v>
<v t="T476"><vh>showSettings</vh></v>
<v t="T477"><vh>update</vh>
<v t="T478"><vh>&lt;&lt; insert the new text in the size box &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; set the fonts in all panes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T480"><vh>leoFrame (Many)</vh>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T483" a="C"><vh>f.createLeoFrame</vh>
<v t="T484"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T485"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T487"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T488"><vh>All configuration routines</vh></v>
<v t="T489"><vh>All event handlers</vh></v>
<v t="T490"><vh>All icon convenience routines</vh></v>
<v t="T491"><vh>All menu stuff</vh></v>
<v t="T492"><vh>All splitter stuff</vh></v>
<v t="T493"><vh>All status area convenience routines</vh></v>
</v>
<v t="T494"><vh>leoGlobals</vh>
<v t="T495"><vh>All dialog utils</vh></v>
<v t="T496"><vh>All Tk.Text selection utils</vh></v>
</v>
<v t="T497"><vh>leoPrefs</vh>
<v t="T498" a="C"><vh>prefs.__init__</vh>
<v t="T499"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T500"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T501"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T178" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt; frame</vh></v>
<v t="T502"><vh>&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="T503"><vh>leoTree (Many)</vh>
<v t="T504" a="C"><vh>tree.Birth &amp; death</vh>
<v t="T505" a="C"><vh>tree.__init__</vh></v>
<v t="T506"><vh>tree.deleteBindings</vh></v>
<v t="T507"><vh>tree.deleteWidgets</vh></v>
<v t="T508" a="C"><vh>tree.injectCallbacks (class method)</vh>
<v t="T509"><vh>&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;</vh>
<v t="T510"><vh>OnBoxClick</vh></v>
<v t="T511"><vh>OnDrag</vh></v>
<v t="T512"><vh>OnEndDrag</vh></v>
<v t="T513"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T514"><vh>OnHeadlineKey</vh></v>
<v t="T515"><vh>OnHyperLinkControlClick</vh></v>
<v t="T516"><vh>OnHyperLinkEnter</vh></v>
<v t="T517"><vh>OnHyperLinkLeave</vh></v>
<v t="T518"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T519"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
<v t="T520"><vh>Most drawing routines</vh></v>
<v t="T521"><vh>Most event handlers</vh></v>
<v t="T522"><vh>All key handlers</vh></v>
<v t="T523" a="C"><vh>tree.moveUpDown</vh></v>
</v>
<v t="T524"><vh>leoUndo</vh>
<v t="T525" a="C"><vh>undoRedoText</vh>
<v t="T526"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T530"><vh>Rerwite colorizer to use jEdit language descriptionfiles</vh>
<v t="T531"><vh>Option: case insensitive keywords</vh></v>
</v>
<v t="T330" a="C"><vh>Resolve Conflicts command</vh>
<v t="T331"><vh>Jonathon 1</vh></v>
<v t="T332"><vh>Jonathan 2</vh></v>
<v t="T333"><vh>Gil 1</vh></v>
<v t="T334"><vh>Gil 2</vh></v>
</v>
<v t="T323" a="C"><vh>Better configuration &amp; settings</vh>
<v t="T324"><vh>Add settings menu</vh>
<v t="T325"><vh>Notes</vh></v>
<v t="T326"><vh>Cleanup prefs code?</vh></v>
</v>
<v t="T327"><vh>multiple copies of leoConfig.txt</vh>
<v t="T328"><vh>Different fonts for Linux/Mac</vh></v>
</v>
<v t="T329"><vh>Clear Recent Files command?</vh></v>
</v>
</v>
<v t="T532"><vh>2. Best minor improvements</vh>
<v t="T533"><vh>Use @file extension by default if no @language</vh></v>
<v t="T534"><vh>Secondary icons: use for marks?</vh></v>
</v>
<v t="T535"><vh>3. Other improvements</vh>
<v t="T536"><vh>Support @file-thin-thick-wait-now-old-new</vh></v>
<v t="T537"><vh>Disallow writes outside a "top-level" folder</vh></v>
<v t="T538"><vh>Find box</vh></v>
<v t="T539"><vh>Show diffs of changed node in top_df.read</vh></v>
<v t="T540"><vh>Note windows</vh></v>
<v t="T541"><vh>@tab, @notab (or make @tabwidth -n work again)</vh></v>
<v t="T542"><vh>@@first &lt;n&gt;</vh></v>
<v t="T543"><vh>Minimizing/maximizing windows</vh></v>
<v t="T544"><vh>Mutliple cut/paste buffers?</vh></v>
<v t="T545"><vh>Import/Export to yaml</vh></v>
<v t="T546"><vh>Meta key</vh>
<v t="T547"><vh>Comments</vh></v>
<v t="T548"><vh>Request</vh></v>
<v t="T549"><vh>From Brian Theado</vh></v>
</v>
<v t="T550"><vh>Emacs comint-mode</vh></v>
<v t="T551"><vh>Open text files in text window</vh></v>
<v t="T552"><vh>Delay converting tabs to spaces</vh></v>
<v t="T553"><vh>More support for integrated debugging (bdb plugin?)</vh></v>
<v t="T554"><vh>Calltips</vh>
<v t="T555"><vh>Study for Tooltips/Auto-completion</vh>
<v t="T556"><vh>Writing an Idle extension</vh></v>
<v t="T557"><vh>config.txt</vh></v>
<v t="T558"><vh>AutoExpand.py (idle extension)</vh>
<v t="T559"><vh>&lt;&lt; decls &gt;&gt;</vh></v>
<v t="T560"><vh>__init__</vh></v>
<v t="T561"><vh>expand_word_event</vh></v>
<v t="T562"><vh>getwords</vh></v>
<v t="T563"><vh>getprevword</vh></v>
</v>
<v t="T564"><vh>CallTips.py (idle extension)</vh>
<v t="T565"><vh>&lt;&lt; class CallTips members &gt;&gt;</vh>
<v t="T566"><vh> data members</vh></v>
<v t="T567"><vh>__init__</vh></v>
<v t="T568"><vh>close</vh></v>
<v t="T569"><vh>_make_tk_calltip_window</vh></v>
<v t="T570"><vh>_remove_calltip_window</vh></v>
<v t="T571"><vh>paren_open_event</vh></v>
<v t="T572"><vh>paren_close_event</vh></v>
<v t="T573"><vh>check_calltip_cancel_event</vh></v>
<v t="T574"><vh>calltip_cancel_event</vh></v>
<v t="T575"><vh>get_object_at_cursor</vh></v>
</v>
<v t="T576"><vh>_find_constructor</vh></v>
<v t="T577"><vh>get_arg_text</vh>
<v t="T578"><vh>&lt;&lt; set fob depending on the type of ob &gt;&gt;</vh></v>
<v t="T579"><vh>&lt;&lt; get argText for functions and lambdas &gt;&gt;</vh></v>
<v t="T580"><vh>&lt;&lt; append the docstring if it exists &gt;&gt;</vh></v>
</v>
<v t="T581"><vh>Test code</vh></v>
</v>
</v>
<v t="T582"><vh>Test</vh></v>
</v>
</v>
<v t="T583"><vh>4. Minor improvements</vh>
<v t="T584"><vh>@read-only: optional scan on entry: load node on double-click</vh></v>
<v t="T585"><vh>Delay body display so alt+arrow keys aren't slowed</vh></v>
<v t="T586"><vh>Import dialog improvements</vh></v>
<v t="T587"><vh>automatic "tab nanny" and syntax checking of Python code</vh></v>
<v t="T588"><vh>Double Click Node command</vh></v>
<v t="T589"><vh>Keep right panes constant when tiling horizontally</vh></v>
<v t="T590"><vh>LeoDocs.leo -&gt; html or latex</vh></v>
<v t="T591"><vh>suggestions</vh></v>
<v t="T592"><vh>More compare options</vh></v>
<v t="T593"><vh>do @file http &amp; @file ftp</vh></v>
<v t="T594"><vh>@dictionary</vh></v>
<v t="T595"><vh>@script executes body text</vh></v>
<v t="T596"><vh>Enhancements to extract section</vh></v>
<v t="T597"><vh>Zipped .leo files</vh></v>
</v>
<v t="T598"><vh>5. Might do, put don't count on it</vh>
<v t="T599"><vh>@template directive?</vh></v>
<v t="T600"><vh>Add slots to Leo classes</vh></v>
<v t="T601"><vh>Allow other section delims besides &lt;&lt; and &gt;&gt;</vh></v>
<v t="T602"><vh>Auto-completion (probably won't be done)</vh></v>
<v t="T603"><vh>Put up file dialog on empty @url, etc.</vh></v>
<v t="T604"><vh>Recording sessions and ways to create clones</vh></v>
<v t="T605"><vh>regex replace</vh></v>
<v t="T606"><vh>Remote access Scott Powell</vh></v>
<v t="T607"><vh>Split panes (could be done in gui plugins)</vh></v>
<v t="T608"><vh>Displaying tree structured data (code from Leo wiki)</vh>
<v t="T609"><vh>LeoInterface.py</vh></v>
<v t="T610"><vh>foldersize_leo.py</vh></v>
</v>
</v>
<v t="T611"><vh>6. Pobably never</vh>
<v t="T612"><vh>Can't do</vh>
<v t="T613"><vh>Import multiple files</vh></v>
<v t="T614"><vh>add mutex so only one copy of Leo will run</vh></v>
<v t="T615"><vh>call tips to extend headlines</vh></v>
</v>
<v t="T616"><vh>Won't do</vh>
<v t="T617"><vh>Fix Borland bugs (v2.8)</vh>
<v t="T618"><vh>Fix javadoc problem</vh></v>
<v t="T619"><vh>Contract All keeps current text pane</vh></v>
<v t="T620"><vh>Null node to clipboard:invalid outl/file </vh></v>
<v t="T621"><vh>Endless tangle with repeated @root file</vh></v>
</v>
</v>
</v>
<v t="T622"><vh>Cleanup</vh>
<v t="T623"><vh>(Convert @doc comments to doc strings)</vh>
<v t="T624"><vh>re tests</vh></v>
<v t="T625"><vh>@file ../scripts/docpart2docstring.py</vh>
<v t="T626"><vh>replaceDocPart</vh></v>
<v t="T627"><vh>replaceDocParts</vh></v>
</v>
</v>
<v t="T628"><vh>Use xml parser to read .leo files</vh></v>
<v t="T629"><vh>Reorg (Maybe)</vh>
<v t="T630"><vh>Create leoKeys.py</vh></v>
<v t="T631"><vh>Create leoEvents.py</vh></v>
<v t="T632"><vh>Create leoMenus.py</vh></v>
</v>
</v>
<v t="T633"><vh>Unit Testing: Ongoing</vh>
<v t="T634" a="C"><vh>validateOutlineWithParent</vh>
<v t="T635"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T636"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T637"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="T638" a="C"><vh>createTopologyList</vh></v>
<v t="T639"><vh>unittest urls</vh>
<v t="T640"><vh>@url http://www.python.org/doc/current/lib/module-unittest.html</vh></v>
<v t="T641"><vh>@url http://diveintopython.org/roman_divein.html</vh></v>
<v t="T642"><vh>@folder-read-only c:/Python22/Lib/Test contains many test suites</vh></v>
</v>
</v>
</v>
<v t="T643"><vh>Bugs to fix asap</vh>
<v t="T644"><vh>Urgent 4</vh>
<v t="T645"><vh>Cut/paste bug on X windows (easy)</vh>
<v t="T646"><vh>(Cut &amp; Paste ) (Middle-button bug reported by Timo)</vh>
<v t="T647"><vh> Paste bug report</vh></v>
<v t="T648"><vh> Test</vh></v>
<v t="T649" a="C"><vh>canPasteOutline</vh></v>
<v t="T650" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T651"><vh>cutOutline</vh></v>
<v t="T652"><vh>copyOutline</vh></v>
<v t="T653"><vh>pasteOutline</vh></v>
</v>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T654" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T655"><vh>bound_paragraph (TK stuff)</vh></v>
<v t="T656" a="C"><vh>getindex</vh></v>
<v t="T657"><vh>getAllText &amp; getSelectedText</vh></v>
<v t="T658" a="C"><vh>getTextSelection</vh></v>
<v t="T659"><vh>setTextSelection</vh></v>
</v>
</v>
</v>
<v t="T660"><vh>Change All bug</vh></v>
<v t="T661"><vh>(Find in current node only option)</vh>
<v t="T662"><vh>Test</vh>
<v t="T663"><vh>Search only this node in "node only" mode</vh>
<v t="T664"><vh>NewHeadline</vh></v>
</v>
<v t="T665"><vh>NewHeadline</vh></v>
</v>
<v t="T666" a="C"><vh>setConfigFindIvars</vh></v>
<v t="T667" a="C"><vh>setCommandsFindIvars</vh></v>
<v t="T453" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T454"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
</v>
<v t="T668" a="C"><vh>getFindPanelSettings</vh>
<v t="T669" a="C"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T670" a="C"><vh>putFindSettings</vh>
<v t="T671"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T672" a="C"><vh>findNextMatch</vh></v>
</v>
<v t="T673"><vh>Fix problems writing files with embedded binary characters (probably already fixed)</vh></v>
</v>
<v t="T674"><vh>Minor 6</vh>
<v t="T675"><vh>Use pywin extensions to fix cut/paste bugs</vh>
<v t="T676"><vh>Automatic select &amp; Paste bug</vh></v>
</v>
<v t="T677"><vh>Continuation problem</vh></v>
<v t="T678"><vh>(Fix Window positioning bugs)</vh>
<v t="T679"><vh>Report 1: settings not in leoConfig.leo</vh></v>
<v t="T680"><vh>Remember log/tree splitter position</vh></v>
<v t="T681"><vh>Report 2: Find in status area</vh></v>
</v>
<v t="T682"><vh>Extract bugs</vh>
<v t="T683"><vh>Reports</vh>
<v t="T684"><vh>Leading slashes are removed</vh></v>
<v t="T685"><vh>Extract Section is enabled when it should not be</vh></v>
<v t="T686"><vh>Documentation problem</vh></v>
<v t="T687"><vh>Doesn't check for complete section name</vh></v>
</v>
</v>
<v t="T688"><vh>(tab bug)</vh>
<v t="T689"><vh>Report</vh></v>
<v t="T690"><vh>Minimal test</vh></v>
<v t="T691"><vh>Test File for Non Expanding Tabs</vh></v>
</v>
<v t="T692"><vh>Import problems</vh></v>
</v>
</v>
<v t="T693"><vh>(Project Views)</vh>
<v t="T694"><vh>  Reports</vh>
<v t="T695"><vh>(Translation problems)</vh>
<v t="T696"><vh> Report</vh></v>
<v t="T697"><vh> Report 2</vh></v>
</v>
<v t="T698"><vh>(Control-T switches letters in headlines)</vh></v>
</v>
<v t="T699"><vh>  Tests</vh>
<v t="T700"><vh> Colorizing Tests</vh>
<v t="T701"><vh>(colorizing bug)</vh>
<v t="T702"><vh>report</vh></v>
<v t="T703"><vh>@file c:\prog\test\Enroll SerNum.c</vh>
<v t="T704"><vh>&lt;&lt; Defines &gt;&gt;</vh></v>
<v t="T705"><vh>&lt;&lt; Head &gt;&gt;</vh></v>
</v>
</v>
<v t="T706"><vh>C Test 1</vh></v>
<v t="T707"><vh>HTML test</vh></v>
<v t="T708"><vh>HTML2  test</vh></v>
<v t="T709"><vh>mixed tests</vh></v>
<v t="T710"><vh>php test</vh></v>
<v t="T711"><vh>python 1</vh></v>
<v t="T712"><vh>python 2</vh></v>
<v t="T713"><vh>rebol keywords</vh></v>
<v t="T714"><vh>(cweb colorizing)</vh>
<v t="T715"><vh> Bug report</vh></v>
<v t="T716"><vh> latex test</vh></v>
<v t="T717"><vh> cweb test</vh>
<v t="T718"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T719"><vh> Open With...</vh>
<v t="T720"><vh>(hook to check for conflicting Open With changes)</vh>
<v t="T721"><vh> Request</vh></v>
<v t="T722"><vh> Test</vh>
<v t="T723"><vh>@file c:\prog\test\conflictText.txt</vh></v>
</v>
</v>
</v>
</v>
<v t="T724"><vh> Abandoned &amp; Unfinished projects</vh>
<v t="T725"><vh>Abandoned projects</vh>
<v t="T726"><vh>(Positions &amp; shared tnodes) (Do not delete)</vh>
<v t="T727"><vh>(Class position)</vh>
<v t="T728"><vh>To do</vh>
<v t="T729"><vh>Write prototype code that creates vxnodes</vh></v>
<v t="T730"><vh>Write code that creates &amp; destroys clones</vh></v>
<v t="T731"><vh>Rewrite undo logic</vh></v>
<v t="T732"><vh>Write code that tests positions</vh></v>
<v t="T733"><vh>Rewrite read/write code (and use xml parser)</vh></v>
<v t="T734"><vh>Revise format of .leo files</vh></v>
</v>
<v t="T735"><vh>Notes</vh>
<v t="T736"><vh>Design notes (posting)</vh></v>
<v t="T737"><vh>About clones and links</vh></v>
</v>
<v t="T738"><vh>class position</vh>
<v t="T739"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="T740"><vh>&lt;&lt; about copying and memory allocation &gt;&gt;</vh></v>
<v t="T741"><vh>p.__init__</vh></v>
<v t="T742"><vh>p.__cmp__</vh></v>
<v t="T743"><vh>copy</vh></v>
<v t="T744"><vh>Moving within bags</vh>
<v t="T745"><vh>linkV &amp; targetV</vh></v>
<v t="T746"><vh>pop</vh></v>
<v t="T747"><vh>push</vh></v>
</v>
<v t="T748"><vh>Getters (preserve position of self)</vh>
<v t="T749"><vh>p.bodyString</vh></v>
<v t="T750"><vh>p.childIndex</vh></v>
<v t="T751"><vh>p.currentVnode</vh></v>
<v t="T752"><vh>p.exists</vh></v>
<v t="T753"><vh>p.findRoot</vh></v>
<v t="T754"><vh>p.hasBack</vh></v>
<v t="T755"><vh>p.hasChildren</vh></v>
<v t="T756"><vh>p.hasNext</vh></v>
<v t="T757"><vh>p.hasParent</vh></v>
<v t="T758"><vh>p.headString &amp; p.cleanHeadString</vh></v>
<v t="T759"><vh>p.isExpanded</vh></v>
<v t="T760"><vh>p.isValid</vh></v>
<v t="T761"><vh>p.isVisible</vh></v>
<v t="T762"><vh>p.level</vh></v>
<v t="T763"><vh>p.numberOfChildren</vh></v>
</v>
<v t="T764"><vh>Traversal routines (preserve position of self)</vh>
<v t="T765"><vh>p.back</vh></v>
<v t="T766"><vh>p.firstChild</vh></v>
<v t="T767"><vh>p.lastChild</vh></v>
<v t="T768"><vh>p.lastNode</vh></v>
<v t="T769"><vh>p.next</vh></v>
<v t="T770"><vh>p.nodeAfterTree</vh></v>
<v t="T771"><vh>p.nthChild</vh></v>
<v t="T772"><vh>p.parent</vh></v>
<v t="T773"><vh>p.threadBack</vh></v>
<v t="T774"><vh>p.threadNext</vh></v>
<v t="T775"><vh>p.visBack</vh></v>
<v t="T776"><vh>p.visNext</vh></v>
</v>
<v t="T777"><vh>Move routines (change position of self)</vh>
<v t="T778"><vh>p.finishMove</vh></v>
<v t="T779"><vh>p.moveToBack</vh></v>
<v t="T780"><vh>p.moveToFirstChild</vh></v>
<v t="T781"><vh>p.moveToLastChild</vh></v>
<v t="T782"><vh>p.moveToLastNode</vh></v>
<v t="T783"><vh>p.moveToNext</vh></v>
<v t="T784"><vh>p.moveToNodeAfterTree</vh></v>
<v t="T785"><vh>p.moveToNthChild</vh></v>
<v t="T786"><vh>p.moveToParent</vh></v>
<v t="T787"><vh>p.moveToThreadBack</vh></v>
<v t="T788"><vh>p.moveToThreadNext</vh></v>
<v t="T789"><vh>p.moveToVisBack</vh></v>
<v t="T790"><vh>p.moveToVisNext</vh></v>
</v>
</v>
</v>
<v t="T791"><vh>Tree redraw code</vh>
<v t="T792"><vh>drawVxTree</vh>
<v t="T793"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T794"><vh>drawVxNode</vh></v>
<v t="T795"><vh>drawVxText</vh></v>
</v>
<v t="T796"><vh>class vxnode</vh>
<v t="T797"><vh>&lt;&lt; about the vxnode class &gt;&gt;</vh></v>
<v t="T798"><vh>vx.__init__</vh></v>
</v>
<v t="T799"><vh>class newVnode</vh>
<v t="T800" a="C"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="T801"><vh>newv.__init__</vh></v>
</v>
</v>
<v t="T802"><vh>(Precompute mThreadNext, and maybe mThreadBack)</vh>
<v t="T803"><vh>STATISTICS for threadNext and threadBack</vh>
<v t="T804"><vh>Result of running profiler</vh></v>
</v>
<v t="T805"><vh>Code (copies: not the actual code: untested)</vh>
<v t="T806"><vh>linkAfter (copy)</vh></v>
<v t="T807"><vh>linkAsNthChild (copy)</vh></v>
<v t="T808"><vh>linkAsRoot (copy)</vh></v>
<v t="T809"><vh>unlink (copy)</vh></v>
<v t="T810"><vh>unlinkThreadLinks</vh></v>
<v t="T811"><vh>updateTheadLinks</vh></v>
<v t="T812"><vh>threadBack &amp; computeThreadBack</vh></v>
<v t="T813"><vh>threadNext &amp; computeThreadNext</vh></v>
<v t="T814"><vh>computeLastNodeForThreadBack</vh></v>
</v>
</v>
<v t="T815"><vh>(use mChildren array to represent children)</vh>
<v t="T816"><vh>Children (vnode getters)  (untested code)</vh>
<v t="T817"><vh>children (untested code)</vh></v>
<v t="T818"><vh>childIndex (untested code)</vh></v>
<v t="T819"><vh>firstChild (untested code)</vh></v>
<v t="T820"><vh>hasChildren (untested code)</vh></v>
<v t="T821"><vh>lastChild (untested code)</vh></v>
<v t="T822"><vh>nthChild (untested code)</vh></v>
<v t="T823"><vh>numberOfChildren (untested code)</vh></v>
</v>
<v t="T824"><vh>Move/Link code</vh>
<v t="T825"><vh>back (untested code)</vh></v>
<v t="T826"><vh>next (untested code)</vh></v>
<v t="T827"><vh>linkAsNthChild TO DO</vh></v>
<v t="T828"><vh>linkAfter TO DO</vh></v>
<v t="T829"><vh>unlink TO DO</vh></v>
<v t="T830"><vh>linkAsRoot (untested code)</vh>
<v t="T831"><vh>&lt;&lt; link v as the root vnode using c.frame.dummyChildren &gt;&gt;</vh></v>
<v t="T832"><vh>&lt;&lt; link v as the root vnode using mBack, mNext &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T833"><vh>Unfinished projects</vh>
<v t="T834"><vh>(Button class)</vh>
<v t="T835"><vh>Notes to Edward</vh></v>
<v t="T836"><vh>@file ButtonQ.py</vh>
<v t="T837"><vh>__init__</vh>
<v t="T838"><vh>&lt;&lt; get inputs to this method &gt;&gt;</vh></v>
<v t="T839"><vh>&lt;&lt; see if there is an ampersand in the string. &gt;&gt;</vh>
<v t="T840"><vh>&lt;&lt; handle an ampersand &gt;&gt;</vh></v>
</v>
<v t="T841"><vh>&lt;&lt; make the button with the correct text &gt;&gt;</vh></v>
<v t="T842"><vh>&lt;&lt; bind the button &gt;&gt;</vh></v>
</v>
<v t="T843"><vh>callback</vh></v>
</v>
</v>
<v t="T844"><vh>(Incremental update of screen)</vh>
<v t="T845"><vh>From Frame class</vh>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T846" a="C"><vh>Scrolling callbacks (frame)</vh></v>
</v>
<v t="T847"><vh>From Tree class</vh>
<v t="T848" a="C"><vh>drawBox (tag_bind)</vh>
<v t="T849"><vh>&lt;&lt; define onBoxClickCallback &gt;&gt;</vh></v>
</v>
<v t="T850" a="C"><vh>drawIcon (tag_bind)</vh>
<v t="T851"><vh>&lt;&lt; define icon click callbacks &gt;&gt;</vh></v>
</v>
<v t="T852" a="C"><vh>drawNode &amp; force_draw_node</vh></v>
<v t="T853" a="C"><vh>drawText (bind)</vh>
<v t="T854"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; define the headline click callbacks &gt;&gt;</vh></v>
</v>
<v t="T856" a="C"><vh>drawTree</vh>
<v t="T857"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T858" a="C"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="T859" a="C"><vh>Drawing routines (tree)...</vh>
<v t="T860"><vh>redraw</vh></v>
<v t="T861"><vh>force_redraw</vh></v>
<v t="T862"><vh>redraw_now</vh></v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T864"><vh>idle_second_redraw</vh></v>
</v>
<v t="T505" a="C"><vh>tree.__init__</vh></v>
<v t="T865" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
</v>
<v t="T873"><vh>Used only for incremental redraws</vh>
<v t="T874" a="C"><vh>allocateNodes</vh></v>
<v t="T875" a="C"><vh>allocateNodesBeforeScrolling</vh></v>
<v t="T876" a="C"><vh>setVisibleArea</vh></v>
<v t="T877" a="C"><vh>setVisibleAreaToFullCanvas</vh></v>
<v t="T878" a="C"><vh>tree.updateTree</vh></v>
</v>
</v>
<v t="T879"><vh>(Syntax coloring a la jEdit) (do not delete)</vh>
<v t="T880"><vh>Ideas for dynamic code</vh></v>
<v t="T881"><vh>New data structures</vh></v>
<v t="T882"><vh>jEdit modes</vh>
<v t="T883"><vh>tex.xml</vh>
<v t="T884"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="T885"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
<v t="T886"><vh>python.xml</vh>
<v t="T887"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="T888"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="T889"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="T890"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="T891"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="T892"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="T893"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="T894"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="T895"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T896"><vh>jEdit docs</vh>
<v t="T897"><vh>The Preamble and MODE tag</vh></v>
<v t="T898"><vh>The PROPS Tag (Leo could ignore these)</vh></v>
<v t="T899"><vh>The RULES Tag</vh></v>
</v>
</v>
<v t="T900"><vh>(vnode code to optimize moves)</vh>
<v t="T901"><vh>middleware</vh>
<v t="T902"><vh>create_dependent_trees</vh></v>
<v t="T903"><vh>destroy_dependent_trees (just unlinks them)</vh></v>
<v t="T904"><vh>move_dependent_trees_down</vh></v>
<v t="T905"><vh>move_dependent_trees_left</vh></v>
<v t="T906"><vh>move_dependent_trees_right</vh></v>
<v t="T907"><vh>move_dependent_trees_up</vh></v>
</v>
</v>
</v>
</v>
<v t="T908"><vh> Commands</vh>
<v t="T909"><vh> File menu</vh>
<v t="T910"><vh>Open With</vh>
<v t="T911"><vh>(Warn on Open With conflicts)</vh>
<v t="T912"><vh>Report: Synchronization problem</vh></v>
<v t="T913"><vh>Reply</vh></v>
</v>
<v t="T914"><vh>(Hang in Open With)</vh>
<v t="T915"><vh>Report</vh></v>
<v t="T916"><vh>Report 2 (probably fixed)</vh></v>
</v>
</v>
<v t="T917"><vh>Tangle/Untangle/Cweb/Noweb</vh>
<v t="T918"><vh>(cweb &amp; cweb hack)</vh>
<v t="T919"><vh>Original bug report</vh></v>
<v t="T920"><vh>cweb hack</vh>
<v t="T921"><vh>writing...</vh>
<v t="T922" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T923"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T924" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
</v>
<v t="T925"><vh>reading...</vh>
<v t="T926"><vh>skipSentinelStart</vh></v>
<v t="T927" a="C"><vh>sentinelKind</vh></v>
<v t="T928"><vh>nodeSentinelText</vh>
<v t="T929"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="T930" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T931" a="C"><vh>&lt;&lt; scan old ref &gt;&gt; (3.0)</vh></v>
<v t="T932" a="C"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
</v>
</v>
<v t="T933" a="C"><vh>directiveKind</vh></v>
</v>
<v t="T934"><vh>(tangle_done bug)</vh></v>
</v>
<v t="T935"><vh>Read/Write/Save</vh>
<v t="T936"><vh>(Write all cloned @file-nosent nodes with different paths)</vh>
<v t="T937"><vh>Notes</vh></v>
<v t="T938"><vh>Report &amp; reply</vh></v>
</v>
</v>
</v>
<v t="T939"><vh> Edit menu</vh>
<v t="T940"><vh>(Reformat Paragraph)</vh>
<v t="T941"><vh>tests</vh></v>
</v>
</v>
<v t="T942"><vh> Outline menu</vh>
<v t="T943"><vh>(Demote bugs)</vh></v>
<v t="T944"><vh>(fixed huge performance bug)</vh>
<v t="T945"><vh>tick statistics</vh></v>
</v>
</v>
</v>
<v t="T946"><vh> Configuration, customization, plugins &amp; prefs</vh>
<v t="T947"><vh>(Preferences &amp; config settings)</vh>
<v t="T948"><vh>7/18 Changed precedence scheme for preferences</vh></v>
</v>
</v>
<v t="T949"><vh> Directives</vh>
<v t="T950"><vh>(@first &amp; @last)</vh>
<v t="T951"><vh>theory of operation</vh></v>
</v>
<v t="T952"><vh>(@nosentinelsfile problems)</vh>
<v t="T953"><vh> Bug report &amp; resolution</vh></v>
</v>
<v t="T954"><vh>(@path changes)</vh></v>
<v t="T955"><vh>(Allow @comment after @language plain)</vh>
<v t="T956"><vh>Test</vh></v>
</v>
<v t="T957"><vh>(create_nonexistent_directories)</vh>
<v t="T958"><vh>Initial report</vh></v>
</v>
<v t="T959"><vh>(Nested @others directives )</vh>
<v t="T960"><vh>Proof that nested @others directives are valid</vh></v>
</v>
<v t="T961"><vh>(Options for @file &amp; @root)</vh>
<v t="T962"><vh>Tests</vh>
<v t="T963"><vh>@file-nosent c:\prog\test\filenosent.txt</vh>
<v t="T964"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T965"><vh>@file-noref c:\prog\test\filenoref.txt</vh>
<v t="T966"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T967"><vh>@file-asis c:\prog\test\fileasis.txt</vh>
<v t="T968"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T969"><vh>(REM_ hack and perlpod hacks)</vh>
<v t="T970"><vh>perlpod test</vh>
<v t="T971"><vh>perlpod test</vh>
<v t="T972"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T973"><vh>REM test</vh>
<v t="T974"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="T975"><vh>(Suppress @@ sentinel unless leading @ starts a directive)</vh>
<v t="T976"><vh>@file c:\prog\test\perltest.txt</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
<v t="T933" a="C"><vh>directiveKind</vh></v>
</v>
</v>
<v t="T978"><vh> Drawing</vh>
<v t="T979"><vh>(Scrollwheel) </vh></v>
<v t="T980"><vh>(Selecting scrolls partially visible headlines)</vh>
<v t="T981"><vh>Report</vh></v>
<v t="T865" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T982"><vh> Events &amp; Hooks &amp; Bindings</vh>
<v t="T983"><vh>(up-down arrows )</vh>
<v t="T984"><vh> Original proc moveUpDown</vh></v>
<v t="T985"><vh> New notes from Brian</vh></v>
<v t="T986"><vh> Request</vh></v>
<v t="T987"><vh> Test</vh></v>
<v t="T523" a="C"><vh>tree.moveUpDown</vh></v>
</v>
</v>
<v t="T988"><vh> Files &amp; Directories</vh>
<v t="T989"><vh>( Open files in  "wb" mode )</vh>
<v t="T990" a="C"><vh>openOutputFile (compare)</vh></v>
<v t="T991" a="C"><vh>update (config)</vh>
<v t="T992"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="T993" a="C"><vh>flattenOutline</vh></v>
<v t="T994" a="C"><vh>outlineToWeb</vh></v>
<v t="T995" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
<v t="T996" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T997" a="C"><vh>tangle.put_all_roots</vh>
<v t="T998"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T999"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1000"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1001"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
</v>
<v t="T1002"><vh>(@delims bug)</vh>
<v t="T1003"><vh>initial report</vh></v>
<v t="T1004"><vh>second report</vh>
<v t="T1005"><vh>&lt;&lt;intro&gt;&gt;</vh></v>
</v>
<v t="T1006" a="C"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
</v>
<v t="T1007"><vh>(Allowing collapsed XML tags)</vh>
<v t="T1008"><vh>Bug report</vh></v>
</v>
<v t="T1009"><vh>(assert 0 in putBodyPart)</vh>
<v t="T1010"><vh>@file c:\prog\test\TestRoar.txt </vh>
<v t="T1011"><vh>&lt;&lt; Raw ON &gt;&gt;</vh></v>
<v t="T1012"><vh>&lt;&lt; Raw OFF &gt;&gt;</vh></v>
<v t="T1013"><vh>&lt;&lt;Stuff&gt;&gt;</vh></v>
</v>
<v t="T933" a="C"><vh>directiveKind</vh></v>
<v t="T1014" a="C"><vh>putBodyPart</vh>
<v t="T1015"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1016"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1017"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1018"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1019"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1020"><vh>(atFile read bug)</vh></v>
<v t="T1021"><vh>(Block comment gets doubled in html)</vh>
<v t="T1022"><vh>@file c:\prog\test\htmlTest.txt</vh></v>
<v t="T1023" a="C"><vh>scanDoc</vh>
<v t="T1024"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T1025"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T1026"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T1027"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T1028"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T1029"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
</v>
<v t="T1030"><vh>(Deleting clones does not mark nodes dirty!)</vh>
<v t="T1031" a="C"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="T1032" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T1033" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="T1034" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1035"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1036"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1037" a="C"><vh>v.sortChildren</vh></v>
<v t="T1038" a="C"><vh>v.moveToNthChildOf</vh></v>
<v t="T1039" a="C"><vh>c.deleteHeadline</vh></v>
</v>
<v t="T1040"><vh>(double @root bug)</vh>
<v t="T1041"><vh>Assert fails</vh></v>
<v t="T1042"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="T1043"><vh>(Javadoc problem)</vh>
<v t="T1044"><vh>Java test</vh>
<v t="T1045"><vh>MemoryBuffer.java</vh>
<v t="T1046"><vh>&lt;&lt; MemoryBuffer declarations &gt;&gt;</vh></v>
<v t="T1047"><vh>class MemoryBuffer</vh>
<v t="T1048"><vh>&lt;&lt; class MemoryBuffer declarations &gt;&gt;</vh></v>
<v t="T1049"><vh>MemoryBuffer</vh></v>
<v t="T1050"><vh>getHeight</vh></v>
<v t="T1051"><vh>getWidth</vh></v>
<v t="T1052"><vh>negotiateDimensions</vh></v>
</v>
</v>
</v>
</v>
<v t="T1053"><vh>(missing dirty marks ) </vh>
<v t="T1033" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="T1032" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="T1054"><vh>(Partial path name problems)</vh>
<v t="T1055"><vh> Tests</vh>
<v t="T1056"><vh>@file Icons/test.txt</vh></v>
<v t="T1057"><vh>@root Icons/test2.txt</vh></v>
</v>
</v>
<v t="T1058"><vh>(Read cloned @file nodes only once)</vh>
<v t="T1059"><vh> multiple read test</vh>
<v t="T1060" a="C"><vh>@file c:\prog\test\multiple.txt</vh></v>
<v t="T1060" a="C"><vh>@file c:\prog\test\multiple.txt</vh></v>
</v>
</v>
<v t="T1061"><vh>(remarking bad @file nodes dirty)</vh></v>
<v t="T1062"><vh>(remove blank lines)</vh>
<v t="T1063" a="C"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T1064"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1065"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T930" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1066"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1067"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T1068" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1069"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1070"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1071"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1072"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1074"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1075"><vh>inAtOthers</vh></v>
<v t="T1076"><vh>isSectionName</vh></v>
<v t="T1077"><vh>putAtOthers</vh></v>
<v t="T1078"><vh>putAtOthersChild</vh></v>
<v t="T1079"><vh>putRef</vh>
<v t="T1080"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T1081"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1082" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T927" a="C"><vh>sentinelKind</vh></v>
<v t="T924" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
</v>
<v t="T1083"><vh>(Restore access modes when writing)</vh>
<v t="T1084"><vh>atFile</vh>
<v t="T1085"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
<v t="T1086"><vh>utils (for tangle)</vh>
<v t="T1087" a="C"><vh>update_file_if_changed</vh></v>
</v>
</v>
<v t="T1088"><vh>(stylesheet element in .leo files)</vh>
<v t="T1089" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1090"><vh>get routines</vh></v>
<v t="T1091"><vh>match routines</vh></v>
</v>
<v t="T1092" a="C"><vh>putProlog</vh>
<v t="T1093"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T1095" a="C"><vh>getXmlStylesheetTag</vh></v>
</v>
<v t="T1096"><vh>(subdirstest problems)</vh>
<v t="T1097"><vh>From subdirtests.leo</vh>
<v t="T1098"><vh>c:/prog/test/new does not exist</vh>
<v t="T1099"><vh>@path new @root test1.txt</vh></v>
<v t="T1100"><vh>@root new/test2.txt</vh></v>
</v>
<v t="T1101"><vh>c:/prog/test does exist</vh>
<v t="T1102"><vh>@path c:/prog/test @root test3.txt</vh></v>
<v t="T1103"><vh>@root c:/prog/test/test4.txt</vh></v>
<v t="T1104"><vh>@root test5.txt</vh></v>
</v>
</v>
<v t="T1105" a="C"><vh>setRootFromText</vh></v>
<v t="T1106" a="C"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="T1107"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1109" a="C"><vh>utils_rename</vh></v>
<v t="T1087" a="C"><vh>update_file_if_changed</vh></v>
<v t="T1110" a="C"><vh>getBaseDirectory</vh></v>
</v>
<v t="T1111"><vh>(@file-nosent buglett)</vh>
<v t="T1112"><vh>report</vh></v>
<v t="T1113"><vh>@file-nosent c:/prog/test/nosentIndentTest.txt</vh>
<v t="T1114"><vh>&lt;&lt;ref&gt;&gt;</vh></v>
</v>
<v t="T1115"><vh>Code</vh>
<v t="T1068" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1069"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1070"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1071"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1072"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1074"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1075"><vh>inAtOthers</vh></v>
<v t="T1076"><vh>isSectionName</vh></v>
<v t="T1077"><vh>putAtOthers</vh></v>
<v t="T1078"><vh>putAtOthersChild</vh></v>
<v t="T1079"><vh>putRef</vh>
<v t="T1080"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T1081"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1116" a="C"><vh>Writing (old)</vh>
<v t="T1117"><vh>Top level</vh>
<v t="T1118"><vh>atFile.rawWrite</vh>
<v t="T1119"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1121"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1122"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T1124"><vh>atFile.silentWrite</vh>
<v t="T1125"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T1126"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T1127"><vh>atFile.write</vh>
<v t="T1128"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1130"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1131"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1132"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1133"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T1134" a="C"><vh>atFile.writeAll</vh>
<v t="T1135"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1136"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1137"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="T1138"><vh>atFile.writeMissing</vh>
<v t="T1139"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T1140"><vh>&lt;&lt; create self.outputFile &gt;&gt;</vh></v>
<v t="T1141"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="T1142"><vh>Top level write helpers</vh>
<v t="T1143"><vh>atFile.closeWriteFile</vh></v>
<v t="T1144"><vh>atFile.handleWriteException</vh></v>
<v t="T1145"><vh>atFile.openWriteFile</vh></v>
<v t="T1146"><vh>atFile.putInitialComment</vh></v>
<v t="T1147"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T1148"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T1149"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T1150"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T1151"><vh>atFile.outputStringWithLineEndings</vh></v>
</v>
</v>
<v t="T1014" a="C"><vh>putBodyPart</vh>
<v t="T1015"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1016"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1017"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1018"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1019"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T1152"><vh>putDoc</vh></v>
<v t="T1153"><vh>putDocPart</vh>
<v t="T1154"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1068" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1069"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1070"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1071"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1072"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1074"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1075"><vh>inAtOthers</vh></v>
<v t="T1076"><vh>isSectionName</vh></v>
<v t="T1077"><vh>putAtOthers</vh></v>
<v t="T1078"><vh>putAtOthersChild</vh></v>
<v t="T1079"><vh>putRef</vh>
<v t="T1080"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T1081"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1155"><vh>Utils</vh>
<v t="T1156"><vh>putBuffered</vh></v>
<v t="T1082" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T922" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T923"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T1157"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T1158"><vh>putIndent</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T1159" a="C"><vh> Menus</vh>
<v t="T1160"><vh>canonicalizeShortcut</vh>
<v t="T1161"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T1162"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T1163"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T1164"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T1165"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T1166"><vh>createMenuBar</vh>
<v t="T1167"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1168"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1170"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1171"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1173"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1174" a="C"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1175"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1176"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1177"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1178"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1179"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1180"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1181"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1182"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1183"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T1184"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1185"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1186"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1187" a="C"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1188"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T1189"><vh>frame.doCommand</vh></v>
<v t="T1190"><vh>get/set/destroyMenu</vh></v>
<v t="T1191"><vh>Menu Command Handlers</vh>
<v t="T1192"><vh>File Menu</vh>
<v t="T1193"><vh>top level</vh>
<v t="T1194" a="C"><vh>OnNew</vh></v>
<v t="T1195" a="C"><vh>frame.OnOpen</vh>
<v t="T1196"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1197" a="C"><vh>frame.OnOpenWith and allies</vh>
<v t="T1198"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T1199"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="T1200"><vh>&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="T1202"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="T1203"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="T1204" a="C"><vh>frame.createOpenWithTempFile</vh>
<v t="T1205"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="T1206"><vh>frame.openWithTempFilePath</vh></v>
</v>
<v t="T1207" a="C"><vh>frame.OpenWithFileName</vh></v>
<v t="T1208"><vh>frame.OnClose</vh></v>
<v t="T1209"><vh>OnSave</vh></v>
<v t="T1210"><vh>OnSaveAs</vh></v>
<v t="T1211"><vh>OnSaveTo</vh></v>
<v t="T1212" a="C"><vh>frame.OnRevert</vh></v>
<v t="T1213"><vh>frame.OnQuit</vh></v>
<v t="T1214"><vh>frame.updateRecentFiles</vh></v>
</v>
<v t="T1215"><vh>Recent Files submenu &amp; allies</vh>
<v t="T1216"><vh>OnClearRecentFiles</vh></v>
<v t="T1217" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1218"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1219" a="C"><vh>createRecentFilesMenuItems</vh></v>
</v>
<v t="T1220"><vh>Read/Write submenu</vh>
<v t="T1221" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T1222" a="C"><vh>OnReadAtFileNodes</vh></v>
<v t="T1223"><vh>OnWriteDirtyAtFileNodes</vh></v>
<v t="T1224"><vh>OnWriteMissingAtFileNodes</vh></v>
<v t="T1225"><vh>OnWriteOutlineOnly</vh></v>
<v t="T1226" a="C"><vh>OnWriteAtFileNodes</vh></v>
<v t="T1227" a="C"><vh>4.0 Commands</vh>
<v t="T1228" a="C"><vh>OnImportDerivedFile</vh></v>
<v t="T1229"><vh>OnWriteNew/OldDerivedFiles</vh></v>
</v>
</v>
<v t="T1230"><vh>Tangle submenu</vh>
<v t="T1231"><vh>OnTangleAll</vh></v>
<v t="T1232"><vh>OnTangleMarked</vh></v>
<v t="T1233"><vh>OnTangle</vh></v>
</v>
<v t="T1234"><vh>Untangle submenu</vh>
<v t="T1235"><vh>OnUntangleAll</vh></v>
<v t="T1236"><vh>OnUntangleMarked</vh></v>
<v t="T1237"><vh>OnUntangle</vh></v>
</v>
<v t="T1238"><vh>Import&amp;Export submenu</vh>
<v t="T1239"><vh>OnExportHeadlines</vh></v>
<v t="T1240"><vh>OnFlattenOutline</vh></v>
<v t="T1241"><vh>OnImportAtRoot</vh></v>
<v t="T1242"><vh>OnImportAtFile</vh></v>
<v t="T1243"><vh>OnImportCWEBFiles</vh></v>
<v t="T1244"><vh>OnImportFlattenedOutline</vh></v>
<v t="T1245"><vh>OnImportNowebFiles</vh></v>
<v t="T1246"><vh>OnOutlineToCWEB</vh></v>
<v t="T1247"><vh>OnOutlineToNoweb</vh></v>
<v t="T1248"><vh>OnRemoveSentinels</vh></v>
<v t="T1249"><vh>OnWeave</vh></v>
</v>
</v>
<v t="T1250"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T1251"><vh>Edit top level</vh>
<v t="T1252"><vh>OnUndo</vh></v>
<v t="T1253"><vh>OnRedo</vh></v>
<v t="T1254" a="C"><vh>Cut/Copy/Paste body text</vh>
<v t="T1255"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T1256"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T1257"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
</v>
<v t="T1258"><vh>OnDelete</vh></v>
<v t="T1259" a="C"><vh>OnExecuteScript</vh>
<v t="T1260"><vh>&lt;&lt; get script into s &gt;&gt;</vh></v>
<v t="T1261"><vh>&lt;&lt; redirect output if redirect_execute_script_output_to_log_pane &gt;&gt;</vh></v>
</v>
<v t="T1262" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T1263"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T1264"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T1265"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T1266"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="T1267"><vh>&lt;&lt; set v to the node given by vnodeName and childIndex or n &gt;&gt;</vh>
<v t="T1268"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="T1269"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="T1270"><vh>&lt;&lt; set v to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="T1271"><vh>&lt;&lt; set v to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="T1272"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="T1273"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T1274"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T1275"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="T1276"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T1277"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T1278"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T1279"><vh>&lt;&lt; set vnodeName and childIndex from s &gt;&gt;</vh></v>
</v>
<v t="T1280"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="T1281"><vh>OnSelectAll</vh></v>
<v t="T1282"><vh>OnFontPanel</vh></v>
<v t="T1283"><vh>OnColorPanel</vh></v>
<v t="T1284"><vh>OnViewAllCharacters</vh></v>
<v t="T1285"><vh>OnPreferences</vh></v>
</v>
<v t="T1286"><vh>Edit Body submenu</vh>
<v t="T1287"><vh>OnConvertBlanks &amp; OnConvertAllBlanks</vh></v>
<v t="T1288"><vh>OnConvertTabs &amp; OnConvertAllTabs</vh></v>
<v t="T1289"><vh>OnDedent</vh></v>
<v t="T1290"><vh>OnExtract</vh></v>
<v t="T1291"><vh>OnExtractNames</vh></v>
<v t="T1292"><vh>OnExtractSection</vh></v>
<v t="T1293" a="C"><vh>OnFindMatchingBracket</vh>
<v t="T1294" a="C"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1295"><vh>OnIndent</vh></v>
<v t="T1296"><vh>OnInsertBody/HeadlineTime &amp; allies</vh>
<v t="T1297"><vh>getTime</vh></v>
</v>
</v>
<v t="T1298"><vh>Edit Headline submenu</vh>
<v t="T1299"><vh>OnEditHeadline</vh></v>
<v t="T1300"><vh>OnEndEditHeadline</vh></v>
<v t="T1301"><vh>OnAbortEditHeadline</vh></v>
<v t="T1302"><vh>OnToggleAngleBrackets</vh></v>
</v>
<v t="T1303"><vh>Find submenu (frame methods)</vh>
<v t="T1304"><vh>OnFindPanel</vh></v>
<v t="T1305"><vh>OnFindNext</vh></v>
<v t="T1306"><vh>OnFindPrevious</vh></v>
<v t="T1307"><vh>OnReplace</vh></v>
<v t="T1308"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T1309"><vh>Outline Menu</vh>
<v t="T1310"><vh>top level</vh>
<v t="T1311"><vh>OnCutNode</vh></v>
<v t="T1312"><vh>OnCopyNode</vh></v>
<v t="T1313"><vh>OnPasteNodee</vh></v>
<v t="T1314"><vh>OnDeleteNode</vh></v>
<v t="T1315"><vh>OnInsertNode</vh></v>
<v t="T1316"><vh>OnCloneNode</vh></v>
<v t="T1317"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T1318"><vh>Expand/Contract</vh>
<v t="T1319"><vh>No longer used</vh>
<v t="T1320"><vh>OnContractChildren (no longer used)</vh></v>
<v t="T1321"><vh>OnContractAllChildren (no longer used)</vh></v>
<v t="T1322"><vh>OnExpandAllChildren (no longer used)</vh></v>
<v t="T1323"><vh>OnExpandChildren (no longer used)</vh></v>
</v>
<v t="T1324"><vh>OnContractAll</vh></v>
<v t="T1325"><vh>OnContractNode</vh></v>
<v t="T1326"><vh>OnContractParent</vh></v>
<v t="T1327"><vh>OnExpandAll</vh></v>
<v t="T1328"><vh>OnExpandNextLevel</vh></v>
<v t="T1329"><vh>OnExpandNode</vh></v>
<v t="T1330"><vh>OnExpandPrevLevel</vh></v>
<v t="T1331"><vh>OnExpandToLevel1..9</vh></v>
</v>
<v t="T1332"><vh>Move/Select</vh>
<v t="T1333"><vh>OnMoveDownwn</vh></v>
<v t="T1334"><vh>OnMoveLeft</vh></v>
<v t="T1335"><vh>OnMoveRight</vh></v>
<v t="T1336"><vh>OnMoveUp</vh></v>
<v t="T1337"><vh>OnPromote</vh></v>
<v t="T1338"><vh>OnDemote</vh></v>
<v t="T1339"><vh>OnGoPrevVisible</vh></v>
<v t="T1340"><vh>OnGoNextVisible</vh></v>
<v t="T1341"><vh>OnGoBack</vh></v>
<v t="T1342"><vh>OnGoNext</vh></v>
</v>
<v t="T1343"><vh>Mark/Goto</vh>
<v t="T1344" a="C"><vh>OnGoPrevVisitedNode</vh></v>
<v t="T1345" a="C"><vh>OnGoNextVisitedNode</vh></v>
<v t="T1346"><vh>OnGoToFirstNode</vh></v>
<v t="T1347"><vh>OnGoToLastNode</vh></v>
<v t="T1348"><vh>OnGoToNextChanged</vh></v>
<v t="T1349"><vh>OnGoToNextClone</vh></v>
<v t="T1350"><vh>OnGoToNextMarked</vh></v>
<v t="T1351"><vh>OnGoToNextSibling</vh></v>
<v t="T1352"><vh>OnGoToParent</vh></v>
<v t="T1353"><vh>OnGoToPrevSibling</vh></v>
<v t="T1354"><vh>OnMark</vh></v>
<v t="T1355"><vh>OnMarkChangedItems</vh></v>
<v t="T1356"><vh>OnMarkChangedRoots</vh></v>
<v t="T1357"><vh>OnMarkClones</vh></v>
<v t="T1358"><vh>OnMarkSubheads</vh></v>
<v t="T1359"><vh>OnUnmarkAll</vh></v>
</v>
</v>
<v t="T1360"><vh>Window Menu</vh>
<v t="T1361"><vh>OnEqualSizedPanes</vh></v>
<v t="T1362"><vh>OnToggleActivePane</vh></v>
<v t="T1363"><vh>OnToggleSplitDirection</vh></v>
<v t="T1364"><vh>OnCascade</vh></v>
<v t="T1365"><vh>OnMinimizeAll</vh></v>
<v t="T1366"><vh>OnHideLogWindow</vh></v>
<v t="T1367"><vh>OnOpenCompareWindow</vh></v>
<v t="T1368" a="C"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1369"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="T1371"><vh>&lt;&lt; Try to open idle in pre-Python 2.3 systems&gt;&gt;</vh></v>
<v t="T1372"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
</v>
<v t="T1373"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T1374"><vh>Help Menu</vh>
<v t="T1375"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1376"><vh>OnLeoDocumentation</vh></v>
<v t="T1377"><vh>OnLeoHome</vh></v>
<v t="T1378"><vh>OnLeoHelp</vh>
<v t="T1379"><vh>showProgressBar</vh>
<v t="T1380"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
<v t="T1381"><vh>OnLeoTutorial (version number)</vh></v>
<v t="T1382"><vh>OnLeoConfig, OnApplyConfig</vh></v>
</v>
</v>
<v t="T1383" a="C"><vh>Menu Convenience Routines</vh>
<v t="T1384" a="C"><vh>createMenuEntries</vh>
<v t="T1385"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1386"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="T1391"><vh>createMenuItemsFromTable</vh></v>
<v t="T1392"><vh>createNewMenu</vh></v>
<v t="T1393" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1394"><vh>deleteMenu</vh></v>
<v t="T1395"><vh>deleteMenuItem</vh></v>
<v t="T1396"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1397"><vh>Menu enablers (Frame)</vh>
<v t="T1398"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1399"><vh>hasSelection</vh></v>
<v t="T1400"><vh>updateFileMenu</vh></v>
<v t="T1401"><vh>updateEditMenu</vh></v>
<v t="T1402"><vh>updateOutlineMenu</vh></v>
</v>
</v>
<v t="T1403"><vh>(Convenience routines for hooks)</vh>
<v t="T1404"><vh>Convenience routines that enable and disable the "idle" hook</vh>
<v t="T1405" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
</v>
<v t="T1383" a="C"><vh>Menu Convenience Routines</vh>
<v t="T1384" a="C"><vh>createMenuEntries</vh>
<v t="T1385"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1386"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="T1391"><vh>createMenuItemsFromTable</vh></v>
<v t="T1392"><vh>createNewMenu</vh></v>
<v t="T1393" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1394"><vh>deleteMenu</vh></v>
<v t="T1395"><vh>deleteMenuItem</vh></v>
<v t="T1396"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1406" a="C"><vh>file/module/plugin_date</vh></v>
<v t="T1407" a="C"><vh>plugin_signon</vh></v>
</v>
<v t="T1408"><vh>(Key handlers)</vh>
<v t="T1409" a="C"><vh>body key handlers (tree)</vh>
<v t="T1410"><vh>idle_body_key</vh>
<v t="T1411"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="T1412"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1413"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1414"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="T1415"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="T1416" a="C"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="T1417"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="T1418"><vh>onBodyChanged</vh></v>
<v t="T1419"><vh>OnBodyKey</vh></v>
<v t="T1420"><vh>onBodyWillChange</vh></v>
</v>
<v t="T1421" a="C"><vh>headline key handlers (tree)</vh>
<v t="T1422"><vh>onHeadChanged</vh></v>
<v t="T1423"><vh>OnHeadlineKey</vh></v>
<v t="T1424"><vh>idle_head_key</vh>
<v t="T1425"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="T1426"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="T1430"><vh>What doesn't work</vh></v>
</v>
<v t="T1431"><vh>(scanAllDirectives, scanDirectives, related utils)</vh>
<v t="T1432"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="T1433"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T1435"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1436"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1437"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1438"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1439"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1440"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T1441"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T1442"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1443"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1444"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T1445"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T1446" a="C"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T1447" a="C"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T1448"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="T1449"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="T1450" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T1451"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="T1452"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1453"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1454"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1455"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="T1456"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1457"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="T1458"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="T1459"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1460"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="T1461"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1462"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1463"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="T1464"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="T1465" a="C"><vh>tree.scanForTabWidth</vh>
<v t="T1466"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T1467" a="C"><vh>scanColorDirectives</vh>
<v t="T1468"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T1469"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T1470" a="C"><vh>Directive utils...</vh>
<v t="T1471"><vh>@language and @comment directives (leoUtils)</vh>
<v t="T1472"><vh>set_delims_from_language</vh></v>
<v t="T1473"><vh>set_delims_from_string</vh></v>
<v t="T1474"><vh>set_language</vh></v>
</v>
<v t="T1475"><vh>findReference</vh></v>
<v t="T1106" a="C"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="T1107"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1476"><vh>getOutputNewline</vh></v>
<v t="T1477"><vh>scanAtEncodingDirective</vh></v>
<v t="T1478"><vh>scanAtLineendingDirective</vh></v>
<v t="T1479"><vh>scanAtPagewidthDirective</vh></v>
<v t="T1480"><vh>scanAtTabwidthDirective</vh></v>
<v t="T1481" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1482"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1483"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1484"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1485"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1488"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="T1491"><vh>Tests</vh>
<v t="T1492"><vh>@rawfile c:\prog\test\rawFileTest.txt</vh>
<v t="T1493"><vh>node 1</vh></v>
<v t="T1494"><vh>node 2</vh></v>
</v>
<v t="T1495"><vh>@silentfile c:\prog\test\silentFileTest.txt</vh></v>
<v t="T1496"><vh>@root c:\prog\test\tangleTest.txt</vh>
<v t="T1497"><vh>ref</vh></v>
</v>
</v>
</v>
<v t="T1498"><vh>(Unicode)</vh>
<v t="T1499"><vh> Bug Reports</vh>
<v t="T1500"><vh> Report</vh></v>
<v t="T1501"><vh> Report 1 (not a problem)</vh></v>
<v t="T1502"><vh> Report 2 (a problem)</vh></v>
<v t="T1503"><vh>Report: not real?</vh></v>
</v>
<v t="T1504"><vh> Code</vh>
<v t="T1505"><vh> App</vh>
<v t="T1506" a="C"><vh>app.__init__</vh>
<v t="T1507"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="T1508"><vh>app.finishCreate</vh></v>
</v>
<v t="T1509"><vh>Config</vh>
<v t="T1510" a="C"><vh>update_section</vh></v>
<v t="T1511" a="C"><vh>&lt;&lt; get config options &gt;&gt;</vh></v>
<v t="T1512" a="C"><vh>&lt;&lt; convert find/change options to unicode &gt;&gt;</vh></v>
</v>
<v t="T1513"><vh>Derived files</vh>
<v t="T1514"><vh>atFile.__init__&amp; initIvars</vh></v>
<v t="T1515"><vh>Reading (old)</vh>
<v t="T1516"><vh>completeFirstDirectives (Dave Hein)</vh></v>
<v t="T1517"><vh>completeLastDirectives (Dave Hein)</vh></v>
<v t="T1518"><vh>createNthChild (3.0)</vh>
<v t="T1519"><vh>&lt;&lt; check the headlines &gt;&gt;</vh></v>
</v>
<v t="T1520"><vh>handleLinesFollowingSentinel</vh>
<v t="T1521"><vh>&lt;&lt; remove the comment delims from s &gt;&gt;</vh></v>
</v>
<v t="T1522"><vh>readLine</vh></v>
<v t="T1523"><vh>readLinesToNextSentinel</vh></v>
<v t="T1023" a="C"><vh>scanDoc</vh>
<v t="T1024"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T1025"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T1026"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T1027"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T1028"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T1029"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="T1524" a="C"><vh>scanHeader</vh>
<v t="T1525"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
<v t="T1526"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="T1527"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="T1528"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="T1529"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="T1530"><vh>scanText</vh>
<v t="T1531"><vh>&lt;&lt; put the next line into s &gt;&gt;</vh></v>
<v t="T1532"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T1533"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T1534"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v t="T1535"><vh>&lt;&lt; handle the line in s &gt;&gt;</vh>
<v t="T1536"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="T1537"><vh>&lt;&lt; handle common sentinels &gt;&gt;</vh>
<v t="T1538"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="T931" a="C"><vh>&lt;&lt; scan old ref &gt;&gt; (3.0)</vh></v>
<v t="T1539"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T1540"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T1541"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T1063" a="C"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T1064"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1065"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T930" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1066"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1067"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T1542"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v t="T1543"><vh>&lt;&lt; handle rare sentinels &gt;&gt;</vh>
<v t="T1544"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T932" a="C"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
<v t="T1545"><vh>&lt;&lt; scan @comment &gt;&gt;</vh></v>
<v t="T1006" a="C"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="T1546"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
</v>
<v t="T1547"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1116" a="C"><vh>Writing (old)</vh>
<v t="T1117"><vh>Top level</vh>
<v t="T1118"><vh>atFile.rawWrite</vh>
<v t="T1119"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1121"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1122"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T1124"><vh>atFile.silentWrite</vh>
<v t="T1125"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T1126"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T1127"><vh>atFile.write</vh>
<v t="T1128"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1130"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1131"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1132"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1133"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T1134" a="C"><vh>atFile.writeAll</vh>
<v t="T1135"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1136"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1137"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="T1138"><vh>atFile.writeMissing</vh>
<v t="T1139"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T1140"><vh>&lt;&lt; create self.outputFile &gt;&gt;</vh></v>
<v t="T1141"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="T1142"><vh>Top level write helpers</vh>
<v t="T1143"><vh>atFile.closeWriteFile</vh></v>
<v t="T1144"><vh>atFile.handleWriteException</vh></v>
<v t="T1145"><vh>atFile.openWriteFile</vh></v>
<v t="T1146"><vh>atFile.putInitialComment</vh></v>
<v t="T1147"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T1148"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T1149"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T1150"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T1151"><vh>atFile.outputStringWithLineEndings</vh></v>
</v>
</v>
<v t="T1014" a="C"><vh>putBodyPart</vh>
<v t="T1015"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1016"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1017"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1018"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1019"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T1152"><vh>putDoc</vh></v>
<v t="T1153"><vh>putDocPart</vh>
<v t="T1154"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1068" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1069"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1070"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1071"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1072"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1074"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1075"><vh>inAtOthers</vh></v>
<v t="T1076"><vh>isSectionName</vh></v>
<v t="T1077"><vh>putAtOthers</vh></v>
<v t="T1078"><vh>putAtOthersChild</vh></v>
<v t="T1079"><vh>putRef</vh>
<v t="T1080"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T1081"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1155"><vh>Utils</vh>
<v t="T1156"><vh>putBuffered</vh></v>
<v t="T1082" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T922" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T923"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T1157"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T1158"><vh>putIndent</vh></v>
</v>
</v>
<v t="T1524" a="C"><vh>scanHeader</vh>
<v t="T1525"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
<v t="T1526"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="T1527"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="T1528"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="T1529"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="T1548"><vh>putOpenLeoSentinel</vh></v>
<v t="T1082" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
</v>
<v t="T1549"><vh>Find</vh>
<v t="T1550" a="C"><vh>find.set_ivars</vh></v>
</v>
<v t="T1551"><vh>Import/Export</vh>
<v t="T1552" a="C"><vh>exportHeadlines</vh></v>
<v t="T993" a="C"><vh>flattenOutline</vh></v>
<v t="T994" a="C"><vh>outlineToWeb</vh></v>
<v t="T1553" a="C"><vh>setEncoding</vh></v>
<v t="T1554" a="C"><vh>weave</vh>
<v t="T996" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1555"><vh>&lt;&lt; write the context of v to f &gt;&gt;</vh></v>
</v>
</v>
<v t="T1556"><vh>Leo files</vh>
<v t="T1557"><vh>Reading</vh>
<v t="T1089" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1090"><vh>get routines</vh></v>
<v t="T1091"><vh>match routines</vh></v>
</v>
<v t="T1558" a="C"><vh>getXmlVersionTag</vh></v>
</v>
<v t="T1559"><vh>Writing</vh>
<v t="T1560" a="C"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T1092" a="C"><vh>putProlog</vh>
<v t="T1093"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1561"><vh>Log</vh>
<v t="T1562"><vh>log encoding</vh></v>
<v t="T1563" a="C"><vh>f.put, putnl</vh></v>
<v t="T1564" a="C"><vh>es, enl, ecnl</vh></v>
</v>
<v t="T1565"><vh>Nodes</vh>
<v t="T1566"><vh>vnode setters</vh>
<v t="T1567" a="C"><vh>Head and body text</vh>
<v t="T1568" a="C"><vh>appendStringToBody</vh></v>
<v t="T1569"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1570"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T1571"><vh>setHeadStringOrHeadline</vh></v>
</v>
</v>
<v t="T1572"><vh>tnode setters</vh>
<v t="T1573" a="C"><vh>Setting body text</vh>
<v t="T1574"><vh>setTnodeText</vh></v>
<v t="T1575"><vh>setSelection</vh></v>
</v>
</v>
</v>
<v t="T1576"><vh>Tangle</vh>
<v t="T1577" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
</v>
<v t="T1578"><vh>Undo...</vh>
<v t="T1579" a="C"><vh>setUndoTypingParams</vh>
<v t="T1580"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1581"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T525" a="C"><vh>undoRedoText</vh>
<v t="T526"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
<v t="T1582" a="C"><vh>Unicode utils...</vh>
<v t="T1583"><vh>isUnicode</vh></v>
<v t="T1584"><vh>isValidEncoding</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
<v t="T1586" a="C"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T1587"><vh>getpreferredencoding from 2.3a2</vh>
<v t="T1588"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="T1589"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1590"><vh> Notes...</vh>
<v t="T1591"><vh>Code notes: big picture</vh></v>
<v t="T1592"><vh>Code notes: encodings</vh></v>
<v t="T1593"><vh>Unicode notes (from gil)</vh></v>
<v t="T1594"><vh>Unicode design</vh>
<v t="T1595"><vh>Unicode links</vh></v>
<v t="T1596"><vh>unicode tests</vh></v>
<v t="T1597"><vh>From  Martin v. Lwis (use unicode to interface with tk)</vh></v>
<v t="T1598"><vh>Dave Hein</vh></v>
<v t="T1599"><vh>Gil Schwartz</vh></v>
<v t="T1600"><vh>Gil's long post</vh>
<v t="T1601"><vh>Internal representation</vh></v>
<v t="T1602"><vh>Encoding conversion points</vh></v>
<v t="T1603"><vh>Encoding process &amp; error handling</vh></v>
<v t="T1604"><vh>Programming considerations</vh></v>
</v>
</v>
</v>
<v t="T1605"><vh> Tests</vh>
<v t="T1606"><vh>@file-asis c:\prog\test\asisTest.txt</vh></v>
<v t="T1607"><vh>@file-nosent c:\prog\test\nosentTest.txt</vh></v>
<v t="T1608"><vh>@file-noref c:\prog\test\norefTest.txt</vh></v>
</v>
<v t="T1609"><vh> Tests</vh>
<v t="T1610"><vh>Import/export tests</vh>
<v t="T1611"><vh>test</vh>
<v t="T1612"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="T1613"><vh>@file c:/prog/test/unicodeTest.doc</vh>
<v t="T1614"><vh>New</vh></v>
</v>
</v>
<v t="T1615"><vh>( Replace getdefaultlocale)</vh>
<v t="T1616"><vh>About getdefaultlocale</vh></v>
</v>
</v>
<v t="T1617"><vh>3.11.1 projects</vh>
<v t="T1618"><vh>(Control-dragging bug)</vh>
<v t="T1619"><vh> Report</vh></v>
</v>
</v>
<v t="T1620"><vh>3.12 projects</vh>
<v t="T1621"><vh>3.12 beta 1</vh>
<v t="T1622"><vh>(@wrap and @nowrap directives)</vh>
<v t="T1623" a="C"><vh>f.setWrap</vh></v>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
</v>
<v t="T1624"><vh>(Add new panes to Leo windows)</vh>
<v t="T483" a="C"><vh>f.createLeoFrame</vh>
<v t="T484"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T485"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T487"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1625" a="C"><vh>createLeoSplitter</vh></v>
<v t="T1626" a="C"><vh>Icon area: convenience routines</vh>
<v t="T1627"><vh>createIconBar</vh></v>
<v t="T1628"><vh>hideIconBar</vh></v>
<v t="T1629"><vh>clearIconBar</vh></v>
<v t="T1630"><vh>showIconBar</vh></v>
<v t="T1631"><vh>addIconButton</vh>
<v t="T1632"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
</v>
<v t="T1633" a="C"><vh>Status line: convenience routines</vh>
<v t="T1634"><vh>createStatusLine</vh></v>
<v t="T1635"><vh>clearStatusLine</vh></v>
<v t="T1636"><vh>putStatusLine</vh></v>
<v t="T1637" a="C"><vh>updateStatusRowCol</vh></v>
</v>
</v>
<v t="T1638"><vh>(Bugs when cutting/pasting trees)</vh>
<v t="T1639"><vh>Reports</vh>
<v t="T1640"><vh>Report 1 (fixed, I think)</vh></v>
<v t="T1641"><vh>Report 2 (fixed, I think)</vh></v>
<v t="T1642"><vh>Report 3</vh></v>
</v>
<v t="T1643"><vh> Code</vh>
<v t="T1506" a="C"><vh>app.__init__</vh>
<v t="T1507"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="T650" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T651"><vh>cutOutline</vh></v>
<v t="T652"><vh>copyOutline</vh></v>
<v t="T653"><vh>pasteOutline</vh></v>
</v>
<v t="T1644"><vh>Reading</vh>
<v t="T1645" a="C"><vh>compactFileIndices</vh></v>
<v t="T1646" a="C"><vh>getLeoFile (calls setAllJoinLinks, initAllCloneBits)</vh>
<v t="T1647"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1648"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="T1649"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
</v>
<v t="T1650" a="C"><vh>finishPaste</vh>
<v t="T1651"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T1652"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T1653" a="C"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T1654" a="C"><vh>getTnodes</vh></v>
<v t="T1655" a="C"><vh>getTnode</vh>
<v t="T1656"><vh>&lt;&lt; handle read from file &gt;&gt;</vh></v>
<v t="T1657"><vh>&lt;&lt; handle read from clipboard &gt;&gt;</vh></v>
<v t="T1658"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="T1659" a="C"><vh>getVnodes</vh></v>
<v t="T1660" a="C"><vh>getVnode</vh>
<v t="T1661"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="T1662"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
</v>
</v>
<v t="T1663"><vh>Writing</vh>
<v t="T1664" a="C"><vh>assignFileIndices</vh></v>
<v t="T1665" a="C"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="T1666" a="C"><vh>v.copyTreeWithNewTnodes (new after 3.11.1) (not used at present)</vh></v>
<v t="T1667" a="C"><vh>putTnodes</vh>
<v t="T1668"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="T1669" a="C"><vh>putTnode</vh>
<v t="T1670"><vh>&lt;&lt; put unknown tnode attributes &gt;&gt;</vh></v>
</v>
<v t="T1671" a="C"><vh>putVnodes</vh></v>
</v>
</v>
</v>
<v t="T1672"><vh>(Check Clones Script)</vh>
<v t="T1673" a="C"><vh>headString &amp; cleanHeadString</vh></v>
<v t="T1674" a="C"><vh>checkClones2Links</vh>
<v t="T1675"><vh>&lt;&lt; clear statistics &gt;&gt;</vh></v>
<v t="T1676"><vh>&lt;&lt; print statistics &gt;&gt;</vh></v>
<v t="T1677"><vh>&lt;&lt; handle each item in v's join list &gt;&gt;</vh></v>
</v>
<v t="T1678"><vh>Results of running checkClones2Links on LeoPy.leo</vh></v>
</v>
<v t="T1679"><vh>(Fix memory leaks)</vh>
<v t="T1680"><vh>Initialization routines</vh>
<v t="T1506" a="C"><vh>app.__init__</vh>
<v t="T1507"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="T401" a="C"><vh>run &amp; allies</vh>
<v t="T402"><vh>isValidPython</vh></v>
<v t="T403"><vh>computeLoadDir</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
</v>
</v>
<v t="T1681"><vh>quit/open/close routines</vh>
<v t="T1682" a="C"><vh>app.destroyAllWindowObjects</vh>
<v t="T1683"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="T1684" a="C"><vh>app.closeLeoWindow</vh></v>
<v t="T1685" a="C"><vh>app.finishQuit</vh></v>
<v t="T1686" a="C"><vh>app.onQuit</vh></v>
<v t="T1195" a="C"><vh>frame.OnOpen</vh>
<v t="T1196"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1687" a="C"><vh>frame.destroyAllPanels</vh></v>
<v t="T1688" a="C"><vh>frame.promptForSave</vh>
<v t="T1689"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T1690" a="C"><vh>Garbage Collection</vh>
<v t="T1691"><vh>clearAllIvars</vh></v>
<v t="T1692"><vh>collectGarbage</vh>
<v t="T1693"><vh>&lt;&lt; make a list of the new objects &gt;&gt;</vh></v>
</v>
<v t="T1694"><vh>printGc</vh></v>
<v t="T1695"><vh>printGcRefs</vh></v>
</v>
</v>
<v t="T1696"><vh>(Hooks and plugins for user directives)</vh>
<v t="T1697" a="C"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="T1698" a="C"><vh>doHook</vh></v>
<v t="T1481" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1482"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1483"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1484"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1485"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1488"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="T1699"><vh>@file ../plugins/add_directives.py</vh>
<v t="T1700"><vh>addPluginDirectives</vh></v>
<v t="T1701"><vh>scanPluginDirectives</vh></v>
</v>
</v>
<v t="T1702"><vh>(Hooks and plugins for user markup)</vh>
<v t="T1703"><vh>Init &amp; Utils</vh>
<v t="T1704" a="C"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="T1705"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="T1706" a="C"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
<v t="T1707" a="C"><vh>color.__init__</vh>
<v t="T1708"><vh>&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;</vh></v>
<v t="T1709"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; define fonts and data for wiki tags &gt;&gt;</vh></v>
</v>
<v t="T1711" a="C"><vh>index &amp; tag</vh></v>
<v t="T1712" a="C"><vh>skip_python_string</vh></v>
</v>
<v t="T1713"><vh>Code containing "color-optional-markup" hook</vh>
<v t="T1714" a="C"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T1715" a="C"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T1716" a="C"><vh>continueDocPart</vh>
<v t="T1717"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T1718"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T1719" a="C"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T1720" a="C"><vh>continueBlockComment</vh></v>
<v t="T1721" a="C"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T1722" a="C"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
</v>
<v t="T1723"><vh> Colorizing Test</vh></v>
</v>
<v t="T1724"><vh>(Make window bigger when opening Leo from leo.py)</vh>
<v t="T1194" a="C"><vh>OnNew</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
<v t="T1725" a="C"><vh>f.setInitialWindowGeometry</vh></v>
</v>
<v t="T1726"><vh>(Nav plugin &amp; related stuff)</vh>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
<v t="T1344" a="C"><vh>OnGoPrevVisitedNode</vh></v>
<v t="T1345" a="C"><vh>OnGoNextVisitedNode</vh></v>
<v t="T1727"><vh>fillbox (recent sections)</vh>
<v t="T1728"><vh>&lt;&lt; reconstruct the contents of self.box &gt;&gt;&gt;</vh></v>
</v>
</v>
<v t="T1729"><vh>(Open With problems)</vh>
<v t="T1730"><vh>What I did</vh></v>
<v t="T1393" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1197" a="C"><vh>frame.OnOpenWith and allies</vh>
<v t="T1198"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T1199"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="T1200"><vh>&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="T1202"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="T1203"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="T1204" a="C"><vh>frame.createOpenWithTempFile</vh>
<v t="T1205"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="T1206"><vh>frame.openWithTempFilePath</vh></v>
</v>
<v t="T1384" a="C"><vh>createMenuEntries</vh>
<v t="T1385"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1386"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
</v>
<v t="T1731"><vh>(Problems with convert tabs to blanks)</vh></v>
<v t="T1732"><vh>(Rewriting joinList code)</vh>
<v t="T1733"><vh>  What I did</vh></v>
<v t="T1734"><vh> Unused code</vh>
<v t="T1735"><vh>setJoinList</vh></v>
<v t="T1736"><vh>getJoinList</vh></v>
<v t="T1737"><vh>setJoinHead</vh></v>
<v t="T1738"><vh>isOnJoinListOf</vh></v>
<v t="T1739"><vh>unjoinNode</vh></v>
<v t="T1740"><vh>unused code from atFile.read</vh>
<v t="T1741"><vh>atFile.joinTrees (NO LONGER USED)</vh></v>
<v t="T1742"><vh>&lt;&lt; Handle clone bits &gt;&gt; (no longer used)</vh></v>
<v t="T1743"><vh>&lt;&lt; Join cloned trees &gt;&gt; (no longer used)</vh></v>
</v>
</v>
<v t="T1744"><vh>Changed Code</vh>
<v t="T1745" a="C"><vh>v.joinNodeTo (rewritten for 4.0)</vh></v>
<v t="T1746" a="C"><vh>v.unjoinTree</vh></v>
</v>
<v t="T1747"><vh>Clone Tests (Sigh)</vh>
<v t="T1748" a="C"><vh>AA</vh>
<v t="T1749"><vh>BB</vh>
<v t="T1750"><vh>E</vh></v>
<v t="T1751"><vh>abc</vh></v>
</v>
<v t="T1752"><vh>CC</vh></v>
</v>
<v t="T1748" a="C"><vh>AA</vh>
<v t="T1749"><vh>BB</vh>
<v t="T1750"><vh>E</vh></v>
<v t="T1751"><vh>abc</vh></v>
</v>
<v t="T1752"><vh>CC</vh></v>
</v>
</v>
</v>
<v t="T1753"><vh>(Support for LeoN)</vh>
<v t="T1754" a="C"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh></v>
<v t="T1755"><vh>runMainLoop</vh></v>
</v>
<v t="T1756"><vh>(Using xml parser)</vh>
<v t="T1757"><vh>characters</vh></v>
<v t="T1758"><vh>endDocument</vh></v>
<v t="T1759"><vh>endElement</vh></v>
<v t="T1760"><vh>other methods</vh></v>
<v t="T1761"><vh>startDocument</vh></v>
<v t="T1762"><vh>startElement</vh></v>
</v>
<v t="T1763"><vh>(Write Dirty @file Nodes command)</vh>
<v t="T1764" a="C"><vh>writeDirtyAtFileNodes</vh></v>
<v t="T1134" a="C"><vh>atFile.writeAll</vh>
<v t="T1135"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1136"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1137"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1765"><vh>3.12 beta 2</vh>
<v t="T1766"><vh>(Added apply button to Font panel)</vh></v>
<v t="T1767"><vh>(Allow plugins to extend popup menus)</vh>
<v t="T1768"><vh>Request</vh></v>
<v t="T1769" a="C"><vh>tree.OnPopup &amp; allies</vh>
<v t="T1770"><vh>OnPopupFocusLost</vh></v>
<v t="T1771"><vh>createPopupMenu</vh>
<v t="T1772"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="T1773"><vh>enablePopupMenuItems</vh>
<v t="T1774"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="T1775"><vh>showPopupMenu</vh></v>
</v>
<v t="T1776" a="C"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
</v>
<v t="T1777"><vh>(Copy lists in OpenWith code when deleting elements when looping on the list)</vh></v>
<v t="T1778"><vh>(Double-clicking didn't work after creating new Leo window)</vh>
<v t="T1779" a="C"><vh>Event handlers (Frame)</vh>
<v t="T1780"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="T1781"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="T1782"><vh>frame.OnVisibility</vh></v>
<v t="T1783"><vh>OnActivateBody</vh></v>
<v t="T1784"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="T1785"><vh>OnActivateLog</vh></v>
<v t="T1786"><vh>OnActivateTree</vh></v>
<v t="T1787"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="T1788"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="T1789" a="C"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="T1790" a="C"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T1791" a="C"><vh>Focus (leoGlobals)</vh></v>
<v t="T1792" a="C"><vh>Selecting &amp; editing (tree)</vh>
<v t="T1793"><vh>abortEditLabelCommand</vh></v>
<v t="T1794"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T1795" a="C"><vh>editLabel</vh></v>
<v t="T1796"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1797"><vh>tree.expandAllAncestors</vh></v>
<v t="T1465" a="C"><vh>tree.scanForTabWidth</vh>
<v t="T1466"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
<v t="T1798" a="C"><vh>tree.set...LabelState</vh>
<v t="T1799"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T1800"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T1801"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
<v t="T1802" a="C"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T1207" a="C"><vh>frame.OpenWithFileName</vh></v>
</v>
<v t="T1803"><vh>(Fix cut/paste problem)(seems to work now)</vh></v>
<v t="T1804"><vh>(Fixed bug importing upper case extensions)</vh>
<v t="T1805" a="C"><vh>createOutline</vh>
<v t="T1806"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
<v t="T1807"><vh>(Fixed bug that forced body_pane_wraps to 1)</vh>
<v t="T1623" a="C"><vh>f.setWrap</vh></v>
<v t="T1481" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1482"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1483"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1484"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1485"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1488"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="T1808"><vh>(Fixed colorizer exception when undoing paste)</vh>
<v t="T1809"><vh>Traceback &amp; Report</vh></v>
<v t="T1810" a="C"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T1811"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1812"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T1813"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T1814"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
</v>
<v t="T1815"><vh>(Fixed crash on Open With: Shift-Control-O)</vh>
<v t="T1174" a="C"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
</v>
<v t="T1816"><vh>(Fixed line-break bug with @nosent files)</vh>
<v t="T1817"><vh>Report</vh></v>
<v t="T1116" a="C"><vh>Writing (old)</vh>
<v t="T1117"><vh>Top level</vh>
<v t="T1118"><vh>atFile.rawWrite</vh>
<v t="T1119"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1121"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1122"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T1124"><vh>atFile.silentWrite</vh>
<v t="T1125"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T1126"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T1127"><vh>atFile.write</vh>
<v t="T1128"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1130"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1120" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1131"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="T1123" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1132"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1133"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T1134" a="C"><vh>atFile.writeAll</vh>
<v t="T1135"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1136"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1137"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="T1138"><vh>atFile.writeMissing</vh>
<v t="T1139"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T1140"><vh>&lt;&lt; create self.outputFile &gt;&gt;</vh></v>
<v t="T1141"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="T1142"><vh>Top level write helpers</vh>
<v t="T1143"><vh>atFile.closeWriteFile</vh></v>
<v t="T1144"><vh>atFile.handleWriteException</vh></v>
<v t="T1145"><vh>atFile.openWriteFile</vh></v>
<v t="T1146"><vh>atFile.putInitialComment</vh></v>
<v t="T1147"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T1148"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T1149"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T1150"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T1151"><vh>atFile.outputStringWithLineEndings</vh></v>
</v>
</v>
<v t="T1014" a="C"><vh>putBodyPart</vh>
<v t="T1015"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1016"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1017"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1018"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1019"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T1152"><vh>putDoc</vh></v>
<v t="T1153"><vh>putDocPart</vh>
<v t="T1154"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1068" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1069"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1070"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1071"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1072"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1074"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1075"><vh>inAtOthers</vh></v>
<v t="T1076"><vh>isSectionName</vh></v>
<v t="T1077"><vh>putAtOthers</vh></v>
<v t="T1078"><vh>putAtOthersChild</vh></v>
<v t="T1079"><vh>putRef</vh>
<v t="T1080"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T1081"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1155"><vh>Utils</vh>
<v t="T1156"><vh>putBuffered</vh></v>
<v t="T1082" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T922" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T923"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T1157"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T1158"><vh>putIndent</vh></v>
</v>
</v>
</v>
<v t="T1818"><vh>(Fixed missing log bug)</vh>
<v t="T1819" a="C"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="T1207" a="C"><vh>frame.OpenWithFileName</vh></v>
</v>
<v t="T1820"><vh>(Fixed more dragging problems)</vh>
<v t="T504" a="C"><vh>tree.Birth &amp; death</vh>
<v t="T505" a="C"><vh>tree.__init__</vh></v>
<v t="T506"><vh>tree.deleteBindings</vh></v>
<v t="T507"><vh>tree.deleteWidgets</vh></v>
<v t="T508" a="C"><vh>tree.injectCallbacks (class method)</vh>
<v t="T509"><vh>&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;</vh>
<v t="T510"><vh>OnBoxClick</vh></v>
<v t="T511"><vh>OnDrag</vh></v>
<v t="T512"><vh>OnEndDrag</vh></v>
<v t="T513"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T514"><vh>OnHeadlineKey</vh></v>
<v t="T515"><vh>OnHyperLinkControlClick</vh></v>
<v t="T516"><vh>OnHyperLinkEnter</vh></v>
<v t="T517"><vh>OnHyperLinkLeave</vh></v>
<v t="T518"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T519"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
<v t="T1821" a="C"><vh>Event handers (tree)</vh>
<v t="T1822"><vh>OnActivate</vh>
<v t="T1823"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="T1824"><vh>OnBoxClick</vh></v>
<v t="T1790" a="C"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="T1825"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1409" a="C"><vh>body key handlers (tree)</vh>
<v t="T1410"><vh>idle_body_key</vh>
<v t="T1411"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="T1412"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1413"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1414"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="T1415"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="T1416" a="C"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="T1417"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="T1418"><vh>onBodyChanged</vh></v>
<v t="T1419"><vh>OnBodyKey</vh></v>
<v t="T1420"><vh>onBodyWillChange</vh></v>
</v>
<v t="T1826"><vh>tree.OnContinueDrag</vh>
<v t="T1827"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="T1828"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="T1829"><vh>tree.OnCtontrolT</vh></v>
<v t="T1830" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1831" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1832"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1421" a="C"><vh>headline key handlers (tree)</vh>
<v t="T1422"><vh>onHeadChanged</vh></v>
<v t="T1423"><vh>OnHeadlineKey</vh></v>
<v t="T1424"><vh>idle_head_key</vh>
<v t="T1425"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="T1426"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="T1833" a="C"><vh>tree.OnIconClick &amp; OnIconRightClick</vh>
<v t="T1834"><vh>&lt;&lt; define drag callbacks &gt;&gt;</vh></v>
</v>
<v t="T1835"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1836"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="T1837"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1838"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="T1769" a="C"><vh>tree.OnPopup &amp; allies</vh>
<v t="T1770"><vh>OnPopupFocusLost</vh></v>
<v t="T1771"><vh>createPopupMenu</vh>
<v t="T1772"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="T1773"><vh>enablePopupMenuItems</vh>
<v t="T1774"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="T1775"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="T859" a="C"><vh>Drawing routines (tree)...</vh>
<v t="T860"><vh>redraw</vh></v>
<v t="T861"><vh>force_redraw</vh></v>
<v t="T862"><vh>redraw_now</vh></v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T864"><vh>idle_second_redraw</vh></v>
</v>
<v t="T850" a="C"><vh>drawIcon (tag_bind)</vh>
<v t="T851"><vh>&lt;&lt; define icon click callbacks &gt;&gt;</vh></v>
</v>
<v t="T1839" a="C"><vh>OnDrag</vh></v>
<v t="T1840" a="C"><vh>v.OnEndDrag</vh></v>
<v t="T1831" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1832"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1830" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1833" a="C"><vh>tree.OnIconClick &amp; OnIconRightClick</vh>
<v t="T1834"><vh>&lt;&lt; define drag callbacks &gt;&gt;</vh></v>
</v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T1841" a="C"><vh>v.Callbacks (handles event hooks)(to be eliminated)</vh>
<v t="T1842"><vh>OnBoxClick</vh></v>
<v t="T1839" a="C"><vh>OnDrag</vh></v>
<v t="T1840" a="C"><vh>v.OnEndDrag</vh></v>
<v t="T1776" a="C"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T1843"><vh>OnHeadlineKey</vh></v>
<v t="T1844"><vh>OnHyperLinkControlClick</vh></v>
<v t="T1845"><vh>OnHyperLinkEnter</vh></v>
<v t="T1846"><vh>OnHyperLinkLeave</vh></v>
<v t="T1847"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T1848"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
<v t="T1849"><vh>(Fixed Nav button bug?)</vh>
<v t="T1850"><vh> Report</vh></v>
<v t="T1851"><vh>updateNavButtons (nav_buttons.py)</vh></v>
</v>
<v t="T1852"><vh>(Fixed problem with destroying Leo windows)</vh>
<v t="T1853"><vh> Report</vh></v>
<v t="T1854" a="C"><vh>app.destroyWindow</vh></v>
<v t="T1195" a="C"><vh>frame.OnOpen</vh>
<v t="T1196"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1217" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1218"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1212" a="C"><vh>frame.OnRevert</vh></v>
</v>
<v t="T1855"><vh>(Fixed refresh problem after Read @file Node)</vh>
<v t="T1856"><vh>Report</vh></v>
<v t="T1857" a="C"><vh>readAtFileNodes</vh></v>
</v>
<v t="T1858"><vh>(Fixed Sort bug)</vh>
<v t="T1859"><vh>Report</vh></v>
<v t="T1860" a="C"><vh>c.sortTopLevel</vh>
<v t="T1861"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="T1037" a="C"><vh>v.sortChildren</vh></v>
</v>
<v t="T1862"><vh>(Fixed yet another bug in Open With logic)</vh>
<v t="T1204" a="C"><vh>frame.createOpenWithTempFile</vh>
<v t="T1205"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
</v>
<v t="T1863"><vh>(Improved how headlines are highlighted)</vh>
<v t="T1864" a="C"><vh>c.insertHeadline</vh></v>
<v t="T1795" a="C"><vh>editLabel</vh></v>
<v t="T1798" a="C"><vh>tree.set...LabelState</vh>
<v t="T1799"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T1800"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T1801"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
<v t="T1865" a="C"><vh>trace</vh></v>
<v t="T853" a="C"><vh>drawText (bind)</vh>
<v t="T854"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; define the headline click callbacks &gt;&gt;</vh></v>
</v>
<v t="T1791" a="C"><vh>Focus (leoGlobals)</vh></v>
</v>
<v t="T1866"><vh>(Improved reportBadChars)</vh>
<v t="T1867"><vh>Report</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
</v>
<v t="T1868"><vh>(Paritally fixed goto line number bug)</vh>
<v t="T1869"><vh>Report</vh></v>
<v t="T1262" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T1263"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T1264"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T1265"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T1266"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="T1267"><vh>&lt;&lt; set v to the node given by vnodeName and childIndex or n &gt;&gt;</vh>
<v t="T1268"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="T1269"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="T1270"><vh>&lt;&lt; set v to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="T1271"><vh>&lt;&lt; set v to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="T1272"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="T1273"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T1274"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T1275"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="T1276"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T1277"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T1278"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T1279"><vh>&lt;&lt; set vnodeName and childIndex from s &gt;&gt;</vh></v>
</v>
<v t="T1280"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
</v>
<v t="T1870"><vh>(Reformat paragraph index error)</vh>
<v t="T1871"><vh>Report</vh></v>
<v t="T427" a="C"><vh>getBodyLines</vh></v>
</v>
<v t="T1872"><vh>(Removed c.copyTree and v.copyNode and rewrote v.copyTree)</vh>
<v t="T1873" a="C"><vh>c.clone</vh></v>
<v t="T1874" a="C"><vh>v.addTreeToJoinLists (new in 3.12 beta 2)</vh></v>
<v t="T1875" a="C"><vh>v.clone</vh></v>
<v t="T1876" a="C"><vh>v.cloneTree</vh></v>
<v t="T1877" a="C"><vh>v.copyTree</vh></v>
<v t="T1878" a="C"><vh>v.createDependents</vh></v>
<v t="T1879" a="C"><vh>v.destroyDependents</vh></v>
</v>
<v t="T1880"><vh>(Restore cursor after undo/redo)</vh>
<v t="T658" a="C"><vh>getTextSelection</vh></v>
</v>
<v t="T1881"><vh>(Updated marks window dynamically)</vh>
<v t="T1882" a="C"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="T1883" a="C"><vh>clearMarked</vh></v>
</v>
<v t="T1884"><vh>(Updated row/col when plugins not enabled)</vh>
<v t="T1633" a="C"><vh>Status line: convenience routines</vh>
<v t="T1634"><vh>createStatusLine</vh></v>
<v t="T1635"><vh>clearStatusLine</vh></v>
<v t="T1636"><vh>putStatusLine</vh></v>
<v t="T1637" a="C"><vh>updateStatusRowCol</vh></v>
</v>
</v>
</v>
<v t="T1885"><vh>3.12 beta 3</vh>
<v t="T1886"><vh>(create_nonexistent_directories bug? works for me)</vh>
<v t="T1887"><vh>Report</vh></v>
<v t="T1888"><vh>@file c:\prog\test\newdir\newdir2\createDir.txt</vh></v>
</v>
<v t="T1889"><vh>(Fix undoReplace bug, removed c.copyTree and rewrite v.copyTree)</vh>
<v t="T1890"><vh>Fix undo bug again?</vh></v>
<v t="T1891"><vh>Routines that use undo replace</vh>
<v t="T415" a="C"><vh>convertAllBlanks</vh></v>
<v t="T416" a="C"><vh>convertAllTabs</vh></v>
<v t="T421" a="C"><vh>extract</vh>
<v t="T422"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
</v>
<v t="T1892" a="C"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1893" a="C"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1894" a="C"><vh>undoReplace</vh></v>
</v>
<v t="T1895"><vh>(Replaced exec with getattr/setattr)</vh>
<v t="T1896"><vh>Colorizer...</vh>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="T1897"><vh>Config...</vh>
<v t="T667" a="C"><vh>setCommandsFindIvars</vh></v>
<v t="T666" a="C"><vh>setConfigFindIvars</vh></v>
</v>
<v t="T1898"><vh>FileCommands</vh>
<v t="T669" a="C"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T1899"><vh>Find...</vh>
<v t="T1900" a="C"><vh>find.init</vh>
<v t="T1901"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1550" a="C"><vh>find.set_ivars</vh></v>
</v>
<v t="T1902"><vh>Prefs...</vh>
<v t="T1903" a="C"><vh>prefs.init</vh>
<v t="T1904"><vh>&lt;&lt; remember values for revert &gt;&gt;</vh></v>
<v t="T1905"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1906" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T1907"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="T1908"><vh>undo...</vh>
<v t="T1909" a="C"><vh>clearIvars</vh></v>
<v t="T1910" a="C"><vh>getBead, peekBead, setBead</vh></v>
<v t="T1579" a="C"><vh>setUndoTypingParams</vh>
<v t="T1580"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1581"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1911"><vh>(Use "file in directory" format for entries in Recent Files list)</vh>
<v t="T1219" a="C"><vh>createRecentFilesMenuItems</vh></v>
</v>
</v>
</v>
<v t="T1912"><vh>3.12.1 projects</vh>
<v t="T1913"><vh>(Fixed improper "No absolute directory specified anywhere" message)</vh>
<v t="T1914"><vh>Report</vh></v>
<v t="T1915" a="C"><vh>save</vh></v>
</v>
<v t="T1916"><vh>(Fixed Shortcut Problems)</vh>
<v t="T1917" a="C"><vh>getShortcut</vh></v>
<v t="T1384" a="C"><vh>createMenuEntries</vh>
<v t="T1385"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1386"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
</v>
<v t="T1918"><vh>(Add/delete scrollbars for @wrap and @nowrap)</vh>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
<v t="T483" a="C"><vh>f.createLeoFrame</vh>
<v t="T484"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T485"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T487"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1623" a="C"><vh>f.setWrap</vh></v>
</v>
<v t="T1919"><vh>(Worked around shutdown problems with 2.3)</vh>
<v t="T1698" a="C"><vh>doHook</vh></v>
<v t="T1685" a="C"><vh>app.finishQuit</vh></v>
<v t="T1637" a="C"><vh>updateStatusRowCol</vh></v>
<v t="T1405" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
</v>
</v>
<v t="T1920"><vh>4.0 Projects</vh>
<v t="T1921"><vh>(4.0: bad tnodeList index following cut/paste of @root tree)</vh>
<v t="T1922" a="C"><vh>findChild</vh></v>
</v>
<v t="T1923"><vh>(4.0: icon code)</vh>
<v t="T1924" a="C"><vh>setDefaultIcon</vh></v>
<v t="T1925" a="C"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="T1926"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="T1927"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="T1928"><vh>(4.0: Last-minute fixes to write logic)</vh>
<v t="T1929"><vh>Report</vh></v>
<v t="T1227" a="C"><vh>4.0 Commands</vh>
<v t="T1228" a="C"><vh>OnImportDerivedFile</vh></v>
<v t="T1229"><vh>OnWriteNew/OldDerivedFiles</vh></v>
</v>
<v t="T1226" a="C"><vh>OnWriteAtFileNodes</vh></v>
<v t="T1930" a="C"><vh>writeAtFileNodes</vh></v>
<v t="T1764" a="C"><vh>writeDirtyAtFileNodes</vh></v>
<v t="T1931" a="C"><vh>writeMissingAtFileNodes</vh></v>
<v t="T1646" a="C"><vh>getLeoFile (calls setAllJoinLinks, initAllCloneBits)</vh>
<v t="T1647"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1648"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="T1649"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
</v>
<v t="T1922" a="C"><vh>findChild</vh></v>
<v t="T1932" a="C"><vh>top_df.writeMissing</vh>
<v t="T1933"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T1934"><vh>&lt;&lt; create df.outputFile &gt;&gt;</vh></v>
<v t="T1935"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="T1936" a="C"><vh>top_df.writeAll</vh>
<v t="T1937"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1938"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1939"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
</v>
<v t="T1940"><vh>(4.0: Rewrite frame/commander ctor logic)</vh>
<v t="T1941" a="C"><vh> newLeoCommanderAndFrame</vh>
<v t="T1942"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="T1943" a="C"><vh>computeWindowTitle</vh></v>
<v t="T1944" a="C"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="T1909" a="C"><vh>clearIvars</vh></v>
</v>
<v t="T504" a="C"><vh>tree.Birth &amp; death</vh>
<v t="T505" a="C"><vh>tree.__init__</vh></v>
<v t="T506"><vh>tree.deleteBindings</vh></v>
<v t="T507"><vh>tree.deleteWidgets</vh></v>
<v t="T508" a="C"><vh>tree.injectCallbacks (class method)</vh>
<v t="T509"><vh>&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;</vh>
<v t="T510"><vh>OnBoxClick</vh></v>
<v t="T511"><vh>OnDrag</vh></v>
<v t="T512"><vh>OnEndDrag</vh></v>
<v t="T513"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T514"><vh>OnHeadlineKey</vh></v>
<v t="T515"><vh>OnHyperLinkControlClick</vh></v>
<v t="T516"><vh>OnHyperLinkEnter</vh></v>
<v t="T517"><vh>OnHyperLinkLeave</vh></v>
<v t="T518"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T519"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
<v t="T1945" a="C"><vh>c.Birth &amp; death</vh>
<v t="T1946" a="C"><vh>c.__init__, initIvars</vh>
<v t="T1947"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T1948"><vh>c.__repr__ &amp; __str__</vh></v>
</v>
<v t="T1949" a="C"><vh>frame.Birth &amp; Death</vh>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T1950" a="C"><vh>f.version &amp; signon stuff</vh></v>
<v t="T1951"><vh>f.finishCreate</vh>
<v t="T1952"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T1953"><vh>f.__repr__</vh></v>
<v t="T1954"><vh>f.clearAllIvars</vh></v>
<v t="T483" a="C"><vh>f.createLeoFrame</vh>
<v t="T484"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T485"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T487"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1687" a="C"><vh>frame.destroyAllPanels</vh></v>
<v t="T1688" a="C"><vh>frame.promptForSave</vh>
<v t="T1689"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T1688" a="C"><vh>frame.promptForSave</vh>
<v t="T1689"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T1955"><vh>(4.0: Startup code)</vh>
<v t="T1802" a="C"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T1956" a="C"><vh>app &amp; leoProxy</vh></v>
<v t="T1957"><vh>To do _after_ resting</vh></v>
<v t="T1958" a="C"><vh>app.createTkGui</vh></v>
<v t="T401" a="C"><vh>run &amp; allies</vh>
<v t="T402"><vh>isValidPython</vh></v>
<v t="T403"><vh>computeLoadDir</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
</v>
</v>
<v t="T1959"><vh>(4.0: Whitespace after @doc and @space)</vh>
<v t="T1960"><vh>Report</vh></v>
<v t="T1961" a="C"><vh>doc lines... (write)</vh>
<v t="T1962"><vh>putBlankDocLine</vh></v>
<v t="T1963"><vh>putStartDocLine</vh></v>
<v t="T1964"><vh>putDocLine</vh>
<v t="T1965"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1966"><vh>putEndDocLine</vh></v>
<v t="T1967"><vh>putPending</vh></v>
</v>
<v t="T1968" a="C"><vh>readStartAt, readStartDoc &amp; readStartDocLine</vh></v>
<v t="T1969" a="C"><vh>readLastDocLine</vh></v>
</v>
<v t="T1970"><vh>(Better hints for extract commands)</vh>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
</v>
<v t="T1971"><vh>(Clone mark bug)</vh>
<v t="T1972"><vh>Report</vh></v>
<v t="T1973" a="C"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="T1974"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T1039" a="C"><vh>c.deleteHeadline</vh></v>
<v t="T1864" a="C"><vh>c.insertHeadline</vh></v>
<v t="T1873" a="C"><vh>c.clone</vh></v>
<v t="T1975" a="C"><vh>initAllCloneBits &amp; initAllCloneBitsInTree</vh></v>
<v t="T1976"><vh>c.initJoinedClonedBits (changed in 3.11.1)</vh></v>
<v t="T1977"><vh>validateOutline</vh></v>
</v>
<v t="T1978" a="C"><vh>Moving, Dragging, Promote, Demote, Sort (commands)</vh>
<v t="T1979"><vh>c.dragAfter</vh></v>
<v t="T1980"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="T1981"><vh>c.dragToNthChildOf</vh></v>
<v t="T1034" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1035"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1036"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1860" a="C"><vh>c.sortTopLevel</vh>
<v t="T1861"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="T1982"><vh>demote</vh></v>
<v t="T1983"><vh>moveOutlineDown</vh>
<v t="T1984"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T1985"><vh>moveOutlineLeft</vh></v>
<v t="T1986"><vh>moveOutlineRight</vh></v>
<v t="T1987"><vh>moveOutlineUp</vh>
<v t="T1988"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T1989"><vh>promote</vh></v>
<v t="T1990"><vh>c.dragCloneAfter (changed in 3.11.1)</vh></v>
</v>
</v>
<v t="T1991"><vh>(Drag settings)</vh>
<v t="T1830" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1831" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1832"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
<v t="T1992"><vh>(Encoding problem in Open With)</vh>
<v t="T1993"><vh>Report</vh></v>
<v t="T1204" a="C"><vh>frame.createOpenWithTempFile</vh>
<v t="T1205"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
</v>
<v t="T1994"><vh>(Fixed clone bug)</vh>
<v t="T1873" a="C"><vh>c.clone</vh></v>
</v>
<v t="T1995"><vh>(Force a complete recolor after any cut/paste or corresponding undo/redo)</vh>
<v t="T1996"><vh>Report</vh></v>
<v t="T1997" a="C"><vh>The interface with the tree class</vh></v>
<v t="T1998" a="C"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="T1416" a="C"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="T1999" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
<v t="T2000" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
<v t="T525" a="C"><vh>undoRedoText</vh>
<v t="T526"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="T1254" a="C"><vh>Cut/Copy/Paste body text</vh>
<v t="T1255"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T1256"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T1257"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
</v>
</v>
<v t="T2001"><vh>(Forcing Leo to quit from a plugin)</vh>
<v t="T401" a="C"><vh>run &amp; allies</vh>
<v t="T402"><vh>isValidPython</vh></v>
<v t="T403"><vh>computeLoadDir</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
</v>
</v>
<v t="T2002"><vh>(Go To Line Number command)</vh>
<v t="T2003"><vh>Notes</vh></v>
<v t="T2004"><vh>Request: make Go To Line Number work with @file-nosent files</vh></v>
<v t="T2005"><vh>tests</vh>
<v t="T2006"><vh>@file c:\prog\test\lineTest.txt</vh>
<v t="T2007"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T2008"><vh>@rawfile c:\prog\test\rawLineTest.txt</vh>
<v t="T2009"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T1262" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T1263"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T1264"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T1265"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T1266"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="T1267"><vh>&lt;&lt; set v to the node given by vnodeName and childIndex or n &gt;&gt;</vh>
<v t="T1268"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="T1269"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="T1270"><vh>&lt;&lt; set v to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="T1271"><vh>&lt;&lt; set v to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="T1272"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="T1273"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T1274"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T1275"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="T1276"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T1277"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T1278"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T1279"><vh>&lt;&lt; set vnodeName and childIndex from s &gt;&gt;</vh></v>
</v>
<v t="T1280"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
</v>
<v t="T2010"><vh>(Import elisp files)</vh>
<v t="T2011" a="C"><vh>scanElispText &amp; allies</vh>
<v t="T2012"><vh>skipElispParens</vh></v>
<v t="T2013"><vh>skipElispId</vh></v>
<v t="T2014"><vh>createElispFunction</vh></v>
<v t="T2015"><vh>createElispDataNode</vh></v>
</v>
</v>
<v t="T2016"><vh>(Make sure @rawfile writes a newline before all sentinels)</vh>
<v t="T2017" a="C"><vh>new_df.rawWrite</vh>
<v t="T2018"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T2019"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2020"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T2021"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T2022"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T2023" a="C"><vh>putLeadInSentinel</vh></v>
</v>
<v t="T2024"><vh>(Mark @file node dirty if the node has been changed when reading)</vh>
<v t="T1646" a="C"><vh>getLeoFile (calls setAllJoinLinks, initAllCloneBits)</vh>
<v t="T1647"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1648"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="T1649"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
</v>
<v t="T2025" a="C"><vh>fileCommands.open</vh>
<v t="T2026" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
<v t="T2027"><vh>&lt;&lt; Make the top node visible &gt;&gt;</vh></v>
</v>
<v t="T2028" a="C"><vh>top_df.read</vh>
<v t="T2029"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="T2030"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="T2031"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="T2032"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="T2033"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="T2034"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="T2035"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="T2036" a="C"><vh>setChanged</vh></v>
<v t="T1033" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="T1032" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="T2037"><vh>(Problems matching parens)</vh>
<v t="T1293" a="C"><vh>OnFindMatchingBracket</vh>
<v t="T1294" a="C"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1294" a="C"><vh>findMatchingBracket</vh></v>
</v>
<v t="T2038"><vh>(Problems with settings)</vh>
<v t="T2039"><vh>Report</vh></v>
<v t="T2040" a="C"><vh>set_lang</vh></v>
<v t="T2041" a="C"><vh>top</vh></v>
</v>
<v t="T2042"><vh>(Put Clear Recent Files in Recent Files menu</vh>
<v t="T1219" a="C"><vh>createRecentFilesMenuItems</vh></v>
</v>
<v t="T2043"><vh>(Python import bug)</vh>
<v t="T2044"><vh>Report</vh></v>
<v t="T2045" a="C"><vh>Python scanners</vh>
<v t="T2046"><vh>scanPythonClass</vh>
<v t="T2047"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="T2048"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="T2049"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="T2050"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
<v t="T2051"><vh>&lt;&lt; append any other class material &gt;&gt;</vh></v>
</v>
<v t="T2052"><vh>scanPythonDef</vh>
<v t="T2053"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="T2054"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T2055"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="T2056"><vh>scanPythonDecls</vh>
<v t="T2057"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="T2058"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="T2059"><vh>scanPythonText</vh>
<v t="T2060"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="T2061"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="T2062"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2063"><vh>(Re-enable python window?)</vh>
<v t="T1187" a="C"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1368" a="C"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1369"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="T1371"><vh>&lt;&lt; Try to open idle in pre-Python 2.3 systems&gt;&gt;</vh></v>
<v t="T1372"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
</v>
<v t="T1373"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T2064"><vh>(Remove Sentinels: blank output)</vh>
<v t="T2065"><vh>Report</vh></v>
<v t="T2066" a="C"><vh>removeSentinelsCommand</vh>
<v t="T2067"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="T2068"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="T995" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T2069"><vh>(Scrollwheel)</vh>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T1789" a="C"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="T2070"><vh>(Setting to redirect script output to log pane)</vh>
<v t="T1259" a="C"><vh>OnExecuteScript</vh>
<v t="T1260"><vh>&lt;&lt; get script into s &gt;&gt;</vh></v>
<v t="T1261"><vh>&lt;&lt; redirect output if redirect_execute_script_output_to_log_pane &gt;&gt;</vh></v>
</v>
</v>
<v t="T2071"><vh>(Speed up clone operation by calling initAllCloneBitsInTree)</vh>
<v t="T1975" a="C"><vh>initAllCloneBits &amp; initAllCloneBitsInTree</vh></v>
<v t="T1873" a="C"><vh>c.clone</vh></v>
</v>
<v t="T2072"><vh>(Support elisp colorizing)</vh>
<v t="T176" a="C"><vh>How to add support for a new language</vh>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="T178" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt; frame</vh></v>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
<v t="T180" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="T181"><vh>&lt;&lt; actionscript keywords &gt;&gt;</vh></v>
<v t="T182"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T183"><vh>&lt;&lt; elisp keywords&gt;&gt;</vh></v>
<v t="T184"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T185"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T186"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T187"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T188"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T189"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
<v t="T190"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T191"><vh>&lt;&lt; rebol keywords &gt;&gt;</vh></v>
<v t="T192"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2073"><vh>(Undo changes)</vh>
<v t="T2074" a="M"><vh> Commands that should be undoable</vh>
<v t="T2075"><vh>Import Derived Files</vh>
<v t="T1228" a="C"><vh>OnImportDerivedFile</vh></v>
<v t="T2076" a="C"><vh>importDerivedFiles</vh></v>
<v t="T2077" a="C"><vh>createImportedNode</vh></v>
<v t="T2028" a="C"><vh>top_df.read</vh>
<v t="T2029"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="T2030"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="T2031"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="T2032"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="T2033"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="T2034"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="T2035"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
</v>
<v t="T414" a="C"><vh>Edit Body Text</vh>
<v t="T415" a="C"><vh>convertAllBlanks</vh></v>
<v t="T416" a="C"><vh>convertAllTabs</vh></v>
<v t="T417"><vh>convertBlanks</vh></v>
<v t="T418"><vh>convertTabs</vh></v>
<v t="T419"><vh>createLastChildNode</vh></v>
<v t="T420"><vh>dedentBody</vh></v>
<v t="T421" a="C"><vh>extract</vh>
<v t="T422"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T427" a="C"><vh>getBodyLines</vh></v>
<v t="T428"><vh>getBodySelection</vh></v>
<v t="T429"><vh>indentBody</vh></v>
<v t="T430"><vh>reformatParagraph</vh>
<v t="T431"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T432"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="T1222" a="C"><vh>OnReadAtFileNodes</vh></v>
</v>
<v t="T2078"><vh> Notes</vh>
<v t="T2079"><vh>Crasher in undo replace</vh></v>
</v>
<v t="T2080"><vh>Code</vh>
<v t="T1893" a="C"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1892" a="C"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1894" a="CM"><vh>undoReplace</vh></v>
<v t="T2081" a="C"><vh>saveTree, restoreExtraAttributes</vh></v>
<v t="T2082" a="C"><vh>t.extraAttributes &amp; setExtraAttributes</vh></v>
<v t="T2083" a="C"><vh>v.extraAttributes &amp; setExtraAttributes</vh></v>
</v>
</v>
<v t="T2084"><vh>(Unicode problems in beta 3)</vh>
<v t="T2085"><vh>test</vh></v>
<v t="T1582" a="C"><vh>Unicode utils...</vh>
<v t="T1583"><vh>isUnicode</vh></v>
<v t="T1584"><vh>isValidEncoding</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
<v t="T1586" a="C"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T1587"><vh>getpreferredencoding from 2.3a2</vh>
<v t="T1588"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="T1589"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
<v t="T2086"><vh>Problem 1: Typing in body pane</vh></v>
<v t="T2087"><vh>Problem 2: the app.log should be cleared when switching windows</vh>
<v t="T2088"><vh>Traceback: Opening leoConfig.leo</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
<v t="T1563" a="C"><vh>f.put, putnl</vh></v>
<v t="T1819" a="C"><vh>app.setLog, lockLog, unlocklog</vh></v>
</v>
</v>
<v t="T2089"><vh>(Unicode problems with Python 2.3)</vh>
<v t="T2090"><vh>To do</vh></v>
<v t="T2091"><vh>What I did</vh></v>
<v t="T2092"><vh>Report Unicode traces</vh>
<v t="T2093"><vh>in colorize (doNormalState)</vh></v>
<v t="T2094"><vh>opening leoConfig.leo (in scanDirectives)</vh></v>
<v t="T2095"><vh>opening new Outline (in scanDirectives)</vh></v>
</v>
<v t="T2096" a="C"><vh>doNormalState</vh>
<v t="T2097"><vh>Valid regardless of latex mode</vh>
<v t="T2098"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="T2099"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="T2100"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="T2101"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="T2102"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T2103"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T2104"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T1719" a="C"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T1721" a="C"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T2105"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T2106"><vh>Vaid only in latex mode</vh>
<v t="T2107"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T2108"><vh>Valid when not in latex_mode</vh>
<v t="T1714" a="C"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T2109"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T2110"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T2111"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T2112"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T2113"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T2114" a="C"><vh>createVnode</vh>
<v t="T2115"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="T2116" a="C"><vh>class colorizer</vh>
<v t="T180" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="T181"><vh>&lt;&lt; actionscript keywords &gt;&gt;</vh></v>
<v t="T182"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T183"><vh>&lt;&lt; elisp keywords&gt;&gt;</vh></v>
<v t="T184"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T185"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T186"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T187"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T188"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T189"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
<v t="T190"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T191"><vh>&lt;&lt; rebol keywords &gt;&gt;</vh></v>
<v t="T192"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
</v>
<v t="T1707" a="C"><vh>color.__init__</vh>
<v t="T1708"><vh>&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;</vh></v>
<v t="T1709"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; define fonts and data for wiki tags &gt;&gt;</vh></v>
</v>
<v t="T2117"><vh>color.callbacks...</vh>
<v t="T2118"><vh>OnHyperLinkControlClick</vh></v>
<v t="T2119"><vh>OnHyperLinkEnter</vh></v>
<v t="T2120"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="T2121"><vh>colorize &amp; recolor_range</vh></v>
<v t="T2122"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="T1704" a="C"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="T1705"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="T2123"><vh>&lt;&lt; all state ivars match &gt;&gt;</vh></v>
<v t="T1810" a="C"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T1811"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1812"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T1813"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T1814"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="T2124"><vh>&lt;&lt; non-incrementally color the text &gt;&gt;</vh></v>
<v t="T2125"><vh>&lt;&lt; update state ivars &gt;&gt;</vh></v>
<v t="T2126"><vh>&lt;&lt; set state ivars to "unknown" &gt;&gt;</vh></v>
<v t="T2127"><vh>&lt;&lt; completely recolor in two passes &gt;&gt;</vh>
<v t="T2128"><vh>&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;</vh></v>
</v>
</v>
<v t="T2129"><vh>colorizeLine &amp; allies</vh>
<v t="T1720" a="C"><vh>continueBlockComment</vh></v>
<v t="T2130"><vh>continueSingle/DoubleString</vh></v>
<v t="T1716" a="C"><vh>continueDocPart</vh>
<v t="T1717"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T1718"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T2131"><vh>continueNocolor</vh></v>
<v t="T1715" a="C"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T1722" a="C"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="T2132"><vh>doLatexLine</vh></v>
<v t="T2096" a="C"><vh>doNormalState</vh>
<v t="T2097"><vh>Valid regardless of latex mode</vh>
<v t="T2098"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="T2099"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="T2100"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="T2101"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="T2102"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T2103"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T2104"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T1719" a="C"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T1721" a="C"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T2105"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T2106"><vh>Vaid only in latex mode</vh>
<v t="T2107"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T2108"><vh>Valid when not in latex_mode</vh>
<v t="T1714" a="C"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T2109"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T2110"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T2111"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T2112"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T2113"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T2133"><vh>doNowebSecRef</vh>
<v t="T2134"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T1706" a="C"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
<v t="T1467" a="C"><vh>scanColorDirectives</vh>
<v t="T1468"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T1469"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T2135"><vh>color.schedule</vh></v>
<v t="T2136"><vh>getCwebWord</vh></v>
<v t="T2137"><vh>removeAllImages</vh></v>
<v t="T2138"><vh>updateSyntaxColorer</vh></v>
<v t="T2139"><vh>useSyntaxColoring</vh></v>
<v t="T2140"><vh>Utils</vh>
<v t="T1711" a="C"><vh>index &amp; tag</vh></v>
<v t="T2141"><vh>setFirstLineState</vh></v>
<v t="T2142"><vh>skip_id</vh></v>
<v t="T1712" a="C"><vh>skip_python_string</vh></v>
<v t="T2143"><vh>skip_string</vh></v>
</v>
</v>
<v t="T2144"><vh>In leoGlobals</vh>
<v t="T1481" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1482"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1483"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1484"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1485"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1488"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="T1582" a="C"><vh>Unicode utils...</vh>
<v t="T1583"><vh>isUnicode</vh></v>
<v t="T1584"><vh>isValidEncoding</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
<v t="T1586" a="C"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T1587"><vh>getpreferredencoding from 2.3a2</vh>
<v t="T1588"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="T1589"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
<v t="T654" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T655"><vh>bound_paragraph (TK stuff)</vh></v>
<v t="T656" a="C"><vh>getindex</vh></v>
<v t="T657"><vh>getAllText &amp; getSelectedText</vh></v>
<v t="T658" a="C"><vh>getTextSelection</vh></v>
<v t="T659"><vh>setTextSelection</vh></v>
</v>
</v>
<v t="T2145"><vh>Contain calls to tkText.get</vh>
<v t="T414" a="C"><vh>Edit Body Text</vh>
<v t="T415" a="C"><vh>convertAllBlanks</vh></v>
<v t="T416" a="C"><vh>convertAllTabs</vh></v>
<v t="T417"><vh>convertBlanks</vh></v>
<v t="T418"><vh>convertTabs</vh></v>
<v t="T419"><vh>createLastChildNode</vh></v>
<v t="T420"><vh>dedentBody</vh></v>
<v t="T421" a="C"><vh>extract</vh>
<v t="T422"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T427" a="C"><vh>getBodyLines</vh></v>
<v t="T428"><vh>getBodySelection</vh></v>
<v t="T429"><vh>indentBody</vh></v>
<v t="T430"><vh>reformatParagraph</vh>
<v t="T431"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T432"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="T1259" a="C"><vh>OnExecuteScript</vh>
<v t="T1260"><vh>&lt;&lt; get script into s &gt;&gt;</vh></v>
<v t="T1261"><vh>&lt;&lt; redirect output if redirect_execute_script_output_to_log_pane &gt;&gt;</vh></v>
</v>
<v t="T2146" a="C"><vh>OnReturnKey (no longer used)</vh></v>
<v t="T1293" a="C"><vh>OnFindMatchingBracket</vh>
<v t="T1294" a="C"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1637" a="C"><vh>updateStatusRowCol</vh></v>
<v t="T2147"><vh>Find stuff</vh>
<v t="T1550" a="C"><vh>find.set_ivars</vh></v>
<v t="T2148" a="C"><vh>batchChange</vh>
<v t="T2149"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T2150"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
<v t="T2151" a="C"><vh>changeAll</vh></v>
<v t="T2152" a="C"><vh>findAll</vh></v>
<v t="T2153" a="C"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
</v>
<v t="T2154"><vh>Contain t.bodyString</vh>
<v t="T2155" a="C"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T2156" a="C"><vh>readEndNode</vh></v>
<v t="T1568" a="C"><vh>appendStringToBody</vh></v>
</v>
<v t="T2157"><vh>Containing headString</vh>
<v t="T2158" a="C"><vh>t.__init__</vh></v>
</v>
<v t="T2159"><vh>Key asserts</vh>
<v t="T2160" a="C"><vh>bodyString</vh></v>
<v t="T1673" a="C"><vh>headString &amp; cleanHeadString</vh></v>
</v>
</v>
<v t="T2161"><vh>leoGui projects...</vh>
<v t="T2162"><vh>(Connecting frames to gui)</vh>
<v t="T2163"><vh>To do</vh></v>
<v t="T1946" a="C"><vh>c.__init__, initIvars</vh>
<v t="T1947"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T1802" a="C"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
<v t="T1194" a="C"><vh>OnNew</vh></v>
<v t="T1221" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T1941" a="C"><vh> newLeoCommanderAndFrame</vh>
<v t="T1942"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="T2164" a="C"><vh>Creating Frames</vh></v>
<v t="T1447" a="C"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T2165" a="C"><vh>Interface with commander</vh>
<v t="T2166"><vh>The interface with frame internals</vh></v>
<v t="T2167"><vh>The interface with the body pane</vh></v>
<v t="T1997" a="C"><vh>The interface with the tree class</vh></v>
</v>
</v>
<v t="T2168"><vh>(Eliiminating vnode callbacks)</vh>
<v t="T1997" a="C"><vh>The interface with the tree class</vh></v>
<v t="T1841" a="C"><vh>v.Callbacks (handles event hooks)(to be eliminated)</vh>
<v t="T1842"><vh>OnBoxClick</vh></v>
<v t="T1839" a="C"><vh>OnDrag</vh></v>
<v t="T1840" a="C"><vh>v.OnEndDrag</vh></v>
<v t="T1776" a="C"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T1843"><vh>OnHeadlineKey</vh></v>
<v t="T1844"><vh>OnHyperLinkControlClick</vh></v>
<v t="T1845"><vh>OnHyperLinkEnter</vh></v>
<v t="T1846"><vh>OnHyperLinkLeave</vh></v>
<v t="T1847"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T1848"><vh>OnIconDoubleClick</vh></v>
</v>
<v t="T848" a="C"><vh>drawBox (tag_bind)</vh>
<v t="T849"><vh>&lt;&lt; define onBoxClickCallback &gt;&gt;</vh></v>
</v>
<v t="T850" a="C"><vh>drawIcon (tag_bind)</vh>
<v t="T851"><vh>&lt;&lt; define icon click callbacks &gt;&gt;</vh></v>
</v>
<v t="T1833" a="C"><vh>tree.OnIconClick &amp; OnIconRightClick</vh>
<v t="T1834"><vh>&lt;&lt; define drag callbacks &gt;&gt;</vh></v>
</v>
<v t="T853" a="C"><vh>drawText (bind)</vh>
<v t="T854"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; define the headline click callbacks &gt;&gt;</vh></v>
</v>
<v t="T1690" a="C"><vh>Garbage Collection</vh>
<v t="T1691"><vh>clearAllIvars</vh></v>
<v t="T1692"><vh>collectGarbage</vh>
<v t="T1693"><vh>&lt;&lt; make a list of the new objects &gt;&gt;</vh></v>
</v>
<v t="T1694"><vh>printGc</vh></v>
<v t="T1695"><vh>printGcRefs</vh></v>
</v>
<v t="T859" a="C"><vh>Drawing routines (tree)...</vh>
<v t="T860"><vh>redraw</vh></v>
<v t="T861"><vh>force_redraw</vh></v>
<v t="T862"><vh>redraw_now</vh></v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T864"><vh>idle_second_redraw</vh></v>
</v>
</v>
<v t="T2169"><vh>(Injecting tree callbacks into the vnode class)</vh>
<v t="T508" a="C"><vh>tree.injectCallbacks (class method)</vh>
<v t="T509"><vh>&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;</vh>
<v t="T510"><vh>OnBoxClick</vh></v>
<v t="T511"><vh>OnDrag</vh></v>
<v t="T512"><vh>OnEndDrag</vh></v>
<v t="T513"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T514"><vh>OnHeadlineKey</vh></v>
<v t="T515"><vh>OnHyperLinkControlClick</vh></v>
<v t="T516"><vh>OnHyperLinkEnter</vh></v>
<v t="T517"><vh>OnHyperLinkLeave</vh></v>
<v t="T518"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T519"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
<v t="T2170"><vh>(wm_iconbitmap version problem)</vh>
<v t="T1924" a="C"><vh>setDefaultIcon</vh></v>
</v>
</v>
</v>
</v>
<v t="T2171" a="V"><vh>Code</vh>
<v t="T2172"><vh>  Overview of code</vh>
<v t="T2173" a="C"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T2174" a="C"><vh>&lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="T2175" a="C"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="T2176" a="C"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T2177" a="C"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="T2178" a="C"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
</v>
<v t="T2179"><vh> Distribution scripts &amp; files</vh>
<v t="T2180"><vh>leo.nsi</vh>
<v t="T2181"><vh>@root ../dist/leo.nsi</vh>
<v t="T2182"><vh>&lt;&lt; installer settings &gt;&gt;</vh>
<v t="T2183"><vh>&lt;&lt; icons used by the installer &gt;&gt;</vh></v>
<v t="T2184"><vh>&lt;&lt; the installation dir &gt;&gt;</vh></v>
<v t="T2185"><vh>&lt;&lt; the user license &gt;&gt;</vh></v>
<v t="T2186"><vh>&lt;&lt; Additional Installer Settings &gt;&gt;</vh></v>
</v>
<v t="T2187"><vh>&lt;&lt; required files section &gt;&gt;</vh>
<v t="T2188"><vh>&lt;&lt; check to see whether Python is installed &gt;&gt;</vh></v>
</v>
<v t="T2189"><vh>&lt;&lt; optional files section&gt;&gt;</vh></v>
<v t="T2190"><vh>&lt;&lt; file association &gt;&gt;</vh></v>
<v t="T2191"><vh>&lt;&lt; post install section &gt;&gt;</vh></v>
<v t="T2192"><vh>&lt;&lt; uninstall section &gt;&gt;</vh>
<v t="T2193"><vh>&lt;&lt; remove file association &gt;&gt;</vh></v>
<v t="T2194"><vh>&lt;&lt; remove program folder &gt;&gt;</vh></v>
<v t="T2195"><vh>&lt;&lt; remove shortcuts &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2196"><vh>@silentfile ../doc/LICENSE.TXT</vh></v>
<v t="T2197"><vh>@silentfile ../doc/INSTALL.TXT</vh>
<v t="T2198"><vh>System requirements</vh></v>
<v t="T2199"><vh>Linux installation</vh></v>
<v t="T2200"><vh>Windows installation</vh></v>
<v t="T2201"><vh>MacOS installation</vh></v>
<v t="T2202"><vh>Shell &amp; batch scripts</vh></v>
</v>
<v t="T2203" a="C"><vh>@silentfile ../doc/PKG-INFO.TXT</vh></v>
<v t="T2204" a="C"><vh>@silentfile ../doc/README.TXT</vh></v>
<v t="T2205"><vh>@silentfile ../manifest.in</vh></v>
<v t="T2206"><vh>setup &amp; pre/postSetup (usually @ignore'd)</vh>
<v t="T2207" tnodeList="2207,2208,2209"><vh>@file ../preSetup.py</vh>
<v t="T2208"><vh>saveAllLeoFiles</vh></v>
<v t="T2209"><vh>tangleLeoConfigDotLeo</vh></v>
</v>
<v t="T2210" tnodeList="2210,2212,2213,2214,2215,2211"><vh>@file ../setup.py</vh>
<v t="T2211" a="C"><vh>&lt;&lt; setup info for setup.py &gt;&gt; UPDATE BY HAND</vh></v>
<v t="T2212"><vh>printReminders</vh></v>
<v t="T2213"><vh>generateModules</vh></v>
<v t="T2214" a="C"><vh>replacePatterns</vh></v>
<v t="T2215"><vh>setDefaultParams</vh></v>
</v>
<v t="T2216" tnodeList="2216,2214,2217"><vh>@file ../postSetup.py</vh>
<v t="T2214" a="C"><vh>replacePatterns</vh></v>
<v t="T2217"><vh>unsetDefaultParams</vh></v>
</v>
</v>
<v t="T2218"><vh>Linux scripts</vh>
<v t="T2219"><vh>@silentfile ../install</vh></v>
<v t="T2220" tnodeList="2220"><vh>@silentfile ../uninstall</vh></v>
</v>
</v>
<v t="T2221"><vh> Scripts</vh>
<v t="T2222"><vh>@file-nosent ../scripts/LinixInstall.py</vh></v>
<v t="T2223"><vh>../scripts/findDosFile</vh></v>
<v t="T2224" tnodeList="2224,2226,2227,2228,2229,2230,2232,2233,2234,2235,2236,2237,2238,2239,2241,2242,2243,2244,2245,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291"><vh>@file ../scripts/c2py.py</vh>
<v t="T2225"><vh>Documentation</vh>
<v t="T2226"><vh>&lt;&lt; what c2py does &gt;&gt;</vh></v>
<v t="T2227"><vh>&lt;&lt; theory of operation &gt;&gt;</vh></v>
</v>
<v t="T2228"><vh>&lt;&lt; specifying user types &gt;&gt;</vh></v>
<v t="T2229"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
<v t="T2230"><vh>speedTest</vh></v>
<v t="T2231"><vh>leo1to2</vh>
<v t="T2232"><vh>leo1to2</vh></v>
<v t="T2233"><vh>convertLeo1to2</vh></v>
<v t="T2234"><vh>convertStringLeo1to2</vh></v>
<v t="T2235"><vh>convertCodeList1to2</vh></v>
</v>
<v t="T2236"><vh>c2py entry points</vh>
<v t="T2237"><vh>convertCurrentTree</vh></v>
<v t="T2238"><vh>convertLeoTree</vh></v>
<v t="T2239"><vh>convertCFileToPython</vh></v>
</v>
<v t="T2240"><vh>c2py Top Level</vh>
<v t="T2241"><vh>convertCStringToPython</vh></v>
<v t="T2242"><vh>convertCodeList</vh></v>
<v t="T2243"><vh>convertDocList</vh></v>
<v t="T2244"><vh>skipDocPart</vh></v>
<v t="T2245"><vh>skipCodePart</vh></v>
</v>
<v t="T2246"><vh>removeSentinels</vh></v>
<v t="T2247"><vh>Scanning &amp; Replacing</vh>
<v t="T2248"><vh>convertLeadingBlanks</vh></v>
<v t="T2249"><vh>findInList</vh></v>
<v t="T2250"><vh>findInCode</vh></v>
<v t="T2251"><vh>mungeAllFunctions</vh>
<v t="T2252"><vh>handlePossibleFunctionHeader</vh></v>
<v t="T2253"><vh>massageFunctionArgs</vh></v>
<v t="T2254"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="T2255"><vh>massageFunctionBody</vh>
<v t="T2256"><vh>massageIvars</vh></v>
<v t="T2257"><vh>removeCasts</vh></v>
<v t="T2258"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="T2259"><vh>handleAllKeywords</vh>
<v t="T2260"><vh>handleKeyword</vh></v>
</v>
<v t="T2261"><vh>isWs and isWOrNl</vh></v>
<v t="T2262"><vh>isSectionDef</vh></v>
<v t="T2263"><vh>isStringOrComment</vh></v>
<v t="T2264"><vh>match</vh></v>
<v t="T2265"><vh>matchWord</vh></v>
<v t="T2266"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="T2267"><vh>removeAllCComments</vh></v>
<v t="T2268"><vh>removeAllCSentinels</vh></v>
<v t="T2269"><vh>removeAllPythonComments</vh></v>
<v t="T2270"><vh>removeAllPythonSentinels</vh></v>
<v t="T2271"><vh>removeAtRoot</vh></v>
<v t="T2272"><vh>removeBlankLines</vh></v>
<v t="T2273"><vh>removeExcessWs</vh>
<v t="T2274"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="T2275"><vh>removeLeadingAtCode</vh></v>
<v t="T2276"><vh>removeMatchingBrackets</vh></v>
<v t="T2277"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="T2278"><vh>removeTrailingWs</vh></v>
<v t="T2279"><vh>replace</vh></v>
<v t="T2280"><vh>replaceComments</vh></v>
<v t="T2281"><vh>replaceSectionDefs</vh></v>
<v t="T2282"><vh>safeReplace</vh></v>
<v t="T2283"><vh>skipCBlockComment</vh></v>
<v t="T2284"><vh>skipPastLine</vh></v>
<v t="T2285"><vh>skipPastWord</vh></v>
<v t="T2286"><vh>skipString</vh></v>
<v t="T2287"><vh>skipStringOrComment</vh></v>
<v t="T2288"><vh>skipToMatchingBracket</vh></v>
<v t="T2289"><vh>skipWs and skipWsAndNl</vh></v>
<v t="T2290"><vh>stringToList</vh></v>
<v t="T2291"><vh>listToString</vh></v>
</v>
</v>
<v t="T2292"><vh>@file ../scripts/disStats.py</vh>
<v t="T2293"><vh>go</vh></v>
<v t="T2294"><vh>getFiles</vh></v>
<v t="T2295"><vh>getModules</vh></v>
<v t="T2296"><vh>any</vh></v>
<v t="T2297"><vh>code</vh></v>
<v t="T2298"><vh>print_stats</vh></v>
</v>
<v t="T2299"><vh>@file ../scripts/leoFindScript.py</vh>
<v t="T2300"><vh>changeAll</vh></v>
<v t="T2301"><vh>changeNext</vh></v>
<v t="T2302"><vh>changePrev</vh></v>
<v t="T2303"><vh>findAll</vh></v>
<v t="T2304"><vh>findNext</vh></v>
<v t="T2305"><vh>findPrev</vh></v>
<v t="T2306"><vh>reChangeAll</vh></v>
<v t="T2307"><vh>reChangeNext</vh></v>
<v t="T2308"><vh>reChangePrev</vh></v>
<v t="T2309"><vh>reFindAll</vh></v>
<v t="T2310"><vh>reFindNext</vh></v>
<v t="T2311"><vh>reFindPrev</vh></v>
<v t="T2312"><vh>lineAtPos</vh></v>
<v t="T2313"><vh>printFindList</vh></v>
</v>
<v t="T2314"><vh>@file ../scripts/openLeo.py</vh></v>
<v t="T2315"><vh>@file ../scripts/tangle_done.py</vh>
<v t="T2316"><vh>run</vh></v>
<v t="T2317"><vh>convertRSTfilesToHTML</vh>
<v t="T2318"><vh>&lt;&lt; Convert root to corresponding .html file &gt;&gt;</vh></v>
</v>
</v>
<v t="T2319"><vh>@file ../scripts/untangle_done.py</vh></v>
<v t="T2320" a="C"><vh>importFiles</vh></v>
</v>
<v t="T2321"><vh> Version stuff (update this for every release)</vh>
<v t="T1950" a="C"><vh>f.version &amp; signon stuff</vh></v>
<v t="T2211" a="C"><vh>&lt;&lt; setup info for setup.py &gt;&gt; UPDATE BY HAND</vh></v>
<v t="T2203" a="C"><vh>@silentfile ../doc/PKG-INFO.TXT</vh></v>
<v t="T2204" a="C"><vh>@silentfile ../doc/README.TXT</vh></v>
<v t="T2322"><vh>Previous readme files</vh>
<v t="T2323"><vh>3.x</vh>
<v t="T2324"><vh>3.12</vh></v>
<v t="T2325"><vh>3.11</vh></v>
<v t="T2326"><vh>3.10</vh></v>
<v t="T2327"><vh>3.9</vh></v>
<v t="T2328"><vh>3.8</vh></v>
<v t="T2329"><vh>3.7</vh></v>
<v t="T2330"><vh>3.6</vh></v>
<v t="T2331"><vh>3.5</vh></v>
<v t="T2332"><vh>3.4</vh></v>
<v t="T2333"><vh>3.3</vh></v>
<v t="T2334"><vh>3.2</vh></v>
<v t="T2335"><vh>3.1</vh></v>
<v t="T2336"><vh>3.0</vh></v>
</v>
<v t="T2337"><vh>2.x</vh>
<v t="T2338"><vh>2.5</vh></v>
<v t="T2339"><vh>2.4</vh></v>
<v t="T2340"><vh>2.3</vh></v>
<v t="T2341"><vh>2.2</vh></v>
</v>
</v>
</v>
<v t="T2342" tnodeList="2342,2343,401,402,403,404,2344"><vh>@file leo.py </vh>
<v t="T2343"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="T401" a="C"><vh>run &amp; allies</vh>
<v t="T402"><vh>isValidPython</vh></v>
<v t="T403"><vh>computeLoadDir</vh></v>
<v t="T404" a="C"><vh>createFrame (leo.py)</vh></v>
</v>
<v t="T2344"><vh>profile</vh></v>
</v>
<v t="T2345" tnodeList="2345,1506,1507,177,1684,1958,2346,2347,1682,1683,2348,2349,1854,1685,2350,2351,1686,1819,2352"><vh>@file leoApp.py</vh>
<v t="T1506" a="C"><vh>app.__init__</vh>
<v t="T1507"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T177" a="C"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="T1684" a="C"><vh>app.closeLeoWindow</vh></v>
<v t="T1958" a="C"><vh>app.createTkGui</vh></v>
<v t="T2346"><vh>app.destroyAllGlobalWindows</vh></v>
<v t="T2347"><vh>app.destroyAllOpenWithFiles</vh></v>
<v t="T1682" a="C"><vh>app.destroyAllWindowObjects</vh>
<v t="T1683"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="T2348"><vh>app.destroyOpenWithFilesForFrame</vh></v>
<v t="T2349"><vh>app.destroyOpenWithFileWithDict</vh></v>
<v t="T1854" a="C"><vh>app.destroyWindow</vh></v>
<v t="T1685" a="C"><vh>app.finishQuit</vh></v>
<v t="T2350"><vh>app.forceShutdown</vh></v>
<v t="T2351"><vh>app.get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="T1686" a="C"><vh>app.onQuit</vh></v>
<v t="T1819" a="C"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="T2352"><vh>app.writeWaitingLog</vh></v>
</v>
<v t="T2353" tnodeList="2353,2354,2355,2356,2357,2359,2028,2029,2030,2031,2032,2033,2034,2035,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,1936,1937,1938,1939,2374,2375,1932,1933,1934,1935,2376,2377,2378,2077,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2401,2402,2403,2404,2155,2408,2409,2410,2411,2412,2413,2405,2406,2407,2414,2415,2418,2419,2417,2416,2420,2421,2400,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2435,2436,2437,2438,2439,2440,2445,2446,2447,2442,2441,2443,2444,2448,2449,2450,2451,2452,2453,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2458,2469,2461,2470,2471,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2495,2493,2494,2496,2497,2498,2499,2500,2501,2502,2503,2504,2505,2507,2508,2509,2510,2511,2512,2513,2514,2516,1922,2517,2518,2519,2520,2521,2522,1968,2524,2525,2526,2527,2528,2530,2531,2156,2532,1969,2534,2535,2536,2537,2538,2539,2540,2541,2542,2543,2545,2546,2023,2547,2548,2549,2550,2551,2552,2555,2556,2557,2558,2559,2560,2561,2562,2563,2017,2018,2019,2020,2021,2022,2564,2565,2567,2568,2569,2570,2571,1962,1963,1964,1965,1966,1967,2573,2574,2575"><vh>@file leoAtFile.py </vh>
<v t="T2354"><vh>&lt;&lt; global atFile constants &gt;&gt;</vh></v>
<v t="T2355"><vh>&lt;&lt; class baseAtFile methods &gt;&gt;</vh>
<v t="T2356"><vh>atFile.__init__ &amp; initIvars</vh></v>
<v t="T2357"><vh>top_df.error</vh></v>
<v t="T2358"><vh>Reading</vh>
<v t="T2359"><vh> top_df.readAll</vh></v>
<v t="T2028" a="C"><vh>top_df.read</vh>
<v t="T2029"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="T2030"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="T2031"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="T2032"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="T2033"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="T2034"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="T2035"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="T2360"><vh>top_df.scanDefaultDirectory</vh>
<v t="T2361"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T2362"><vh>&lt;&lt; handle @path &gt;&gt;</vh>
<v t="T2363"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T2364"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T2365"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="T2366"><vh>top_df.scanHeader</vh>
<v t="T2367"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
<v t="T2368"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="T2369"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="T2370"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="T2371"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="T2372"><vh>top_df.readLine</vh></v>
</v>
<v t="T2373"><vh>Writing</vh>
<v t="T1936" a="C"><vh>top_df.writeAll</vh>
<v t="T1937"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T1938"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T1939"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="T2374"><vh>top_df.write, rawWrite, silentWrite</vh></v>
<v t="T2375"><vh>top_df.writeOld/NewDerivedFiles</vh></v>
<v t="T1932" a="C"><vh>top_df.writeMissing</vh>
<v t="T1933"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T1934"><vh>&lt;&lt; create df.outputFile &gt;&gt;</vh></v>
<v t="T1935"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2376"><vh>&lt;&lt; class baseOldDerivedFile methods &gt;&gt;</vh>
<v t="T2377"><vh> old_df.__init__&amp; initIvars</vh>
<v t="T2378"><vh>&lt;&lt; init atFile ivars &gt;&gt;</vh></v>
</v>
<v t="T2379"><vh>Reading (3.x)</vh>
<v t="T2077" a="C"><vh>createImportedNode</vh></v>
<v t="T2380"><vh>old_df.readOpenFile</vh></v>
<v t="T2381"><vh>completeFirstDirectives</vh></v>
<v t="T2382"><vh>completeLastDirectives</vh></v>
<v t="T2383"><vh>createNthChild</vh>
<v t="T2384"><vh>&lt;&lt; check the headlines &gt;&gt;</vh></v>
</v>
<v t="T2385"><vh>handleLinesFollowingSentinel</vh>
<v t="T2386"><vh>&lt;&lt; remove the comment delims from s &gt;&gt;</vh></v>
</v>
<v t="T2387"><vh>readLine</vh></v>
<v t="T2388"><vh>readLinesToNextSentinel</vh></v>
<v t="T2389"><vh>scanDoc</vh>
<v t="T2390"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T2391"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T2392"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T2393"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T2394"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T2395"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="T2396"><vh>scanText</vh>
<v t="T2397"><vh>&lt;&lt; put the next line into s &gt;&gt;</vh></v>
<v t="T2398"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T2399"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T2400"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v t="T2401"><vh>&lt;&lt; handle the line in s &gt;&gt;</vh>
<v t="T2402"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="T2403"><vh>&lt;&lt; handle common sentinels &gt;&gt;</vh>
<v t="T2404"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="T2405"><vh>&lt;&lt; scan old ref &gt;&gt; (3.0)</vh></v>
<v t="T2406"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T2155" a="C"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T2407"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T2408"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T2409"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T2410"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T2411"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T2412"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T2413"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T2414"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v t="T2415"><vh>&lt;&lt; handle rare sentinels &gt;&gt;</vh>
<v t="T2416"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T2417"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
<v t="T2418"><vh>&lt;&lt; scan @comment &gt;&gt;</vh></v>
<v t="T2419"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="T2420"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
</v>
<v t="T2421"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2422"><vh>Sentinels (3.x)</vh>
<v t="T2423"><vh>nodeSentinelText</vh>
<v t="T2424"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="T2425"><vh>putCloseNodeSentinel</vh></v>
<v t="T2426"><vh>putCloseSentinels</vh></v>
<v t="T2427"><vh>putOpenLeoSentinel</vh></v>
<v t="T2428"><vh>putOpenNodeSentinel</vh></v>
<v t="T2429"><vh>putOpenSentinels</vh></v>
<v t="T2430"><vh>putSentinel (applies cweb hack)</vh></v>
<v t="T2431"><vh>sentinelKind</vh></v>
<v t="T2432"><vh>sentinelName</vh></v>
<v t="T2433"><vh>skipSentinelStart</vh></v>
</v>
<v t="T2434"><vh>Utilites (3.x)</vh>
<v t="T2435"><vh>directiveKind</vh></v>
<v t="T2436"><vh>error</vh></v>
<v t="T2437"><vh>readError</vh></v>
<v t="T2438"><vh>scanAllDirectives</vh>
<v t="T2439"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T2440"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T2441"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T2442"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T2443"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T2444"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T2445"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T2446"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T2447"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T2448"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T2449"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T2450"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T2451"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T2452"><vh>skipIndent</vh></v>
<v t="T2453"><vh>writeError</vh></v>
</v>
<v t="T2454"><vh>Writing (3.x)</vh>
<v t="T2455"><vh>Top level</vh>
<v t="T2456"><vh>old_df.rawWrite</vh>
<v t="T2457"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T2458" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2459"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T2460"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T2461" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T2462"><vh>old_df.silentWrite</vh>
<v t="T2463"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T2464"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T2465"><vh>old_df.write</vh>
<v t="T2466"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T2467"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T2468"><vh>&lt;&lt; write then entire @file tree &gt;&gt; (3.x)</vh>
<v t="T2458" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2469"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="T2461" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T2470"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T2471"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T2472"><vh>Top level write helpers</vh>
<v t="T2473"><vh>atFile.closeWriteFile</vh></v>
<v t="T2474"><vh>atFile.handleWriteException</vh></v>
<v t="T2475"><vh>atFile.openWriteFile</vh></v>
<v t="T2476"><vh>atFile.putInitialComment</vh></v>
<v t="T2477"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T2478"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T2479"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T2480"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T2481"><vh>atFile.outputStringWithLineEndings</vh></v>
</v>
</v>
<v t="T2482"><vh>putBodyPart</vh>
<v t="T2483"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T2484"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T2485"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T2486"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T2487"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T2488"><vh>putDoc</vh></v>
<v t="T2489"><vh>putDocPart (3.x)</vh>
<v t="T2490"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T2491"><vh>putCodePart &amp; allies</vh>
<v t="T2492"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T2493"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T2494"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T2495"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T2496"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T2497"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T2498"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T2499"><vh>inAtOthers</vh></v>
<v t="T2500"><vh>isSectionName</vh></v>
<v t="T2501"><vh>putAtOthers</vh></v>
<v t="T2502"><vh>putAtOthersChild</vh></v>
<v t="T2503"><vh>putRef</vh>
<v t="T2504"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T2505"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2506"><vh>Writing Utils</vh>
<v t="T2507"><vh>putBuffered</vh></v>
<v t="T2508"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T2509"><vh>putDirective  (handles @delims)</vh>
<v t="T2510"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T2511"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T2512"><vh>putIndent</vh></v>
</v>
</v>
</v>
<v t="T2513"><vh>&lt;&lt; class baseNewDerivedFile methods &gt;&gt;</vh>
<v t="T2514"><vh>newDerivedFile.__init__</vh></v>
<v t="T2515"><vh>Reading (4.x)</vh>
<v t="T2516"><vh>new_df.readOpenFile</vh></v>
<v t="T1922" a="C"><vh>findChild</vh></v>
<v t="T2517"><vh>scanText4 &amp; allies</vh>
<v t="T2518"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="T2519"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="T2520"><vh>readNormalLine</vh>
<v t="T2521"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T2522"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="T2523"><vh>start sentinels</vh>
<v t="T1968" a="C"><vh>readStartAt, readStartDoc &amp; readStartDocLine</vh></v>
<v t="T2524"><vh>readStartLeo</vh></v>
<v t="T2525"><vh>readStartNode</vh>
<v t="T2526"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="T2527"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="T2528"><vh>readStartOthers</vh></v>
</v>
<v t="T2529"><vh>end sentinels</vh>
<v t="T2530"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="T2531"><vh>readEndLeo</vh></v>
<v t="T2156" a="C"><vh>readEndNode</vh></v>
<v t="T2532"><vh>readEndOthers</vh></v>
<v t="T1969" a="C"><vh>readLastDocLine</vh></v>
</v>
<v t="T2533"><vh>Unpaired sentinels</vh>
<v t="T2534"><vh>ignoreOldSentinel</vh></v>
<v t="T2535"><vh>readAfterRef</vh></v>
<v t="T2536"><vh>readComment</vh></v>
<v t="T2537"><vh>readDelims</vh></v>
<v t="T2538"><vh>readDirective</vh></v>
<v t="T2539"><vh>readNl</vh></v>
<v t="T2540"><vh>readNonl</vh></v>
<v t="T2541"><vh>readRef</vh></v>
<v t="T2542"><vh>readVerbatim</vh></v>
</v>
<v t="T2543"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
</v>
<v t="T2544"><vh>Sentinels (4.x)</vh>
<v t="T2545"><vh>nodeSentinelText</vh>
<v t="T2546"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="T2023" a="C"><vh>putLeadInSentinel</vh></v>
<v t="T2547"><vh>putOpenLeoSentinel</vh></v>
<v t="T2548"><vh>putOpenNodeSentinel</vh></v>
<v t="T2549"><vh>putSentinel (applies cweb hack)</vh>
<v t="T2550"><vh>&lt;&lt; apply the cweb hack to s &gt;&gt;</vh></v>
</v>
<v t="T2551"><vh>skipSentinelStart</vh></v>
<v t="T2552"><vh>sentinelKind</vh></v>
</v>
<v t="T2553"><vh>Writing (4.x)</vh>
<v t="T2554"><vh>Top level</vh>
<v t="T2555"><vh>new_df.closeWriteFile</vh></v>
<v t="T2556"><vh>new_df.write</vh>
<v t="T2557"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T2558"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T2559"><vh>&lt;&lt; write then entire @file tree &gt;&gt; (4.x)</vh>
<v t="T2560"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2561"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T2562"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T2563"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T2017" a="C"><vh>new_df.rawWrite</vh>
<v t="T2018"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T2019"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2020"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T2021"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T2022"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2564"><vh>putBody</vh>
<v t="T2565"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="T2566"><vh>code lines...</vh>
<v t="T2567"><vh>inAtOthers</vh></v>
<v t="T2568"><vh>putAtOthersChild</vh></v>
<v t="T2569"><vh>putAtOthersLine</vh></v>
<v t="T2570"><vh>putCodeLine</vh></v>
<v t="T2571"><vh>putRefLine</vh></v>
</v>
<v t="T1961" a="C"><vh>doc lines... (write)</vh>
<v t="T1962"><vh>putBlankDocLine</vh></v>
<v t="T1963"><vh>putStartDocLine</vh></v>
<v t="T1964"><vh>putDocLine</vh>
<v t="T1965"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1966"><vh>putEndDocLine</vh></v>
<v t="T1967"><vh>putPending</vh></v>
</v>
<v t="T2572"><vh>Writing Utils...</vh>
<v t="T2573"><vh>hasSectionName</vh></v>
<v t="T2574"><vh>os, onl, etc.</vh></v>
<v t="T2575"><vh>directiveKind</vh></v>
</v>
</v>
</v>
</v>
<v t="T2576" tnodeList="2576,1697,2577,2578,2579,2580,408,409,2581,2582,2583,2584,2585,2586,2587,411,412,2588,2589,2116,180,181,182,183,184,185,186,187,188,190,192,189,191,1707,1708,1709,1710,2118,2119,2120,2121,2122,1704,1705,179,2123,1810,1811,1812,1813,1814,2124,2127,2128,2125,2126,2129,1720,2130,1716,1717,1718,2131,1715,1722,2132,2096,2098,2099,2100,2101,2102,2104,2103,1719,1721,2105,2107,1714,2109,2110,2111,2112,2113,2133,2134,1706,1467,1468,1469,2135,2136,2137,2138,2139,2140,1711,2141,2142,1712,2143"><vh>@file leoColor.py</vh>
<v t="T1697" a="C"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="T2577"><vh>&lt;&lt; define colorizer constants &gt;&gt;</vh></v>
<v t="T2578"><vh>&lt;&lt; define color panel data &gt;&gt;</vh></v>
<v t="T2579"><vh>class leoColorPanel</vh>
<v t="T2580"><vh>colorPanel.__init__</vh></v>
<v t="T408" a="C"><vh>run</vh>
<v t="T409"><vh>&lt;&lt; create color panel &gt;&gt;</vh></v>
</v>
<v t="T2581"><vh>showColorPicker</vh></v>
<v t="T2582"><vh>showColorName</vh></v>
<v t="T2583"><vh>colorPanel.onOk, onCancel, onRevert</vh></v>
<v t="T2584"><vh>update</vh></v>
</v>
<v t="T2585"><vh>class leoColorNamePanel</vh>
<v t="T2586"><vh>namePanel.__init__</vh></v>
<v t="T2587"><vh>getSelection</vh></v>
<v t="T411" a="C"><vh>run</vh>
<v t="T412"><vh>&lt;&lt; create color name panel &gt;&gt;</vh></v>
</v>
<v t="T2588"><vh>onOk, onCancel, onRevert, OnApply</vh></v>
<v t="T2589"><vh>select</vh></v>
</v>
<v t="T2116" a="C"><vh>class colorizer</vh>
<v t="T180" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="T181"><vh>&lt;&lt; actionscript keywords &gt;&gt;</vh></v>
<v t="T182"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T183"><vh>&lt;&lt; elisp keywords&gt;&gt;</vh></v>
<v t="T184"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T185"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T186"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T187"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T188"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T189"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
<v t="T190"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T191"><vh>&lt;&lt; rebol keywords &gt;&gt;</vh></v>
<v t="T192"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
</v>
<v t="T1707" a="C"><vh>color.__init__</vh>
<v t="T1708"><vh>&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;</vh></v>
<v t="T1709"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; define fonts and data for wiki tags &gt;&gt;</vh></v>
</v>
<v t="T2117"><vh>color.callbacks...</vh>
<v t="T2118"><vh>OnHyperLinkControlClick</vh></v>
<v t="T2119"><vh>OnHyperLinkEnter</vh></v>
<v t="T2120"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="T2121"><vh>colorize &amp; recolor_range</vh></v>
<v t="T2122"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="T1704" a="C"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="T1705"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T179" a="C"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="T2123"><vh>&lt;&lt; all state ivars match &gt;&gt;</vh></v>
<v t="T1810" a="C"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T1811"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1812"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T1813"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T1814"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="T2124"><vh>&lt;&lt; non-incrementally color the text &gt;&gt;</vh></v>
<v t="T2125"><vh>&lt;&lt; update state ivars &gt;&gt;</vh></v>
<v t="T2126"><vh>&lt;&lt; set state ivars to "unknown" &gt;&gt;</vh></v>
<v t="T2127"><vh>&lt;&lt; completely recolor in two passes &gt;&gt;</vh>
<v t="T2128"><vh>&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;</vh></v>
</v>
</v>
<v t="T2129"><vh>colorizeLine &amp; allies</vh>
<v t="T1720" a="C"><vh>continueBlockComment</vh></v>
<v t="T2130"><vh>continueSingle/DoubleString</vh></v>
<v t="T1716" a="C"><vh>continueDocPart</vh>
<v t="T1717"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T1718"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T2131"><vh>continueNocolor</vh></v>
<v t="T1715" a="C"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T1722" a="C"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="T2132"><vh>doLatexLine</vh></v>
<v t="T2096" a="C"><vh>doNormalState</vh>
<v t="T2097"><vh>Valid regardless of latex mode</vh>
<v t="T2098"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="T2099"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="T2100"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="T2101"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="T2102"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T2103"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T2104"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T1719" a="C"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T1721" a="C"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T2105"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T2106"><vh>Vaid only in latex mode</vh>
<v t="T2107"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T2108"><vh>Valid when not in latex_mode</vh>
<v t="T1714" a="C"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T2109"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T2110"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T2111"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T2112"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T2113"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T2133"><vh>doNowebSecRef</vh>
<v t="T2134"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T1706" a="C"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
<v t="T1467" a="C"><vh>scanColorDirectives</vh>
<v t="T1468"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T1469"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T2135"><vh>color.schedule</vh></v>
<v t="T2136"><vh>getCwebWord</vh></v>
<v t="T2137"><vh>removeAllImages</vh></v>
<v t="T2138"><vh>updateSyntaxColorer</vh></v>
<v t="T2139"><vh>useSyntaxColoring</vh></v>
<v t="T2140"><vh>Utils</vh>
<v t="T1711" a="C"><vh>index &amp; tag</vh></v>
<v t="T2141"><vh>setFirstLineState</vh></v>
<v t="T2142"><vh>skip_id</vh></v>
<v t="T1712" a="C"><vh>skip_python_string</vh></v>
<v t="T2143"><vh>skip_string</vh></v>
</v>
</v>
</v>
<v t="T2590" tnodeList="2590,1946,1947,1948,2591,2592,651,652,653,2594,2595,2596,2597,2598,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,2600,2601,2602,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,649,2619,2620,2621,2622,2623,2624,2625,2628,2629,2630,2631,2632,2633,2634,2635,2636,2638,2639,2640,2642,2643,2644,2645,2646,2647,2036,1974,1039,1864,1873,1975,1976,1977,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,1979,1980,1981,1034,1035,1036,1860,1861,1982,1983,1984,1985,1986,1987,1988,1989,1990,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670"><vh>@file leoCommands.py</vh>
<v t="T1945" a="C"><vh>c.Birth &amp; death</vh>
<v t="T1946" a="C"><vh>c.__init__, initIvars</vh>
<v t="T1947"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T1948"><vh>c.__repr__ &amp; __str__</vh></v>
</v>
<v t="T2591"><vh>c.setIvarsFromFind</vh></v>
<v t="T2592"><vh>c.setIvarsFromPrefs</vh></v>
<v t="T650" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T651"><vh>cutOutline</vh></v>
<v t="T652"><vh>copyOutline</vh></v>
<v t="T653"><vh>pasteOutline</vh></v>
</v>
<v t="T2593"><vh>Drawing Utilities</vh>
<v t="T2594"><vh>beginUpdate</vh></v>
<v t="T2595"><vh>bringToFront</vh></v>
<v t="T2596"><vh>endUpdate</vh></v>
<v t="T2597"><vh>recolor</vh></v>
<v t="T2598"><vh>redraw &amp; repaint</vh></v>
</v>
<v t="T414" a="C"><vh>Edit Body Text</vh>
<v t="T415" a="C"><vh>convertAllBlanks</vh></v>
<v t="T416" a="C"><vh>convertAllTabs</vh></v>
<v t="T417"><vh>convertBlanks</vh></v>
<v t="T418"><vh>convertTabs</vh></v>
<v t="T419"><vh>createLastChildNode</vh></v>
<v t="T420"><vh>dedentBody</vh></v>
<v t="T421" a="C"><vh>extract</vh>
<v t="T422"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T423" a="C"><vh>extractSection</vh>
<v t="T424"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T425" a="C"><vh>extractSectionNames</vh>
<v t="T426"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T427" a="C"><vh>getBodyLines</vh></v>
<v t="T428"><vh>getBodySelection</vh></v>
<v t="T429"><vh>indentBody</vh></v>
<v t="T430"><vh>reformatParagraph</vh>
<v t="T431"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T432"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="T2599"><vh>Enabling Menu Items (Commands)</vh>
<v t="T2600"><vh>canContractAllHeadlines</vh></v>
<v t="T2601"><vh>canContractAllSubheads</vh></v>
<v t="T2602"><vh>canContractParent</vh></v>
<v t="T2603"><vh>canContractSubheads</vh></v>
<v t="T2604"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T2605"><vh>canDemote</vh></v>
<v t="T2606"><vh>canExpandAllHeadlines</vh></v>
<v t="T2607"><vh>canExpandAllSubheads</vh></v>
<v t="T2608"><vh>canExpandSubheads</vh></v>
<v t="T2609"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T2610"><vh>canFindMatchingBracket</vh></v>
<v t="T2611"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T2612"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T2613"><vh>canMarkChangedHeadline</vh></v>
<v t="T2614"><vh>canMarkChangedRoots</vh></v>
<v t="T2615"><vh>canMoveOutlineDown</vh></v>
<v t="T2616"><vh>canMoveOutlineLeft</vh></v>
<v t="T2617"><vh>canMoveOutlineRight</vh></v>
<v t="T2618"><vh>canMoveOutlineUp</vh></v>
<v t="T649" a="C"><vh>canPasteOutline</vh></v>
<v t="T2619"><vh>canPromote</vh></v>
<v t="T2620"><vh>canRevert</vh></v>
<v t="T2621"><vh>canSelect....</vh></v>
<v t="T2622"><vh>canShiftBodyLeft/Right</vh></v>
<v t="T2623"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T2624"><vh>canUndo &amp; canRedo</vh></v>
<v t="T2625"><vh>canUnmarkAll</vh></v>
</v>
<v t="T2626"><vh>Expand &amp; Contract</vh>
<v t="T2627"><vh>Commands</vh>
<v t="T2628"><vh>contractAllHeadlines</vh></v>
<v t="T2629"><vh>contractNode</vh></v>
<v t="T2630"><vh>contractParent</vh></v>
<v t="T2631"><vh>expandAllHeadlines</vh></v>
<v t="T2632"><vh>expandAllSubheads</vh></v>
<v t="T2633"><vh>expandLevel1..9</vh></v>
<v t="T2634"><vh>expandNextLevel</vh></v>
<v t="T2635"><vh>expandNode</vh></v>
<v t="T2636"><vh>expandPrevLevel</vh></v>
</v>
<v t="T2637"><vh>Utilities</vh>
<v t="T2638"><vh>contractSubtree</vh></v>
<v t="T2639"><vh>expandSubtree</vh></v>
<v t="T2640"><vh>expandToLevel</vh></v>
</v>
</v>
<v t="T2641"><vh>Getters &amp; Setters</vh>
<v t="T2642"><vh>c.currentVnode</vh></v>
<v t="T2643"><vh>clearAllMarked</vh></v>
<v t="T2644"><vh>clearAllVisited</vh></v>
<v t="T2645"><vh>fileName</vh></v>
<v t="T2646"><vh>isChanged</vh></v>
<v t="T2647"><vh>rootVnode</vh></v>
<v t="T2036" a="C"><vh>setChanged</vh></v>
</v>
<v t="T1973" a="C"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="T1974"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T1039" a="C"><vh>c.deleteHeadline</vh></v>
<v t="T1864" a="C"><vh>c.insertHeadline</vh></v>
<v t="T1873" a="C"><vh>c.clone</vh></v>
<v t="T1975" a="C"><vh>initAllCloneBits &amp; initAllCloneBitsInTree</vh></v>
<v t="T1976"><vh>c.initJoinedClonedBits (changed in 3.11.1)</vh></v>
<v t="T1977"><vh>validateOutline</vh></v>
</v>
<v t="T2648"><vh>Mark &amp; Unmark &amp; goto</vh>
<v t="T2649"><vh>goToNextDirtyHeadline</vh></v>
<v t="T2650"><vh>goToNextMarkedHeadline</vh></v>
<v t="T2651"><vh>goToNextClone</vh></v>
<v t="T2652"><vh>markChangedHeadlines</vh></v>
<v t="T2653"><vh>markChangedRoots</vh></v>
<v t="T2654"><vh>markAllAtFileNodesDirty</vh></v>
<v t="T2655"><vh>markAtFileNodesDirty</vh></v>
<v t="T2656"><vh>markClones</vh></v>
<v t="T2657"><vh>markHeadline</vh></v>
<v t="T2658"><vh>markSubheads</vh></v>
<v t="T2659"><vh>unmarkAll</vh></v>
</v>
<v t="T1978" a="C"><vh>Moving, Dragging, Promote, Demote, Sort (commands)</vh>
<v t="T1979"><vh>c.dragAfter</vh></v>
<v t="T1980"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="T1981"><vh>c.dragToNthChildOf</vh></v>
<v t="T1034" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1035"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1036"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1860" a="C"><vh>c.sortTopLevel</vh>
<v t="T1861"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="T1982"><vh>demote</vh></v>
<v t="T1983"><vh>moveOutlineDown</vh>
<v t="T1984"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T1985"><vh>moveOutlineLeft</vh></v>
<v t="T1986"><vh>moveOutlineRight</vh></v>
<v t="T1987"><vh>moveOutlineUp</vh>
<v t="T1988"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T1989"><vh>promote</vh></v>
<v t="T1990"><vh>c.dragCloneAfter (changed in 3.11.1)</vh></v>
</v>
<v t="T2660"><vh>Selecting &amp; Updating (commands)</vh>
<v t="T2661"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="T2662"><vh>endEditing (calls tree.endEditLabel)</vh></v>
<v t="T2663"><vh>selectThreadBack</vh></v>
<v t="T2664"><vh>selectThreadNext</vh></v>
<v t="T2665"><vh>selectVisBack</vh></v>
<v t="T2666"><vh>selectVisNext</vh></v>
<v t="T2667"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="T2668"><vh>selectVnodeWithEditing</vh></v>
</v>
<v t="T2669"><vh>Syntax coloring interface</vh>
<v t="T2670"><vh>updateSyntaxColorer</vh></v>
</v>
</v>
<v t="T2671" tnodeList="2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2687,2688,2689,2690,990,2691,2692,2693,2694,434,2695,435,436,437,438,439,440,441,2696,2697,2699,2700,2701,2702"><vh>@file leoCompare.py</vh>
<v t="T2672"><vh>choose</vh></v>
<v t="T2673"><vh>go</vh></v>
<v t="T2674"><vh>class leoCompare</vh>
<v t="T2675"><vh>compare.__init__</vh></v>
<v t="T2676"><vh>compare_directories (entry)</vh></v>
<v t="T2677"><vh>compare_files (entry)</vh></v>
<v t="T2678"><vh>compare_lines</vh></v>
<v t="T2679"><vh>compare_open_files</vh>
<v t="T2680"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="T2681"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="T2682"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="T2683"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="T2684"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="T2685"><vh>filecmp</vh></v>
<v t="T2686"><vh>utils...</vh>
<v t="T2687"><vh>doOpen</vh></v>
<v t="T2688"><vh>dump</vh></v>
<v t="T2689"><vh>dumpToEndOfFile</vh></v>
<v t="T2690"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="T990" a="C"><vh>openOutputFile (compare)</vh></v>
<v t="T2691"><vh>show</vh></v>
<v t="T2692"><vh>showIvars</vh></v>
</v>
</v>
<v t="T2693"><vh>class leoComparePanel</vh>
<v t="T2694"><vh>browser</vh></v>
<v t="T434" a="C"><vh>comparePanel.__init__</vh></v>
<v t="T2695"><vh>finishCreate</vh></v>
<v t="T435" a="C"><vh>run</vh>
<v t="T436"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T437"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="T438"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="T439"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="T2696"><vh>show</vh></v>
<v t="T2697"><vh>setIvarsFromWidgets</vh></v>
<v t="T2698"><vh>Event handlers...</vh>
<v t="T2699"><vh>onBrowse...</vh></v>
<v t="T2700"><vh>onClose</vh></v>
<v t="T2701"><vh>onCompare...</vh></v>
<v t="T2702"><vh>onPrintMatchedLines</vh></v>
</v>
</v>
</v>
<v t="T2703" tnodeList="2703,2704,2705,2706,2707,2709,2710,2711,2712,2713,2714,2715,2716,1917,2717,667,2718,2719,666,2720,2721,1511,2722,1512,2723,991,992,1510"><vh>@file leoConfig.py</vh>
<v t="T2704"><vh>&lt;&lt; define defaultsDict &gt;&gt;</vh></v>
<v t="T2705"><vh>config.__init__</vh>
<v t="T2706"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T2707"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v t="T2708"><vh>getters/setters</vh>
<v t="T2709"><vh>get...FromDict &amp; setDict</vh></v>
<v t="T2710"><vh>get/setColors</vh></v>
<v t="T2711"><vh>get/setComparePref</vh></v>
<v t="T2712"><vh>get/setFindPref</vh></v>
<v t="T2713"><vh>get/setPref</vh></v>
<v t="T2714"><vh>get/setRecentFiles</vh></v>
<v t="T2715"><vh>get/setWindowPrefs</vh></v>
<v t="T2716"><vh>config.getFontFromParams</vh></v>
<v t="T1917" a="C"><vh>getShortcut</vh></v>
<v t="T2717"><vh>init/Boolean/ConfigParam</vh></v>
<v t="T667" a="C"><vh>setCommandsFindIvars</vh></v>
<v t="T2718"><vh>setCommandsIvars</vh>
<v t="T2719"><vh>&lt;&lt; set prefs ivars &gt;&gt;</vh></v>
</v>
<v t="T666" a="C"><vh>setConfigFindIvars</vh></v>
<v t="T2720"><vh>setConfigIvars</vh></v>
</v>
<v t="T2721"><vh>open</vh>
<v t="T1511" a="C"><vh>&lt;&lt; get config options &gt;&gt;</vh></v>
<v t="T2722"><vh>&lt;&lt; get recent files &gt;&gt;</vh></v>
<v t="T1512" a="C"><vh>&lt;&lt; convert find/change options to unicode &gt;&gt;</vh></v>
<v t="T2723"><vh>&lt;&lt; print options &gt;&gt;</vh></v>
</v>
<v t="T991" a="C"><vh>update (config)</vh>
<v t="T992"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="T1510" a="C"><vh>update_section</vh></v>
</v>
<v t="T2724" tnodeList="2724,443,444,445,446,447,448,449,450,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765"><vh>@file leoDialog.py</vh>
<v t="T443" a="C"><vh> class leoDialog</vh>
<v t="T444"><vh>__init__ (leoDialog)</vh></v>
<v t="T445"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="T446"><vh>center</vh></v>
<v t="T447"><vh>createButtons</vh></v>
<v t="T448"><vh>createMessageFrame</vh></v>
<v t="T449"><vh>createTopFrame</vh></v>
<v t="T450"><vh>run</vh></v>
</v>
<v t="T2725"><vh>class aboutLeo</vh>
<v t="T2726"><vh>aboutLeo.__init__</vh></v>
<v t="T2727"><vh>aboutLeo.createFrame</vh></v>
<v t="T2728"><vh>onAboutLeoEmail</vh></v>
<v t="T2729"><vh>onAboutLeoUrl</vh></v>
<v t="T2730"><vh>setArrowCursor, setDefaultCursor</vh></v>
</v>
<v t="T2731"><vh>class askLeoID</vh>
<v t="T2732"><vh>askLeoID.__init__</vh></v>
<v t="T2733"><vh>askLeoID.createFrame</vh></v>
<v t="T2734"><vh>onCloseWindow</vh></v>
<v t="T2735"><vh>onButton</vh></v>
<v t="T2736"><vh>onKey</vh>
<v t="T2737"><vh>&lt;&lt; eliminate invalid characters &gt;&gt;</vh></v>
<v t="T2738"><vh>&lt;&lt; enable the ok button if there are 4 or more valid characters &gt;&gt;</vh></v>
</v>
</v>
<v t="T2739"><vh>class askOk</vh>
<v t="T2740"><vh>askOk.__init__</vh></v>
<v t="T2741"><vh>askOk.onKey</vh></v>
</v>
<v t="T2742"><vh>class askOkCancel</vh>
<v t="T2743"><vh>askOkCancel.__init__</vh></v>
<v t="T2744"><vh>askOkCancel.onKey</vh></v>
</v>
<v t="T2745"><vh>class askOkCancelNumber</vh>
<v t="T2746"><vh>askOKCancelNumber.__init__</vh></v>
<v t="T2747"><vh>askOKCancelNumber.createFrame</vh></v>
<v t="T2748"><vh>askOKCancelNumber.okButton, cancelButton</vh></v>
<v t="T2749"><vh>askOKCancelNumber.onKey</vh>
<v t="T2750"><vh>&lt;&lt; eliminate non-numbers &gt;&gt;</vh></v>
</v>
</v>
<v t="T2751"><vh>class askYesNo</vh>
<v t="T2752"><vh>askYesNo.__init__</vh></v>
<v t="T2753"><vh>askYesNo.onKey</vh></v>
</v>
<v t="T2754"><vh>class askYesNoCancel</vh>
<v t="T2755"><vh>askYesNoCancel.__init__</vh></v>
<v t="T2756"><vh>askYesNoCancel.onKey</vh></v>
<v t="T2757"><vh>askYesNoCancel.noButton &amp; yesButton</vh></v>
</v>
<v t="T2758"><vh>class listboxDialog</vh>
<v t="T2759"><vh>listboxDialog.__init__</vh></v>
<v t="T2760"><vh>addStdButtons</vh></v>
<v t="T2761"><vh>createFrame</vh></v>
<v t="T2762"><vh>destroy</vh></v>
<v t="T2763"><vh>hide</vh></v>
<v t="T2764"><vh>fillbox</vh></v>
<v t="T2765"><vh>go</vh></v>
</v>
</v>
<v t="T2766" tnodeList="2766,2767,2114,2115,1650,1651,1652,1090,1091,2770,2771,2772,668,669,2773,1646,1647,1648,1649,2774,1653,2775,2776,2777,2778,1655,1658,1657,1656,1654,1660,1661,1662,2779,1659,1095,1558,2780,2781,2782,1857,2783,2026,2025,2026,2027,2784,2785,1664,1645,1560,2788,2789,2790,670,671,2791,2792,2793,2794,2795,1665,2796,2797,2798,2799,1092,1093,1094,1669,1670,2800,1667,1668,2801,2802,2803,2805,2804,1671,1915,2806,2807,2808,2809,2810,2811,2812,2811,2812,1930,1764,1931,2813,2814"><vh>@file leoFileCommands.py</vh>
<v t="T2767"><vh>leoFileCommands._init_</vh></v>
<v t="T2768"><vh>Reading</vh>
<v t="T2114" a="C"><vh>createVnode</vh>
<v t="T2115"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="T1650" a="C"><vh>finishPaste</vh>
<v t="T1651"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T1652"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T2769"><vh>get routines</vh>
<v t="T1089" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1090"><vh>get routines</vh></v>
<v t="T1091"><vh>match routines</vh></v>
</v>
<v t="T2770"><vh>getClipboardHeader</vh></v>
<v t="T2771"><vh>getCloneWindows</vh></v>
<v t="T2772"><vh>getEscapedString</vh></v>
<v t="T668" a="C"><vh>getFindPanelSettings</vh>
<v t="T669" a="C"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T2773"><vh>getGlobals (changed for 4.0)</vh></v>
<v t="T1646" a="C"><vh>getLeoFile (calls setAllJoinLinks, initAllCloneBits)</vh>
<v t="T1647"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1648"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="T1649"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
</v>
<v t="T2774"><vh>getLeoHeader</vh></v>
<v t="T1653" a="C"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T2775"><vh>getPosition</vh></v>
<v t="T2776"><vh>getPrefs</vh>
<v t="T2777" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
</v>
<v t="T2778"><vh>getSize</vh></v>
<v t="T1655" a="C"><vh>getTnode</vh>
<v t="T1656"><vh>&lt;&lt; handle read from file &gt;&gt;</vh></v>
<v t="T1657"><vh>&lt;&lt; handle read from clipboard &gt;&gt;</vh></v>
<v t="T1658"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="T1654" a="C"><vh>getTnodes</vh></v>
<v t="T1660" a="C"><vh>getVnode</vh>
<v t="T1661"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="T1662"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
</v>
<v t="T2779"><vh>getTnodeList (4.0)</vh></v>
<v t="T1659" a="C"><vh>getVnodes</vh></v>
<v t="T1095" a="C"><vh>getXmlStylesheetTag</vh></v>
<v t="T1558" a="C"><vh>getXmlVersionTag</vh></v>
<v t="T2780"><vh>skipWs</vh></v>
<v t="T2781"><vh>skipWsAndNl</vh></v>
</v>
<v t="T2782"><vh>newTnode</vh></v>
<v t="T1857" a="C"><vh>readAtFileNodes</vh></v>
<v t="T2783"><vh>fileCommands.readOutlineOnly</vh>
<v t="T2026" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T2025" a="C"><vh>fileCommands.open</vh>
<v t="T2026" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
<v t="T2027"><vh>&lt;&lt; Make the top node visible &gt;&gt;</vh></v>
</v>
<v t="T2784"><vh>fileCommands.setAllJoinLinks</vh></v>
<v t="T2785"><vh>xmlUnescape</vh></v>
</v>
<v t="T2786"><vh>Writing</vh>
<v t="T1664" a="C"><vh>assignFileIndices</vh></v>
<v t="T1645" a="C"><vh>compactFileIndices</vh></v>
<v t="T2787"><vh>put routines</vh>
<v t="T1560" a="C"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T2788"><vh>putClipboardHeader</vh>
<v t="T2789"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="T2790"><vh>putEscapedString</vh></v>
<v t="T670" a="C"><vh>putFindSettings</vh>
<v t="T671"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T2791"><vh>putGlobals (changed for 4.0)</vh>
<v t="T2792"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="T2793"><vh>&lt;&lt; put the position of this frame &gt;&gt;</vh></v>
<v t="T2794"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="T2795"><vh>putHeader</vh></v>
<v t="T1665" a="C"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="T2796"><vh>putPostlog</vh></v>
<v t="T2797"><vh>putPrefs</vh>
<v t="T2798"><vh>&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt; (putPrefs)</vh>
<v t="T2799"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="T1092" a="C"><vh>putProlog</vh>
<v t="T1093"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T1669" a="C"><vh>putTnode</vh>
<v t="T1670"><vh>&lt;&lt; put unknown tnode attributes &gt;&gt;</vh></v>
</v>
<v t="T2800"><vh>putTnodeList (4.0)</vh></v>
<v t="T1667" a="C"><vh>putTnodes</vh>
<v t="T1668"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="T2801" a="C"><vh>putVnode (3.x and 4.x)</vh>
<v t="T2802"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T2803"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T2804"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
<v t="T2805"><vh>&lt;&lt; put unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="T1671" a="C"><vh>putVnodes</vh></v>
</v>
<v t="T1915" a="C"><vh>save</vh></v>
<v t="T2806"><vh>saveAs</vh></v>
<v t="T2807"><vh>saveTo</vh></v>
<v t="T2808"><vh>setDefaultDirectoryForNewFiles</vh></v>
<v t="T2809"><vh>write_LEO_file</vh>
<v t="T2810"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="T2811"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="T2812"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
</v>
<v t="T1930" a="C"><vh>writeAtFileNodes</vh></v>
<v t="T1764" a="C"><vh>writeDirtyAtFileNodes</vh></v>
<v t="T1931" a="C"><vh>writeMissingAtFileNodes</vh></v>
<v t="T2813"><vh>writeOutlineOnly</vh></v>
<v t="T2814"><vh>xmlEscape</vh></v>
</v>
</v>
<v t="T2815" tnodeList="2815,2178,2816,2817,2818,2819,2146,2820,453,454,455,457,456,458,1900,1901,1550,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2148,2149,2150,2834,2151,2835,2836,2152,2837,672,2838,2839,2840,2841,2153,2843,2844,2845,2846,2847,2848,2849,2850,2851"><vh>@file leoFind.py</vh>
<v t="T2178" a="C"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="T2816"><vh>class leoFindBase</vh>
<v t="T2817"><vh>findBase.__init__</vh></v>
<v t="T2818"><vh>onCloseWindow</vh></v>
<v t="T2819"><vh>resetWrap</vh></v>
<v t="T2146" a="C"><vh>OnReturnKey (no longer used)</vh></v>
</v>
<v t="T2820"><vh>class leoFind</vh>
<v t="T453" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T454"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
</v>
<v t="T455" a="C"><vh>find.createFrame</vh>
<v t="T456"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T1900" a="C"><vh>find.init</vh>
<v t="T1901"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1550" a="C"><vh>find.set_ivars</vh></v>
<v t="T2821"><vh>Top Level Commands</vh>
<v t="T2822"><vh>changeButton</vh></v>
<v t="T2823"><vh>changeAllButton</vh></v>
<v t="T2824"><vh>changeThenFindButton</vh></v>
<v t="T2825"><vh>findButton</vh></v>
<v t="T2826"><vh>findAllButton</vh></v>
<v t="T2827"><vh>changeCommand</vh></v>
<v t="T2828"><vh>changeThenFindCommandd</vh></v>
<v t="T2829"><vh>findNextCommand</vh></v>
<v t="T2830"><vh>fndPreviousCommand</vh></v>
<v t="T2831"><vh>setup_button</vh></v>
<v t="T2832"><vh>setup_command</vh></v>
</v>
<v t="T2833"><vh>Utilities</vh>
<v t="T2148" a="C"><vh>batchChange</vh>
<v t="T2149"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T2150"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
<v t="T2834"><vh>change</vh></v>
<v t="T2151" a="C"><vh>changeAll</vh></v>
<v t="T2835"><vh>changeSelection</vh></v>
<v t="T2836"><vh>changeThenFind</vh></v>
<v t="T2152" a="C"><vh>findAll</vh></v>
<v t="T2837"><vh>findNext</vh></v>
<v t="T672" a="C"><vh>findNextMatch</vh></v>
<v t="T2838"><vh>selectNextVnode</vh></v>
<v t="T2839"><vh>search</vh>
<v t="T2840"><vh>&lt;&lt; search again after getting stuck going backward &gt;&gt;</vh></v>
<v t="T2841"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T2153" a="C"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T2842"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T2843"><vh>checkArgs</vh></v>
<v t="T2844"><vh>initBatchCommands</vh></v>
<v t="T2845"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T2846"><vh>initInHeadline</vh></v>
<v t="T2847"><vh>initInteractiveCommands</vh></v>
<v t="T2848"><vh>printLine</vh></v>
<v t="T2849"><vh>restore</vh></v>
<v t="T2850"><vh>save</vh></v>
<v t="T2851"><vh>showSuccess</vh></v>
</v>
</v>
</v>
</v>
<v t="T2852" tnodeList="2852,461,462,463,464,465,466,467,2854,2855,2856,2857,2858,2860,2861,469,470,471,472,473,474,475,476,477,478,479"><vh>@file leoFontPanel.py</vh>
<v t="T460" a="C"><vh>Birth &amp; Death</vh>
<v t="T461"><vh>fontPanel.__init__</vh></v>
<v t="T462"><vh>create_outer</vh>
<v t="T463"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; create the font pane &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; create the checkboxes &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; create the buttons &gt;&gt;</vh></v>
</v>
<v t="T467"><vh>finishCreate</vh></v>
</v>
<v t="T2853"><vh>Buttons</vh>
<v t="T2854"><vh>onApply</vh></v>
<v t="T2855"><vh>onCancel</vh></v>
<v t="T2856"><vh>onOk</vh>
<v t="T2857"><vh>&lt;&lt; update the configuration settings &gt;&gt;</vh></v>
</v>
<v t="T2858"><vh>onRevert</vh></v>
</v>
<v t="T2859"><vh>Events</vh>
<v t="T2860"><vh>selectFont</vh></v>
<v t="T2861"><vh>onSizeEntryKey</vh></v>
</v>
<v t="T468" a="C"><vh>Helpers</vh>
<v t="T469"><vh>getActiveFont</vh></v>
<v t="T470"><vh>getFontSettings</vh></v>
<v t="T471"><vh>getImpliedFont</vh></v>
<v t="T472"><vh>hide</vh></v>
<v t="T473"><vh>revertIvars</vh></v>
<v t="T474"><vh>run</vh></v>
<v t="T475"><vh>setRevertVars</vh></v>
<v t="T476"><vh>showSettings</vh></v>
<v t="T477"><vh>update</vh>
<v t="T478"><vh>&lt;&lt; insert the new text in the size box &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; set the fonts in all panes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2862" tnodeList="2862,481,482,1950,1951,1952,1953,1954,483,484,485,486,487,1687,1688,1689,2864,2865,2866,2867,1725,2868,2869,2870,1623,2871,2166,1997,846,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1627,1628,1629,1630,1631,1632,2872,1563,2873,1160,1164,1161,1162,1163,1165,1166,1173,1174,1175,1176,1177,1178,1179,1180,1167,1168,1169,1170,1171,1172,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1216,1217,1218,1219,1221,1222,1223,1224,1225,1226,1228,1229,1231,1232,1233,1235,1236,1237,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1252,1253,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1299,1300,1301,1302,1304,1305,1306,1307,1308,1311,1312,1313,1314,1315,1316,1317,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1398,1399,1400,1401,1402,2874,2875,2876,1625,2877,2878,2879,2880,2881,1633,1634,1635,1636,1637"><vh>@file leoFrame.py</vh>
<v t="T1949" a="C"><vh>frame.Birth &amp; Death</vh>
<v t="T481" a="C"><vh>f.__init__</vh>
<v t="T482"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
</v>
<v t="T1950" a="CM"><vh>f.version &amp; signon stuff</vh></v>
<v t="T1951"><vh>f.finishCreate</vh>
<v t="T1952"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T1953"><vh>f.__repr__</vh></v>
<v t="T1954"><vh>f.clearAllIvars</vh></v>
<v t="T483" a="C"><vh>f.createLeoFrame</vh>
<v t="T484"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T485"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T486" a="C"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T487"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1687" a="C"><vh>frame.destroyAllPanels</vh></v>
<v t="T1688" a="C"><vh>frame.promptForSave</vh>
<v t="T1689"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T2863"><vh>Configuration</vh>
<v t="T2864"><vh>f.configureBar</vh></v>
<v t="T2865"><vh>f.configureBarsFromConfig</vh></v>
<v t="T2866"><vh>f.reconfigureFromConfig</vh></v>
<v t="T2867"><vh>f.setBodyFontFromConfig</vh></v>
<v t="T1725" a="C"><vh>f.setInitialWindowGeometry</vh></v>
<v t="T2868"><vh>f.setLogFontFromConfig</vh></v>
<v t="T2869"><vh>f.setTabWidth</vh></v>
<v t="T2870"><vh>f.setTreeColorsFromConfig</vh></v>
<v t="T1623" a="C"><vh>f.setWrap</vh></v>
<v t="T2871"><vh>reconfigurePanes (use config bar_width)</vh></v>
</v>
<v t="T2165" a="C"><vh>Interface with commander</vh>
<v t="T2166"><vh>The interface with frame internals</vh></v>
<v t="T2167"><vh>The interface with the body pane</vh></v>
<v t="T1997" a="C"><vh>The interface with the tree class</vh></v>
</v>
<v t="T846" a="C"><vh>Scrolling callbacks (frame)</vh></v>
<v t="T1779" a="C"><vh>Event handlers (Frame)</vh>
<v t="T1780"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="T1781"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="T1782"><vh>frame.OnVisibility</vh></v>
<v t="T1783"><vh>OnActivateBody</vh></v>
<v t="T1784"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="T1785"><vh>OnActivateLog</vh></v>
<v t="T1786"><vh>OnActivateTree</vh></v>
<v t="T1787"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="T1788"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="T1789" a="C"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="T1626" a="C"><vh>Icon area: convenience routines</vh>
<v t="T1627"><vh>createIconBar</vh></v>
<v t="T1628"><vh>hideIconBar</vh></v>
<v t="T1629"><vh>clearIconBar</vh></v>
<v t="T1630"><vh>showIconBar</vh></v>
<v t="T1631"><vh>addIconButton</vh>
<v t="T1632"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
</v>
<v t="T2872"><vh>f.longFileName &amp; shortFileName</vh></v>
<v t="T1563" a="C"><vh>f.put, putnl</vh></v>
<v t="T2873"><vh>f.getFocus</vh></v>
<v t="T1159" a="C"><vh> Menus</vh>
<v t="T1160"><vh>canonicalizeShortcut</vh>
<v t="T1161"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T1162"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T1163"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T1164"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T1165"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T1166"><vh>createMenuBar</vh>
<v t="T1167"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1168"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1170"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1171"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1173"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1174" a="C"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1175"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1176"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1177"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1178"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1179"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1180"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1181"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1182"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1183"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T1184"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1185"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1186"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1187" a="C"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1188"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T1189"><vh>frame.doCommand</vh></v>
<v t="T1190"><vh>get/set/destroyMenu</vh></v>
<v t="T1191"><vh>Menu Command Handlers</vh>
<v t="T1192"><vh>File Menu</vh>
<v t="T1193"><vh>top level</vh>
<v t="T1194" a="C"><vh>OnNew</vh></v>
<v t="T1195" a="C"><vh>frame.OnOpen</vh>
<v t="T1196"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1197" a="C"><vh>frame.OnOpenWith and allies</vh>
<v t="T1198"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T1199"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="T1200"><vh>&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="T1202"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="T1203"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="T1204" a="C"><vh>frame.createOpenWithTempFile</vh>
<v t="T1205"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="T1206"><vh>frame.openWithTempFilePath</vh></v>
</v>
<v t="T1207" a="C"><vh>frame.OpenWithFileName</vh></v>
<v t="T1208"><vh>frame.OnClose</vh></v>
<v t="T1209"><vh>OnSave</vh></v>
<v t="T1210"><vh>OnSaveAs</vh></v>
<v t="T1211"><vh>OnSaveTo</vh></v>
<v t="T1212" a="C"><vh>frame.OnRevert</vh></v>
<v t="T1213"><vh>frame.OnQuit</vh></v>
<v t="T1214"><vh>frame.updateRecentFiles</vh></v>
</v>
<v t="T1215"><vh>Recent Files submenu &amp; allies</vh>
<v t="T1216"><vh>OnClearRecentFiles</vh></v>
<v t="T1217" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1218"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T1219" a="C"><vh>createRecentFilesMenuItems</vh></v>
</v>
<v t="T1220"><vh>Read/Write submenu</vh>
<v t="T1221" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T1222" a="C"><vh>OnReadAtFileNodes</vh></v>
<v t="T1223"><vh>OnWriteDirtyAtFileNodes</vh></v>
<v t="T1224"><vh>OnWriteMissingAtFileNodes</vh></v>
<v t="T1225"><vh>OnWriteOutlineOnly</vh></v>
<v t="T1226" a="C"><vh>OnWriteAtFileNodes</vh></v>
<v t="T1227" a="C"><vh>4.0 Commands</vh>
<v t="T1228" a="C"><vh>OnImportDerivedFile</vh></v>
<v t="T1229"><vh>OnWriteNew/OldDerivedFiles</vh></v>
</v>
</v>
<v t="T1230"><vh>Tangle submenu</vh>
<v t="T1231"><vh>OnTangleAll</vh></v>
<v t="T1232"><vh>OnTangleMarked</vh></v>
<v t="T1233"><vh>OnTangle</vh></v>
</v>
<v t="T1234"><vh>Untangle submenu</vh>
<v t="T1235"><vh>OnUntangleAll</vh></v>
<v t="T1236"><vh>OnUntangleMarked</vh></v>
<v t="T1237"><vh>OnUntangle</vh></v>
</v>
<v t="T1238"><vh>Import&amp;Export submenu</vh>
<v t="T1239"><vh>OnExportHeadlines</vh></v>
<v t="T1240"><vh>OnFlattenOutline</vh></v>
<v t="T1241"><vh>OnImportAtRoot</vh></v>
<v t="T1242"><vh>OnImportAtFile</vh></v>
<v t="T1243"><vh>OnImportCWEBFiles</vh></v>
<v t="T1244"><vh>OnImportFlattenedOutline</vh></v>
<v t="T1245"><vh>OnImportNowebFiles</vh></v>
<v t="T1246"><vh>OnOutlineToCWEB</vh></v>
<v t="T1247"><vh>OnOutlineToNoweb</vh></v>
<v t="T1248"><vh>OnRemoveSentinels</vh></v>
<v t="T1249"><vh>OnWeave</vh></v>
</v>
</v>
<v t="T1250"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T1251"><vh>Edit top level</vh>
<v t="T1252"><vh>OnUndo</vh></v>
<v t="T1253"><vh>OnRedo</vh></v>
<v t="T1254" a="C"><vh>Cut/Copy/Paste body text</vh>
<v t="T1255"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T1256"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T1257"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
</v>
<v t="T1258"><vh>OnDelete</vh></v>
<v t="T1259" a="C"><vh>OnExecuteScript</vh>
<v t="T1260"><vh>&lt;&lt; get script into s &gt;&gt;</vh></v>
<v t="T1261"><vh>&lt;&lt; redirect output if redirect_execute_script_output_to_log_pane &gt;&gt;</vh></v>
</v>
<v t="T1262" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T1263"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T1264"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T1265"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T1266"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="T1267"><vh>&lt;&lt; set v to the node given by vnodeName and childIndex or n &gt;&gt;</vh>
<v t="T1268"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="T1269"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="T1270"><vh>&lt;&lt; set v to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="T1271"><vh>&lt;&lt; set v to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="T1272"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="T1273"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T1274"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T1275"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="T1276"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T1277"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T1278"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T1279"><vh>&lt;&lt; set vnodeName and childIndex from s &gt;&gt;</vh></v>
</v>
<v t="T1280"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="T1281"><vh>OnSelectAll</vh></v>
<v t="T1282"><vh>OnFontPanel</vh></v>
<v t="T1283"><vh>OnColorPanel</vh></v>
<v t="T1284"><vh>OnViewAllCharacters</vh></v>
<v t="T1285"><vh>OnPreferences</vh></v>
</v>
<v t="T1286"><vh>Edit Body submenu</vh>
<v t="T1287"><vh>OnConvertBlanks &amp; OnConvertAllBlanks</vh></v>
<v t="T1288"><vh>OnConvertTabs &amp; OnConvertAllTabs</vh></v>
<v t="T1289"><vh>OnDedent</vh></v>
<v t="T1290"><vh>OnExtract</vh></v>
<v t="T1291"><vh>OnExtractNames</vh></v>
<v t="T1292"><vh>OnExtractSection</vh></v>
<v t="T1293" a="C"><vh>OnFindMatchingBracket</vh>
<v t="T1294" a="C"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1295"><vh>OnIndent</vh></v>
<v t="T1296"><vh>OnInsertBody/HeadlineTime &amp; allies</vh>
<v t="T1297"><vh>getTime</vh></v>
</v>
</v>
<v t="T1298"><vh>Edit Headline submenu</vh>
<v t="T1299"><vh>OnEditHeadline</vh></v>
<v t="T1300"><vh>OnEndEditHeadline</vh></v>
<v t="T1301"><vh>OnAbortEditHeadline</vh></v>
<v t="T1302"><vh>OnToggleAngleBrackets</vh></v>
</v>
<v t="T1303"><vh>Find submenu (frame methods)</vh>
<v t="T1304"><vh>OnFindPanel</vh></v>
<v t="T1305"><vh>OnFindNext</vh></v>
<v t="T1306"><vh>OnFindPrevious</vh></v>
<v t="T1307"><vh>OnReplace</vh></v>
<v t="T1308"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T1309"><vh>Outline Menu</vh>
<v t="T1310"><vh>top level</vh>
<v t="T1311"><vh>OnCutNode</vh></v>
<v t="T1312"><vh>OnCopyNode</vh></v>
<v t="T1313"><vh>OnPasteNodee</vh></v>
<v t="T1314"><vh>OnDeleteNode</vh></v>
<v t="T1315"><vh>OnInsertNode</vh></v>
<v t="T1316"><vh>OnCloneNode</vh></v>
<v t="T1317"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T1318"><vh>Expand/Contract</vh>
<v t="T1319"><vh>No longer used</vh>
<v t="T1320"><vh>OnContractChildren (no longer used)</vh></v>
<v t="T1321"><vh>OnContractAllChildren (no longer used)</vh></v>
<v t="T1322"><vh>OnExpandAllChildren (no longer used)</vh></v>
<v t="T1323"><vh>OnExpandChildren (no longer used)</vh></v>
</v>
<v t="T1324"><vh>OnContractAll</vh></v>
<v t="T1325"><vh>OnContractNode</vh></v>
<v t="T1326"><vh>OnContractParent</vh></v>
<v t="T1327"><vh>OnExpandAll</vh></v>
<v t="T1328"><vh>OnExpandNextLevel</vh></v>
<v t="T1329"><vh>OnExpandNode</vh></v>
<v t="T1330"><vh>OnExpandPrevLevel</vh></v>
<v t="T1331"><vh>OnExpandToLevel1..9</vh></v>
</v>
<v t="T1332"><vh>Move/Select</vh>
<v t="T1333"><vh>OnMoveDownwn</vh></v>
<v t="T1334"><vh>OnMoveLeft</vh></v>
<v t="T1335"><vh>OnMoveRight</vh></v>
<v t="T1336"><vh>OnMoveUp</vh></v>
<v t="T1337"><vh>OnPromote</vh></v>
<v t="T1338"><vh>OnDemote</vh></v>
<v t="T1339"><vh>OnGoPrevVisible</vh></v>
<v t="T1340"><vh>OnGoNextVisible</vh></v>
<v t="T1341"><vh>OnGoBack</vh></v>
<v t="T1342"><vh>OnGoNext</vh></v>
</v>
<v t="T1343"><vh>Mark/Goto</vh>
<v t="T1344" a="C"><vh>OnGoPrevVisitedNode</vh></v>
<v t="T1345" a="C"><vh>OnGoNextVisitedNode</vh></v>
<v t="T1346"><vh>OnGoToFirstNode</vh></v>
<v t="T1347"><vh>OnGoToLastNode</vh></v>
<v t="T1348"><vh>OnGoToNextChanged</vh></v>
<v t="T1349"><vh>OnGoToNextClone</vh></v>
<v t="T1350"><vh>OnGoToNextMarked</vh></v>
<v t="T1351"><vh>OnGoToNextSibling</vh></v>
<v t="T1352"><vh>OnGoToParent</vh></v>
<v t="T1353"><vh>OnGoToPrevSibling</vh></v>
<v t="T1354"><vh>OnMark</vh></v>
<v t="T1355"><vh>OnMarkChangedItems</vh></v>
<v t="T1356"><vh>OnMarkChangedRoots</vh></v>
<v t="T1357"><vh>OnMarkClones</vh></v>
<v t="T1358"><vh>OnMarkSubheads</vh></v>
<v t="T1359"><vh>OnUnmarkAll</vh></v>
</v>
</v>
<v t="T1360"><vh>Window Menu</vh>
<v t="T1361"><vh>OnEqualSizedPanes</vh></v>
<v t="T1362"><vh>OnToggleActivePane</vh></v>
<v t="T1363"><vh>OnToggleSplitDirection</vh></v>
<v t="T1364"><vh>OnCascade</vh></v>
<v t="T1365"><vh>OnMinimizeAll</vh></v>
<v t="T1366"><vh>OnHideLogWindow</vh></v>
<v t="T1367"><vh>OnOpenCompareWindow</vh></v>
<v t="T1368" a="C"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1369"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="T1371"><vh>&lt;&lt; Try to open idle in pre-Python 2.3 systems&gt;&gt;</vh></v>
<v t="T1372"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
</v>
<v t="T1373"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T1374"><vh>Help Menu</vh>
<v t="T1375"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1376"><vh>OnLeoDocumentation</vh></v>
<v t="T1377"><vh>OnLeoHome</vh></v>
<v t="T1378"><vh>OnLeoHelp</vh>
<v t="T1379"><vh>showProgressBar</vh>
<v t="T1380"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
<v t="T1381"><vh>OnLeoTutorial (version number)</vh></v>
<v t="T1382"><vh>OnLeoConfig, OnApplyConfig</vh></v>
</v>
</v>
<v t="T1383" a="C"><vh>Menu Convenience Routines</vh>
<v t="T1384" a="C"><vh>createMenuEntries</vh>
<v t="T1385"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1386"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="T1391"><vh>createMenuItemsFromTable</vh></v>
<v t="T1392"><vh>createNewMenu</vh></v>
<v t="T1393" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1394"><vh>deleteMenu</vh></v>
<v t="T1395"><vh>deleteMenuItem</vh></v>
<v t="T1396"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1397"><vh>Menu enablers (Frame)</vh>
<v t="T1398"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1399"><vh>hasSelection</vh></v>
<v t="T1400"><vh>updateFileMenu</vh></v>
<v t="T1401"><vh>updateEditMenu</vh></v>
<v t="T1402"><vh>updateOutlineMenu</vh></v>
</v>
</v>
<v t="T2874"><vh>Splitter stuff</vh>
<v t="T2875"><vh>resizePanesToRatio</vh></v>
<v t="T2876"><vh>bindBar</vh></v>
<v t="T1625" a="C"><vh>createLeoSplitter</vh></v>
<v t="T2877"><vh>divideAnySplitter</vh></v>
<v t="T2878"><vh>divideLeoSplitter</vh></v>
<v t="T2879"><vh>initialRatios</vh></v>
<v t="T2880"><vh>onDrag...</vh></v>
<v t="T2881"><vh>placeSplitter</vh></v>
</v>
<v t="T1633" a="C"><vh>Status line: convenience routines</vh>
<v t="T1634"><vh>createStatusLine</vh></v>
<v t="T1635"><vh>clearStatusLine</vh></v>
<v t="T1636"><vh>putStatusLine</vh></v>
<v t="T1637" a="C"><vh>updateStatusRowCol</vh></v>
</v>
</v>
<v t="T2882" tnodeList="2882,2883,638,1674,1675,1677,1676,2885,2886,2887,1943,1472,1473,1474,1475,1106,1107,1108,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1802,2889,2890,2891,2894,2895,1110,2896,2897,2898,1754,2899,2900,2901,2902,1087,1109,2903,2904,2905,2906,1865,2907,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,1406,2920,2921,2922,2923,2924,2925,2926,1690,1691,1692,1693,1694,1695,2928,1791,2930,2931,1405,1698,1407,2933,2935,2936,2937,2938,2939,1956,2940,1564,2041,2942,656,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,655,656,657,658,659,2989,2990,2991,2992,2993,2994,2995,2996,1583,1584,1585,1586,1587,1588,1589"><vh>@file leoGlobals.py</vh>
<v t="T2883"><vh>&lt;&lt; define general constants &gt;&gt;</vh></v>
<v t="T2884"><vh>Checking Leo Files...</vh>
<v t="T638" a="C"><vh>createTopologyList</vh></v>
<v t="T1674" a="C"><vh>checkClones2Links</vh>
<v t="T1675"><vh>&lt;&lt; clear statistics &gt;&gt;</vh></v>
<v t="T1676"><vh>&lt;&lt; print statistics &gt;&gt;</vh></v>
<v t="T1677"><vh>&lt;&lt; handle each item in v's join list &gt;&gt;</vh></v>
</v>
<v t="T2885" a="C"><vh>checkTopologyOfAllClones</vh></v>
</v>
<v t="T2886"><vh>CheckVersion (Dave Hein)</vh></v>
<v t="T2887"><vh>class Bunch</vh></v>
<v t="T1943" a="C"><vh>computeWindowTitle</vh></v>
<v t="T2888"><vh>Commands &amp; Directives</vh>
<v t="T1470" a="C"><vh>Directive utils...</vh>
<v t="T1471"><vh>@language and @comment directives (leoUtils)</vh>
<v t="T1472"><vh>set_delims_from_language</vh></v>
<v t="T1473"><vh>set_delims_from_string</vh></v>
<v t="T1474"><vh>set_language</vh></v>
</v>
<v t="T1475"><vh>findReference</vh></v>
<v t="T1106" a="C"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="T1107"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1476"><vh>getOutputNewline</vh></v>
<v t="T1477"><vh>scanAtEncodingDirective</vh></v>
<v t="T1478"><vh>scanAtLineendingDirective</vh></v>
<v t="T1479"><vh>scanAtPagewidthDirective</vh></v>
<v t="T1480"><vh>scanAtTabwidthDirective</vh></v>
<v t="T1481" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1482"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1483"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1484"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1485"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1488"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="T1802" a="C"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T2889"><vh>wrap_lines</vh>
<v t="T2890"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="T2891"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
</v>
<v t="T2892"><vh>Debugging, Dumping, Timing, Tracing &amp; Sherlock</vh>
<v t="T2893"><vh>Files &amp; Directories...</vh>
<v t="T2894"><vh>create_temp_name</vh></v>
<v t="T2895"><vh>ensure_extension</vh></v>
<v t="T1110" a="C"><vh>getBaseDirectory</vh></v>
<v t="T2896"><vh>makeAllNonExistentDirectories</vh></v>
<v t="T2897"><vh>readlineForceUnixNewline (Steven P. Schaefer)</vh></v>
<v t="T2898"><vh>redirecting stderr and stdout</vh>
<v t="T1754" a="C"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh></v>
<v t="T2899"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh></v>
<v t="T2900"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
<v t="T2901"><vh>sanitize_filename</vh></v>
<v t="T2902"><vh>shortFileName</vh></v>
<v t="T1087" a="C"><vh>update_file_if_changed</vh></v>
<v t="T1109" a="C"><vh>utils_rename</vh></v>
</v>
<v t="T2903"><vh>Sherlock...</vh>
<v t="T2904"><vh>init_sherlock</vh></v>
<v t="T2905"><vh>get_Sherlock_args</vh></v>
<v t="T2906"><vh>init_trace</vh></v>
<v t="T1865" a="C"><vh>trace</vh></v>
<v t="T2907"><vh>trace_tag</vh></v>
</v>
<v t="T2908"><vh>Statistics</vh>
<v t="T2909"><vh>clear_stats</vh></v>
<v t="T2910"><vh>print_stats</vh></v>
<v t="T2911"><vh>stat</vh></v>
</v>
<v t="T2912"><vh>Timing</vh></v>
<v t="T2913"><vh>alert</vh></v>
<v t="T2914"><vh>angleBrackets &amp; virtual_event_name</vh></v>
<v t="T2915"><vh>callerName</vh></v>
<v t="T2916"><vh>dump</vh></v>
<v t="T2917"><vh>es_error</vh></v>
<v t="T2918"><vh>es_event_exception</vh></v>
<v t="T2919" a="C"><vh>es_exception</vh></v>
<v t="T1406" a="C"><vh>file/module/plugin_date</vh></v>
<v t="T2920"><vh>funcToMethod</vh></v>
<v t="T2921"><vh>get_line &amp; get_line_after</vh></v>
<v t="T2922"><vh>pause</vh></v>
<v t="T2923"><vh>printBindings</vh></v>
<v t="T2924"><vh>printGlobals</vh></v>
<v t="T2925"><vh>printLeoModules</vh></v>
</v>
<v t="T2926"><vh>executeScript</vh></v>
<v t="T1690" a="C"><vh>Garbage Collection</vh>
<v t="T1691"><vh>clearAllIvars</vh></v>
<v t="T1692"><vh>collectGarbage</vh>
<v t="T1693"><vh>&lt;&lt; make a list of the new objects &gt;&gt;</vh></v>
</v>
<v t="T1694"><vh>printGc</vh></v>
<v t="T1695"><vh>printGcRefs</vh></v>
</v>
<v t="T2927"><vh>Gui convenience routines...</vh>
<v t="T2928"><vh>Dialog utils...</vh></v>
<v t="T1791" a="C"><vh>Focus (leoGlobals)</vh></v>
<v t="T2929"><vh>Menus...</vh>
<v t="T2930"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="T2931"><vh>enableMenu &amp; disableMenu &amp; setMenuLabel</vh></v>
</v>
</v>
<v t="T2932"><vh>Hooks &amp; plugins</vh>
<v t="T1405" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="T1698" a="C"><vh>doHook</vh></v>
<v t="T1407" a="C"><vh>plugin_signon</vh></v>
</v>
<v t="T2933"><vh>importFromPath</vh></v>
<v t="T2934"><vh>Lists...</vh>
<v t="T2935"><vh>appendToList</vh></v>
<v t="T2936"><vh>flattenList</vh></v>
<v t="T2937"><vh>listToString</vh></v>
</v>
<v t="T2938"><vh>makeDict</vh></v>
<v t="T2939"><vh>Most common functions</vh>
<v t="T1956" a="C"><vh>app &amp; leoProxy</vh></v>
<v t="T2940"><vh>choose</vh></v>
<v t="T1564" a="C"><vh>es, enl, ecnl</vh></v>
<v t="T2041" a="C"><vh>top</vh></v>
<v t="T2941"><vh>trace is defined below</vh></v>
<v t="T2942"><vh>windows</vh></v>
</v>
<v t="T2943"><vh>Scanning, selection &amp; whitespace...</vh>
<v t="T656" a="C"><vh>getindex</vh></v>
<v t="T2944"><vh>scanAtFileOptions</vh>
<v t="T2945"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="T2946"><vh>scanAtRootOptions</vh>
<v t="T2947"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="T2948"><vh>scanError</vh></v>
<v t="T2949"><vh>scanf</vh></v>
<v t="T2950"><vh>Scanners: calling scanError</vh>
<v t="T2951"><vh>skip_block_comment</vh></v>
<v t="T2952"><vh>skip_braces</vh></v>
<v t="T2953"><vh>skip_php_braces (Dave Hein)</vh></v>
<v t="T2954"><vh>skip_parens</vh></v>
<v t="T2955"><vh>skip_pascal_begin_end</vh></v>
<v t="T2956"><vh>skip_pascal_block_comment</vh></v>
<v t="T2957"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="T2958"><vh>skip_heredoc_string : called by php import (Dave Hein)</vh></v>
<v t="T2959"><vh>skip_pp_directive</vh></v>
<v t="T2960"><vh>skip_pp_if</vh></v>
<v t="T2961"><vh>skip_pp_part</vh></v>
<v t="T2962"><vh>skip_python_string</vh></v>
<v t="T2963"><vh>skip_string : called by tangle</vh></v>
<v t="T2964"><vh>skip_to_semicolon</vh></v>
<v t="T2965"><vh>skip_typedef</vh></v>
</v>
<v t="T2966"><vh>Scanners: no error messages</vh>
<v t="T2967"><vh>escaped</vh></v>
<v t="T2968"><vh>find_line_start</vh></v>
<v t="T2969"><vh>find_on_line</vh></v>
<v t="T2970"><vh>is_c_id</vh></v>
<v t="T2971"><vh>is_nl</vh></v>
<v t="T2972"><vh>is_special</vh></v>
<v t="T2973"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="T2974"><vh>match</vh></v>
<v t="T2975"><vh>match_c_word</vh></v>
<v t="T2976"><vh>match_ignoring_case</vh></v>
<v t="T2977"><vh>match_word</vh></v>
<v t="T2978"><vh>skip_blank_lines</vh></v>
<v t="T2979"><vh>skip_c_id</vh></v>
<v t="T2980"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="T2981"><vh>skip_long</vh></v>
<v t="T2982"><vh>skip_matching_delims</vh></v>
<v t="T2983"><vh>skip_nl</vh></v>
<v t="T2984"><vh>skip_non_ws</vh></v>
<v t="T2985"><vh>skip_pascal_braces</vh></v>
<v t="T2986"><vh>skip_to_char</vh></v>
<v t="T2987"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="T654" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T655"><vh>bound_paragraph (TK stuff)</vh></v>
<v t="T656" a="C"><vh>getindex</vh></v>
<v t="T657"><vh>getAllText &amp; getSelectedText</vh></v>
<v t="T658" a="C"><vh>getTextSelection</vh></v>
<v t="T659"><vh>setTextSelection</vh></v>
</v>
<v t="T2988"><vh>Whitespace...</vh>
<v t="T2989"><vh>computeLeadingWhitespace</vh></v>
<v t="T2990"><vh>computeWidth</vh></v>
<v t="T2991"><vh>get_leading_ws</vh></v>
<v t="T2992"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T2993"><vh>removeLeadingWhitespace</vh></v>
<v t="T2994"><vh>removeTrailingWs</vh></v>
<v t="T2995"><vh>skip_leading_ws</vh></v>
<v t="T2996"><vh>skip_leading_ws_with_indent</vh></v>
</v>
</v>
<v t="T1582" a="C"><vh>Unicode utils...</vh>
<v t="T1583"><vh>isUnicode</vh></v>
<v t="T1584"><vh>isValidEncoding</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
<v t="T1586" a="C"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T1587"><vh>getpreferredencoding from 2.3a2</vh>
<v t="T1588"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="T1589"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2997" tnodeList="2997,2998,2999,3000,3001,3002,1941,1942,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3014,3015,1924,3016,3017,3018,3019,3020,3021,3022,3023,3024,3026,3027,2164,3029,3030,3031,1925,1926,1927,3033,3034,3035"><vh>@file leoGui.py</vh>
<v t="T2998"><vh>class leoGui</vh>
<v t="T2999"><vh>leoGui.__init__</vh></v>
<v t="T3000"><vh>guiName</vh></v>
<v t="T3001"><vh>oops</vh></v>
<v t="T3002"><vh>interface to Leo's core</vh>
<v t="T1941" a="C"><vh> newLeoCommanderAndFrame</vh>
<v t="T1942"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="T3003"><vh>destroyLeoFrame</vh></v>
<v t="T3004"><vh>destroy</vh></v>
</v>
<v t="T3005"><vh>base-class methods: overridden in subclasses</vh>
<v t="T3006"><vh>Birth, death &amp; rebirth</vh></v>
<v t="T3007"><vh>runMainLoop</vh></v>
<v t="T3008"><vh>Creating frames</vh></v>
<v t="T3009"><vh>Creating and running dialogs</vh></v>
<v t="T3010"><vh>Dialog utils</vh></v>
<v t="T3011"><vh>Focus utils</vh></v>
</v>
</v>
<v t="T3012"><vh>class tkinterGui(leoGui)</vh>
<v t="T3013"><vh>Birth &amp; death</vh>
<v t="T3014"><vh> tkinterGui.__init__</vh></v>
<v t="T3015"><vh>createRootWindow &amp; allies</vh>
<v t="T1924" a="C"><vh>setDefaultIcon</vh></v>
<v t="T3016"><vh>setEncoding</vh></v>
<v t="T3017"><vh>getDefaultConfigFont</vh></v>
<v t="T3018"><vh>createGlobalWindows</vh></v>
</v>
<v t="T3019"><vh>destroyLeoFrame</vh></v>
<v t="T3020"><vh>destroy</vh></v>
<v t="T3021"><vh>finishCreate</vh></v>
<v t="T3022"><vh>killGui (not used)</vh></v>
<v t="T3023"><vh>recreateRootWindow (not used)</vh></v>
<v t="T3024"><vh>runMainLoop</vh></v>
</v>
<v t="T3025"><vh>Called by leoConfig</vh>
<v t="T3026"><vh>getFontFromParams</vh></v>
</v>
<v t="T3027"><vh>Creating and running dialogs</vh></v>
<v t="T2164" a="C"><vh>Creating Frames</vh></v>
<v t="T3028"><vh>Focus utils</vh>
<v t="T3029"><vh>get_focus</vh></v>
<v t="T3030"><vh>set_focus</vh></v>
<v t="T3031"><vh>force_focus</vh></v>
</v>
<v t="T3032"><vh>Dialog &amp; Icon utils</vh>
<v t="T1925" a="C"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="T1926"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="T1927"><vh>createLeoIcon</vh></v>
</v>
<v t="T3033"><vh>get_window_info</vh></v>
<v t="T3034"><vh>center_dialog</vh></v>
<v t="T3035"><vh>create_labeled_frame</vh></v>
</v>
</v>
</v>
<v t="T3036" tnodeList="3036,3038,2320,3037,1805,1806,2076,3040,3041,3043,3044,3045,3046,3047,3048,3049,3050,3051,3053,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3065,3066,3067,3068,2046,2047,2048,2049,2050,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,3070,3071,3072,3074,3073,3075,3076,3077,3078,3079,3088,3089,3090,3091,3080,3081,3082,3083,3084,3085,3086,3087,3092,2011,2012,2013,2014,2015,3093,3094,3100,3101,3102,3103,3095,3096,3097,3098,3099,3092,3104,3105,3108,3109,3110,3106,3111,3107,3092,3113,3114,3115,3116,3117,3118,3117,3118,3119,3120,3121,3121,3122,1552,993,994,2066,2067,2068,995,3123,3124,1554,996,1555,3126,3127,3128,3129,3130,3131,3132,3133,3134,1553,3135,3136,3137,3138,3139"><vh>@file leoImport.py</vh>
<v t="T3037"><vh>import.__init__</vh></v>
<v t="T3038"><vh>&lt;&lt; scripts &gt;&gt;</vh>
<v t="T2320" a="C"><vh>importFiles</vh></v>
</v>
<v t="T3039"><vh>Import</vh>
<v t="T1805" a="C"><vh>createOutline</vh>
<v t="T1806"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="T2076" a="C"><vh>importDerivedFiles</vh></v>
<v t="T3040"><vh>importFilesCommand</vh>
<v t="T3041"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="T3042"><vh>importFlattenedOutline &amp; allies</vh>
<v t="T3043"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="T3044"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="T3045"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="T3046"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="T3047"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="T3048"><vh>importFlattenedOutline</vh>
<v t="T3049"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="T3050"><vh>moreHeadlineLevel</vh></v>
<v t="T3051"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="T3052"><vh>importWebCommand &amp; allies</vh>
<v t="T3053"><vh>createOutlineFromWeb</vh></v>
<v t="T3054"><vh>importWebCommand</vh></v>
<v t="T3055"><vh>findFunctionDef</vh></v>
<v t="T3056"><vh>scanBodyForHeadline</vh>
<v t="T3057"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="T3058"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="T3059"><vh>scanWebFile (handles limbo)</vh>
<v t="T3060"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="T3061"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="T3062"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="T3063"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="T3064"><vh>Symbol table</vh>
<v t="T3065"><vh>cstCanonicalize</vh></v>
<v t="T3066"><vh>cstDump</vh></v>
<v t="T3067"><vh>cstEnter</vh></v>
<v t="T3068"><vh>cstLookup</vh></v>
</v>
</v>
<v t="T3069"><vh>Scanners for createOutline</vh>
<v t="T2045" a="C"><vh>Python scanners</vh>
<v t="T2046"><vh>scanPythonClass</vh>
<v t="T2047"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="T2048"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="T2049"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="T2050"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
<v t="T2051"><vh>&lt;&lt; append any other class material &gt;&gt;</vh></v>
</v>
<v t="T2052"><vh>scanPythonDef</vh>
<v t="T2053"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="T2054"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T2055"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="T2056"><vh>scanPythonDecls</vh>
<v t="T2057"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="T2058"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="T2059"><vh>scanPythonText</vh>
<v t="T2060"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="T2061"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="T2062"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="T3070"><vh>scanPHPText (Dave Hein)</vh>
<v t="T3071"><vh>&lt;&lt; Append file if not pure PHP &gt;&gt;</vh></v>
<v t="T3072"><vh>&lt;&lt; define scanPHPText vars &gt;&gt;</vh></v>
<v t="T3073"><vh>&lt;&lt; handle possible heredoc string &gt;&gt;</vh></v>
<v t="T3074"><vh>&lt;&lt; handle possible PHP comments &gt;&gt;</vh></v>
<v t="T3075"><vh>&lt;&lt; handle possible class or function &gt;&gt;</vh></v>
<v t="T3076"><vh>&lt;&lt; handle end of class &gt;&gt;</vh></v>
<v t="T3077"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T3078"><vh>scanCText</vh>
<v t="T3079"><vh>&lt;&lt; define scanCText vars &gt;&gt;</vh></v>
<v t="T3080"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="T3081"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="T3082"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt; (scans function)</vh>
<v t="T3083"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="T3084"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="T3085"><vh>&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="T3086"><vh>&lt;&lt; create children for the namespace &gt;&gt;</vh></v>
<v t="T3087"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
</v>
<v t="T3088"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T3089"><vh>&lt;&lt; handle equal sign in C&gt;&gt;</vh></v>
<v t="T3090"><vh>&lt;&lt; handle open paren in C &gt;&gt;</vh></v>
<v t="T3091"><vh>&lt;&lt; handle semicolon in C &gt;&gt;</vh></v>
<v t="T3092" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T2011" a="C"><vh>scanElispText &amp; allies</vh>
<v t="T2012"><vh>skipElispParens</vh></v>
<v t="T2013"><vh>skipElispId</vh></v>
<v t="T2014"><vh>createElispFunction</vh></v>
<v t="T2015"><vh>createElispDataNode</vh></v>
</v>
<v t="T3093"><vh>scanJavaText</vh>
<v t="T3094"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="T3095"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="T3096"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="T3097"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T3098"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="T3099"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="T3100"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="T3101"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="T3102"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="T3103"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="T3092" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T3104"><vh>scanPascalText</vh>
<v t="T3105"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="T3106"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="T3107"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
<v t="T3108"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="T3109"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="T3110"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh></v>
</v>
<v t="T3111"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
</v>
<v t="T3092" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T3112"><vh>Export</vh>
<v t="T3113"><vh>convertCodePartToWeb</vh>
<v t="T3114"><vh>&lt;&lt; put v's headline ref in head_ref&gt;&gt;</vh></v>
<v t="T3115"><vh>&lt;&lt; put name following @root or @file in file_name &gt;&gt;</vh>
<v t="T3116"><vh>&lt;&lt; Set file_name &gt;&gt;</vh></v>
</v>
<v t="T3117"><vh>&lt;&lt; append ref to file_name &gt;&gt;</vh></v>
<v t="T3118"><vh>&lt;&lt; append head_ref &gt;&gt;</vh></v>
</v>
<v t="T3119"><vh>convertDocPartToWeb (handle @ %def)</vh></v>
<v t="T3120"><vh>convertVnodeToWeb</vh>
<v t="T3121"><vh>&lt;&lt; Supply a missing doc part &gt;&gt;</vh></v>
</v>
<v t="T3122"><vh>copyPart</vh></v>
<v t="T1552" a="C"><vh>exportHeadlines</vh></v>
<v t="T993" a="C"><vh>flattenOutline</vh></v>
<v t="T994" a="C"><vh>outlineToWeb</vh></v>
<v t="T2066" a="C"><vh>removeSentinelsCommand</vh>
<v t="T2067"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="T2068"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="T995" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="T3123"><vh>removeSentinelLines</vh>
<v t="T3124"><vh>&lt;&lt; handle possible sentinel &gt;&gt;</vh></v>
</v>
<v t="T1554" a="C"><vh>weave</vh>
<v t="T996" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1555"><vh>&lt;&lt; write the context of v to f &gt;&gt;</vh></v>
</v>
</v>
<v t="T3125"><vh>Utilities</vh>
<v t="T3126"><vh>createHeadline</vh></v>
<v t="T3127"><vh>error</vh></v>
<v t="T3128"><vh>getLeadingIndent</vh></v>
<v t="T3129"><vh>isDocStart and isModuleStart</vh></v>
<v t="T3130"><vh>massageBody</vh></v>
<v t="T3131"><vh>massageComment</vh></v>
<v t="T3132"><vh>massageWebBody</vh>
<v t="T3133"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="T3134"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="T1553" a="C"><vh>setEncoding</vh></v>
<v t="T3135"><vh>skipLeadingComments</vh>
<v t="T3136"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="T3137"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="T3138"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="T3139"><vh>undentBody</vh></v>
</v>
</v>
<v t="T3140" tnodeList="3140,2176,2173,3141,3142,2158,2082,3144,3145,3147,3148,3149,1574,1575,3152,3153,3154,3155,3156,3157,3158,3159,3160,800,3162,3163,3164,3165,1841,1842,1839,1840,1776,1843,1844,1845,1846,1847,1848,3167,3168,3169,3170,3171,3172,3173,3175,3176,3177,2083,3180,3181,3182,3183,3184,3185,3187,3188,3189,3190,3191,3192,3193,3194,3195,3196,2160,3197,3198,3199,1673,3200,3201,3202,1568,1569,1570,1571,3204,3206,3207,3208,3209,1883,3210,3211,3212,3213,3214,1031,1032,3215,1033,1882,3216,3217,3218,3219,3220,3221,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3235,3236,3237,3238,3239,3240,1875,3241,3242,3243,3244,1038,1037,1874,1876,3246,1877,1666,1878,1879,3247,3248,1745,3249,3250,1746,3251,634,635,636,637,3252,3253,3254,3255,3256,3257,3258,3259"><vh>@file leoNodes.py</vh>
<v t="T2173" a="C"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T2176" a="C"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T3141"><vh>class tnode</vh>
<v t="T3142"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="T2158" a="C"><vh>t.__init__</vh></v>
<v t="T2082" a="C"><vh>t.extraAttributes &amp; setExtraAttributes</vh></v>
<v t="T3143"><vh>Getters</vh>
<v t="T3144"><vh>hasBody</vh></v>
<v t="T3145"><vh>loadBodyPaneFromTnode</vh></v>
<v t="T3146"><vh>Status bits</vh>
<v t="T3147"><vh>isDirty</vh></v>
<v t="T3148"><vh>isRichTextBit</vh></v>
<v t="T3149"><vh>isVisited</vh></v>
</v>
</v>
<v t="T3150"><vh>Setters</vh>
<v t="T1573" a="C"><vh>Setting body text</vh>
<v t="T1574"><vh>setTnodeText</vh></v>
<v t="T1575"><vh>setSelection</vh></v>
</v>
<v t="T3151"><vh>Status bits</vh>
<v t="T3152"><vh>clearDirty</vh></v>
<v t="T3153"><vh>clearRichTextBit</vh></v>
<v t="T3154"><vh>clearVisited</vh></v>
<v t="T3155"><vh>setDirty</vh></v>
<v t="T3156"><vh>setRichTextBit</vh></v>
<v t="T3157"><vh>setVisited</vh></v>
</v>
<v t="T3158"><vh>setCloneIndex</vh></v>
<v t="T3159"><vh>setFileIndex</vh></v>
</v>
</v>
<v t="T3160"><vh>class vnode</vh>
<v t="T800" a="C"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="T3161"><vh>Birth &amp; death</vh>
<v t="T3162"><vh>v.__cmp__ (not used)</vh></v>
<v t="T3163"><vh>v.__init__</vh>
<v t="T3164"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T3165"><vh>v.__repr__ &amp; v.__str__</vh></v>
</v>
<v t="T1841" a="C"><vh>v.Callbacks (handles event hooks)(to be eliminated)</vh>
<v t="T1842"><vh>OnBoxClick</vh></v>
<v t="T1839" a="C"><vh>OnDrag</vh></v>
<v t="T1840" a="C"><vh>v.OnEndDrag</vh></v>
<v t="T1776" a="C"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T1843"><vh>OnHeadlineKey</vh></v>
<v t="T1844"><vh>OnHyperLinkControlClick</vh></v>
<v t="T1845"><vh>OnHyperLinkEnter</vh></v>
<v t="T1846"><vh>OnHyperLinkLeave</vh></v>
<v t="T1847"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T1848"><vh>OnIconDoubleClick</vh></v>
</v>
<v t="T3166"><vh>Comparisons (vnode)</vh>
<v t="T3167"><vh>afterHeadlineMatch</vh></v>
<v t="T3168"><vh>at/../NodeName</vh></v>
<v t="T3169"><vh>isAt/../Node</vh></v>
<v t="T3170"><vh>isAnyAtFileNode &amp; isAnyAtFileNodeName</vh></v>
<v t="T3171"><vh>isAtIgnoreNode</vh></v>
<v t="T3172"><vh>isAtOthersNode</vh></v>
<v t="T3173"><vh>matchHeadline</vh></v>
</v>
<v t="T3174"><vh>File Conversion (vnode)</vh>
<v t="T3175"><vh>convertTreeToString</vh></v>
<v t="T3176"><vh>moreHead</vh></v>
<v t="T3177"><vh>v.moreBody</vh></v>
</v>
<v t="T2083" a="C"><vh>v.extraAttributes &amp; setExtraAttributes</vh></v>
<v t="T3178"><vh>Getters</vh>
<v t="T3179"><vh>Children</vh>
<v t="T3180"><vh>childIndex</vh></v>
<v t="T3181"><vh>firstChild</vh></v>
<v t="T3182"><vh>hasChildren</vh></v>
<v t="T3183"><vh>lastChild</vh></v>
<v t="T3184"><vh>nthChild</vh></v>
<v t="T3185"><vh>numberOfChildren (n)</vh></v>
</v>
<v t="T3186"><vh>Status Bits</vh>
<v t="T3187"><vh>isCloned</vh></v>
<v t="T3188"><vh>isDirty</vh></v>
<v t="T3189"><vh>isExpanded</vh></v>
<v t="T3190"><vh>isMarked</vh></v>
<v t="T3191"><vh>isOrphan</vh></v>
<v t="T3192"><vh>isSelected</vh></v>
<v t="T3193"><vh>isTopBitSet</vh></v>
<v t="T3194"><vh>isVisible</vh></v>
<v t="T3195"><vh>isVisited</vh></v>
<v t="T3196"><vh>status</vh></v>
</v>
<v t="T2160" a="C"><vh>bodyString</vh></v>
<v t="T3197"><vh>currentVnode (vnode)</vh></v>
<v t="T3198"><vh>edit_text</vh></v>
<v t="T3199"><vh>findRoot</vh></v>
<v t="T1673" a="C"><vh>headString &amp; cleanHeadString</vh></v>
<v t="T3200"><vh>isAncestorOf</vh></v>
<v t="T3201"><vh>isRoot</vh></v>
<v t="T3202"><vh>v.exists</vh></v>
</v>
<v t="T3203"><vh>Setters</vh>
<v t="T1567" a="C"><vh>Head and body text</vh>
<v t="T1568" a="C"><vh>appendStringToBody</vh></v>
<v t="T1569"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1570"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T1571"><vh>setHeadStringOrHeadline</vh></v>
</v>
<v t="T3204"><vh>computeIcon &amp; setIcon</vh></v>
<v t="T3205"><vh>Status bits</vh>
<v t="T3206"><vh>clearAllVisited</vh></v>
<v t="T3207"><vh>clearAllVisitedInTree</vh></v>
<v t="T3208"><vh>clearClonedBit</vh></v>
<v t="T3209"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="T1883" a="C"><vh>clearMarked</vh></v>
<v t="T3210"><vh>clearOrphan</vh></v>
<v t="T3211"><vh>clearVisited</vh></v>
<v t="T3212"><vh>clearVisitedInTree</vh></v>
<v t="T3213"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="T3214"><vh>initStatus</vh></v>
<v t="T1031" a="C"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="T1032" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T3215"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="T1033" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="T1882" a="C"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="T3216"><vh>setOrphan</vh></v>
<v t="T3217"><vh>setSelected (vnode, new)</vh></v>
<v t="T3218"><vh>setVisited</vh></v>
</v>
<v t="T3219"><vh>setSelection</vh></v>
<v t="T3220"><vh>setT</vh></v>
<v t="T3221"><vh>trimTrailingLines</vh></v>
</v>
<v t="T3222"><vh>Tree Traversal (vnode)</vh>
<v t="T3223"><vh>back</vh></v>
<v t="T3224"><vh>lastNode</vh></v>
<v t="T3225"><vh>level</vh></v>
<v t="T3226"><vh>next</vh></v>
<v t="T3227"><vh>nodeAfterTree</vh></v>
<v t="T3228"><vh>parent</vh></v>
<v t="T3229"><vh>threadBack</vh></v>
<v t="T3230"><vh>threadNext</vh></v>
<v t="T3231"><vh>visBack</vh></v>
<v t="T3232"><vh>visNext</vh></v>
</v>
<v t="T3233"><vh>Moving, Inserting, Deleting, Cloning, Sorting (vnode)</vh>
<v t="T3234"><vh>Entry Points (vnode)</vh>
<v t="T3235"><vh>doDelete</vh></v>
<v t="T3236"><vh>insertAfter</vh></v>
<v t="T3237"><vh>insertAsLastChild</vh></v>
<v t="T3238"><vh>insertAsNthChild</vh></v>
<v t="T3239"><vh>moveToRoot</vh></v>
<v t="T3240"><vh>restoreOutlineFromDVnodes (test)</vh></v>
<v t="T1875" a="C"><vh>v.clone</vh></v>
<v t="T3241"><vh>v.linkAfter</vh></v>
<v t="T3242"><vh>v.linkAsNthChild</vh></v>
<v t="T3243"><vh>v.linkAsRoot</vh></v>
<v t="T3244"><vh>v.moveAfter</vh></v>
<v t="T1038" a="C"><vh>v.moveToNthChildOf</vh></v>
<v t="T1037" a="C"><vh>v.sortChildren</vh></v>
</v>
<v t="T3245"><vh>Helper functions</vh>
<v t="T1874" a="C"><vh>v.addTreeToJoinLists (new in 3.12 beta 2)</vh></v>
<v t="T1876" a="C"><vh>v.cloneTree</vh></v>
<v t="T3246"><vh>v.copyCloneBitsTo</vh></v>
<v t="T1877" a="C"><vh>v.copyTree</vh></v>
<v t="T1666" a="C"><vh>v.copyTreeWithNewTnodes (new after 3.11.1) (not used at present)</vh></v>
<v t="T1878" a="C"><vh>v.createDependents</vh></v>
<v t="T1879" a="C"><vh>v.destroyDependents</vh></v>
<v t="T3247"><vh>v.destroyTree (does nothing!)(Called only from destroy dependents)</vh></v>
<v t="T3248"><vh>v.invalidOutline</vh></v>
<v t="T1745" a="C"><vh>v.joinNodeTo (rewritten for 4.0)</vh></v>
<v t="T3249"><vh>v.joinTreeTo</vh></v>
<v t="T3250"><vh>v.shouldBeClone</vh></v>
<v t="T1746" a="C"><vh>v.unjoinTree</vh></v>
<v t="T3251"><vh>v.unlink</vh></v>
<v t="T634" a="C"><vh>validateOutlineWithParent</vh>
<v t="T635"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T636"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T637"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T3252"><vh>class nodeIndices</vh>
<v t="T3253"><vh>nodeIndices.__init__</vh></v>
<v t="T3254"><vh>areEqual</vh></v>
<v t="T3255"><vh>get/setDefaultId</vh></v>
<v t="T3256"><vh>getNewIndex</vh></v>
<v t="T3257"><vh>scanGnx</vh></v>
<v t="T3258"><vh>setTimeString</vh></v>
<v t="T3259"><vh>toString</vh></v>
</v>
</v>
<v t="T3260" tnodeList="3260,3261,3262,3263,3264,3265"><vh>@file leoPlugins.py</vh>
<v t="T3261"><vh>loadHandlers</vh></v>
<v t="T3262"><vh>doHandlersForTag</vh></v>
<v t="T3263"><vh>registerHandler</vh></v>
<v t="T3264"><vh>registerExclusiveHandler</vh></v>
<v t="T3265"><vh>funcToMethod</vh></v>
</v>
<v t="T3266" tnodeList="3266,498,499,500,501,178,502,1903,1904,1905,1906,1907,2040,3268,3269,3269"><vh>@file leoPrefs.py</vh>
<v t="T498" a="C"><vh>prefs.__init__</vh>
<v t="T499"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T500"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T501"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T178" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt; frame</vh></v>
<v t="T502"><vh>&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;</vh></v>
</v>
<v t="T1903" a="C"><vh>prefs.init</vh>
<v t="T1904"><vh>&lt;&lt; remember values for revert &gt;&gt;</vh></v>
<v t="T1905"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T3267"><vh>Event handlers</vh>
<v t="T1906" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T1907"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T2040" a="C"><vh>set_lang</vh></v>
<v t="T3268"><vh>prefs.onOK, onCancel, onRevert</vh>
<v t="T3269"><vh>&lt;&lt; restore options &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T3270" tnodeList="3270,2175,3271,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,1446,1447,1448,1449,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3307,3306,3308,3309,3310,3311,3314,3315,3318,3317,3319,3320,3321,3316,3322,3323,3324,3325,3326,3327,3328,1577,997,998,999,1000,1001,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,3344,3345,3346,3347,3348,3348,3349,3350,3351,3353,3354,3355,3356,3357,3358,3359,3360,3361,3363,3364,3365,3366,3367,3369,3370,3371,3372,3373,3370,3374,3375,3379,3381,3380,3377,3376,3378,3377,3382,3383,3377,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3395,3396,3394,3397,3398,3399,3400,3401,3402,3403,3404,3405,3406,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,1105,3420,3421,3422,3423,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,3424,3425,3426,3427"><vh>@file leoTangle.py</vh>
<v t="T2175" a="C"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="T3271"><vh>&lt;&lt; constants &amp; synonyms &gt;&gt;</vh></v>
<v t="T3272"><vh>node classes</vh>
<v t="T3273"><vh>class tst_node</vh>
<v t="T3274"><vh>tst_node.__init__</vh></v>
<v t="T3275"><vh>tst_node.__repr__</vh></v>
</v>
<v t="T3276"><vh>class part_node</vh>
<v t="T3277"><vh>part_node.__init__</vh></v>
<v t="T3278"><vh>part_node.__repr__</vh></v>
</v>
<v t="T3279"><vh>class ust_node</vh>
<v t="T3280"><vh>ust_node.__init__</vh></v>
<v t="T3281"><vh>ust_node.__repr__</vh></v>
</v>
<v t="T3282"><vh>class def_node</vh>
<v t="T3283"><vh>def_node.__init__</vh></v>
<v t="T3284"><vh>def_node.__repr__</vh></v>
</v>
<v t="T3285"><vh>class root_attributes (Stephen P. Schaefer)</vh>
<v t="T3286"><vh>root_attributes.__init__</vh>
<v t="T3287"><vh>&lt;&lt; trace the state &gt;&gt;</vh></v>
</v>
<v t="T3288"><vh>root_attributes.__repr__</vh></v>
</v>
</v>
<v t="T3289"><vh>class tangleCommands methods</vh>
<v t="T3290"><vh>tangle.__init__</vh></v>
<v t="T1446" a="C"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T1447" a="C"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T1448"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="T1449"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="T3291"><vh>top level</vh>
<v t="T3292"><vh>cleanup</vh>
<v t="T3293"><vh>&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;</vh></v>
</v>
<v t="T3294"><vh>initTangleCommand</vh></v>
<v t="T3295"><vh>initUntangleCommand</vh></v>
<v t="T3296"><vh>tangle</vh></v>
<v t="T3297"><vh>tangleAll</vh></v>
<v t="T3298"><vh>tangleMarked</vh></v>
<v t="T3299"><vh>tanglePass1</vh></v>
<v t="T3300"><vh>tanglePass2</vh></v>
<v t="T3301"><vh>tangleTree (calls cleanup)</vh></v>
<v t="T3302"><vh>untangle</vh></v>
<v t="T3303"><vh>untangleAll</vh></v>
<v t="T3304"><vh>untangleMarked</vh></v>
<v t="T3305"><vh>untangleRoot (calls cleanup)</vh>
<v t="T3306" a="C"><vh>&lt;&lt; return if @silent or unknown language &gt;&gt;</vh></v>
<v t="T3307"><vh>&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</vh></v>
<v t="T3308"><vh>&lt;&lt; Read the file into file_buf  &gt;&gt;</vh></v>
<v t="T3309"><vh>&lt;&lt; Pass 2:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</vh></v>
</v>
<v t="T3310"><vh>untangleTree</vh>
<v t="T3311"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
</v>
<v t="T3312"><vh>tangle</vh>
<v t="T3313"><vh>Pass 1</vh>
<v t="T3314"><vh>handle_newline</vh></v>
<v t="T3315"><vh>skip_body</vh>
<v t="T3316"><vh>The interface between tangle and untangle</vh>
<v t="T3317"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T3318"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="T3319"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T3320"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T3321"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T3322"><vh>skip_code</vh>
<v t="T3323"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="T3324"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
<v t="T3325"><vh>&lt;&lt; skip a CWEB code section &gt;&gt;</vh>
<v t="T3326"><vh>&lt;&lt; handle CWEB control code &gt;&gt;</vh></v>
</v>
</v>
<v t="T3327"><vh>skip_doc</vh></v>
<v t="T3328"><vh>skip_headline</vh></v>
</v>
<v t="T3329"><vh>Pass 2</vh>
<v t="T1577" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
<v t="T997" a="C"><vh>tangle.put_all_roots</vh>
<v t="T998"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T999"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1000"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1001"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T3330"><vh>put_code</vh>
<v t="T3331"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="T3332"><vh>&lt;&lt; handle 2-character CWEB control codes &gt;&gt;</vh></v>
<v t="T3333"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
</v>
<v t="T3334"><vh>put_doc</vh>
<v t="T3335"><vh>&lt;&lt;put the doc part&gt;&gt;</vh>
<v t="T3336"><vh>&lt;&lt;output or skip whitespace or newlines&gt;&gt;</vh></v>
<v t="T3337"><vh>&lt;&lt;compute the width of the next word&gt;&gt;</vh></v>
<v t="T3338"><vh>&lt;&lt;output next word&gt;&gt;</vh></v>
</v>
</v>
<v t="T3339"><vh>put_leading_ws</vh></v>
<v t="T3340"><vh>put_newline</vh>
<v t="T3341"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="T3342"><vh>put_part_node</vh></v>
<v t="T3343"><vh>put_section</vh>
<v t="T3344"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="T3345"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="T3346"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="T3347"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="T3348"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="T3349"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="T3350"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
<v t="T3351"><vh>section_check</vh></v>
</v>
</v>
<v t="T3352"><vh>tst</vh>
<v t="T3353"><vh>st_check</vh></v>
<v t="T3354"><vh>st_dump</vh></v>
<v t="T3355"><vh>st_dump_node</vh></v>
<v t="T3356"><vh>st_enter</vh>
<v t="T3357"><vh>&lt;&lt;check for duplicate code definitions &gt;&gt;</vh></v>
<v t="T3358"><vh>&lt;&lt;remember root node attributes&gt;&gt;</vh></v>
</v>
<v t="T3359"><vh>st_enter_root_name</vh></v>
<v t="T3360"><vh>st_enter_section_name</vh></v>
<v t="T3361"><vh>st_lookup</vh></v>
</v>
<v t="T3362"><vh>ust</vh>
<v t="T3363"><vh>ust_dump</vh></v>
<v t="T3364"><vh>ust_enter</vh>
<v t="T3365"><vh>&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</vh></v>
</v>
<v t="T3366"><vh>ust_lookup</vh></v>
<v t="T3367"><vh>ust_warn_about_orphans</vh></v>
</v>
<v t="T3368"><vh>untangle</vh>
<v t="T3369"><vh>compare_comments</vh>
<v t="T3370" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v t="T3371"><vh>massage_block_comment (no longer used)</vh></v>
<v t="T3372"><vh>forgiving_compare</vh>
<v t="T3373"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="T3370" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
<v t="T3374"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="T3375"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="T3376"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="T3377" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T3378"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
</v>
<v t="T3379"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="T3377" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T3380"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="T3381"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
</v>
<v t="T3382"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="T3383"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="T3377" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="T3384"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="T3385"><vh>&lt;&lt; Trace the mismatch &gt;&gt;</vh></v>
</v>
<v t="T3386"><vh>mismatch</vh></v>
<v t="T3387"><vh>scan_derived_file (pass 1)</vh>
<v t="T3388"><vh>&lt;&lt; set the private global matching vars &gt;&gt;</vh></v>
<v t="T3389"><vh>&lt;&lt; Skip the header line output by tangle &gt;&gt;</vh></v>
<v t="T3390"><vh>&lt;&lt; handle the start of a new line &gt;&gt;</vh></v>
<v t="T3391"><vh>&lt;&lt; handle a sentinel line &gt;&gt;</vh>
<v t="T3392"><vh>&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</vh></v>
</v>
<v t="T3393"><vh>&lt;&lt; copy the entire line &gt;&gt;</vh></v>
<v t="T3394"><vh>&lt;&lt; copy a string &gt;&gt;</vh></v>
<v t="T3395"><vh>&lt;&lt; copy a multi-line comment &gt;&gt;</vh></v>
<v t="T3396"><vh>&lt;&lt; copy an alternate multi-line comment &gt;&gt;</vh></v>
<v t="T3397"><vh>&lt;&lt; end all open sections &gt;&gt;</vh></v>
</v>
<v t="T3398"><vh>update_def (pass 2)</vh>
<v t="T3399"><vh>&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</vh></v>
</v>
<v t="T3400"><vh>update_current_vnode</vh></v>
</v>
<v t="T3401"><vh>utility methods</vh>
<v t="T3402"><vh>compare_section_names</vh></v>
<v t="T3403"><vh>copy</vh></v>
<v t="T3404"><vh>error, pathError, warning</vh></v>
<v t="T3405"><vh>is_end_of_directive</vh></v>
<v t="T3406"><vh>is_end_of_string</vh></v>
<v t="T3407"><vh>is_escaped</vh></v>
<v t="T3408"><vh>is_section_name</vh></v>
<v t="T3409"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="T3410"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="T3411"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="T3412"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="T3413"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="T3414"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="T3415"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="T3416"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="T3417"><vh>push_new_def_node</vh></v>
<v t="T3418"><vh>scan_short_val</vh></v>
<v t="T3419"><vh>setRootFromHeadline</vh></v>
<v t="T1105" a="C"><vh>setRootFromText</vh></v>
<v t="T3420"><vh>skip_CWEB_section_name</vh></v>
<v t="T3421"><vh>skip_noweb_section_name</vh></v>
<v t="T3422"><vh>skip_section_name</vh></v>
<v t="T3423"><vh>standardize_name</vh></v>
<v t="T1450" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T1451"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="T1452"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1453"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1454"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1455"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="T1456"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1457"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="T1458"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="T1459"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1460"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="T1461"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1462"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1463"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="T1464"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="T3424"><vh>token_type</vh>
<v t="T3425"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T3426"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T3427"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T3428" tnodeList="3428,3429,2174,3430,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,3432,3433,848,849,850,851,860,861,862,863,864,852,853,854,855,856,857,3434,3435,858,3436,3437,3438,3439,3440,865,3441,1998,3442,1821,1822,1823,1824,1790,1825,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1826,1827,1828,1829,1830,1831,1832,1421,1422,1423,1424,1425,1426,1427,1428,1429,1833,1834,1835,1836,1837,1838,1769,1770,1771,1772,1773,1774,1775,874,875,3444,877,876,878,1793,1794,1795,1796,1797,1465,1466,866,867,868,869,870,871,872,1798,1799,1800,1801,523"><vh>@file leoTree.py</vh>
<v t="T3429"><vh>&lt;&lt; about the tree classes &gt;&gt;</vh></v>
<v t="T2174" a="C"><vh>&lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="T3430"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="T504" a="C"><vh>tree.Birth &amp; death</vh>
<v t="T505" a="C"><vh>tree.__init__</vh></v>
<v t="T506"><vh>tree.deleteBindings</vh></v>
<v t="T507"><vh>tree.deleteWidgets</vh></v>
<v t="T508" a="C"><vh>tree.injectCallbacks (class method)</vh>
<v t="T509"><vh>&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;</vh>
<v t="T510"><vh>OnBoxClick</vh></v>
<v t="T511"><vh>OnDrag</vh></v>
<v t="T512"><vh>OnEndDrag</vh></v>
<v t="T513"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T514"><vh>OnHeadlineKey</vh></v>
<v t="T515"><vh>OnHyperLinkControlClick</vh></v>
<v t="T516"><vh>OnHyperLinkEnter</vh></v>
<v t="T517"><vh>OnHyperLinkLeave</vh></v>
<v t="T518"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T519"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
<v t="T3431"><vh>Drawing</vh>
<v t="T3432"><vh>About drawing and updating</vh></v>
<v t="T3433"><vh>beginUpdate</vh></v>
<v t="T848" a="C"><vh>drawBox (tag_bind)</vh>
<v t="T849"><vh>&lt;&lt; define onBoxClickCallback &gt;&gt;</vh></v>
</v>
<v t="T850" a="C"><vh>drawIcon (tag_bind)</vh>
<v t="T851"><vh>&lt;&lt; define icon click callbacks &gt;&gt;</vh></v>
</v>
<v t="T859" a="C"><vh>Drawing routines (tree)...</vh>
<v t="T860"><vh>redraw</vh></v>
<v t="T861"><vh>force_redraw</vh></v>
<v t="T862"><vh>redraw_now</vh></v>
<v t="T863" a="C"><vh>idle_redraw</vh></v>
<v t="T864"><vh>idle_second_redraw</vh></v>
</v>
<v t="T852" a="C"><vh>drawNode &amp; force_draw_node</vh></v>
<v t="T853" a="C"><vh>drawText (bind)</vh>
<v t="T854"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; define the headline click callbacks &gt;&gt;</vh></v>
</v>
<v t="T856" a="C"><vh>drawTree</vh>
<v t="T857"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T3434"><vh>endUpdate</vh></v>
<v t="T3435"><vh>headWidth</vh></v>
<v t="T858" a="C"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="T3436"><vh>lastVisible</vh></v>
<v t="T3437"><vh>setLineHeight</vh></v>
<v t="T3438"><vh>tree.forceRecolor</vh></v>
<v t="T3439"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="T3440"><vh>tree.getIconImage</vh></v>
<v t="T865" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T3441"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="T1998" a="C"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="T3442"><vh>tree.yoffset</vh></v>
</v>
<v t="T1821" a="C"><vh>Event handers (tree)</vh>
<v t="T1822"><vh>OnActivate</vh>
<v t="T1823"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="T1824"><vh>OnBoxClick</vh></v>
<v t="T1790" a="C"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="T1825"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1409" a="C"><vh>body key handlers (tree)</vh>
<v t="T1410"><vh>idle_body_key</vh>
<v t="T1411"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="T1412"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1413"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1414"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="T1415"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="T1416" a="C"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="T1417"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="T1418"><vh>onBodyChanged</vh></v>
<v t="T1419"><vh>OnBodyKey</vh></v>
<v t="T1420"><vh>onBodyWillChange</vh></v>
</v>
<v t="T1826"><vh>tree.OnContinueDrag</vh>
<v t="T1827"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="T1828"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="T1829"><vh>tree.OnCtontrolT</vh></v>
<v t="T1830" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1831" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1832"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1421" a="C"><vh>headline key handlers (tree)</vh>
<v t="T1422"><vh>onHeadChanged</vh></v>
<v t="T1423"><vh>OnHeadlineKey</vh></v>
<v t="T1424"><vh>idle_head_key</vh>
<v t="T1425"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="T1426"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="T1833" a="C"><vh>tree.OnIconClick &amp; OnIconRightClick</vh>
<v t="T1834"><vh>&lt;&lt; define drag callbacks &gt;&gt;</vh></v>
</v>
<v t="T1835"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1836"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="T1837"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1838"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="T1769" a="C"><vh>tree.OnPopup &amp; allies</vh>
<v t="T1770"><vh>OnPopupFocusLost</vh></v>
<v t="T1771"><vh>createPopupMenu</vh>
<v t="T1772"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="T1773"><vh>enablePopupMenuItems</vh>
<v t="T1774"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="T1775"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="T3443"><vh>Incremental drawing</vh>
<v t="T874" a="C"><vh>allocateNodes</vh></v>
<v t="T875" a="C"><vh>allocateNodesBeforeScrolling</vh></v>
<v t="T3444"><vh>updateNode</vh></v>
<v t="T877" a="C"><vh>setVisibleAreaToFullCanvas</vh></v>
<v t="T876" a="C"><vh>setVisibleArea</vh></v>
<v t="T878" a="C"><vh>tree.updateTree</vh></v>
</v>
<v t="T1792" a="C"><vh>Selecting &amp; editing (tree)</vh>
<v t="T1793"><vh>abortEditLabelCommand</vh></v>
<v t="T1794"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T1795" a="C"><vh>editLabel</vh></v>
<v t="T1796"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1797"><vh>tree.expandAllAncestors</vh></v>
<v t="T1465" a="C"><vh>tree.scanForTabWidth</vh>
<v t="T1466"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T866" a="C"><vh>tree.select</vh>
<v t="T867"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T868"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T871"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
<v t="T1798" a="C"><vh>tree.set...LabelState</vh>
<v t="T1799"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T1800"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T1801"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
<v t="T523" a="C"><vh>tree.moveUpDown</vh></v>
</v>
<v t="T3445" tnodeList="3445,2177,3446,1944,1909,3448,3449,3450,1910,3451,3452,3453,1579,1580,1581,3454,3455,3456,3458,3457,3459,3460,1893,3461,1999,3462,3463,3464,3465,3466,3467,1892,3468,2000,2081,3470,3471,3472,1894,525,526,527,528,529,3473,3474,3475"><vh>@file leoUndo.py</vh>
<v t="T2177" a="C"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="T3446"><vh>&lt;&lt; Define optional ivars &gt;&gt;</vh></v>
<v t="T1944" a="C"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="T1909" a="C"><vh>clearIvars</vh></v>
</v>
<v t="T3447"><vh>State routines...</vh>
<v t="T3448"><vh>clearUndoState</vh></v>
<v t="T3449"><vh>canRedo &amp; canUndo</vh></v>
<v t="T3450"><vh>enableMenuItems</vh></v>
<v t="T1910" a="C"><vh>getBead, peekBead, setBead</vh></v>
<v t="T3451"><vh>redoMenuName, undoMenuName</vh></v>
<v t="T3452"><vh>setRedoType, setUndoType</vh></v>
<v t="T3453"><vh>setUndoParams</vh></v>
<v t="T1579" a="C"><vh>setUndoTypingParams</vh>
<v t="T1580"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1581"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T3454"><vh>setUndoTypes</vh></v>
</v>
<v t="T3455"><vh>u.redo</vh>
<v t="T3456"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="T3457"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="T3458"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="T3459"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="T3460"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="T1893" a="C"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T3461"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="T1999" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="T3462"><vh>u.undo</vh>
<v t="T3463"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="T3464"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="T3465"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="T3466"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="T1892" a="C"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T3467"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="T3468"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="T2000" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v t="T3469"><vh>Undo helpers</vh>
<v t="T2081" a="C"><vh>saveTree, restoreExtraAttributes</vh></v>
<v t="T3470"><vh>findSharedVnode</vh></v>
<v t="T3471"><vh>undoDemote</vh></v>
<v t="T3472"><vh>undoPromote</vh></v>
<v t="T1894" a="C"><vh>undoReplace</vh></v>
<v t="T525" a="C"><vh>undoRedoText</vh>
<v t="T526"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="T3473"><vh>undoSortChildren</vh></v>
<v t="T3474"><vh>undoSortSiblings</vh></v>
<v t="T3475"><vh>undoSortTopLevel</vh></v>
</v>
</v>
<v t="T3476"><vh>Unit Testing</vh>
<v t="T3477"><vh>Driver scripts</vh></v>
<v t="T3478" tnodeList="3478,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3493,3494,3495,3496,3497,3498,3499,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516,3517,3518,3519,3520,3521,3522,3523,3524,3525,3526,3527,3528,3529,3530"><vh>@file leoTest.py</vh>
<v t="T3479"><vh>@url http://pyunit.sourceforge.net/pyunit.html</vh></v>
<v t="T3480"><vh>tests of leoColor.py</vh>
<v t="T3481"><vh>class colorTests</vh>
<v t="T3482"><vh>color</vh></v>
<v t="T3483"><vh>setUp</vh></v>
<v t="T3484"><vh>tearDown</vh></v>
<v t="T3485"><vh>testC</vh></v>
<v t="T3486"><vh>testHTML1</vh></v>
<v t="T3487"><vh>testHTML2</vh></v>
<v t="T3488"><vh>testPHP</vh></v>
<v t="T3489"><vh>testPython1</vh></v>
<v t="T3490"><vh>testPython2</vh></v>
<v t="T3491"><vh>testRebol</vh></v>
</v>
</v>
<v t="T3492"><vh>Other stuff (not ready yet)</vh>
<v t="T3493"><vh>tests of leoNodes.py</vh>
<v t="T3494"><vh>class cloneTests</vh>
<v t="T3495"><vh>testCone</vh></v>
<v t="T3496"><vh>testMoveIntoClone</vh></v>
<v t="T3497"><vh>testMoveOutOfClone</vh></v>
<v t="T3498"><vh>testInsertInsideClone</vh></v>
<v t="T3499"><vh>testDeleteInsideClone</vh></v>
<v t="T3500"><vh>testInsertInsideClone</vh></v>
<v t="T3501"><vh>testDeleteInsideClone</vh></v>
</v>
<v t="T3502"><vh>class LeoNodeError</vh></v>
<v t="T3503"><vh>class moveTests</vh></v>
<v t="T3504"><vh>class nodeSanityTests</vh>
<v t="T3505"><vh>testNextBackLinks</vh></v>
<v t="T3506"><vh>testParentChildLinks</vh></v>
<v t="T3507"><vh>testJoinLists</vh></v>
<v t="T3508"><vh>testThreadNextBack</vh></v>
<v t="T3509"><vh>testNextBack</vh></v>
<v t="T3510"><vh>testVisNextBack</vh></v>
<v t="T3511"><vh>testFirstChildParent</vh></v>
</v>
<v t="T3512"><vh>class statusBitsChecks</vh>
<v t="T3513"><vh>testDirtyBits</vh></v>
</v>
<v t="T3514"><vh>class undoTests</vh>
<v t="T3515"><vh>testUndoMoveLeft</vh></v>
<v t="T3516"><vh>testRedoMoveLeft</vh></v>
</v>
</v>
<v t="T3517"><vh>class outlineConsistencyTests</vh></v>
<v t="T3518"><vh>functions</vh>
<v t="T3519"><vh>numberOfNodesInOutline, numberOfClonesInOutline</vh></v>
<v t="T3520"><vh>createTestOutline</vh></v>
<v t="T3521"><vh>loadTestLeoFile</vh></v>
<v t="T3522"><vh>copyTestOutline</vh></v>
<v t="T3523"><vh>compareTwoOutlines</vh></v>
<v t="T3524"><vh>compareLeoFiles</vh></v>
<v t="T3525"><vh>validateOutline</vh></v>
</v>
<v t="T3526"><vh>Scripts for checking clones</vh>
<v t="T3527"><vh>checkForMismatchedJoinedNodes</vh></v>
<v t="T3528"><vh>checkForPossiblyBrokenLinks</vh></v>
<v t="T3529"><vh>checkTopologiesOfLinkedNodes</vh></v>
<v t="T3530"><vh>checkLinksOfNodesWithSameTopologies (to do)</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T3531"><vh>(Bugs fixed in 4.0.1)</vh>
<v t="T2777" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
<v t="T2023" a="C"><vh>putLeadInSentinel</vh></v>
<v t="T1802" a="C"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T2885" a="C"><vh>checkTopologyOfAllClones</vh></v>
<v t="T3532"><vh>Script to check topology of all clones</vh></v>
<v t="T3533"><vh>(4.0: Allow unknown attributes in vnodes and tnodes)</vh>
<v t="T3534"><vh>Reading...</vh>
<v t="T2114" a="C"><vh>createVnode</vh>
<v t="T2115"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="T1655" a="C"><vh>getTnode</vh>
<v t="T1656"><vh>&lt;&lt; handle read from file &gt;&gt;</vh></v>
<v t="T1657"><vh>&lt;&lt; handle read from clipboard &gt;&gt;</vh></v>
<v t="T1658"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="T1660" a="C"><vh>getVnode</vh>
<v t="T1661"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="T1662"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
</v>
</v>
<v t="T3535"><vh>Writing</vh>
<v t="T1669" a="C"><vh>putTnode</vh>
<v t="T1670"><vh>&lt;&lt; put unknown tnode attributes &gt;&gt;</vh></v>
</v>
<v t="T2801" a="C"><vh>putVnode (3.x and 4.x)</vh>
<v t="T2802"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T2803"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T2804"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
<v t="T2805"><vh>&lt;&lt; put unknown vnode attributes &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T3536" a="E"><vh>(Bugs fixed in 4.0.2)</vh>
<v t="T3537"><vh>Test of report bad chars</vh></v>
<v t="T2919" a="C"><vh>es_exception</vh></v>
<v t="T1585" a="C"><vh>reportBadChars</vh></v>
<v t="T1586" a="C"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T3538"><vh>(Better message when @comment inhibits Untangle command)</vh>
<v t="T3306" a="C"><vh>&lt;&lt; return if @silent or unknown language &gt;&gt;</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@ignore
@nocolor
@ Older diary entries are in LeoDocs.leo.</t>
<t tx="T2"></t>
<t tx="T3"></t>
<t tx="T4">This caused problems opening &amp; closing Leo for some people.</t>
<t tx="T5"></t>
<t tx="T6"></t>
<t tx="T7">- Simplified undoReplace code &amp; removed asserts.
- The text param is no longer used and could be removed.

Undo tests:
	
(passed) Read @file Nodes.
(passed) Import Derived Files

(passed) Extract Section
(passed) Extract Section Names.
(passed) Extract

(passed) Convert Tabs &amp; Convert All Tabs.</t>
<t tx="T8"></t>
<t tx="T9"></t>
<t tx="T10">This is too distracting while typing the directive.</t>
<t tx="T11">@nocolor

The following appears in run() in leo.py:

@color

doHook("start1")
if app.killed: return # 10/15/03: allows the plugin to kill the app.</t>
<t tx="T12">This command was not taking into account the optional -ver= part of the @+leo sentinel.</t>
<t tx="T13">The command now looks at joined nodes if no ancestor @file node.</t>
<t tx="T14"></t>
<t tx="T15"></t>
<t tx="T16"></t>
<t tx="T17"></t>
<t tx="T18">- Replaced all calls to v.copyTree related to undo by c.undoer.saveTree.

- Hacked u.undoReplace to handle tuple returned by u.saveTree.

- Fixed bugs in Convert All Blanks and Convert All Tabs routines.
	- These routines call convertBlanks and convertTabs as helpers.
	- Added arg to convertBlanks and convertTabs controlling whether these routines set undo state.
</t>
<t tx="T19"></t>
<t tx="T20"></t>
<t tx="T21"></t>
<t tx="T22">@language elisp
@color

(defun abc 'a "abc
xyz" cons)</t>
<t tx="T23">Must call c.initAllCloneBits.</t>
<t tx="T24"></t>
<t tx="T25">This is a temporary expedient.  Probably using ch.isalpha() would be better</t>
<t tx="T26">When doing a back scan we must test for the start of the text _after_ looking for brackets.</t>
<t tx="T27"></t>
<t tx="T28"></t>
<t tx="T29">This was tricky to get right:
	
- There are several calls to after_idle(idle_body_key), so which gets scheduled is a matter of timing.  To handle that I added the tree.forceFullRedraw() routine.

- The undo/redo code also recolors the text.  Added a new param to undoRedoText so that it could force a full redraw after cut/paste.</t>
<t tx="T30">The new code is now guaranteed to go to the proper node of the outline.  However, @doc parts may disrupt line counts within a node.</t>
<t tx="T31"></t>
<t tx="T32"></t>
<t tx="T33">Somehow a number of calls to c.initJoinedCloneBits got omitted.</t>
<t tx="T34">vnode attributes would typically be used for things like marks or additional icons.

tnode attributes would typically be used for anything associated with shared headline or body text.</t>
<t tx="T35">tkinterGui.destroy must call frame.top.destroy.</t>
<t tx="T36"></t>
<t tx="T37"></t>
<t tx="T38">The code was attempting to reference an ivar.  I placed sentinelNameDict inside sentinelName() and referenced it directly.</t>
<t tx="T39">This is required so that attributes get set in the leoApp object rather than the proxy object.</t>
<t tx="T40"></t>
<t tx="T41"></t>
<t tx="T42"></t>
<t tx="T43">This is a big step forward.  newLeoCommanderAndFrame provides a place to explore the complexities of initializing LeoFrames and their commanders.

newLeoCommanderAndFrame does the following.  Order is _crucial_:

- first creates an "empty" frame first to pass to the commanders.  This was an Aha!
- then creates the commander and all subcommanders.
- then calls the new frame.finishCreate routine to create the actual frames (and set c.body).
- finally calls c.undoer.clearUndoState(), which requires that menus have already been created.

The present code should be moved to the tkinterGui class.</t>
<t tx="T44">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="T45"></t>
<t tx="T46"></t>
<t tx="T47"></t>
<t tx="T48"></t>
<t tx="T49"></t>
<t tx="T50"></t>
<t tx="T51">This is much more natural and less cluttered.</t>
<t tx="T52">There were bugs involving the c.pattern_match_flag and c.suboutline_only_flag.

The present code is way too fragil and clumsy.  I plan to rewrite it completely when the configuration logic is redone.

Also, the present code using only a single copy of leoConfig.txt, so changing a setting in one .leo file may change settings in other .leo files.</t>
<t tx="T53">@nocolor

Class level-code after the method definitions was dropped:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="T54"></t>
<t tx="T55">allow_clone_drags = 1
# 1: Allows control-dragging to create clones.
# 0: All drags move nodes.
# See also: look_for_control_drag_on_mouse_down
# Setting this setting to 0 allows Leo to be used on Aqua.

enable_drag_messages = 1
# 1: Tell whether drags will move nodes or clone nodes.
# 0: Don't issue such messages.</t>
<t tx="T56">The read code now clears the dirty bit in the root vnode before looking for changed text.

While I was at it, I moved some of the dirty bit logic into getLeoFile.  This makes all read commands work the same.</t>
<t tx="T57">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed:

- There are "off-by-one" errors.
- It is possible that a complete rewrite in the 4.0 case would be significantly better.</t>
<t tx="T58">This was easy: just write a newline and an @nonl sentinel if the text does not end in a newline.

Compare with the messy 3.x code: a huge simplification.</t>
<t tx="T59">The reason this was so strange is that the at.sentinels ivar was not initialized properly, either in the the old or new classes.  Usually this ivar is set properly (to true) because the _preceding_ file is an @file node that does init the ivar to true.

So the fix was just to set self.sentinel = true in new_df.rawWrite and old_df.rawWrite</t>
<t tx="T60"></t>
<t tx="T61"></t>
<t tx="T62">Again, this wasn't an error, and it was confusing.</t>
<t tx="T63">This wasn't a bug, but it was quite confusing.</t>
<t tx="T64">This avoids overriding the base putSentinel routine with a routine with a different signature.

This argument was never used anyway.</t>
<t tx="T65">This avoids overriding the base scanText routine with a routine with a different signature.</t>
<t tx="T66">leo.py

- Added leoDialog and traceback to import list.
- Removed app args from createFrame and initSherlock.

leoApp

- Changed tList = [] to tDict = {}
- Removed app.finishCreate.

- leoCommands

- Removed some unused local vars in Convert Blanks/Tabs and Reformat Paragraph commands.

leoCompare

- Removed import leoApp, leoCommands from run() method.

leoFileCommands

- Removed unused self.a ivar.
- Removed unused first line below in getPrefs:
	s = string.lower(name)
	language = string.replace(name,"/","")

leoFrame:

- removed some imports from inside createNewMenu and deleteMenuItem.  Plugins should not need these.

- Removed unused vars:
	changed: &lt;&lt; read optional version param &gt;&gt;
	changed: old_df.readOpenFile
	changed: scanText
	changed: &lt;&lt; Test for @path &gt;&gt;
	changed: &lt;&lt; compute relative path from s[k:] &gt;&gt;
	changed: putDocPart (3.x)
	changed: putCodePart &amp; allies
	changed: new_df.readOpenFile
	changed: nodeSentinelText
	changed: &lt;&lt; write then entire @file tree &gt;&gt; (4.x)

leoGlobals:

- Removed unused vars in
	scanAtTabwidthDirective,skip_braces,skip_php_braces,skip_pp_part,isValidEncoding
	&lt;&lt; Set local vars &gt;&gt;
	&lt;&lt; compute relative path from s[k:] &gt;&gt;

leoGui

- Changed self.defaultFont to app.config.defaultFont in getFontFromParams.
- Added leoFrame to import list.

leoNodes

- Fixed real bug in appendStringToBody.
	- The code used none instead of None: changed test just to if not s: return

leoPlugins

- Removed import sys from loadHanders()

leoTree

- Disabled unused call to canvas.find_closest in OnContinueDrag.  Maybe this will help performance?</t>
<t tx="T67">Fixed:

c:\prog\leoCVS\leo\src\leoFileCommands.py:814: Local variable (config) not used
c:\prog\leoCVS\leo\src\leoImport.py:994: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (cmp) not used
c:\prog\leoCVS\leo\src\leoFontPanel.py:155: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoApp.py:224: Local variable (tList) not used
c:\prog\leoCVS\leo\src\leoTree.py:1512: Parameter (v) not used (createPopupMenu)
c:\prog\leoCVS\leo\src\leoTree.py:1603: Parameter (v) not used (showPopupMenu)
c:\prog\leoCVS\leo\src\leoApp.py:365: No module attribute (leoID) found (remove app.setLeoId)</t>
<t tx="T68"></t>
<t tx="T69">- Changed app().x to app.x everywhere.

- Changed a.x to app.x everywhere, and eliminated the assignments a = app()

This paves the way to use the app.gui.x pattern more widely.

I did this now so that I could check this with Pychecker: I must run Pychecker anyway so this kills two birds with one stone.
</t>
<t tx="T70"></t>
<t tx="T71">The reason app() is needed is that it's definition doesn't change, even though what it returns does change during startup.

The problem with using a global app var is that from leoGlobals import * picks up and _caches_ the _uninitialized_ value.  Setting leoGlobals.app in the startup logic does not affect all the cached values.

The only way to prevent this would be be avoid importing any of Leo's modules until after the app object has been created.  This looks impossible, and it would be very brittle even if it were possible.

I _really_ would like from leoGlobals import app to work, but how to delay the import until later?</t>
<t tx="T72">These routines now do the following:

1. Print a warning message if their internal string representation is not a unicode string.

2. Convert their results to unicode.</t>
<t tx="T73">The tnode ctor now ensures that headline and body text are converted to Unicode using app.tkEncoding.</t>
<t tx="T74">This was never needed, and removing it prepares to change app from a function to a global var.
</t>
<t tx="T75"></t>
<t tx="T76">1. Called getAllText in the following routines:

colorizeAnyLanguage
convertAllBlanks,convertAllTabs,extract,extractSection,extractSectionNames
OnExecuteScript

2. Called getSelectedText in the following routines:

OnExecuteScript

3. Called x = toUnicode(s,app().tkEncoding) in the following routines after a call to t.get(...)

bound_paragraph,getBodyLines,reformatParagraph
OnReturnKey
OnFindMatchingBracket,findMatchingBracket
updateStatusRowCol
changeAll,findAll
&lt;&lt; test for whole word match &gt;&gt;</t>
<t tx="T77">Previously, nothing was printed if </t>
<t tx="T78">Created new LeoApp16.ico icon w.wm_iconbitmap().

The old code still works with Python 2.2.</t>
<t tx="T79"></t>
<t tx="T80">All the real code has now been moved from leoGlobals.py to leoGui.py.</t>
<t tx="T81"></t>
<t tx="T82"></t>
<t tx="T83">This is the foundation for "foreign" guis.</t>
<t tx="T84"></t>
<t tx="T85"></t>
<t tx="T86">After the 4.0 beta 1 release I changed the default so that _new_ format derived files are written if leoConfig.txt does not exist.</t>
<t tx="T87"></t>
<t tx="T88"></t>
<t tx="T89">This allows the caller to do an auto-save only if something was really written.</t>
<t tx="T90">When I first tried to open LeoPy.leo after writing all @file nodes (With the Write @file Nodes command) I got a

"No joinList for tnode" message.

What I did:

1. Error recovery worked perfectly.  No damage was done!

2. getLeoFile must call setAllJoinLinks _before_ reading @file nodes so that findChild will see a valid joinList.

	- This is perfectly safe in 4.0 because reading _never_ creates vnodes or alters vnode links.

3. writeAtFileNodes now does an auto-save.</t>
<t tx="T91"></t>
<t tx="T92"></t>
<t tx="T93"></t>
<t tx="T94"></t>
<t tx="T95">The output is the same in both the old and new versions.</t>
<t tx="T96"></t>
<t tx="T97">findChild now calls at.readError when t.joinList is None so reading will stop immediately without crashing.</t>
<t tx="T98">@+doc and @+at sentinels indicate trailing whitespace.

It is crucial that whitespace is _always_ handled correctly.</t>
<t tx="T99">This didn't do anything...</t>
<t tx="T100">Must be done to clear tnodeList in the .leo file.  This allows the user to create a 3.x compatible .leo file.</t>
<t tx="T101"></t>
<t tx="T102"></t>
<t tx="T103">I was surprised that the top-level class was a subclass of oldDerivedFile.  This isn't really good.

The first step of separating the class was to make the sentinel constants global to the module.  This required substantial changes.

After that, I separated the atFile class just by providing the initIvars and readLine routines.  To make readLine work I had to init self.encoding.  That's all!

Derived classes must follow base classes in the module, so I changed the top-level node to force the correct order regardless of node order.</t>
<t tx="T104">Changed made:

1. Look ahead in putDocLine to preserve additional leading whitespace.
2. Do _not_ eliminate newline in readLastDocLine.  That must be done only by @nonl logic.

Note:  The code can not do a perfect job of restoring whitespace: it can not distinguish between @ and @space on a line by itself.  However, this construction is rare, and there really is no difference between them.</t>
<t tx="T105"></t>
<t tx="T106">The code calls at.writeAll(writeAtFileNodesFlag=true) to write all nodes in the selected tree.</t>
<t tx="T107">Handling @first and @last is actually quite subtle, and the old code handles the job correctly.

getAtFirstLastLines simply couldn't cut it.  Thanks again to Dave Hein.</t>
<t tx="T108">This must be done to preserve the tnodeList.</t>
<t tx="T109">This code hasn't been tested yet.

- Don't change body text if a) @last and b) only difference is last newline.</t>
<t tx="T110">This is a big step forward:  it eliminates some nasty modes.

- scanHeader returns flag instead of setting ivar.
- Write code uses config.write_old_format_derived_files.</t>
<t tx="T111">Both the old and new write code does this.</t>
<t tx="T112">This is too annoying during testing.</t>
<t tx="T113">We no longer need this: the write_old_format_derived_files setting is enough to disable new writes.

In other words, the transition to 4.0 has begun!</t>
<t tx="T114">This is the clean way of setting the default using the config.write_old_format_derived_files setting.</t>
<t tx="T115">This is the clean way of forcing writes using old or new format.</t>
<t tx="T116">findChild(4.0) and createNthChild (3.x) both now call v.t.setVisited.  The code in top_df.read warns if any non-empty node is unvisited.

This check, and the check that headlines match pretty much guarantees that out-of-synch outlines will generate errors.  In that case, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="T117"></t>
<t tx="T118">These changes made in leoPlugins.leo (use_gnx) first.  They will be moved into LeoPy.leo soon.

What I did:
	- Removed gnx's for now (maybe forever?)
	- Eliminated use_gnx and using_gnx code from new read code.
	- All old read/write routines pass.
	- Fixed a bug in old write code(!!) @verbatim was not output correctly!
	- Created top_df.scanDefaultDirectory and top_df.error.
		- We must have this in order to open files in the proper directory.
 	- Replaced calls to at.init_ivars by df.init_ivars
	- Created new_df.raw_write
	- Create top_df write routines.
	- Created class topLevelDerivedFileCommands
	- Created class oldDerivedFile
	- Created class newDerivedFile(oldDerivedFile)
	- Removed all error recovery logic from old read code.
	- Replaced structureErrors ivar with errors ivar.
	- Old read code now sets t.tempBodyString.
	- Move all common read code into top_df.read.
</t>
<t tx="T119">- Moved setLeoID into leoApp.py
- Moved nodeIndices class into leoNodes.py.
- Moved askLeoID into leoDialogs.py
- Eliminated myTnode class.
- Moved myFrame methods into leoFrame.py and eliminated myFrame.
</t>
<t tx="T120"></t>
<t tx="T121"></t>
<t tx="T122"></t>
<t tx="T123"></t>
<t tx="T124"></t>
<t tx="T125"></t>
<t tx="T126"></t>
<t tx="T127"></t>
<t tx="T128">tnodeList must be a list of tnodes, _not_ a list of tnode indices.

Indices may be reassigned, tnodes won't.

The _only_ place that an index is proper is in the file format itelf.</t>
<t tx="T129">The script is called "Script to compare 3.x and 4.x derived files" in test.leo.
</t>
<t tx="T130">The bug was in directiveKind.  There are two ways for the code to recognize @others.  After inserting the second way, I mistakenly commented out the first way (by commenting out @others in the table).</t>
<t tx="T131"></t>
<t tx="T132"></t>
<t tx="T133"></t>
<t tx="T134"></t>
<t tx="T135">The new version of putLeadInSentinel works as follows:

1. It calls at.putIndent(at.indent) followed by the leading whitespace in the outline line.

The effect of this is

a) to align the @ws sentinel with the following sentinel and
b) to preserve the "spelling" of the leading whitespace on the line.

2. N.B. The calls to putLeadInSentinel happen _before_ at.indent is changed as the result of the leading whitespace. 

Again, this is so that putLeadInSentinel can preserve the spelling of whitespace.

3. The contribution of the @ws sentinel is the _difference_ between the value of at.indent when the @ws sentinel is being read and the actual whitespace on the line.  Again, we do this to make the derived file look better.</t>
<t tx="T136">This makes the @nl look better, and has no other effect.</t>
<t tx="T137">- Special case code for blank lines.
- Created putBlankDocLine.</t>
<t tx="T138"></t>
<t tx="T139"></t>
<t tx="T140"></t>
<t tx="T141"></t>
<t tx="T142">I added this code to the "main" line for upward compatibility with 4.0.  The main line code does nothing with the new tnodeList attribute as yet.</t>
<t tx="T143">This method now uses the tnode list to find the indicated tnode.  It also checks the headline.</t>
<t tx="T144"></t>
<t tx="T145">The code that reads the new tnodeList attribute of vnodes is contained in the "main line" code, i.e., in LeoPy.leo.  This means that Leo will always be able to read (and ignore) the tnodeList attribute.

The code that writes the attribute is part of the use_gnx plugin.

The tnodeList returns a tnode, not a vnode, so it makes sense to keep track of at.t not at.v.
</t>
<t tx="T146">- The new code now hanles the basic cases properly.

- Added @nl sentinel to indicate whether a section ref should be followed by a newline.

- The read code now sets v.t.tempBodyString instead of call v.setBodyStringOrPane.  This is a major advance in error recovery:  nothing at all changes if errors happen.

What I did earlier:
	- Removed @+body and @-body
	- Don't write organizer nodes in @others</t>
<t tx="T147">@ignore
@nocolor</t>
<t tx="T148"></t>
<t tx="T149">I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in LEO, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols dnichols@amci.com</t>
<t tx="T150">Proper FAQ entry for Leo

Almost everything in the present FAQ for Leo is incorrect.

- The proper capitalization is Leo, not LEO.
- Leo is highly supported: Leo should appear in the supported tools section.  
- Leo has great relevance to section 6: What is literate programming.
  See: http://webpages.charter.net/edreamleo/design.html
- All links in the Leo section of the present FAQ are incorrect.

Here is a correct FAQ entry for Leo:

8.x Leo

     Developer:
        Edward K. Ream edreamleo@charter.net

     Version:
        4.0

     Hardware:
        Any platform supporting Python and Tk, including
        Windows, Linux, MacOs X and others.
        Leo requires Python 2.1 or above and tcl/tk 8.3 or above.

     Languages:
        Written in Python. Full support for Python scripting.
        Full support for noweb and cweb.
        Syntax coloring for C, C++, cweb, html, Java, LaTex,
        Pascal, Perl and Perlpod, PHP, plain text, Python, Rebol,
        shell scripts and tcl/tk.

     Formatter:
        Printing and formatting via exports to external editors.

     Availability:
        Leo home:    http://webpages.charter.net/edreamleo/front.html
        SourceForge: http://sourceforge.net/projects/leo/
        Support:     http://sourceforge.net/forum/?group_id=3458
        Download: http://sourceforge.net/project/showfiles.php?group_id=3458
        CVS:         http://sourceforge.net/cvs/?group_id=3458
        Wiki:        http://leo.hd1.org/

     Readme:
        See download link above.

     Description:
        - A programmer's editor, an outlining editor and a flexible browser.
        - A literate programming tool, compatible with noweb and CWEB.
        - A data organizer and project manager. Leo provides multiple views
          of projects within a single outline.
        - Fully scriptable using Python. Leo saves its files in XML format.
        - Extensible: plugins may change all aspects of Leo at runtime.
        - Portable: Leo is 100% pure Python.
        - Open Software, distributed under the Python License.

     Support:
        Leo is highly supported and has many active developers and users.
        See the support link above for general, help and developer forums.

Edward K. Ream
--------------------------------------------------------------------
Edward K. Ream   email:  edreamleo@charter.net
Leo: Literate Editor with Outlines
Leo: http://webpages.charter.net/edreamleo/front.html
--------------------------------------------------------------------</t>
<t tx="T151"></t>
<t tx="T152">leo.py 3.3 is now available at:  http://sourceforge.net/projects/leo/

The highlights of 3.3:
----------------------

- Added support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.

leo.py requires Python 2.2 and tcl/tk 8.3 or above.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
</t>
<t tx="T153">leo.py 3.5 is now available at:  http://sourceforge.net/projects/leo/

The many bugs reported in 3.4 show that leo.py is being heavily used.  leo.py 3.5 corrects all known bugs and adds some new features:

The highlights of 3.5:
----------------------

- Added new entries in the help menu,
  (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added configuration options for horizontal scrollbars.
- Added an importFiles script for mass imports.
- Added better warnings for read-only files.
- Removed all '\r' characters when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.

Version 3.4 has not been announced previously.

The highlights of 3.4:
----------------------

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.

leo.py requires Python 2.2 and tcl/tk 8.3 or above.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458

</t>
<t tx="T154">leo.py 3.6 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.2 and tcl/tk 8.3 or above.

A slashdot article about Leo appeared soon after 3.5 was released.  Leo now has many more users and developers; 3.6 is considerably more friendly to Linux as a result.

The highlights of 3.6:
----------------------

- Fixed several bugs that appear only on Linux.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP languages.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.
- Leo remembers the previous insertion point and scrollbar position when switching between nodes.
- The usual small improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T155">leo.py 3.7 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 and tcl/tk 8.3 or above.

The highlights of 3.7:
----------------------

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T156">leo.py 3.8 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.

Many major improvements have been made to Leo, all made as the result of user requests:

The highlights of 3.8:
----------------------

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option specifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T157">leo.py 3.9 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.

This is one of the most interesting versions of Leo ever released:

The highlights of 3.9:
----------------------
* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
    These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth with other editors.
  - The Go To Line Number command converts lines numbers in derived files
    to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
    This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
    By default, @space, @* and @** sections are colored as latex text.
    Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
    @file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
    installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.

Quote of the month
------------------
"When first I opened Leo, it was out of curiosity. But having used it...
I'LL NEVER GO BACK. THEY'LL HAVE TO PRY LEO OUT OF MY COLD, DEAD FINGERS!
Seriously,it should be renamed 'Crack Cocaine' because it's that addictive.
I'm ready to start a 12-Step group." -- Travers A. Hough

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T158">leo.py 3.10 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.

3.10 corrects bugs, improves Leo's documentation and adds many new features:

The highlights of 3.10:
-----------------------
- Rewrote the Scripting Chapter in Leo's Users Guide.
- Improved the Customization Chapter of the Users Guide.
- Adds several customizations contributed by Leo's users:
  -- @read-only nodes.
  -- Reading empty .leo files.
  -- Redirecting stderr and stdout to Leo's log pane.
- New Mark Clones and Go To Next Clone commands.
- New Export Headlines command.
- Control-dragging a node now clones it.
- New "Node Only checkbox in the Find/Change panel.
- @root-code trees start in code mode by default.
  This allows @root trees to work like @file trees.
- @root-doc  trees start in doc  mode by default.
- Converted leoConfig.py to use @root-code
- New at_root_bodies_start_in_doc_mode option in leoConfig.py.
  Specifies whether @root trees work like @root-code or @root-doc.
- New synonyms: @file-asis = @silentfile
  @file-nosent = @nosentinelsfile ; @file-noref = @rawfile.
- Leo now supports navigation of menus using underlined menus.
- Added an easy way to replace any Leo method by a function.
  The code in customizeLeo.py can now override part of Leo's code!
- Added routines to redirect stderr and stdout to Leo's log pane.
- Added "event1" and "event2" hooks for customized event handling.
- Improved Leo's window icon, and improved how that icon is loaded.
- The usual assortment of bug fixes and minor improvements.
  Actually, this release fixes more than the usual number of bugs.

Quote of the month
------------------
I must say I am very impressed. I have been absolutely seduced by Leo over the
past few days. I tell you, I can not put it down. I feel like a kid with a
shiny new bike...I'm already bursting with new ways I'd like to use the tool in
the future -- Lyn Adams Headley

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T159">leo.py 3.11 beta 1 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

The highlights of 3.11:
-----------------------
** Leo finally supports unicode properly.  This solves a lot of problems.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo. (A major improvement.)
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
	- Added install script for Linux.
- New settings in leoConfig.leo/.txt.
	- Colors for Show Invisibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

Quote of the month
------------------
I only have one week of Leo experience but I already know it will be my default
IDE/project manager.  I have seen several old threads on c.l.python  where people
complain about the lack of a project manager for the free/standard Python IDE's
like Idle.  Leo clearly solves that problem and in a way that commercial tools
can't touch -- Marshall Parsons

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
</t>
<t tx="T160">leo.py 3.11 beta 3                       February 26, 2003

leo.py 3.11 beta 3 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

It appears that just about everyone who has ever reported problems with how Leo handles non-ascii characters is now satisfied with Leo.

- Fixes some unicode problems when the system encoding is not "utf-8".
- Adds the tk_encoding setting.
- Fixes some minor bugs in the Outline To Noweb command.

For all other details, see below.

The highlights of 3.11:
-----------------------
** Leo finally supports unicode properly.  This solves a lot of problems.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo. (A major improvement.)
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
	- Added install script for Linux.
- New settings in leoConfig.leo/.txt.
	- Colors for Show Invisibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

Quote of the month
------------------
I only have one week of Leo experience but I already know it will be my default
IDE/project manager.  I have seen several old threads on c.l.python  where people
complain about the lack of a project manager for the free/standard Python IDE's
like Idle.  Leo clearly solves that problem and in a way that commercial tools
can't touch -- Marshall Parsons

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
</t>
<t tx="T161">leo.py 3.11 beta 4                       March 31, 2003

leo.py 3.11 beta 4 is now available at:  http://sourceforge.net/projects/leo/

This will be the last beta release before 3.11 final.

The highlights of beta 4:
-------------------------
- Fixed several minor problems with unicode.
- Fixed a _huge_ performance bug that slowed moving nodes left.
- Added several new plugins:
	- Support for the VIM editor.
	- A French translation of all menus.
- Added many minor bug fixes and improvements.

The highlights of 3.11:
-----------------------
** Leo now supports unicode properly.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo.
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
	- Added install script for Linux.
- New settings in leoConfig.leo/.txt.
	- Colors for Show Invisibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
</t>
<t tx="T162">leo.py 3.11 final is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

This version of Leo contains many important improvements since 3.10,
especially support for unicode and a new plugin architecture.

The Highlights of 3.11 final:

** Leo supports unicode.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo.
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Fixed a huge performance bug that slowed moving nodes left.
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- New @lineending directive specifies line endings.
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
- New settings in leoConfig.leo/.txt.
	- Added "tk_encoding" setting and related logic.
	- Colors for Show Invisibibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

Quote of the Month:
-------------------
I gave Leo a try a while ago, but did not recognize its strengths as an
outliner. In April 2003 a gave it another try. And when I saw in the online
help mentiontioning clones almost in passing (you got to emphasis this much
more!), I knew: This is it.

If you are like me, you have a kind of knowledge base with infos gathered over
time. And you have projects, where you use some of those infos. Now, with
conventional outliners you begin to double these infos, because you want to
have the infos needed for the project with your project. With Leo you can do
this too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE
TOO! This is a feature I did not see with any other outliner (and I tried a
few). Amazing! Leo directly supports the way I work! -- F. Geiger

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py works on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458

Edward K. Ream</t>
<t tx="T163">leo.py 3.11.1 is now available at:  http://sourceforge.net/projects/leo/

This version fixes two bugs found in the recent 3.11 version:
	
- Leo had startup problems on some Linux systems.

- Creating clones by control dragging did not always work.
  This bug has existed in Leo for a long time.

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py works on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream</t>
<t tx="T164">leo.py 3.12                              July 17, 2003

leo.py 3.12 is now available at: http://sourceforge.net/projects/leo/

This version fixes many bugs and adds several major new features.  There are no known serious bugs in this version of Leo. 

Window sizes are now in pixels rather than grid units, so you must resize existing outlines (.leo files) when opening them for the first time using this version of Leo.  Don't panic!

Highlights of this version:

* Plugged a huge memory leak.
* Fixed a major bug involving undo.
* Added Icon &amp; Status areas to Leo window for use by plugins.
* Important new plugins:
  - The file leoPlugins.leo now contains all plugins.
  - add_directives.py allows plugins to define new directives.
  - color_markup.py supports wiki-styled markup.
  - mod_spelling.py checks spelling (requires aspell to be installed).
  - nav_buttons.py creates browser-style navigation plugins in the icon area.
  - plugins_menu.py creates a Plugins menu items for all loaded plugins.
  - scripts_menu.py creates a Scripts menu for all scripts in scripts folder.
  - spell
  - trace_gc traces all changes to memory at idle time.
* Other enhancements:
  - Redesigned the Find panel.   Non-functional options are dimmed.
  - Added @wrap and @nowrap directives.
  - Added Write Dirty @file Nodes command.
  - Added several new "stub hooks".
  - Hyperlinks are now enabled by default.
  - Leo now loads plugins in alphabetical order.
  - Leo now remembers the size and location of Leo windows.
  - Undo now restores the insert point or the selection range after most commands.
  - Added apply button to Font panel.
  - Improved the reporting of characters that do not exist in the present encoding.
* The usual assortment of bug fixes and minor improvements.
  - There are no known bugs in this version of Leo.

Quote of the month:
-------------------
"Thanks for such a great mind-opening program!" -- Eduardo Dominguez

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py works on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream
</t>
<t tx="T165">leo.py 3.12                              July 17, 2003

leo.py 3.12 is now available at: http://sourceforge.net/projects/leo/

This version fixes many bugs and adds several major new features.

The first announcement of 3.12 appeared a few days ago on SourceForge.  Since then, a few minor bugs have been found.  In particular, if would be best, when installing Leo on Linux, to remove previous installations of Leo before running the install script.  This will ensure that the new subdirectories of the main Leo directory are created properly.

Window sizes are now in pixels rather than grid units, so you must resize existing outlines (.leo files) when opening them for the first time using this version of Leo.  Don't panic!

Highlights of this version:

* Plugged a huge memory leak.
* Fixed a major bug involving undo.
* Added Icon &amp; Status areas to Leo window for use by plugins.
* Important new plugins:
  - The file leoPlugins.leo now contains all plugins.
  - add_directives.py allows plugins to define new directives.
  - color_markup.py supports wiki-styled markup.
  - mod_spelling.py checks spelling (requires aspell to be installed).
  - nav_buttons.py creates browser-style navigation plugins in the icon area.
  - plugins_menu.py creates a Plugins menu items for all loaded plugins.
  - scripts_menu.py creates a Scripts menu for all scripts in scripts folder.
  - spell
  - trace_gc traces all changes to memory at idle time.
* Other enhancements:
  - Redesigned the Find panel.   Non-functional options are dimmed.
  - Added @wrap and @nowrap directives.
  - Added Write Dirty @file Nodes command.
  - Added several new "stub hooks".
  - Hyperlinks are now enabled by default.
  - Leo now loads plugins in alphabetical order.
  - Leo now remembers the size and location of Leo windows.
  - Undo now restores the insert point or the selection range after most commands.
  - Added apply button to Font panel.
  - Improved the reporting of characters that do not exist in the present encoding.
* The usual assortment of bug fixes and minor improvements.
  - There are no known bugs in this version of Leo.

Quote of the month:
-------------------
"Thanks for such a great mind-opening program!" -- Eduardo Dominguez

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py works on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream
</t>
<t tx="T166"></t>
<t tx="T167">Leo 4.0 beta 1                      September 26, 2003

Leo 4.0 beta 1 is now available at: http://sourceforge.net/projects/leo/

This is the first public release of Leo 4.0. Version 4.0 is the culmination of over a year of collaborative design work and several months of actual implementation.

Please use caution when using this beta version of Leo.  It appears solid and it has been tested by only a few people.

Highlights of 4.0:
-----------------

** Improved and simplified format of derived files.
  - Eliminated child indices, extraneous blank lines and @body sentinels.
  - Eliminated @node sentinels that indicate outline structure.
  - New @nl and @nonl sentinels indicate where newlines are and aren't.
  - These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
  - Reading derived files _never_ alters outline structure or links.
  - Read errors leave the outline completely unchanged.
  - Broken clone links are gone forever.
  - As a result, using 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
  - Leo reads all derived files properly, regardless of version.
  - Leo writes new-format derived files by default, and this default may be changed.
  - New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
  - Write 3.x Derived File.
  - Write 4.x Derived File.
  - Import Derived File.
  - Clear Recent Files.

- Several new plugins.
- Several minor bug fixes.

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py works on Linux, Windows and MacOs X Jaguar.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream</t>
<t tx="T168">Leo 4.0 beta 2 is now available at: http://sourceforge.net/projects/leo/

This is the second public release of Leo 4.0. There are no known serious bugs
in this version of Leo. Version 4.0 is the culmination of over a year of
collaborative design work and several months of actual implementation.

4.0 introduces new file formats.  Please make full backups of important files.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed problems with reading and writing 4.0 derived files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting that allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of derived files.
  - Eliminated child indices, extraneous blank lines and @body sentinels.
  - Eliminated @node sentinels that indicate outline structure.
  - New @nl and @nonl sentinels indicate where newlines are and aren't.
  - These changes largely eliminate unwanted cvs conflicts.
* Greatly improved error handling.
  - Reading derived files _never_ alters outline structure or links.
  - Read errors leave the outline completely unchanged.
  - Broken clone links are gone forever.
  - As a result, using 4.0 is much safer than all previous versions.
* Full compatibility will previous versions of Leo.
  - Leo reads all derived files properly, regardless of version.
  - Leo writes new-format derived files by default, and this default may be changed.
* New commands:
  - Write 3.x Derived File and Write 4.x Derived File commands.
  - Import Derived File command.
  - Clear Recent Files command.
* Several new plugins.

Quote of the month
------------------
I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in Leo, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Leo requires Python 2.1 or above and tcl/tk 8.3 or above.
Leo works on Linux, Windows and MacOs X.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream</t>
<t tx="T169">Leo 4.0 beta 3 is now available at: http://sourceforge.net/projects/leo/

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo. This will likely be the last beta release before 4.0
final.

N.B. 4.0 introduces new file formats. Please make full backups of important
files.

Highlights of 4.0 beta 3
------------------------
- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed problems with reading and writing 4.0 derived files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting that allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of derived files.
  - Eliminated child indices, extraneous blank lines and @body sentinels.
  - Eliminated @node sentinels that indicate outline structure.
  - New @nl and @nonl sentinels indicate where newlines are and aren't.
  - These changes largely eliminate unwanted cvs conflicts.
* Greatly improved error handling.
  - Reading derived files _never_ alters outline structure or links.
  - Read errors leave the outline completely unchanged.
  - Broken clone links are gone forever.
  - As a result, using 4.0 is much safer than all previous versions.
* Full compatibility will previous versions of Leo.
  - Leo reads all derived files properly, regardless of version.
  - Leo writes new-format derived files by default, and this default may be changed.
* New commands:
  - Write 3.x Derived File and Write 4.x Derived File commands.
  - Import Derived File command.
  - Clear Recent Files command.
* Several new plugins.

Quote of the month
------------------
I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in Leo, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Leo requires Python 2.1 or above and tcl/tk 8.3 or above.
Leo works on Linux, Windows and MacOs X.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream
October 9, 2003</t>
<t tx="T170">Leo 4.0 beta 4 is now available at: http://sourceforge.net/projects/leo/

This is the fourth public release of Leo 4.0. There are no known serious bugs
in this version of Leo. This will be the last beta release before 4.0 final.

N.B. 4.0 introduces new file formats. Please make full backups of important
files.

Highlights of 4.0 beta 4
------------------------
- Changed all instances of string.letters to string.ascii_letters.
  string.letters can cause crashes in some locales (Unicode environments).
- Fixed several bugs that caused clone marks not to be set properly.

Highlights of 4.0 beta 3
------------------------
- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed problems with reading and writing 4.0 derived files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting that allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of derived files.
  - Eliminated child indices, extraneous blank lines and @body sentinels.
  - Eliminated @node sentinels that indicate outline structure.
  - New @nl and @nonl sentinels indicate where newlines are and aren't.
  - These changes largely eliminate unwanted cvs conflicts.
* Greatly improved error handling.
  - Reading derived files _never_ alters outline structure or links.
  - Read errors leave the outline completely unchanged.
  - Broken clone links are gone forever.
  - As a result, using 4.0 is much safer than all previous versions.
* Full compatibility will previous versions of Leo.
  - Leo reads all derived files properly, regardless of version.
  - Leo writes new-format derived files by default, and this default may be changed.
* New commands:
  - Write 3.x Derived File and Write 4.x Derived File commands.
  - Import Derived File command.
  - Clear Recent Files command.
* Several new plugins.

Quote of the month
------------------
I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in Leo, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Leo requires Python 2.1 or above and tcl/tk 8.3 or above.
Leo works on Linux, Windows and MacOs X.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream
October 13, 2003</t>
<t tx="T171">Leo 4.0 final is now available at: http://sourceforge.net/projects/leo/

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------
** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File and Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

Quote of the month
------------------
I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in Leo, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols

What is Leo?
------------
- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
- Fully scriptable using Python. Leo saves its files in XML format.
- Portable. leo.py is 100% pure Python.
- Open Software, distributed under the Python License.

Leo requires Python 2.1 or above and tcl/tk 8.3 or above.
Leo works on Linux, Windows and MacOs X.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Wiki:     http://leo.hd1.org/

Edward K. Ream
October 17, 2003</t>
<t tx="T172">@color

# **** Do a full virus scan first!

# **** For reference only     ****
# **** Run this from test.leo ****

# Run pychecker from idle.
if 1:
	import pychecker.checker
	import leo
@nocolor
Documentation
	- Update readme.txt
	- Update LeoDocs.leo
	- Update web site.
Version numbers
	- Update version number in Help menu.
	- Update version number in setup.py (@ignore'd!!)
@color

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")

@nocolor
Create and test leosetup.exe.
	- Create leosetup.exe by right-clicking leo.nsi and choosing "compile with NSI (bz2)"
	- Test created leosetup.exe file.
	- test the files created in c:\program files\leo
Create Release on SourceForge
Uploads
    - Upload leodocs.zip
	- Upload leosetup.exe
	- Upload leo-x-y.zip
	- Upload sbook.chm if it has been changed.
Announcements
	- Announce to SourceForge itself. USE ANNOUNCEMENT FORMAT, not readme format.
	- Announce to Leo's SourceForce site.
	- Announce to comp.lang.python
	- Announce to comp.programming.literate</t>
<t tx="T173">Have you thought about the publicity of 3.6? 
- News item on sourceforge 
- Freshmeat 
- http://www.python.org 
Vaults of Parnassus 
Vault: __main__ . Python Tools/Extensions . Editor / IDE 
- http://www.linux.org 
Development tools 
- http://www.gnu.org 
Just kidding :) 
</t>
<t tx="T174"></t>
<t tx="T175">use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)</t>
<t tx="T176">@nocolor

- Add a new entries in &lt;&lt; define global data structures &gt;&gt; app

- Add a new Tk.Radiobutton in &lt;&lt;create the Target Language frame&gt;&gt;

- Add an entry to the languages list in &lt;&lt;configure language-specific settings&gt;&gt;

- Add a list of the keywords of the language to &lt;&lt; define colorizer keywords &gt;&gt;
	
  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.
	
- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the &lt;preferences&gt; tag (near the top) contains an entry like this:

&lt;preferences allow_rich_text="0" defaultTargetLanguage="Python"&gt;
&lt;/preferences&gt;

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color</t>
<t tx="T177"># Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"cweb" : "@q@ @&gt;", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "&lt;!-- --&gt;",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rebol" : ";", #jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.
	
self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c", 
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "latex",
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl", 
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rebol" : "r",  #jason 2003-07-03
	"shell" : "txt",
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.</t>
<t tx="T178"># Frame and title
w,target = create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("ActionScript", "actionscript"),
	("C/C++","c"),
	("CWEB", "cweb"),
	("elisp","elisp"),
	("HTML", "html"),
	("Java", "java"),
	("LaTeX", "latex"),
	("Pascal", "pascal")]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [
	("Perl", "perl"),
	("Perl+POD", "perlpod"),
	("PHP", "php"),
	("Plain Text", "plain"),
	("Python", "python"),
	("Rebol", "rebol"),
	("tcl/tk", "tcltk")]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")
</t>
<t tx="T179"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
	delim1,delim2,delim3 = set_delims_from_language("c")
elif self.comment_string:
	delim1,delim2,delim3 = set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
	delim1,delim2,delim3 = None,None,None
else:
	delim1,delim2,delim3 = set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.has_string = self.language != "plain"
if self.language == "plain":
	self.string_delims = ()
elif self.language in ("elisp","html"):
	self.string_delims = ('"')
else:
	self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
	"actionscript","c","cweb","elisp","html","java","latex",
	"pascal","perl","perlpod","php","python","rebol","tcltk"]

self.keywords = []
if self.language == "cweb":
	for i in self.c_keywords:
		self.keywords.append(i)
	for i in self.cweb_keywords:
		self.keywords.append(i)
else:
	for name in languages:
		if self.language==name: 
			# trace("setting keywords for",name)
			self.keywords = getattr(self, name + "_keywords")

# Color plain text unless we are under the control of @nocolor.
# state = choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
	self.lb = "&lt;&lt;"
	self.rb = "&gt;&gt;"
else:
	self.lb = choose(self.language == "cweb","@&lt;","&lt;&lt;")
	self.rb = choose(self.language == "cweb","@&gt;","&gt;&gt;")</t>
<t tx="T180">&lt;&lt; actionscript keywords &gt;&gt;
&lt;&lt; c keywords &gt;&gt;
cweb_keywords = c_keywords
&lt;&lt; elisp keywords&gt;&gt;
&lt;&lt; html keywords &gt;&gt;
&lt;&lt; java keywords &gt;&gt;
&lt;&lt; latex keywords &gt;&gt;
&lt;&lt; pascal keywords &gt;&gt;
&lt;&lt; perl keywords &gt;&gt;
perlpod_keywords = perl_keywords
&lt;&lt; python keywords &gt;&gt;
&lt;&lt; tcl/tk keywords &gt;&gt;
&lt;&lt; php keywords &gt;&gt;
&lt;&lt; rebol keywords &gt;&gt;</t>
<t tx="T181">actionscript_keywords = (
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
)</t>
<t tx="T182">c_keywords = (
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while",
	# C++ keywords
	"asm","bool","catch","class","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t")</t>
<t tx="T183"># EKR: needs more work.
elisp_keywords = (
	# Maybe...
	"error","princ",
	# More typical of other lisps...
	"apply","eval",
	"t","nil",
	"and","or","not",
	"cons","car","cdr",
	"cond",
	"defconst","defun","defvar",
	"eq","ne","equal","gt","ge","lt","le",
	"if",
	"let",
	"mapcar",
	"prog","progn",
	"set","setq",
	"type-of",
	"unless",
	"when","while")</t>
<t tx="T184"># No longer used by syntax colorer.
html_keywords = ()

if 0: # Not used at present.
	unused_keywords = (
		# html constructs.
		"a","body","cf",
		"h1","h2","h3","h4","h5","h6",
		"head","html","hr",
		"i","img","li","lu","meta",
		"p","title","ul",
		# Common tags
		"caption","col","colgroup",
		"table","tbody","td","tfoot","th","thead","tr",
		"script","style")

	html_specials = ( "&lt;%","%&gt;" )</t>
<t tx="T185">java_keywords = (
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while")</t>
<t tx="T186">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_keywords = (
	#special keyworlds
	"\\@", "\\(", "\\)", "\\{", "\\}",
	#A
	"\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
	"\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
	"\\appendix", 
	"\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
	#B
	"\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
	"\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
	"\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
	"\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
	#C
	"\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
	"\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
	"\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
	"\\cot", "\\coth",	"csc",
	#D
	"\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
	"\\deg", "\\Delta", 
	"\\delta", "\\depthits", "\\det", 
	"\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
	"\\documentclass", "\\documentstyle", 
	"\\dot", "\\dotfil", "\\downarrow",
	#E
	"\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
	"\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
	"\\eta", "\\example", "\\exists", "\\exp",
	#F
	"\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
	"\\footnotemark", "\\fotenotesize", 
	"\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
	"\\frontmatter",
	#G
	"\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
	"\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
	#H
	"\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
	"\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
	#I
	"\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
	"\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
	#J
	"\\jmath", "\\Join",
	#K
	"\\k", "\\kappa", "\\ker", "\\kill",
	#L
	"\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
	"\\LaTeX", "\\LaTeXe", 
	"\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
	"\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
	"\\linethickness", "\\linewidth",	"\\listfiles",
	"\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
	"\\Longrightarrow",	"longrightarrow",
	#M
	"\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
	"\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
	"\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
	"\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
	#N
	"\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
	"\\newenvironment", "\\newfont",
	"\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
	"\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
	"\\not", "\\nu", "nwarrow",
	#O
	"\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
	"\\overbrace", "\\overline",
	#P
	"\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
	"\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
	"\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
	"\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
	"\\providecomamnd", "\\Psi",	"\\psi", "\\put",
	#Q
	"\\qbezier", "\\quoteblbase", "\\quotesinglbase",
	#R
	"\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
	"\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
	"\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
	"\\Roman", "\\roman", "\\rule", 
	#S
	"\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
	"\\searrow",	"\\sec", "\\section",
	"\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
	"\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
	"\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
	"\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
	"\\sqsupset", "\\SS",
	"\\stackrel", "\\star", "\\subsection", "\\subset", 
	"\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
	#T
	"\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
	"\\tau", "\\telephone",	"\\TeX", "\\textbf",
	"\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
	"\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
	"\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
	"\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
	"\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
	"\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
	"\\Theta", "theta", 
	"\\tilde", "\\thinlines", 
	"\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
	"\\triangle", "\\tt", 
	"\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
	#U
	"\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
	"\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
	"\\usecounter", "\\usepackage", 
	#V
	"\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
	"\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
	"\\vline", "\\vphantom", "\\vspace",
	#W
	"\\widehat", "\\widetilde", "\\widthits", "\\wp",
	#X
	"\\Xi", "\\xi",
	#Z
	"\\zeta" )</t>
<t tx="T187">pascal_keywords = (
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal",
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses",
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" )</t>
<t tx="T188">perl_keywords = (
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s",
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 &amp; FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 &amp; f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn")</t>
<t tx="T189">php_keywords = ( # 08-SEP-2002 DTHEIN
	"__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
	"and", "as", "break",
	"case", "cfunction", "class", "const", "continue",
	"declare", "default", "do",
	"else", "elseif", "enddeclare", "endfor", "endforeach",
	"endif", "endswitch",  "endwhile", "eval", "extends",
	"for", "foreach", "function", "global", "if",
	"new", "old_function", "or", "static", "switch",
	"use", "var", "while", "xor" )
	
# The following are supposed to be followed by ()
php_paren_keywords = (
	"array", "die", "echo", "empty", "exit",
	"include", "include_once", "isset", "list",
	"print", "require", "require_once", "return",
	"unset" )
	
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="T190">python_keywords = (
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print")</t>
<t tx="T191">rebol_keywords = (
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
)</t>
<t tx="T192">tcltk_keywords = ( # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" )</t>
<t tx="T193">Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.</t>
<t tx="T194">To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.</t>
<t tx="T195">teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
&gt; I am plowing through old bug reports, and I found the following, from whom 
&gt; I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

&gt;&gt; - Source files still have the dreaded \r in them. Why don't you switch 
&gt;&gt; to \n only, once and for all, and live happily ever after? ;^) 

&gt; I sure whould like to do that, and I'm not sure how to do this. All 
&gt; versions of the read code attempt to remove '\r' characters, and all 
&gt; versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 
 
</t>
<t tx="T196">Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

&gt; Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward</t>
<t tx="T197">In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; f = open("crlf.txt")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
&gt;&gt;&gt; f = open("crlf.txt", "rU")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline" problem,\n'

</t>
<t tx="T198">&gt; You can open the file in 'binary' mode (adding 'b' to the mode string) and
&gt; the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
</t>
<t tx="T199">import pychecker.checker ; import leo</t>
<t tx="T200">@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.</t>
<t tx="T201"></t>
<t tx="T202">I'd like to start a thread to think more about what we can do to deal with LeoPy.leo
in CVS.

Motivation: after making my Unix EOL fixes, I though I'd get with the program
and create a new node under (Project Views)-&gt;Bugs, and collect under there clones
of all the nodes that I touched as part of the fix.  I managed to get my changes
to LeoPy.py into CVS by doing a cvs up immediately before starting the work,
and being lucky enough that noone made any updates before I finished.

But of course, Edward was working on something else at the time, and when he
went to check in, he got a conflict.  Because of the intractablility of resolving
LeoPy.leo conflicts, he had to blow away my changes to get his in - not the
changes to the .py files (all intact), but the additional "documentation" node
for the bug.

This points out clearly what the .leo file contains that the python files don't:
the structures outside the @file (and @root) nodes.  If we concede that the
LeoPy.leo file is intractable in the presence of conflicts, then to preserve
that information, there would have to be some external, more tractable source
for that structure.  I am not at all convinced that's feasible, but I'm going
to speculate in public to see where it leads me/us.

What would such a structure contain?  All of the headlines, certainly.  Used
in combination with the .py files to rebuild the .leo file, it will also have
to include all the bodies not incorporated into files.  Internally, it will
need a syntax to indicate the tree structure.  So far, we're just building the
entire .leo file over again.  But here's a difference that might make a
difference:

Currently nodes are named in the .leo file with numbers.  The nodes need names,
or else it would be impossible to refer to clones.  Those names are effectively
recreated on the fly when the .leo file gets written, so any addition of a new
node changes all the names of the nodes following it in the tree walk.  That's
the core problem, and indicates a possible solution: what if these names weren't
disposable?  Store this .leo node name along with the node.  New nodes would
be assigned new names (probably the next highest integer).  So, at the end of
this thought process, the proposal is not to add a file external to the .leo
file, but to preserve the node numbers contained in the .leo file.  My python
reference suggests that these integers take about 12 bytes to store; adding
them to each node in LeoPy.leo would add about 30k to the memory footprint

I haven't yet studied the code that reads the .leo file, so any insight or guidance
from those who have would be appreciated before I head further down this path.

    - Stephen</t>
<t tx="T203"></t>
<t tx="T204"></t>
<t tx="T205"></t>
<t tx="T206">leo.py reads and writes exactly like LeoCB</t>
<t tx="T207">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="T208"></t>
<t tx="T209"></t>
<t tx="T210">This marked my complete frustration with wxLeo and wxPython, and the real beginning of the work on leo.py.</t>
<t tx="T211"></t>
<t tx="T212">I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="T213">I am not sure exactly when this happened.  The details apparently have been lost.  There was a time when I was experimenting with Python and wxPython, and a time when I was working on wxWindows version of Leo.</t>
<t tx="T214"></t>
<t tx="T215">Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1684478
By: ktenney

Promo idea;
Several people arguing about the correct answer to 'What is Leo'
A production coder talks about the efficiency advantages.

An academic talks about the increased understanding of the code via literate
concepts.

A documentation writer talks about the organizational benefits of outlines.

A hacker dood talks about how easy it is to write Python to make it do kewel
things.

A system administrator talks about a way to centralize access to config files,
and keep notes on them.

etc.
</t>
<t tx="T216">- Changed execptions.ImportError to ImportError in handleLeoHook.
c:\prog\LeoCVS\leo\leoGlobals.py:1508: No module attribute (ImportError) found

- Changed execptions.ImportError to ImportError in open.
c:\prog\leoCvs\leo\leoConfig.py:683: Catching string exceptions are deprecated (true)
c:\prog\leoCvs\leo\leoConfig.py:683: No module attribute (IOError) found

- Removed force_update global from headline key logic.
c:\prog\LeoCVS\leo\leoTree.py:1247: No global (forceUpdate) found

- Removed n0 from OnGoToLineNumber
c:\prog\leoCvs\leo\leoFrame.py:2466: Local variable (n0) not used

- To do: investigate this:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called</t>
<t tx="T217"></t>
<t tx="T218">New in 2.2 (Do not use)

- Iterators/Generators
- Nested Scopes
- New Classes

The what's new for each version:

http://www.amk.ca/python/2.0/
http://www.amk.ca/python/2.1/
</t>
<t tx="T219"></t>
<t tx="T220"></t>
<t tx="T221"></t>
<t tx="T222">@nocolor

1. You specify default values of _formal parameters_ in a def statement.

2. You specify keywords arguments in a _function call_.

3. An argument list must have any positional arguments followed by any keyword arguments, where the keywords must be chosen from the formal parameter names.  It's not important whether a formal parameter has a default value or not.

4. No argument may receive a value more than once.

5. When a final formal parameter of the form **name is present, it receives a dictionary containing all keyword arguments whose keyword doesn't correspond to a formal parameter.

EKR Notes:

1.  I have been confusing default values with keyword arguments.  _Any_ formal parameter may be specified with a keyword argument!

2.  Arbitrary keyword params can be used if the def has an **arg.</t>
<t tx="T223">In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');
 
&gt; That will be
 
	lines = PyObject_CallMethod(block, "split", "s", "\n");
</t>
<t tx="T224"></t>
<t tx="T225">It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\&gt;set PATH=%PATH%;c:\python22\tools\Scripts

C:\&gt;google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\&gt;google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\&gt;
</t>
<t tx="T226">&gt;&gt; It has a header of just one line. All the ugly stuff is at the end.
&gt;&gt;
&gt;&gt; -------------------------------------------------------------------
&gt;&gt; goto ="python"
&gt;&gt;
&gt;&gt; # Python code goes here
&gt;&gt;
&gt;&gt; ''' hybrid python/batch footer:
&gt;&gt; @:="python"
&gt;&gt; @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
&gt;&gt; @if errorlevel 9009 echo Python may be downloaded from
&gt;www.python.org/download
&gt;&gt; @rem '''
&gt;&gt; -------------------------------------------------------------------
&gt;&gt;
&gt;&gt;         Oren
&gt;&gt;
&gt;

It's for running python scripts on windows, without having to type:

[&lt;path to python&gt;\]python[.exe] &lt;scriptname&gt; [&lt;arguments&gt;*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

</t>
<t tx="T227">@ignore</t>
<t tx="T228">from leoGlobals import *
import sys

a = 99

# __import__(__name__).__dict__.update(dict(tuple))

def f():
	tup = (('a', 1,), ('b', 'two',))
	globals().update(dict(tup))
	print "-" * 20
	a,b = 5,6
	print `a`,`b`
	if 0:
		print globals().get("f")
		print globals().get(sys._getframe(0).f_code.co_name)
	
f()
print `a`,`b`
print globals().get(sys._getframe(0).f_code.co_name)
print __name__
print __import__(__name__)</t>
<t tx="T229">@ignore
@language python
@color</t>
<t tx="T230">if 0:
	
	def app():

		"""Return the singleton application object."""
		
		trace("unexpected call")
	
		global gApp # "global" makes sense only within functions!
		return gApp</t>
<t tx="T231">def setLeoID (self):
	
	tag = ".leoID.txt"
	loadDir = app.loadDir
	configDir = app.config.configDir
	&lt;&lt; return if we can set self.leoID from sys.leoID &gt;&gt;
	&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;
	&lt;&lt; put up a dialog requiring a valid id &gt;&gt;
	&lt;&lt; attempt to create leoID.txt &gt;&gt;</t>
<t tx="T232"># This would be set by in Python's sitecustomize.py file.
try:
	app.leoID = sys.leoID
	es("leoID = " + app.leoID, color="blue")
	return
except:
	app.leoID = None</t>
<t tx="T233">for dir in (configDir,loadDir):
	try:
		fn = os.path.join(dir, tag)
		f = open(fn,'r')
		if f:
			s = f.readline()
			f.close()
			if s and len(s) &gt; 0:
				app.leoID = s
				es("leoID = " + app.leoID, color="blue")
				return
			else:
				es("empty " + tag + " in " + dir, color = "red")
	except:
		app.leoID = None
		
if configDir == loadDir:
	es(tag + " not found in " + loadDir, color="red")
else:
	es(tag + " not found in " + configDir + " or " + loadDir, color="red")

</t>
<t tx="T234">app.leoID = leoDialog.askLeoID().run(modal=true)

es("leoID = " + `app.leoID`, color="blue")</t>
<t tx="T235">for dir in (configDir,loadDir):
	try:
		# Look in configDir first.
		fn = os.path.join(dir, tag)
		f = open(fn,'w')
		if f:
			f.write(app.leoID)
			f.close()
			es("created leoID.txt in " + dir, color="red")
			return
	except: pass
	
if configDir == loadDir:
	es("can not create leoID.txt in " + loadDir, color="red")
else:
	es("can not create leoID.txt in " + configDir + " or " + loadDir, color="red")

</t>
<t tx="T236">The following batch files use @rawfile so that no extraneous lines get generated.

The go.bat batch loads leo.py and opens LeoPy.leo by default, so to work on leo.py I just open a Windows console window and type go.  Add LeoPy folder to your PATH environment variable, or put go.bat in c:\Windows.

The sdist.bat batch file creates a source distribution using distutils and setup.py.

The bdist.bat batch file creates a binary distribution.  It does not work yet.

The manifest.in file contains a list of files to be included in the distutils distribution.</t>
<t tx="T237">rem Create binary distribution using information in setup.py
rem cd c:\prog\LeoPy
c:\python22\python setup.py bdist --formats=wininst</t>
<t tx="T238">cd c:\prog\LeoCVS\leo
c:\python22\python openLeo.py</t>
<t tx="T239">rem print help message re setup.py
c:\python22\python setup.py sdist --help</t>
<t tx="T240">rem creates source distribution using setup.py
rem cd c:\prog\LeoPy
rem --formats=gztar,zip
c:\python22\python setup.py sdist --force-manifest</t>
<t tx="T241"></t>
<t tx="T242"></t>
<t tx="T243">@nocolor

I had completely misunderstood __del__ methods!  __del__ methods _disable_ the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

Note: the tree.recycleBindings ivar _should_ be true.  Indeed, tree.deleteBindings is called by various redraw routines, and recycling those bindings is very important.

Also, there is no need to "help" the gc:

&gt; My app has unlimited undo.  As a result, most "user" data never truly
&gt; gets deleted: the undo stack keeps references to all such data alive
&gt; "forever". 

&gt; I am wondering whether it would be a good idea to put dummy __del__
&gt; methods in the user data classes.  Would this help the gc by telling
&gt; the gc what not to look at?

Remember the gc is generational. That means that any data that has survived 
a garbage collection is automatically excluded from most other garbage 
collections, so most of the time the grabage collector will ignore your 
user data objects anyway.

Or to put it another way, the garbage collector already knows not to look 
at your objects without your help.


3.3.1 Basic customization 

__del__(self)

[snip]
Circular references which are garbage are detected when the option cycle detector is enabled (it's on by default), but can only be cleaned up if there are no Python-level __del__() methods involved. Refer to the documentation for the gc module for more information about how __del__() methods are handled by the cycle detector, particularly the description of the garbage value.</t>
<t tx="T244">if 0: # __del__ methods interfere with the garbage collector.

	def __del__ (self):
		pass
</t>
<t tx="T245">if 0: # __del__ methods interfere with the garbage collector.

	def __del__ (self):
		pass
</t>
<t tx="T246">if 0: # __del__ methods interfere with the garbage collector.

	def __del__ (self):
		pass
</t>
<t tx="T247">if 0: # __del__ methods interfere with the garbage collector.

	def __del__ (self):
		pass
</t>
<t tx="T248">if 0: # __del__ methods interfere with the garbage collector.

	def __del__ (self):
		pass
</t>
<t tx="T249">@ The garbage collector should be able to reclaim garbage containing cycles, and in practice it is difficult to break all links. Having destroy routines is a pragmatic approach.</t>
<t tx="T250">def destroy (self):
	
	"""Clear all links from an atFile object to other objects."""
	
	# print "atFile.destroy" # Don't use trace.
	
	self.outputFile = None
	self.root = None</t>
<t tx="T251">def destroy (self):
	
	"""Clear all links from a commander to other objects."""

	# print "c.destroy" # Don't use trace.
	
	# Clear links to subcommanders.
	self.atFileCommands = None
	self.fileCommands = None
	self.importCommands = None
	self.tangleCommands = None
	self.undoer = None

	# Clear others ivars.
	self.beadList = None
	self.body = None
	self.canvas = None
	self.frame = None
	self.hookFunction = None
	self.log = None
	self.tree = None
	self.visitedList = None
</t>
<t tx="T252">def destroy (self):
	
	"""Clear all links from a color object to other objects."""
	
	# print "color.destroy" # Don't use trace.

	self.v = None
	self.body = None
	config = None
	self.state_dict = None</t>
<t tx="T253">def destroy (self):
	
	"""Clear all links from a frame to other objects."""

	# print "frame.destroy" # Don't use trace.
	
	# Clear links to panels.
	self.colorPanel = None
	self.comparePanel = None
	self.fontPanel = None 
	self.prefsPanel = None
	
	# Clear other ivars.
	self.activeFrame = None
	self.body = None
	self.bodyBar = None
	self.canvas = None
	self.commands = None
	self.draggedItem = None
	self.f1 = self.f2 = None
	self.hwnd = None
	self.icon = None
	self.iconFrame = None
	self.log = None
	self.logBar = None
	self.logColorTags = None
	self.menus = None
	self.menuShortcuts = None
	self.mFileName = None
	self.outerFrame = None
	self.recentFiles = None
	self.splitter1 = self.splitter2 = None
	self.statusFrame  = None
	self.statusLabel = None
	self.statusText = None
	self.title = None
	self.top = None
	self.tree = None
	self.treeBar = None</t>
<t tx="T254">def destroy (self):
	
	# print "import.destroy" # Don't use trace.
	
	self.commands = None
	self.web_st = None</t>
<t tx="T255">def destroy (self):
	
	"""Clear all links from a fileCommands object to other objects."""
	
	# print "fileCommands.destroy" # Don't use trace.
	
	self.a = None
	self.commands = None
	self.copiedTree = None
	self.fileBuffer = None
	self.frame = None
	self.outputFile = None
	self.tnodesDict = None
	self.topVnode = None</t>
<t tx="T256">def destroy (self):
	
	"""Clear all links from a tnode to other objects."""
	
	# print "t.destroy"

	self.joinList = None
</t>
<t tx="T257">def destroy (self):
	
	"""Clear all links from a tangle object to other objects."""
	
	# print "tangle.destroy" # Don't use trace.
	
	self.code = None
	self.doc = None
	self.def_stack = None
	self.file_name = None
	self.header = None
	self.header_name = None
	self.head_root = None
	self.output_file = None
	self.root = None
	self.root_list = None
	self.section_name = None
	self.section_stack = None
	self.tst = None
	self.ust = None
	self.v = None
</t>
<t tx="T258">def destroy (self):
	
	"""Clear all links from a tree to other objects."""

	# print "tree.destroy" # Don't use trace.

	# Delete all references to Tk widgets.
	self.deleteBindings()
	self.canvas.delete("all")
	self.deleteWidgets()

	# Clear all ivars.
	self.bindings = None
	self.colorizer = None
	self.commands = None
	self.canvas = None
	self.currentVnode = None
	self.drag_id = None
	self.editVnode = None
	self.edit_text_dict = None
	self.font = None
	self.fontName = None
	self.iconimages = None
	self.icon_id_dict = None
	self.popupMenu = None
	self.rootVnode = None
	self.tagBindings = None
	self.topVnode = None
	self.widgets = None
</t>
<t tx="T259">def destroy (self):
	
	"""Clear all links from an undo object to other objects."""
	
	# print "undo.destroy" # Don't use trace.
	
	self.beads = None
	self.commands = None
	self.v = None
	
	for ivar in optionalIvars:
		exec('self.%s = None' % ivar)
</t>
<t tx="T260">def destroy (self):
	
	"""Clear all links from a vnode to other objects."""

	# print "v.destroy" # Don't use trace.

	self.commands = None
	self.t = None
	self.mParent = self.mFirstChild = self.mNext = self.mBack = None
</t>
<t tx="T261"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

v = frame.commands.rootVnode()
while v:
	vList.append(v)
	if v.t:
		key = id(v.t)
		if not tDict.has_key(key):
			tDict[key] = v.t
	v = v.threadNext()
	
for key in tDict.keys():
	tDict[key].destroy()

for v in vList:
	v.destroy()

vList = [] ; tList = [] # Remove these references immediately.</t>
<t tx="T262">def OnInsertGraphicFile(self,event=None):
	
	c = self.commands
	
	filetypes = [("Gif", "*.gif")]
		# Only Gif images are allowed.
		#("Bitmap", "*.bmp"),
		#("Icon", "*.ico"),
	
	fileName = tkFileDialog.askopenfilename(
		title="Insert Graphic",
		filetypes=filetypes,
		defaultextension=".gif")

	if fileName and len(fileName) &gt; 0 and os.path.exists(fileName):
		try:
			fileName = os.path.join(app().loadDir,fileName)
			fileName = os.path.normpath(fileName)
			image = Tkinter.PhotoImage(file=fileName)
		except:
			es("Exception loading: " + fileName)
			es_exception()
			image = None
		if image:
			# print image.height()
			index = c.body.index("insert")
			if 1: # same behavior
				bg = c.body.cget("background")
				w = Tkinter.Label(c.body,image=image,bd=0,bg=bg)
				c.body.window_create(index,window=w,align="baseline")
			else:
				c.body.image_create(index,image=image,align="baseline")
			# c.body.dump(index) # The image isn't drawn unless we take an exception!
</t>
<t tx="T263"></t>
<t tx="T264"></t>
<t tx="T265">def show_cwd (event=None):

	import os

	es("cwd: " + os.getcwd())</t>
<t tx="T266">def importPythonFiles (event=None):

	import leoImport,os

	leoImport.importFiles(os.getcwd(),".py")</t>
<t tx="T267">def importCwebFiles (event=None):

	import leoImport,os

	leoImport.importFiles(os.getcwd(),".py")</t>
<t tx="T268"></t>
<t tx="T269">import distributeLeo
reload(distributeLeo)

# path = r"c:\prog\leoCVS\leo"
ver = "3.11b1"
d = distributeLeo.distributeLeo(ver=ver)
d.create()</t>
<t tx="T270">@first #! /usr/bin/env python
@color
@language python
@ignore

# Experimental distribution scripts

from leoGlobals import *
import os,sys

class distributeLeo:
	@others</t>
<t tx="T271">def __init__ (self,ver,path=r"C:\prog\leoCVS\leo"):

	self.ver = ver
	self.leoDir=path
	self.distDir = os.path.join(path,"dist")
	self.iconsDir = os.path.join(path,"Icons")
	self.fileList = []
	self.manifestFiles = []
	self.iconsList = []
	self.folderName = None
	self.zipFileName = None
	self.tarFileName = None
	self.extraFiles = (
		"__init__.py",
		"LeoPy.leo","LeoDocs.leo",
		"leoConfig.leo","leoConfig.txt",
		"c2py.py","disStats.py","openLeo.py",
		"tangle_done.py", "untangle_done.py",
		"README.TXT","INSTALL.TXT",
		"LICENSE.TXT","PKG-INFO.TXT",
		"leo.rc","leo.res",
		"manifest.in" )

	self.wildcardFiles = ( "leo*.py","Icons/*.*" )
</t>
<t tx="T272">def check (self):

	if 0:
		print ; print "fileList:" ; print
		for f in self.fileList:
			print f
			
	if 1:
		print ; print "iconsList:" ; print
		for f in self.iconsList:
			print f</t>
<t tx="T273">def copyFile (self,name,fromDir,toDir):

	try:
		fromFile = os.path.join(fromDir,name)
		toFile = os.path.join(toDir,name)
		f = open(fromFile)
	except:
		# print "not found:", fromFile
		return
	
	try:
		data = f.read()
		f.close
		f = open(toFile,"w")
		f.write(data)
		f.close()
	except:
		es_exception()</t>
<t tx="T274">def create (self):

	if 1: # Use distutils to do the work.  This doesn't work with gzip or tar.
		os.system(r"cd C:\prog\leoCVS\leo")
		os.system("python setup.py sdist --formats=zip")

	else: # Problems creating zip file...
		self.createFileLists()
		self.check()
		# self.createDistributionFolders()
		self.createZipFile()
		self.createTarGZFile()</t>
<t tx="T275">def createDir (self, name):

	print "creating", name
	os.mkdir(name)
</t>
<t tx="T276">def createDistributionFolders (self):

	self.folderName = os.path.join(self.distDir,"leo-" + self.ver)
	self.iconsFolderName = os.path.join(self.folderName,"Icons")
	
	self.removeDir(self.iconsFolderName)
	self.removeDir(self.folderName)
	self.createDir(self.folderName)
	self.createDir(self.iconsFolderName)
	
	for f in self.fileList:
		self.copyFile(f,self.leoDir,self.folderName)
		
	for f in self.iconsList:
		self.copyFile(f,self.iconsDir,self.iconsFolderName)
</t>
<t tx="T277">def createFileLists (self):

	# Generate the list of modules.
	files = os.listdir(os.getcwd())
	self.fileList = []
	for f in files:
		head,tail = os.path.split(f)
		root,ext = os.path.splitext(tail)
		if tail[0:3]=="leo" and ext==".py":
			self.fileList.append(root+ext)
			
	for f in self.extraFiles:
		self.fileList.append(f)
			
	self.fileList.sort()
	
	self.iconsList = []
	for f in os.listdir(self.iconsDir):
		head,tail = os.path.split(f)
		root,ext = os.path.splitext(tail)
		if ext.lower() in (".gif","bmp","ico"):
			self.iconsList.append(tail)
	self.iconsList.sort()
			
	self.manifestFiles.extend(self.fileList)
	self.manifestFiles.extend(self.wildcardFiles)
	self.manifestFiles.sort()</t>
<t tx="T278">def createZipFile (self):

	self.zipFileName = os.path.join(
		self.distDir,"leo-" + self.ver + ".zip")

	if os.path.exists(self.zipFileName):
		print "removing: ", self.zipFileName
		os.remove(self.zipFileName)
		
	print "creating", self.zipFileName
	try:
		import zipfile
		z = zipfile.ZipFile(self.zipFileName,"w",zipfile.ZIP_DEFLATED)
		for f in self.fileList:
			f = os.path.join(self.leoDir,f)
			if os.path.isfile(f):
				#print "zipping:",f
				z.write(f,"leo/"+f)
		for f in self.iconsList:
			f = os.path.join(self.iconsDir,f)
			if os.path.isfile(f):
				#print "zipping:",f
				z.write(f,"leo/Icons/"+f)
		z.printdir() 
		z.close()
		print "closed:",self.zipFileName
	except:
		es_exception()</t>
<t tx="T279">def createTarGZFile (self):

	pass</t>
<t tx="T280">def removeDir (self,dir):

	if os.path.exists(dir):
		# Remove all files in folder.
		print "removing: ", dir
		for f in os.listdir(dir):
			os.remove(os.path.join(dir,f))
		os.rmdir(dir)
</t>
<t tx="T281">if 0: # This works, and doesn't seem convenient for Leo's importers.
	try:
		import parser
		import pprint
		path = r"c:\prog\test\importIndentTest.py"
		f = open(path)
		s = f.read()
		f.close()
		ast = parser.suite(s)
		tup = ast.totuple()
		print `ast`
		pprint.pprint(tup)
	except:
		import traceback
		traceback.print_exc()</t>
<t tx="T282"></t>
<t tx="T283"></t>
<t tx="T284">depending on how far ahead LeoN is looking, I think SVN
(http://subversion.tigris.org/) might be a better target than CVS.

It fixes many (most?) CVS shortcomings, and is picking up steam in the
OSS world.

</t>
<t tx="T285"></t>
<t tx="T286"></t>
<t tx="T287"></t>
<t tx="T288"></t>
<t tx="T289">@nocolor</t>
<t tx="T290">@nocolor

Outlook: server for email, addresses &amp; calendar.  Groupware.  Chandler similar.

Zope: back end is ZODB.  Zope like an OS: run Python code on Zope.

Zope: another way to access Leo files.  Maybe twisted is better?

Wiki anology: edit Leo files with browser.  Write through the web.

longrun.org

Wiki principles: 
	- Sharing is 90% of collaboration.
	- Zope: Subscribe to a wiki: email when page changes.
	- RSS: xml that defines piece of info(tile,url,abstract)
		- Client has a list of rss feeds: an xml file.
		- List of intesting people: notified when they say something.

Two goals:
	- publish Leo files
	- edit Leo files

Brother needs cvs.
Kent not so worried about cvs.
	-Leo file is a web site!
	- Helper layer between user and OS.
		- Look at aap project.  Author of vim. a-p.org
			- Replacement for make in Python.  Automating tool.
		- Expert prepares Leo file.  User uses it.</t>
<t tx="T291"></t>
<t tx="T292"></t>
<t tx="T293"></t>
<t tx="T294"></t>
<t tx="T295"></t>
<t tx="T296">Developers Forum
By: rodrigo_b ( Rodrigo Benenson ) 
 RE: Leo over the network   
2003-05-10 00:06  
So this is my first proposal: 

Requirements 
-------------------- 

* Read remote outlines. 
** With Leo clients. 
** Over the web. 

* Edit remote outlines. 

* Import remote outlines (retrieve outlines from the web). 

* Synchronize local outlines with remote ones (web to local and local to web). 

* Publish outlines (send outlines to the web). 

* The Leo client have to be keept lighweigth. 

* The Leo remote outline access server should be a lighweigth daemon. 

* This daemon should automagically render HTML from the outlines. 

* The outlines should be editable from the web and via Leo client. 

* Concurency management is must. 

* The remote servers should be included in the leo client as leo nodes (just like leo files, but remotes). 
"@leo-outline leo.server.org:854" 

* By this way I could have access to local server nodes. 
"@leo-outline localhost:854" 

* The remote server should offer one and only one big outline with sub nodes, and so on, and so on... 

* At least the concurency should be managed as "when someone write, all the other ones only can read" 

* It is better if Leo devellop simultaneaously some hypertext/wiki extensions. 

---------------------------- 
End of requeriments 

This requeriments requires a client-server architecture, with basic commands as: 
- Update node 
- Lock/release node 
- Edit outline 
- Download outline 
- Upload outline 

well that is by the moment, I hope that we will be able to create a Finite, clear, requeriments list for this branch of Leo. 

RodrigoB.  

</t>
<t tx="T297"></t>
<t tx="T298">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007586
By: rodrigo_b

z2.py,
&gt;Supposing that that I did find this file, what would I be looking for? 

This is the Main script, the principal program, the code that startup all the
servers, the only python program that make run Zope, it the code called by start.py,
and it is the one to which you pass the command lines.

With the command line you can indicate which services to start up at which ports.
This is IMPORTANT. Also you can enable/disable the Debug mode.

python z2.py --help will give you some infos about what I'm talking about.

In linux the debug or not debug mode, enable the console or daemon mode (that
means 'background task mode').

In windows, I'm not sure that disabling the debug mode will be enough.
I know that at the install time you can setup Zope as a Windows Service, so
it will start automatically every time Windows Startup, and it will not open
a console window.

But first look at the debug mode.

Start.bat give some defaults command lines to z2.py

Webdav,
&gt;What issues are involved in this choice, and why should I care today? 

from www.webdav.org

What is WebDAV? 
Briefly: WebDAV stands for "Web-based Distributed Authoring and Versioning".
It is a set of extensions to the HTTP protocol which allows users to collaboratively
edit and manage files on remote web servers.

For example that means that you can open you Windows Explorer (from your mail
I understand that you work on an MsWindows OS),
tip the url "localhost:%i"%(your webdav port) and you will be able to navigate,
view and edit the Zope Objects just as a normal file system (well, almost).

WebDav is a standard and there are Python implementations. WebDav is support
by  Oscom.

WebDav is cool.
WebDav is the 'highest level tool'.

ZODB,

&gt;Does that mean that gnx's aren't needed with Zope? Could Leo nodes live in
the ZODB?

You have to thinks to ZODB just as what it is: a Persistent Object Database.
Most objects in Zope are Persistents, that mean that their instances do not
die when you shutdown the server.

The ZODB store his data in it own format.
I think that GNX should be keeped.
You have to basic ways to put nodes into Zope.

First: the hard way: create a new Product (Products are something like Zope
plugins) that is based on the Leo code, but were there is no node storage, instead
the node should be Persistents. Then add rendering code to this objects.

Leo node object + Persistence + ZClass + Rendering Code -&gt; Leo Zope node.

Additionaly you should create an Folder like object that should be an 'Leo Outline
Zope Object',  actuating as an Leo nodes container.

This shema is similar to the Zwiki way, with a Zwiki Web and the Zwiki Pages.

Second: Use A zope folder just as Leo manage the @file nodes. Let have simple
DTMLDocuments, edited via WebDav, with &lt;dtml-comments&gt; , and stuff like that.
The Leo import/export that nodes.

RodrigoB.

</t>
<t tx="T299">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009081
By: ktenney

Edward,

I don't see ZLeo replacing Leo, rather a method of accessing
Leo files.

When I write, I almost always want it to be web accessable,
so that I can access it from any browser, and so that I can
share it easily. I would like myfile.leo to live
at http://longrun.org/leo/myfile.leo. It can be read and
written to from any browser (according to how permissions are
configured) The page describing how to configure Apache would
be found at http://longrun.org/leo/myfile.leo/Apache/configure
The only requirement to work with Leo files is a browser.

I wouldn't want to lose the capability to edit outside
the browser, using a standalone version of Leo or Zope's
ExternalEditor product. ExternalEditor allows me to click
an icon to open the page I'm viewing in any editor. I could
open it in Leo as a Leo file, or open just the page in
Vim (http://vim.sourceforge.net/index.php)

Zope is ponderous, I think of it as more of a platform
than an application. My understanding of how Zope works
grows slowly, in the mean time my focus is on _products_.
Installing a product in Zope is like installing an application
in Windows or Linux.

One of the most evolved products is Plone/CMF http://plone.org
which is basically a turnkey web site.

twisted http://twistedmatrix.com is a brilliant set of network
programming tools. That's all I know about it.

I'm not sure about Chandler (http://www.osafoundation.org/) 
(they did choose Python and ZODB http://www.osafoundation.org/technology.htm)

You might try subscribing to a Zope mailing list or two
http://www.zope.org/Resources/MailingLists
The community of users and developers is very important to Zope.

Thanks,
Kent
</t>
<t tx="T300">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007817
By: rodrigo_b

If zope is running some server then this server will be accesible from your
network if and only if there is no firewall in the way.

The people can access to your services using (normally on internet you do not
have a domain name)

your_ip:the_service_port

Example:
zope http service on port 8080 on your machine.
When  you connect to internet your machine got an extra IP.
Then simple put on the web browser

http://your_conexion_ip:8080

and Tada you will see the root_zope/index_html object rendered intro HTML.

Most of the ISP give you a dinamic IP.
Some companies provides you dinamic IP Domain Name services, allowing to attach
a domain name to your machine dinamically (each time you reconect).

then you can have:

http://leo.edward.com:8080/

The 8080 stuff can be avoied if you setup zope to use the standard port 80 for
HTTP service.

With this in mind you can access ftp

ftp://your_ip_or_domain_name:8021

or webdav, or anything else.
</t>
<t tx="T301">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007832
By: rodrigo_b

I would made a warning.

Zope IT IS NOT the only way to obtain an local HTTP server, pythonic and
flexible.

There is a lot of other way.

Also Zope IT IS NOT THE BEST pythonic http/ftp/webdav or anything server
aviable.

I think that we should define better 

What we want to do?

before choosing the tool.

As I said, I had already used Zope, I choosed it because of very specific features,
but nothing indicate that Zope is the best way to get Leo to the colaborative
network universe.

I think that we should at least consider:
- SimpleHTTPServer
- To take of the Medusa Server from Zope (that is use Zope code in the standard
Leo distribution, avoying dependences)
- Twisted matrix (I had no experience with it, but it looks much more
flexible/powerfull)

Zope provides you a specific framework, you have to match you application to
this framework, Zope (in my opinion) it is not a tool, it's an ambient.

It's seems that Edward it is new in the web oriented software, I think it has
a lot of potencialities and it will benefits Leo devellopment.

Please Edward, look at Zope as an example but not as THE options. Think about
what can be done, what should be done, and then we will take the best tool.

Anyway my opinion:
- SimpleHTTP server: usefull, it is in python, not very eficiente, just http
server....
- Medusa: usefull, very eficiente, just http server...
- Twisted Matrix: very powerfull, fresh comunity, confusing documentation, a
new paradigm, a devellopment tool.
- Zope: powerfull, eficient, comes with battery included, bad documentation,
to very paradigm oriented, the apps have to fit the paradigm, don't believe
all the promises, strong enthousiast comunity, poor web examples.


RodrigoB. 
</t>
<t tx="T302">https://sourceforge.net/forum/message.php?msg_id=2007962
By: bwmulder

Since no one else answered this question, let me take a first take on the
question:

If you are connected to the internet, people can use your IP number to connect
to your computer. This IP number is often given dynamically, though some DSL
providers give you fixed IP numbers for an additional fee. If you did not ask
for fixed IP numbers, you probably have an dynamic IP number (I think).

An IP number consist of four digits. A connection to the (example) IP number
111.222.333.444 can by made via the request http://111.222.333.444

If you have a dynamic IP number, and your Internet provider provides you with
some space to publish HTML, you could, via a script, upload your current IP
number dynamically.

You might also consider buying a domain name. In this case, people can use the
domain name to connect to your computer instead of the IP number.

Another consideration are firewalls. Normally, you want a firewall isolating
your computer from attacks from the Internet. I firewall can be some additional
software. I am currently using a router, a piece of hardware, as a firewall.
Windows XP has firewall software build in. You might have to configure your
firewall to let requests for your server go through.

Finally, you might want to check the agreement you entered with your Internet
service provider, if you are allowed to run a server from your connection. It
might become a problem if your server becomes very popular.
</t>
<t tx="T303">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009279
By: paulpaterson

What I see Zope offering is an alternative way of storing and retrieving nodes.
What you also get for "free" with Zope is concurrent access, security,
http/ftp/webdav access to the same node information etc. The hidden price you
pay is that Zope is big and many users will have other tools which can provide
these facilities also.

So, my thinking is that we can abstract the basic idea (alternative ways of
storing and retrieving node information) into Leo and then let the magic really
happen in the concrete implementation stage.

What does this mean? Well, we could change Leo so that whenever it goes to retrieve
Headline or Body it goes to a Node Server object to do that. The Node Server
object uses whatever method it wants to retrieve or set the information. The
Node server would also be responsible for telling Leo what child nodes an object
has and whether they are clones or not.

The cool part is that we could implement different kinds of Node server to talk
to different back-ends. These can then be thought of as drivers. So we might
have,

- a file system driver where all information is stored in files and directories
- a database driver where the DB stores all information
- an ftp driver
- a Zope driver
- the default Leo driver

People could write a driver to their own back end storage system. 

What is the advantage of this?

Well, the magic really happens in the back-end. If you choose a back end which
supports versioning, security, concurrent working, web access, etc etc then
Leo now supports them. If you choose a back-end which supports dynamic mark-up
or some other fancy stuff then Leo supports it. The key is that Leo doesn't
need to bind itself to any one system to achieve this - the end user can install
the relevant driver, configure the back-end and just go with it.

Paul
</t>
<t tx="T304">Ok, I'll have a bash in a rough order or when things occurred...


1. Everything is web based. I had the same problem you did. I ran the
thing and said, "ok, so what did it do". Others have pointed you in the
right direction now with visiting http://localhost:8080 and
http://localhost:8080/manage to view the site and mange it respectively.

If you are running WinNT, 2000 or XP you can also run Zope as a service,
which is much more convenient as you don't need the console window open
all the time.


2. Everything in Zope is an object. Ok, you'll see this a lot. The best
thing to do is think "wow, cool" and then forget it again as you
probably wont really see how this helps at all until you get much deeper
into Zope. 


3. DTML allows you to construct web pages by piecing together bits much
like writing a program from functions. In fact you will find DTML is a
lot like tangling Leo's @root nodes. Here's a bit...

&lt;!-- start html --&gt;

&lt;h&gt;DTML allows you to assemble web pages much like Leo tangles
documents&lt;/h&gt;

&lt;p&gt;For instance, have a look at how this page is constructed&lt;/p&gt;

&lt;dtml-var first_bit&gt;
&lt;dtml-var second_bit&gt;
&lt;dtml-var third_bit&gt;

&lt;!-- end html --&gt;

The &lt;dtml-var name&gt; bit is like a &lt;&lt; name &gt;&gt; directive. It effectively
inserts the object (could be HTML, an image or something more complex)
in the current page. 

To see this snippet in action you can visit my server at
http://24.243.129.68:8080/members/sandbox/index_html

To see the code, visit http://24.243.129.68:8080/members/sandbox/manage
(username=edream, pwd=leo) and then click on the index_html to see the
main DTML. Feel free to mess around in here but please don't publish the
IP address as my ISP doesn't allow servers!


4. There is a lot of power in Zope products. Try going to www.zope.org
and seeing what is available. As an example I put a Wiki in the sandbox
area http://24.243.129.68:8080/members/sandbox/edswiki


5. If you are looking for a good book to begin with then steer clear of
"The Zope Book"! If you don't mind paying then "The book of Zope" is a
much better introduction. When you have read this then "The Zope Book"
will make some sense but really I found this book tremendously hard to
get through.


6. Web standards are very cool! Zope supports FTP. Point your favourite
FTP tool to,

ftp://24.243.129.68:8021/members/sandbox/

Or try using WebDav by creating a network place pointing to

http://24.243.129.68:8080/members/sandbox

You can then use windows explorer or an ftp tool to browse your objects.


7. Everything is an object! I can't do justice to the concept of
Acquisition here but by the time you have messed around with Zope a bit
you should start to see how acquisition starts to make things really
work like classes in Python. 


I realize this isn't very coherent - if I get a spare moment this
weekend I'll knock up a quick demo showing Leo interacting with Zope.

Regards,

Paul
</t>
<t tx="T305">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2016634
By: jasonic

I have been thinking about LeoZopeWiki integration. I am a recovering Zope addict
[1999-2001] :-)  I believe Zope offers a very valuable client and server for
Leo.

I think Ed higlighted the distinction of collboration vs. sharing. So consdering
that re:  Leo and CVS , Leo and Zope, Leo and wikis, I had another idea this
morning..

LEO+JABBER

Jabber is an open XML-based  instant messaging and *presence* system. Although
Jabber is typically used for IM chat, its core designers have a much bigger
vision in mind.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

CVS etc all depend on runing diff on posted static files which are checked in
or out. Clearly valuable, and good for __sharing__ but not so suitable as the
communication paradigm needed for collboration.

Wikis and Zope all suffer from problem of versioning and the time delay and
lack of timely communications to their cobtributors. There is no 'shared state'
or persistence in the collaboration beyond their own files or objectdatabases.

For example if two people want to edit a wiki or Zope site, they have an imeedaiet
problem of knowing whether or not the someone else is working one it already.

Score:
Sharing 1
Collaboration 0

Two  or more people wanting to edit a common project based on Leo have the same
dilemma. They can check the leo file into a wiki, Zope or CVS, but they still
don't have direct communication at teh content level.

score:
Sharing 1
Collaboration 0

PROPOSAL: LeoJabber
1. Integrate a Jabber client into Leo 
2. Add special Leo module to jabberd [Jabber's server daemon]

Leo-based developers could work in direct communication with each other allowing
them to add, edit and comment nodes in a shared le-space, local or remote. Static
publishing via upload/import etc all still apply.

LeoJabber would mean subscribing developers could immediately be aware of changes
and then apply whatever strategy is appropriate for handling them, such as:
 
a. autoUpdate()
b. makeNewNode()
c. runDiffFunctions()
d. notifyPartners()
e. notifyPublic()
etc..

Jabber via its presencing mechanism offers real-time and just-in time communcations.
If you are logged out, then mesages are queued.

An open Jabber message session is actually one long piece of XML data passed
over an XMLSocket :-) Sounds like a great fit for Leo

- All Jabber configs are XML.
- Good smart open source community.
- Similar open embracing philsophy as Leo
- Jabber connects diverse messaging systems., MSN, AOL etc [Most are
close/proprietary, though the trend is toward greater openness and connectivity]
- Many Jabber clients already. There is even one written in Flash so that any
webpage can participate.

Embedding Jabber in Leo would allow 'discussion' threads to  be integrated.
Developers need to bounce idea and notes around just as this forum does. But
often they need to be more provate or more focused on project specifics.
WORKFLOW 
It is important to know  which code is uptodate, but arguably, even *more* important
is to know which people and what discussions are uptodate. And if not, what
their status is. The larger, longer the more global the develpoment office/project,
the more this is true.

IM [instant messaging] are popular largely becuae they offer direct communication
with status feedback to crucial people's workflow:
"off-line", "on-line", "back-soon", "later" etc

Jabber extends this idea to create a platform for any presence application.
That is its long term-goal.

So in a Leo deevlopment project, that presence might apply to adding status
mesages such as
"making changes" "new version" "debugging" "review only" "major re-write"

or perhaps status/presence woudl be used for much lower level Leo-specific
purposes.

"new node"
"cloned to .."
"@file imported"
"version uploaded"
etc

I am not suggesting that Leo forget CVS or file upload storage. But I think
Jabber may truly provide the Missing Link, literally for Leo collaboration.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

hope this makes sense
Jason
</t>
<t tx="T306">@ignore
@nocolor</t>
<t tx="T307"></t>
<t tx="T308">@ignore</t>
<t tx="T309">@nocolor

- Rename present LeoFrame class to leoTkinterFrame and move it to leoTkinterFrame.py.

- Rename present leoTree class to leoTkinterTree and move it to leoTkinterTree.py.</t>
<t tx="T310"></t>
<t tx="T311"></t>
<t tx="T312">from leoGlobals import *

@others</t>
<t tx="T313">class leoBody:
	
	"""Base class for Leo's body pane.
	Must be subclassed by each gui."""
	
	@others</t>
<t tx="T314">class leoBody:
	
	"""Base class for Leo's main window.
	Must be subclassed by each gui."""
	
	@others</t>
<t tx="T315">class leoLog:
	
	"""Base class for Leo's body pane.
	Must be subclassed by each gui."""
	
	@others</t>
<t tx="T316">@color

C:/prog/leoCVS/leo/src\leoAtFile.py:852: Parameter (root) not used
	# Could be removed
C:/prog/leoCVS/leo/src\leoFileCommands.py:429: Parameter (frame) not used
	# Could be removed
C:/prog/leoCVS/leo/src\leoUndo.py:1012: Parameter (text) not used
	# Will be removed
C:/prog/leoCVS/leo/src\leoUndo.py:1088: Parameter (newNewlines) not used
	# Could be removed</t>
<t tx="T317">Maybe the default should be None...

if encoding is None:
	encoding = app.tkEncoding</t>
<t tx="T318">- remove text argument from undoReplace
	- remove oldText &amp; newText args from setUndoParams.</t>
<t tx="T319">@nocolor

can be done now:

- (done) Make a list of routines to replace calls on c.body.
- Make a list of routines to put in gui base classes.
- (done) Work on design.
- Start work on config plugin.
- Study idle tree code.
- Create generalTree class.

after 4.0 final: make changes:

- Have tkinter gui inject callbacks into vnode class.
- Have guis inject gui ivars into vnode class.
- Replace c.body ivar with abstract routines in the frame class.
- Eliminate all references to frame.top outside of LeoFrame class.

- Create a base menu class to hold gui-independent menu data.
- Maybe: create a baseLeoTree class that contains gui-independent code?

Use utilities to allow code like the matching brackets code to work on Python text rather than Tk.Text:

1. Copy Tk.Text to Python string.
2. Use app.gui.selectionRangeToSliceIndices to set starting point for scan.
3. Modify Python string if necessary.
   For example, when scanning for braces, replace comments with blanks.
4. Do the scan in the Python string, computing result as a slice.
5. Call app.gui.sliceIndicesToSelectionRange to compute gui selection.
6. Call app.gui.setSelection.
</t>
<t tx="T320">As of 10/3/03

There are about 11 work weeks left this year.  I shall be happy (and surprised) if I finish the following:

October:

- 1 week: (done) finish 4.0
- 1 week: fix all bugs
- 1 week: abstract all gui code into leoGui.py
- 1 week: move all data from view classes into commanders.

November &amp; December

- 1 week: Create wxPython gui plugin to test new gui code.
- 1 week: finish Find panel: (must be redesigned for gui project)
- 1-2 weeks: Replace leoConfig.leo with new Settings panel.

Notes:

- Paul Paterson is working on a prototype of a client/server plugins manager.  An ongoing project...
- My work year ends December 20.  I'll be taking about 10 days off for Thanksgiving.</t>
<t tx="T321">This section lists projects for which I would like help and for which it should be possible to work relatively independently.  Please contact me before commencing work on these projects so that we can coordinate our efforts.</t>
<t tx="T322">See the Code/Unit Testing section for the present unit testing code.

This is an ongoing project.  I plan to add unit tests when correcting or rewriting code, and there are large areas of code without any unit tests at all.</t>
<t tx="T323"></t>
<t tx="T324">- Add Settings menu.
	- Create Settings menu dynamically from leoConfig.txt
- Write leoConfig.txt by hand.

- Remove Open LeoConfig.leo command
- Remove Apply Settings command (will be done with apply, cancel, ok, revert buttons in all Settings submenus)</t>
<t tx="T325">@nocolor

It would be an understatement to say that the way Leo handles configuration settings could be improved.  The present scheme involves editing leoConfig.leo, then remembering to save all .leo files before tangling leoConfig.leo.  Moreover, even when doing this properly, not all changes to settings "take" immediately.  Furthermore, there are no easy analogies to the typical "apply" or "revert" or "revert to default" buttons commonly seen in options dialogs.

Last night I studied the way the jEdit editor handles options.  See http://www.jedit.org/
Visually, jEdit's "Global Options" dialogs are very impressive.  There is a tree view on the left, there is a unique panel on the left for each item in the tree view.  All options are set visually.

Something like this could be done in Leo, but actually I like the opening up leoConfig.leo and setting options in a typical Leo window.  The advantage of leoConfig.leo is that there is plenty of room to explain what each setting does.

Leo's Set Colors and Set Font dialogs can and should affect the settings in leoConfig.leo, but at present they only affect leoConfig.txt, which is most annoying, and basically wrong.

This morning I realized that a large part of Leo's difficulties with configuration options stems from me trying to work around the limitations of Python's ConfigParser module.  Relying on this module may be the worst mistake I have made in the Python version of Leo.  This mistake has had several ramifications:

-  leoConfig.leo uses @root trees rather than @file trees because ConfigParser deletes all comments when writing leoConfig.txt.  Suppose instead that Leo would read and write leoConfig.txt without the "help" of the ConfigParser module.  For reading, all that is needed is that Leo parse leoConfig.txt into a single configuration dictionary.  This would, in fact, be very easy to do.

- Leo needs to do a better job of ensuring that leoConfig.txt always matches the settings in effect.  This can be done if Leo can _rewrite_ leoConfig.txt as it was (with all comments and especially sentinel lines), merely substituting new settings for old.  This is only slightly harder to do.

Other improvements come to mind, not directly related to the problems with ConfigParser:

- There should be a separate Settings Menu.  This would have the Set Colors and Set Font commands, as well as the following commands: Edit Settings (Same as present Open leoConfig.leo command) and Use Default Settings command (rewrites leoConfig.txt using preset defaults) and possibly Set Default Settings, Apply Settings and Revert Settings commands.

- All classes that use configuration settings should implement a configure method that immediately updates settings to the values just written to leoConfig.txt.  This includes the commands, frame and tree classes, and others.

With this long background, there are two main approaches to improving how Leo handles options:

1. Use a graphical scheme like jEdit does, and dispense with leoConfig.leo entirely.  leoConfig.txt would be the only repository for options.  This graphical scheme would use typical Apply, Revert, OK and Cancel buttons, much like the present Set Colors and Set Font dialogs.

2. Improve how Leo handles leoConfig.leo and leoConfig.txt so that leoConfig.leo can use @file trees and so that settings are _reliably_ updated when the user would expect them to be.

At present, I favor the second scheme.  It is simple to implement, it is the most Leonine, and moreover it allows for full discussion of all options.  True, the graphical way is good looking, but that is about all it has going for it.  I suppose a help feature could be added to the graphical way, but we are talking about a lot of effort for very little real value to the user.

Actually though, the issues of keeping leoConfig.txt up-to-date and of applying settings immediately remain mostly the same regardless of which way is chosen.  In particular, without the "help" of the ConfigParser module Leo could maintain options much more easily.

Anyway, this is how I see matters.  Any comments?

Edward
</t>
<t tx="T326">I'm not at all sure that it is worthwhile now.</t>
<t tx="T327">@nocolor

&gt; It just leaves still the problem of merging ones personal settings of leoConfig.txt 
with the ones in the new distribution. 

I am going to work on this just after 3.11b1 goes out the door. I think what I shall do is have Leo looks for several different files: first leoConfig.txt, then leoSiteConfig.txt, with the latter overriding the former. That way you can have stable settings (leoSiteConfig.txt won't be part of distributions). 

I may also have Leo look for leoLinuxConfig.txt, leoWinConfig.txt and leoMacConfig.txt, depending on the platform, so you can have stable platform settings as well. </t>
<t tx="T328">@nocolor

By: sanori ( Joo-won Jung ) 
 How about split font config for win and unix?   
2003-02-10 12:02  
Developer Forum

How about split the font's configurations like IDLE, python IDE? 
Because the 10pt size in Windows and Unix (X window, exactly) is not the same. Moreover, the font set that the OS provides does not the same. 

I'm using leo on both windows and Linux, and leo is in the vfat partition to use it both OS. Of course, I can change the font size by using the font dialog. But, I want leo to be more comportable. :)

-Sanori 
</t>
<t tx="T329">Shouldn't this be part of a general-purpose configuration?</t>
<t tx="T330">@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
</t>
<t tx="T331">https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

In the .leo, if I edit &lt;&lt;bar&gt;&gt;, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@+leo
#@+node:0::@file foo.py
#@+body
#@+others
#@+node:1::definition of a
#@+body
print "a:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"bar"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:1::definition of a
#@+node:2::definition of b
#@+body
print "b:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation b"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:2::definition of b
#@+node:3::definition of c
#@+body
print "c:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation c"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:3::definition of c
#@-others
#@-body
#@-node:0::@file foo.py
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
</t>
<t tx="T332">By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

&lt;&lt;&lt;&lt;&lt;&lt;&lt; 
blah blah blah? 
======= 
blah blah blah! 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
</t>
<t tx="T333">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
</t>
<t tx="T334">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
</t>
<t tx="T335"></t>
<t tx="T336">These may indicate problems with Tk on Linux.  I can not reproduce them on XP.</t>
<t tx="T337">(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. </t>
<t tx="T338">When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
</t>
<t tx="T339">This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&amp;aid=605277&amp;group_id=12997&amp;atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
</t>
<t tx="T340">The following bugs can not be fixed because they are Tk bugs.</t>
<t tx="T341">Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
</t>
<t tx="T342">1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.</t>
<t tx="T343"></t>
<t tx="T344">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

</t>
<t tx="T345">Create a Tk demo for each bug.</t>
<t tx="T346">@color</t>
<t tx="T347"># This file creates tk test code for prototyping.
@language tcltk
@others

go</t>
<t tx="T348">proc go {} {
	# createLeo 1
	# createLeo 2
	# createFindPanel
	# createPrefsPanel
	# createColorPanel
	# toplevel .font
	# createFontPanel .font
	# createComparePanel
	# createWindowWithIcon
	# createWindowWithCursor
}
</t>
<t tx="T349">proc createLeo { n } {

	toplevel .leo$n

	# Create two splitters
	createSplitter .leo$n.s 1
	createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
	
	text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

	pack .leo$n.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane2.body -expand yes -fill both

	text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
	
	pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

	# -padx is needed to handle overlap of splitter bar
	text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
	scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
	pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
	
	createMenus $n
}</t>
<t tx="T350">proc createMenus { n } {

	# Create the menu bar
	menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
	# to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
	
	.leo$n configure -menu .leo$n.menu
}</t>
<t tx="T351"></t>
<t tx="T352"># Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
	# verticalFlag, height, width could be params
	frame $w -width 4i -height 3i
	frame $w.pane1
	frame $w.pane2
	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		frame $w.bar -height 7
		place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
		place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
		place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 1"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 1 %y"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 1 %y"
	} else {
		# Panes arranged horizontally; vertical splitter bar
		frame $w.bar -width 7
		place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
		place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
		place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 0"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 0 %x"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 0 %x"
	}
	# Borderwidth required
	$w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
	pack $w -expand yes -fill both
}
</t>
<t tx="T353">proc onGrabSplitterBar {w verticalFlag} {

	# We should change the cursor here.
	
	# Changing the relief is pointless.
		# $w.bar configure -relief sunken
	
	# Changing colors is really bad
		# $w.bar configure -relief sunken -background LightSteelBlue4
		# $w.bar configure -background LightSteelBlue4
}</t>
<t tx="T354">proc onDropSplitterBar {w verticalFlag xy} {

	# We should reset the cursor here.
	$w.bar configure -relief raised -background LightSteelBlue2
}
</t>
<t tx="T355"># xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		set wRoot	[winfo rooty $w]
		set barRoot [winfo rooty $w.bar]
		set wMax	[winfo height $w]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		set wRoot	[winfo rootx $w]
		set barRoot [winfo rootx $w.bar]
		set wMax	[winfo width $w]
	}
	set offset [expr double($barRoot) + $xy - $wRoot ]
	# Adjust the pixels, not the frac.
	if { $offset &lt; 3 } { set offset 3 }
	if { $offset &gt; [expr $wMax - 2] } { set offset [expr $wMax - 2] }
	set frac [ expr double($offset) / $wMax ]
	# This redraws the splitter as the drag is occuring.
	# We could also redraw in onDropSplitterBar for non-dynamic updates.
	divideSplitter $w $verticalFlag $frac
	return $frac ;# No longer used
}</t>
<t tx="T356">proc divideSplitter {w verticalFlag frac} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		place $w.bar -rely $frac
		place $w.pane1 -relheight $frac
		place $w.pane2 -relheight [expr 1 - $frac]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		place $w.bar -relx $frac
		place $w.pane1 -relwidth $frac
		place $w.pane2 -relwidth [expr 1 - $frac]
	}
}</t>
<t tx="T357">proc createFindPanel {} {

	toplevel .find
	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create two columns of checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
}
</t>
<t tx="T358">frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
</t>
<t tx="T359">frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
</t>
<t tx="T360"># Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
</t>
<t tx="T361">proc createPrefsPanel {} {

	toplevel .prefs
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
}</t>
<t tx="T362">frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width &amp; page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
</t>
<t tx="T363"># Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
</t>
<t tx="T364"># Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
</t>
<t tx="T365">proc showColorPicker {} {
	tk_chooseColor
}

proc createColorPanel {} {

	toplevel .color
	wm title .color "Syntax Coloring"

	frame .color.f -bd 2 -relief groove
	pack  .color.f -anchor n -pady 2 -ipady 1 -ipadx 0 -expand 1 -fill x
	
	# label .color.f.lab -text "Choose syntax colors..."
	# pack  .color.f.lab -side top -fill x
	
	frame .color.f.docF -bd 2
	pack  .color.f.docF
	label .color.f.docF.lab -text "Doc parts:" -width 14 -anchor e
	button .color.f.docF.show -text "" -bg "red" -width 4
	button .color.f.docF.set -text "Set..." -command showColorPicker
	pack  .color.f.docF.lab .color.f.docF.show .color.f.docF.set -side left -padx 3
	
	frame .color.f.cF -bd 2
	pack  .color.f.cF
	label .color.f.cF.lab -text "Comments:" -width 14 -anchor e
	button .color.f.cF.show -text "" -bg "red" -width 4
	button .color.f.cF.set -text "Set..." -command showColorPicker
	pack  .color.f.cF.lab .color.f.cF.show .color.f.cF.set -side left -padx 3

	frame .color.f.sF -bd 2
	pack  .color.f.sF
	label .color.f.sF.lab  -text "Strings:" -width 14 -anchor e
	button .color.f.sF.show -bg "green" -width 4
	button .color.f.sF.set -text "Set..." -command showColorPicker
	pack  .color.f.sF.lab .color.f.sF.show .color.f.sF.set -side left -padx 3
	
	frame .color.f.kF -bd 2
	pack  .color.f.kF
	label .color.f.kF.lab  -text "Keywords:" -width 14 -anchor e
	button .color.f.kF.show -bg "blue" -width 4
	button .color.f.kF.set -text "Set..." -command showColorPicker
	pack  .color.f.kF.lab .color.f.kF.show .color.f.kF.set -side left -padx 3
	
	frame .color.f.dF -bd 2
	pack  .color.f.dF
	label .color.f.dF.lab  -text "Directives:" -width 14 -anchor e
	button .color.f.dF.show -bg "blue" -width 4
	button .color.f.dF.set -text "Set..." -command showColorPicker
	pack  .color.f.dF.lab .color.f.dF.show .color.f.dF.set -side left -padx 3

	frame .color.f.snF -bd 2
	pack  .color.f.snF
	label .color.f.snF.lab  -text "Section names:" -width 14 -anchor e
	button .color.f.snF.show -bg "red" -width 4
	button .color.f.snF.set -text "Set..." -command showColorPicker
	pack  .color.f.snF.lab .color.f.snF.show .color.f.snF.set -side left -padx 3

	frame .color.f.unF -bd 2
	pack  .color.f.unF
	label .color.f.unF.lab  -text "Undefined names:" -width 14 -anchor e
	button .color.f.unF.show -bg "orange" -width 4 
	button .color.f.unF.set -text "Set..." -command showColorPicker
	pack  .color.f.unF.lab .color.f.unF.show .color.f.unF.set -side left -padx 3
}</t>
<t tx="T366">proc createFontPanel {w} {

	frame $w.top
	frame $w.size -bd 2 -relief "ridge"
	frame $w.sample -bd 2 -relief "ridge"
	pack $w.top $w.size $w.sample -pady 2 -ipadx 5 -anchor w -fill both
	
	&lt;&lt; create family pane &gt;&gt;
	&lt;&lt; create style pane &gt;&gt;
	&lt;&lt; create buttons &gt;&gt;
	&lt;&lt; create size pane &gt;&gt;
	&lt;&lt; create sample pane &gt;&gt;
}</t>
<t tx="T367">frame $w.top.family -bd 2 -relief "ridge"
label $w.top.family.lab -text "family"
listbox $w.top.family.box
pack $w.top.family.lab $w.top.family.box -anchor w

frame $w.top.style -bd 2 -relief "ridge"
frame $w.top.right -bd 2 -relief "flat"
pack $w.top.family $w.top.style $w.top.right -side left -fill y -padx 2 -pady 2 ; # -ipadx 5 -ipady 5</t>
<t tx="T368">label $w.top.style.lab -text "Style"
pack  $w.top.style.lab -anchor w
foreach {name text} {
	b Bold
	i Italic
	u Underline
	o Overstrike
} {
	checkbutton $w.top.style.$name -text $text
	pack $w.top.style.$name -side top -anchor w -expand 1
}</t>
<t tx="T369">foreach {name text} {
	ok OK
	cancel Cancel
	apply Apply
} {
	button $w.top.right.$name -text $text -width 6
	pack   $w.top.right.$name -side top -anchor w -pady 2m ; # -expand 1
}</t>
<t tx="T370">frame $w.size.left
label $w.size.lab -text "Size"

text  $w.size.text -height 1 -width 4
pack  $w.size.lab -anchor w
pack  $w.size.left -side left
pack  $w.size.text -side left -fill x -expand 1

frame $w.size.left.row1
frame $w.size.left.row2
pack $w.size.left.row1 $w.size.left.row2 -side top

foreach {size} {
	8 12 18
} {
	radiobutton $w.size.left.row1.radio$size -text $size -variable size
	pack $w.size.left.row1.radio$size -side left
}
foreach {size} {
	10 14 24
} {
	radiobutton $w.size.left.row2.radio$size -text $size -variable size
	pack $w.size.left.row2.radio$size -side left
}</t>
<t tx="T371">label $w.sample.lab -text "Sample"
pack  $w.sample.lab -side top -anchor w

label $w.sample.text -text "ABCabcXYZxyz123(may be changed)"

# entry $w.sample.text -background [$w.sample cget -background]
# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"

pack $w.sample.text -side top -anchor c -expand 1 -fill none

# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"
# $w.sample.text configure -state disabled</t>
<t tx="T372">@ Build the font panel (except for the apply button, which is handled by the 'configure_apply procedure...
@c

proc origCreateFontPanel {w} {
	# Framed regions.  Do this with grid and labels, as that seems
	# to be the most effective technique in practise!
	frame $w.border1 -class DKFChooseFontFrame
	frame $w.border2 -class DKFChooseFontFrame
	frame $w.border3 -class DKFChooseFontFrame
	frame $w.border4 -class DKFChooseFontFrame
	set gap [get_gap $w]
	grid $w.border1 -row 0 -column 0 -rowspan 4 -columnspan 4 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border2 -row 0 -column 4 -rowspan 4 -columnspan 3 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border3 -row 4 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border4 -row 7 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	incr gap $gap
	foreach col {0 3 4 6 8} {
		grid columnconfigure $w $col -minsize $gap
	}
	foreach row {0 3 4 6 7 9} {
		grid rowconfigure    $w $row -minsize $gap
	}
	grid columnconfigure $w 1 -weight 1
	grid rowconfigure    $w 1 -weight 1
	grid rowconfigure    $w 8 -weight 1

	# Labels for the framed boxes &amp; focus accelerators for their contents
	foreach {subname row col focusWin} {
		Family 0 1 .family     
		Style  0 5 .style.sBold
		Size   4 1 .size.b8    
		Sample 7 1 .sample.text
	} {
		set l [label $w.lbl$subname]
		grid $l -row $row -column $col -sticky w
		## set accel [get_accel $l]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; [list focus $w$focusWin]
		##}
	}

	# Font families
	frame $w.familyBox
	listbox $w.family -exportsel 0 -selectmode browse \
		-xscrollcommand [list $w.familyX set] \
		-yscrollcommand [list $w.familyY set]
	scrollbar $w.familyX -command [list $w.family xview]
	scrollbar $w.familyY -command [list $w.family yview]
	##foreach family [list_families] {
	##	$w.family insert end ['map 'capitalise $family]
	##}
	grid $w.familyBox -row 1 -column 1 -rowspan 1 -columnspan 2 -sticky nsew
	grid columnconfigure $w.familyBox 0 -weight 1
	grid rowconfigure    $w.familyBox 0 -weight 1
	grid $w.family  $w.familyY -sticky nsew -in $w.familyBox
	grid $w.familyX            -sticky nsew -in $w.familyBox
	## bind $w.family &lt;1&gt; [namespace code {'change_family %W [%W nearest %y]}]
	## bindtags $w.family [concat [bindtags $w.family] key$w.family]
	## bind key$w.family &lt;Key&gt; [namespace code {'change_family %W active %A}]

	# Font styles.
	frame $w.style
	grid $w.style -row 1 -column 5 -sticky news
	grid columnconfigure $w.style 0 -weight 1
	foreach {fontstyle lcstyle row next prev} {
		Bold      bold       0 Italic    {}
		Italic    italic     1 Underline Bold
		Underline underline  2 Strikeout Italic
		Strikeout overstrike 3 {}        Underline
	} {
		set b $w.style.s$fontstyle
		checkbutton $b -variable [namespace current]::Style($lcstyle) \
			-command [namespace code 'set_font]
		grid $b -sticky nsew -row $row
		grid rowconfigure $w.style $row -weight 1
		if {[string length $next]} {
			## bind $b &lt;Down&gt; [list focus $w.style.s$next]
		}
		if {[string length $prev]} {
			## bind $b &lt;Up&gt; [list focus $w.style.s$prev]
		}
		## bind $b &lt;Tab&gt;       "[list focus $w.size.b8];break"
		## bind $b &lt;Shift-Tab&gt; "[list focus $w.family ];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; "focus $b; $b invoke"
		## }
		## bind $b &lt;Return&gt; "$b invoke; break"
	}
	
	# Size adjustment.  Common sizes with radio buttons, and an
	# entry for everything else.
	frame $w.size
	grid $w.size -row 5 -column 1 -rowspan 1 -columnspan 7 -sticky nsew
	foreach {size row col u d l r} {
		8  0 0  {} 10 {} 12
		10 1 0   8 {} {} 14
		12 0 1  {} 14  8 18
		14 1 1  12 {} 10 24
		18 0 2  {} 24 12 {}
		24 1 2  18 {} 14 {}
	} {
		set b $w.size.b$size
		radiobutton $b -variable [namespace current]::Size -value $size \
			-command [namespace code 'set_font]
		grid $b -row $row -column $col -sticky ew
		#grid columnconfigure $w.size $col -weight 1
		## bif {[string length $u]} {bind $b &lt;Up&gt;    [list focus $w.size.b$u]}
		## bif {[string length $d]} {bind $b &lt;Down&gt;  [list focus $w.size.b$d]}
		## bif {[string length $l]} {bind $b &lt;Left&gt;  [list focus $w.size.b$l]}
		## bif {[string length $r]} {bind $b &lt;Right&gt; [list focus $w.size.b$r]}
		## bind $b &lt;Tab&gt;       "[list focus $w.size.entry ];break"
		## bind $b &lt;Shift-Tab&gt; "[list focus $w.style.sBold];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; "focus $b; $b invoke"
		## }
		## bind $b &lt;Return&gt; "$b invoke; break"
	}
	entry $w.size.entry -textvariable [namespace current]::Size
	grid $w.size.entry -row 0 -column 3 -rowspan 2 -sticky ew
	grid columnconfigure $w.size 3 -weight 1
	## bind $w.size.entry &lt;Return&gt; [namespace code {'set_font;break}]
	
	# Sample text.  Note that this is editable
	frame $w.sample
	grid $w.sample -row 8 -column 1 -columnspan 7 -sticky nsew
	grid propagate $w.sample 0
	entry $w.sample.text -background [$w.sample cget -background]
	$w.sample.text insert 0 [option get $w.sample.text text Text]
	grid $w.sample.text
	
	# OK, Cancel and (partially) Apply.  See also 'configure_apply
	frame $w.butnframe
	grid $w.butnframe -row 0 -column 7 -rowspan 4 -columnspan 2 -sticky nsew -pady $gap
	foreach {but code} {
		ok  0
		can 1
	} {
		button $w.butnframe.$but -command [namespace code [list set Done $code]]
		pack   $w.butnframe.$but -side top -fill x -padx [expr {$gap/2}] -pady [expr {$gap/2}]
	}
	button $w.butnframe.apl
	## bind $w.butnframe.ok &lt;Down&gt; [list focus $w.butnframe.can]
	## bind $w.butnframe.can &lt;Up&gt; [list focus $w.butnframe.ok]
}</t>
<t tx="T373"># Convenience proc to get the accelerator for a particular window
# if the user has given one.  Makes it simpler to get this right
# everywhere it is needed...

proc get_accel {w} {
	option get $w accelerator Accelerator
}</t>
<t tx="T374"># Get the gap spacing for the frameboxes.  Use a user-specified
# default if there is one (that is a valid integer) and fall back
# to measuring/guessing otherwise.
proc get_gap {w} {
	set gap [option get $w lineGap LineGap]
	if {[catch {incr gap 0}]} {
		# Some cunning font measuring!
		label $w._testing
		set font [$w._testing cget -font]
		set gap [expr {[font metrics $font -linespace]/2+1}]
		destroy $w._testing
	}
	return $gap
}</t>
<t tx="T375"># Get a sorted lower-case list of all the font families defined on
# the system.  A canonicalisation of [font families]
proc list_families {} {
	lsort [string tolower [font families]]
}
</t>
<t tx="T376"># Path 1: text box
# Path 2: text box

# check: File extension: text box

# Radio buttons:
# 	* print all lines
# 	* print mismatches
# 	* print matches
	
# check: stop after first mismatch
# check: send result to file: text box
# check: generate diffs
# check: ignore whitespace
# check: ignore blank lines

proc createComparePanel {} {

	toplevel .comparePanel
}</t>
<t tx="T377"># apparantly this is a Tk bug on XP.
proc createWindowWithCursor {} {

	toplevel .panel
	text     .panel.text
	.panel.text configure -cursor {gumby red green}
	pack .panel.text
}</t>
<t tx="T378">proc createWindowWithIcon {} {

	global tk_library
	global tcl_patchLevel

	toplevel .panel
	
	# ***** Bitmaps apparently must be only 2 colors.  Photos are everything else!

	# wm iconbitmap .panel [image create photo -file c:/prog/leoCVS/leo/Icons/box00.GIF]
	#wm iconbitmap .panel [image create bitmap -file c:/prog/leoCVS/leo/Icons/box00.bmp]
	
	# no errors, no icon
	#wm iconbitmap .panel [image create bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]]
	# wm iconbitmap .panel @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	
	wm iconbitmap .panel info
	
	# Bitmap image1 not defined
	#wm iconbitmap .panel [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	
	# works
	#label .panel.bitmap -borderwidth 2 -relief sunken -bitmap @[file join $tk_library demos images face.bmp]
	#label .panel.lab -text $tk_library
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ prog leoCVS leo Icons face.bmp]
	
	# works!! (Only GIF allowed?)
	label .panel.lab -borderwidth 2 -relief sunken -image \
		[image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	pack  .panel.lab

	label .panel.lab2 -text $tcl_patchLevel
	pack  .panel.lab2
}</t>
<t tx="T379"># w is the frame to be created.
# This configures w.f to be the content.
# Typically, the user will pack more content into w.f.

proc myFrame {w args} {

	# Args must come in pairs.
    if {([llength $args] % 2) != 0} {
        error {wrong # args: should be "myFrame pathName ?options?"}
    }
	# Initialize the local vars.
    set allopts {} # options that apply everywhere.
    set fopts {} # border options.
    set lopts {} # label options (only for labels that are Tk label widgets)
    set labelanchor nw # The usual default.
    set padx 0
    set pady 0
    set bd 2
    set relief groove
    set labelwindow "" # Can be any Tk widget!
    set text "" # The user usually just sets this.
	# Set vars based on args.
    foreach {opt val} $args {
        switch -- $opt {
            -bd - -borderwidth {
                set bd $val
            }
            -relief {
                set relief $val
            }
            -text {
                lappend lopts $opt $val
                set text $val
            }
            -font - -fg - -foreground {
                lappend lopts $opt $val
            }
            -labelanchor {
                set labelanchor $val
            }
            -labelwindow {
                set labelwindow $val
            }
            -padx {
                set padx $val
            }
            -pady {
                set pady $val
            }
            -bg - -background - -cursor {
                lappend allopts $opt $val
            }
            default {
                error "Unknown or unsupported option: $opt"
            }
        }
    }
	# relief and border options are frame options.
    lappend fopts -relief $relief -bd $bd 
	# Create the frame and its border, w.bd.
    eval frame $w $allopts
    eval frame $w.bd $fopts $allopts
	# Create lw depending on args.
    if {$labelwindow != ""} {
		# Used the window the user passed in.
        set lw $labelwindow
        raise $labelwindow $w
    } elseif {$text != ""} {
        set lw $w.l
		# This is typical.
        eval label $lw $lopts $allopts -highlightthickness 0 -bd 0
    } else {
        set lw ""
    }
	# Create the frame's grid.
    eval frame $w.f $allopts
	# Configure w as a grid with 5 rows and columns:
	# 1 border, 2 pad, 3 w.f, 4 pad, 5 border.
    grid columnconfigure $w {2 4} -minsize $padx
    grid rowconfigure    $w {2 4} -minsize $pady
    grid columnconfigure $w 3     -weight 1
    grid rowconfigure    $w 3     -weight 1
    grid columnconfigure $w {1 5} -minsize $bd
    grid rowconfigure    $w {1 5} -minsize $bd
	# Create the border, w.bd.
    grid $w.bd -row 1 -col 1 -rowspan 5 -columnspan 5 -sticky news
	# Create the content, w.f in the center.
    grid $w.f -row 3 -col 3 -sticky news
	# Optional: configure lw, the label window in the frame.
    if {$lw != ""} {
		# n*, s*, w* and e* are patterns to -glob.
        switch -glob $labelanchor {
            n* {
                grid $lw -in $w -row 0 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            s* {
                grid $lw -in $w -row 5 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            w* {
                grid $lw -in $w -row 2 -col 0 -rowspan 3 -columnspan 2 -pady 4
            }
            e* {
                grid $lw -in $w -row 2 -col 5 -rowspan 3 -columnspan 2 -pady 4
            }
        }
		# set the sticky param to the first character of the labelanchor, i.e., n,s,e or w.
        grid $lw -sticky [string index $labelanchor 1]
    }
}</t>
<t tx="T380">proc makeLeoFrame {} {

	# Create the outer labeld frame (doesn't actually have a label).
	myFrame .f -relief ridge -padx 5 -pady 5
	pack .f -fill both -expand 1 -padx 5 -pady 5
	
	# Initialize the grid positioin.
	set row 0
	set col 0
	# lp is the labelanchor value: 1 or two characters, the first character indicates side.
	foreach lp {nw n ne en e es se s sw ws w wn} {
		set w .f.f.f$lp
		# Create a myFrame: everything after %w are args.
		myFrame $w -text "Hej" -padx 2 -pady 2 -labelanchor $lp
		# Place the frame in the grid.
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
	
	# Create the last row.
	foreach wl {l1 l2 l3} {
		# Create the "special" label w.
		switch $wl {
			l1 {
				label .$wl -text Hej -bd 2 -relief groove
			} 
			l2 {
				checkbutton .$wl -text Hej
			} 
			l3 {
				radiobutton .$wl -text Hej
			}
		} 
		set w .f.f.f$wl
	
		# Create the labled frame using the -labelwindow option.
		myFrame $w -labelwindow .$wl -padx 2 -pady 2 -labelanchor nw
		# Place the labeled frame in the grid
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
}</t>
<t tx="T381"></t>
<t tx="T382"># This file creates tk test code for prototyping.
@language tcltk
@others

bindBug
</t>
<t tx="T383">proc canvasBug {} {
	toplevel .test -bg "blue"
	canvas .test.c -bd 20 -bg "white" -relief "raised"
	pack .test.c -expand 1 -fill "both"
	text .test.c.t -height 1 -background "red"
	pack .test.c.t
	menu .test 
}
</t>
<t tx="T384">proc bindBug {} {

	toplevel .top
	
	text .top.t
	pack .top.t
	
	menu .top.m   -tearoff 0
	menu .top.m.f -tearoff 0
	menu .top.m.e -tearoff 0
	
	.top.m.f add separator
	.top.m.f add command -label "A" -command {""}
	.top.m.f add command -label "B" -command {""}

	.top.m add cascade -label "File" -menu top.m.f -underline 0
	.top.m add cascade -label "Edit" -menu top.m.e -underline 0
	
	.top configure -menu .top.m
}
</t>
<t tx="T385"></t>
<t tx="T386"></t>
<t tx="T387">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1819473
By: nobody

When I create a @file node for a file with an uppercase name like TEST.CPP, by
picking up its name, an empty node is created. On saving the leo file, it
empties the TEST.CPP file!! BAD.

On the other hand, if I key in the filename in the dialog box as 'test.cpp'
(all lowercase) the node is created properly.

Rajiv Bhagwat
</t>
<t tx="T388"></t>
<t tx="T389"></t>
<t tx="T390">It would be great to have script-oriented searching, like icon or snobol.

We could have 3 radio buttons:

plain text
pattern match
script</t>
<t tx="T391"></t>
<t tx="T392">Emacs would have to allow the following:

- Full scripting in Python (embedded Python interpreter)
- The ability to draw the Leo screen.
- Full support for plugins, including alternate gui plugins.</t>
<t tx="T393"></t>
<t tx="T394"></t>
<t tx="T395">@color

from leoGlobals import *

d = app().findFrame.searchInfoDict  # This is all scripts really need!

@

- Extend next match routine to handle script matches?

** so a.findFrame.searchIndoDict is a good way of keeping state info:
	
- Searches will set a.findFrame.searchInfo[v=v,body=body,matchObject=m,sel=sel,direction=dir, etc.]
- Changes will use a.findFrame.searchInfo

Use a Bunch instead of a dict?

self.searchInfo = Bunch(v=v,body=body,matchObject=m,sel=sel,direction=dir)

v = findFrame.searchInfo.v, etc.
</t>
<t tx="T396"></t>
<t tx="T397">Jonathan M. Gilligan</t>
<t tx="T398"></t>
<t tx="T399">@nocolor

- Move all dialog classes into leoGui (?)
- Move dialog utils into leoDialog or leoGui.

_some_ of leoColor is gui related.
	- Several routines could be moved into leoGui.

_all_ of leoDialog is gui related!
_all_ of leoFontPanel is gui related!
_all_ of leoFrame is gui related!
_all_ of leoTree is gui related!

_almost all_ of leoPrefs is gui related!
	- perhaps a few "common" routines could be moved into leoGlobals or leoGui.
	(But would this make the code even more confusing?)

_most_ of leoCompare is gui related!
_most_ of leoFind is gui related!
	In fact, most of the find code uses Tk find.
	There are a few crucial routines that are not gui related.



</t>
<t tx="T400">@nocolor

Most of the code are in the following areas:
	
- Creating special frames, adding to base-special frames.

- Initializing Tk.IntVars, etc for special frames.  Remembering tree bindings for recycling.

- Event handlers for events in special frames.

- Getting and manipulating body text.

- Creating leoMenu.py &amp; leoKey.py would reduce the complexity of leoFrame.py.
</t>
<t tx="T401">def run(fileName=None,*args,**keywords):
	
	"""Initialize and run Leo"""
	
	if not isValidPython(): return
	# Create the application object.
	import leoGlobals
	leoGlobals.gApp = leoApp.LeoApp()
	app.loadDir = computeLoadDir()
	# Initialize the configuration class.
	app.config = leoConfig.config()
	# Load plugins. Plugins may create app.gui.
	doHook("start1")
	if app.killed: return # 10/15/03: allows the plugin to kill the app.
	# Create the default gui if needed.
	if app.gui == None: app.createTkGui()
	# Initialize tracing and statistics.
	init_sherlock(args)
	clear_stats()
	# Create the main frame.  Show it and all queued messages.
	c,frame = createFrame(fileName)
	if not frame: return
	app.writeWaitingLog()
	v = c.currentVnode()
	doHook("start2",c=c,v=v,fileName=fileName)
	frame.commands.redraw()
	app.gui.set_focus(frame.commands,frame.body)
	app.gui.runMainLoop()</t>
<t tx="T402">def isValidPython():
	
	message = """
Leo requires Python 2.1 or higher.
You may download Python 2.1 and Python 2.2 from http://python.org/download/
"""
	try:
		if not CheckVersion(sys.version, "2.1"):
			leoDialog.askOk("Python version error",message=message,text="Exit").run(modal=true)
			return false
		else:
			return true
	except:
		print "exception getting Python version"
		traceback.print_exc()
		return false</t>
<t tx="T403">def computeLoadDir():
	
	"""Returns the directory containing leo.py."""
	
	try:
		import leo
		path = os.path.abspath(leo.__file__)
		if path:
			loadDir = os.path.dirname(path)
		else:
			loadDir = None
		if not loadDir:
			loadDir = os.path.abspath(os.getcwd())
			print "Using emergency loadDir:",`loadDir`
		return loadDir
	except:
		print "Exception getting load directory"
		print traceback.print_exc()
		return None</t>
<t tx="T404">def createFrame (fileName):
	
	"""Create a LeoFrame during Leo's startup process."""
	
	# trace(fileName)
	
	# Try to create a frame for the file.
	if fileName:
		fileName = os.path.join(os.getcwd(),fileName)
		fileName = os.path.normpath(fileName)
		if os.path.exists(fileName):
			ok, frame = openWithFileName(fileName) # 7/13/03: the global routine.
			if ok:
				# print fileName
				return frame.commands,frame
	
	# Create a new frame &amp; indicate it is the startup window.
	c,frame = app.gui.newLeoCommanderAndFrame(fileName=None)
	frame.setInitialWindowGeometry()
	frame.startupWindow = true
	
	# Report the failure to open the file.
	if fileName:
		es("File not found: " + fileName)

	return c,frame</t>
<t tx="T405"></t>
<t tx="T406"></t>
<t tx="T407"></t>
<t tx="T408">def run (self):
	
	c = self.commands ; Tk = Tkinter
	config = app.config
	
	self.top = top = Tk.Toplevel(app.root)
	top.title("Syntax colors for " + shortFileName(c.frame.title))
	top.protocol("WM_DELETE_WINDOW", self.onOk)
	attachLeoIcon(top)

	&lt;&lt; create color panel &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0)
	
	# We are associated with a commander, so
	# There is no need to make this a modal dialog.
	if 0:
		top.grab_set() # Make the dialog a modal dialog.
		top.focus_set() # Get all keystrokes.</t>
<t tx="T409">outer = Tk.Frame(top,bd=2,relief="groove")
outer.pack(anchor="n",pady=2,ipady=1,expand=1,fill="x")

# Create all the rows.
for name,option_name,default_color in colorPanelData:
	# Get the color.
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Create the row.
	f = Tk.Frame(outer,bd=2)
	f.pack()
	
	lab=Tk.Label(f,text=name,width=17,anchor="e")

	b1 = Tk.Button(f,text="",state="disabled",bg=color,width=4)
	self.buttons[name]=b1 # For callback.
	self.option_names[name]=option_name # For callback.
	
	b2 = Tk.Button(f,width=12,text=option_color)
	self.nameButtons[name]=b2
	
	# 9/15/02: Added self=self to remove Python 2.1 warning.
	callback = lambda name=name,self=self:self.showColorPicker(name)
	b3 = Tk.Button(f,text="Color Picker...",command=callback)

	# 9/15/02: Added self=self to remove Python 2.1 warning.
	callback = lambda name=name,color=color,self=self:self.showColorName(name,color)
	b4 = Tk.Button(f,text="Color Name...",command=callback)

	lab.pack(side="left",padx=3)
	b1.pack (side="left",padx=3)
	b2.pack (side="left",padx=3)
	b3.pack (side="left",padx=3)
	b4.pack (side="left",padx=3)
	
# Create the Ok, Cancel &amp; Revert buttons
f = Tk.Frame(outer,bd=2)
f.pack()
b = Tk.Button(f,width=6,text="OK",command=self.onOk)
b.pack(side="left",padx=4)
b = Tk.Button(f,width=6,text="Cancel",command=self.onCancel)
b.pack(side="left",padx=4,expand=1,fill="x")
b = Tk.Button(f,width=6,text="Revert",command=self.onRevert)
b.pack(side="right",padx=4)</t>
<t tx="T410"></t>
<t tx="T411">def run (self,name,color):
	
	assert(name==self.name)
	assert(color==self.color)
	self.revertColor = color
	
	Tk = Tkinter
	self.top = top = Tk.Toplevel(app.root)
	top.title("Color names for " + '"' + name + '"')
	top.protocol("WM_DELETE_WINDOW", self.onOk)

	&lt;&lt; create color name panel &gt;&gt;
	self.select(color)
	
	center_dialog(top) # Do this _after_ building the dialog!
	# top.resizable(0,0)
	
	# This must be a modal dialog.
	top.grab_set()
	top.focus_set() # Get all keystrokes.</t>
<t tx="T412"># Create organizer frames
outer = Tk.Frame(top,bd=2,relief="groove")
outer.pack(fill="both",expand=1)

upper = Tk.Frame(outer)
upper.pack(fill="both",expand=1)

# A kludge to give vertical space to the listbox!
spacer = Tk.Frame(upper) 
spacer.pack(side="right",pady="2i") 

lower = Tk.Frame(outer)
# padx=20 gives more room to the Listbox!
lower.pack(padx=40) # Not expanding centers the buttons.

# Create and populate the listbox.
self.box = box = Tk.Listbox(upper) # height doesn't seem to work.
box.bind("&lt;Double-Button-1&gt;", self.onApply)

if color not in colorNamesList:
	box.insert(0,color)
	
names = list(colorNamesList) # It's actually a tuple.
names.sort()
for name in names:
	box.insert("end",name)

bar = Tk.Scrollbar(box)
bar.pack(side="right", fill="y")
box.pack(padx=2,pady=2,expand=1,fill="both")

bar.config(command=box.yview)
box.config(yscrollcommand=bar.set)
	
# Create the row of buttons.
for text,command in (
	("OK",self.onOk),
	("Cancel",self.onCancel),
	("Revert",self.onRevert),
	("Apply",self.onApply) ):
		
	b = Tk.Button(lower,text=text,command=command)
	b.pack(side="left",pady=6,padx=4)</t>
<t tx="T413"></t>
<t tx="T414"></t>
<t tx="T415">def convertAllBlanks (self):
	
	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	oldText = getAllText(c.body)
	oldSel = getTextSelection(c.body)
	count = 0
	while v and v != next:
		if v == current:
			if c.convertBlanks(setUndoParams=false):
				count += 1
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			assert(isUnicode(text))
			lines = string.split(text, '\n')
			for line in lines:
				s = optimizeLeadingWhitespace(line,tabWidth)
				if s != line:
					changed = true ; count += 1
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if count &gt; 0:
		newText = getAllText(c.body)
		newSel = getTextSelection(c.body)
		c.undoer.setUndoParams("Convert All Blanks",
			current,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	es("blanks converted to tabs in %d nodes" % count)</t>
<t tx="T416">def convertAllTabs (self):

	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	oldText = getAllText(c.body)
	oldSel = getTextSelection(c.body)
	count = 0
	while v and v != next:
		if v == current:
			if self.convertTabs(setUndoParams=false):
				count += 1
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			assert(isUnicode(text))
			lines = string.split(text, '\n')
			for line in lines:
				i,w = skip_leading_ws_with_indent(line,0,tabWidth)
				s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
				if s != line:
					changed = true ; count += 1
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if count &gt; 0:
		newText = getAllText(c.body)
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Convert All Tabs",
			current,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	es("tabs converted to blanks in %d nodes" % count)</t>
<t tx="T417">def convertBlanks (self,setUndoParams=true):

	c = self
	head,lines,tail,oldSel,oldYview = c.getBodyLines()
	result = [] ; changed = false

	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			s = optimizeLeadingWhitespace(line,c.tab_width)
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use relative @tabwidth (tabWidth)
		for line in lines:
			s = optimizeLeadingWhitespace(line,tabWidth)
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		undoType = choose(setUndoParams,"Convert Blanks",None)
		c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")
		
	return changed
</t>
<t tx="T418">def convertTabs (self,setUndoParams=true):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	
	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,c.tab_width)
			s = computeLeadingWhitespace(w,-abs(c.tab_width)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use the relative @tabwidth (tabWidth)
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,tabWidth)
			s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		undoType = choose(setUndoParams,"Convert Tabs",None)
		c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")
		
	return changed</t>
<t tx="T419">def createLastChildNode (self,parent,headline,body):
	
	c = self
	if body and len(body) &gt; 0:
		body = string.rstrip(body)
	if not body or len(body) == 0:
		body = ""
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	v.t.setTnodeText(body)
	v.createDependents() # To handle effects of clones.
	v.setDirty()
	c.validateOutline()</t>
<t tx="T420">def dedentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width-abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Undent",oldSel,oldYview)</t>
<t tx="T421">def extract(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	oldText = getAllText(c.body)
	oldSel = getTextSelection(c.body)
	&lt;&lt; Set headline for extract &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	if 1: # update range...
		c.createLastChildNode(v,headline,body)
		undoType =  "Can't Undo" # 12/8/02: None enables further undoes, but there are bugs now.
		c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview)
		newText = getAllText(c.body)
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Extract",
			v,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	c.endUpdate()</t>
<t tx="T422">headline = string.strip(headline)
while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)</t>
<t tx="T423">def extractSection(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	line1 = "\n" + headline
	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	# trace("v:     " + `v`)
	# trace("v_copy:" + `v_copy`)
	oldText = getAllText(c.body)
	oldSel = getTextSelection(c.body)
	&lt;&lt; Set headline for extractSection &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	if 1: # update range...
		c.createLastChildNode(v,headline,body)
		undoType = None # Set undo params later.
		c.updateBodyPane(head,line1,tail,undoType,oldSel,oldYview)
		newText = getAllText(c.body)
		newSel = getTextSelection(c.body)
		c.undoer.setUndoParams("Extract Section",v,
			select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	c.endUpdate()</t>
<t tx="T424">while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)

# Make sure we have a @&lt; or &lt;&lt;
if headline[0:2] != '&lt;&lt;' and headline[0:2] != '@&lt;':
	es("Selected text should start with a section name",color="blue")
	return</t>
<t tx="T425">def extractSectionNames(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	# No change to body or selection of this node.
	oldText = newText = getAllText(c.body)
	i, j = oldSel = newSel = self.getBodySelection()
	c.beginUpdate()
	if 1: # update range...
		found = false
		for s in lines:
			&lt;&lt; Find the next section name &gt;&gt;
			if name:
				self.createLastChildNode(v,name,None)
				found = true
		c.selectVnode(v)
		c.validateOutline()
		if not found:
			es("Selected text should contain one or more section names",color="blue")
	c.endUpdate()
	# No change to body or selection
	c.undoer.setUndoParams("Extract Names",
		v,select=current,oldTree=v_copy,
		oldText=oldText,newText=newText,
		oldSel=oldSel,newSel=newSel)
	# Restore the selection.
	setTextSelection(c.body,i,j)
	set_focus(c,c.body)</t>
<t tx="T426">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
	head2 = string.find(s,"&gt;&gt;",head1)
else:
	head1 = string.find(s,"@&lt;")
	if head1 &gt; -1:
		head2 = string.find(s,"@&gt;",head1)
		
if head1 == -1 or head2 == -1 or head1 &gt; head2:
	name = None
else:
	name = s[head1:head2+2]</t>
<t tx="T427">def getBodyLines (self):
	
	c = self
	oldYview = c.frame.body.yview()
	i, j = oldSel = getTextSelection(c.body)
	# if selection was made from back to front, then i and j are reversed
	if i and j and i != j: # 7/7/03
		# Convert all lines containing any part of the selection.
		if c.body.compare(i,"&gt;",j): i,j = j,i
		i = c.body.index(i + "linestart")
		# 12-SEP-2002 DTHEIN: don't include following line in selection
		endSel = j # position of last character of selection
		trailingNewline = ""
		line,col = j.split(".")
		if col == "0":  # DTHEIN: selection ends at start of next line
			endSel = c.body.index(j + "- 1 chars")
			trailingNewline = '\n'
		else: # DTHEIN: selection ends in the midst of a line
			endSel = c.body.index(j + "lineend")
			j = endSel
		head = c.body.get("1.0",i)
		head = toUnicode(head,app.tkEncoding) # 9/28/03
		tail = c.body.get(j,"end")
		tail = toUnicode(tail,app.tkEncoding) # 9/28/03
	else: # Convert the entire text.
		i = "1.0" ; j = "end" ; head = tail = ""
		endSel = c.body.index(j + "- 1 chars") # 14-SEP-2002 DTHEIN
		trailingNewline = ""
	if i == endSel:
		head = tail = None ; lines = []
	else:
		lines = c.body.get(i,endSel)
		lines = toUnicode(lines,app.tkEncoding) # 9/28/03
		lines = string.split(lines, '\n')
		lines[-1] += trailingNewline # DTHEIN: add newline if needed
	return head,lines,tail,oldSel,oldYview</t>
<t tx="T428">def getBodySelection (self):

	c = self
	i, j = getTextSelection(c.body)
	if i and j and c.body.compare(i,"&gt;",j):
		i,j = j,i
	return i, j</t>
<t tx="T429">def indentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width+abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Indent",oldSel,oldYview)</t>
<t tx="T430">def reformatParagraph(self):
	"""Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting.
Leading tabs are sized to present tab width setting.
First and second line of original text is used to determine leading whitespace
in reformatted text.  Hanging indentation is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@".  Paragraph is selected by position of current insertion
cursor."""

	c = self ; body = c.frame.body
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = []

	dict = scanDirectives(c)
	pageWidth = dict.get("pagewidth")
	tabWidth  = dict.get("tabwidth")
	# trace(`tabWidth`+","+`pageWidth`)

	# If active selection, then don't attempt a reformat.
	selStart, selEnd = getTextSelection(body)
	if selStart != selEnd: return

	# Find the paragraph range.
	data = bound_paragraph(body)
	if data:
		start, end, endsWithNL = data
		firstLine = int(float(start)) - 1 # subtract 1 to get on zero basis
		lastLine = int(float(end)) - 1
	else: return
	
	# Compute the leading whitespace.
	indents = [0,0] ; leading_ws = ["",""] # Bug fix: 11/16/02
	for i in (0,1):
		if firstLine + i &lt; len(lines):
			# Use the original, non-optimized leading whitespace.
			leading_ws[i] = ws = get_leading_ws(lines[firstLine+i])
			indents[i] = computeWidth(ws,tabWidth)
	indents[1] = max(indents)
	# 11/17/02: Bug fix suggested by D.T.Hein.
	if 1 == (lastLine - firstLine):
		leading_ws[1] = leading_ws[0]

	# Put the leading unchanged lines.
	for i in range(0,firstLine):
		result.append(lines[i])
		
	# Wrap the lines, decreasing the page width by indent.
	wrapped_lines = wrap_lines(
		lines[firstLine:lastLine],
		pageWidth-indents[1],
		pageWidth-indents[0])
	lineCount = len(wrapped_lines)
		
	i = 0
	for line in wrapped_lines:
		result.append(leading_ws[i] + line)
		if i &lt; 1: i += 1

	# Put the trailing unchanged lines.
	for i in range(lastLine,len(lines)):
		result.append(lines[i])

	# Replace the text if it changed.
	for i in range(firstLine,lineCount+firstLine):
		if i &gt;= lastLine or lines[i] != result[i]:
			result = string.join(result,'\n')
			c.updateBodyPane(head,result,tail,"Reformat Paragraph",oldSel,oldYview) # Handles undo
			break

	&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;

	# Make sure we can see the new cursor.
	body.see("insert-5l")
</t>
<t tx="T431">lastLine = firstLine + lineCount
if not endsWithNL:
	insPos = str(lastLine) + ".0lineend"
else:
	endPos = body.index("end")
	endLine = int(float(endPos))
	lastLine += 1
	insPos = str(lastLine) + ".0"
	while lastLine &lt; endLine:
		s = body.get(insPos,insPos + "lineend")
		s = toUnicode(s,app.tkEncoding) # 9/28/03
		if s and (0 &lt; len(s)) and not s.isspace():
			break;
		lastLine += 1
		insPos = str(lastLine) + ".0"
setTextSelection(body,insPos,insPos)</t>
<t tx="T432">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):
	
	c = self ; v = c.currentVnode()
	# trace(v)
	# Update the text and set start, end.
	c.body.delete("1.0","end")
	# The caller must do rstrip.head if appropriate.
	if head and len(head) &gt; 0:
		c.body.insert("end",head)
		start = c.body.index("end-1c")
	else: start = "1.0"
	if middle and len(middle) &gt; 0:
		c.body.insert("end",middle)
		end = c.body.index("end-1c")
	else: end = start
	if tail and len(tail) &gt; 0:
		tail = string.rstrip(tail)
	if tail and len(tail) &gt; 0:
		c.body.insert("end",tail)
	# Activate the body key handler by hand.
	c.frame.onBodyChanged(v,undoType,oldSel=oldSel,oldYview=oldYview)
	# Update the changed mark.
	if not c.isChanged():
		c.setChanged(true)
	# Update the icon.
	c.beginUpdate()
	if not v.isDirty():
		v.setDirty()
	c.endUpdate()
	# Update the selection.
	# trace(`start` + "," + `end`)
	setTextSelection(c.body,start,end)
	if oldYview:
		first,last=oldYview
		c.body.yview("moveto",first)
	else:
		c.body.see("insert")
	set_focus(c,c.body)
	c.recolor() # 7/5/02</t>
<t tx="T433"></t>
<t tx="T434">def __init__ (self,c,cmp):

	Tk = Tkinter
	self.commands = c
	self.cmp = cmp
	
	# Ivars pointing to Tk elements.
	self.browseEntries = []
	self.extensionEntry = None
	self.countEntry = None
	self.printButtons = []
	
	# No corresponding cmp ivar.
	self.useOutputFileVar = Tk.IntVar()
	
	# These all correspond to ivars in leoCompare.
	self.appendOutputVar             = Tk.IntVar()

	self.ignoreBlankLinesVar         = Tk.IntVar()
	self.ignoreFirstLine1Var         = Tk.IntVar()
	self.ignoreFirstLine2Var         = Tk.IntVar()
	self.ignoreInteriorWhitespaceVar = Tk.IntVar()
	self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
	self.ignoreSentinelLinesVar      = Tk.IntVar()

	self.limitToExtensionVar         = Tk.IntVar()
	self.makeWhitespaceVisibleVar    = Tk.IntVar()
	
	self.printBothMatchesVar         = Tk.IntVar()
	self.printMatchesVar             = Tk.IntVar()
	self.printMismatchesVar          = Tk.IntVar()
	self.printTrailingMismatchesVar  = Tk.IntVar()
	self.stopAfterMismatchVar        = Tk.IntVar()
	
	# These ivars are set from Entry widgets.
	self.limitCount = 0
	self.limitToExtension = None 
	if 0: # we just use the cmp ivars.
		self.pathName1 = None
		self.pathName2 = None
		self.outputFileName = None
	
	# The default file name in the "output file name" browsers.
	self.defaultOutputFileName = "CompareResults.txt"</t>
<t tx="T435">def run (self):

	Tk = Tkinter
	self.top = top = Tk.Toplevel(app.root)
	top.title("Leo Compare files and directories")
	top.protocol("WM_DELETE_WINDOW", self.onClose)
	&lt;&lt; create the organizer frames &gt;&gt;
	&lt;&lt; create the browser rows &gt;&gt;
	&lt;&lt; create the extension row &gt;&gt;
	&lt;&lt; create the whitespace options frame &gt;&gt;
	&lt;&lt; create the print options frame &gt;&gt;
	&lt;&lt; create the compare buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0)
	self.finishCreate()</t>
<t tx="T436">outer = Tk.Frame(top, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="T437">for row,text,text2,command,var in (
	(row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
	(row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
	(row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

	lab = Tk.Label(row,anchor="e",text=text,width=13)
	lab.pack(side="left",padx=4)
	
	e = Tk.Entry(row)
	e.pack(side="left",padx=2)
	self.browseEntries.append(e)
	
	b = Tk.Button(row,text="browse...",command=command)
	b.pack(side="left",padx=6)

	b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
	b.pack(side="left")</t>
<t tx="T438">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
	text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
	text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="T439">w,f = create_labeled_frame(ws,caption="Whitespace options",relief="groove")
	
for text,var in (
	("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
	("Ignore blank lines",        self.ignoreBlankLinesVar),
	("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
	("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
	("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w")
	
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T440">w,f = create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
	(0,  "Print matched lines",           self.printMatchesVar),
	(20, "Show both matching lines",      self.printBothMatchesVar),
	(0,  "Print mismatched lines",        self.printMismatchesVar),
	(0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w",padx=padx)
	self.printButtons.append(b)
	
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T441">for text,command in (
	("Compare files",      self.onCompareFiles),
	("Compare directories",self.onCompareDirectories) ):
	
	b = Tk.Button(lower,text=text,command=command,width=18)
	b.pack(side="left",padx=6)</t>
<t tx="T442"></t>
<t tx="T443">class baseLeoDialog:
	"""The base class for all Leo dialogs"""
	@others
	
class leoDialog (baseLeoDialog):
	"""A base class for all Leo dialogs that may be overridden by plugins."""
	pass
</t>
<t tx="T444">def __init__(self,title="",resizeable=true):
	
	"""Constructor for base leoDialog class."""
	
	self.answer = None # Value returned from run()
	self.resizeable = resizeable
	self.title = title
	self.modal = None
	
	self.buttonsFrame = None # Frame to hold typical dialog buttons.
	self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
	self.frame = None # The outermost frame in self.top.
	self.root = None # app.root
	self.top = None # The toplevel Tk widget.
	self.focus_widget = None # The widget to get the first focus.</t>
<t tx="T445">def cancelButton(self):
	
	"""Do default click action in cancel button."""
	
	self.answer="cancel"
	self.top.destroy()
	
def noButton(self):
	
	"""Do default click action in no button."""
	
	self.answer="no"
	self.top.destroy()
	
def okButton(self):
	
	"""Do default click action in ok button."""
	
	self.answer="ok"
	self.top.destroy()

def yesButton(self):
	
	"""Do default click action in yes button."""

	self.answer="yes"
	self.top.destroy()</t>
<t tx="T446">def center(self):
	
	"""Center any leoDialog."""
	
	center_dialog(self.top)
</t>
<t tx="T447">def createButtons (self,buttons):
	
	"""Create a row of buttons.
	
	buttons is a list of dictionaries containing the properties of each button."""
	
	assert(self.frame)
	self.buttonsFrame = f = Tk.Frame(self.top)
	f.pack(side="top",padx=30)

	# Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
	buttonList = []
	for d in buttons:
		text = d.get("text","&lt;missing button name&gt;")
		isDefault = d.get("default",false)
		underline = d.get("underline",0)
		command = d.get("command",None)
		bd = choose(isDefault,4,2)

		b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
		b.pack(side="left",padx=5,pady=10)
		buttonList.append(b)
		
		if isDefault and command:
			self.defaultButtonCommand = command
		
	return buttonList</t>
<t tx="T448">def createMessageFrame (self,message):
	
	"""Create a frame containing a Tk.Label widget."""

	label = Tk.Label(self.frame,text=message)
	label.pack(pady=10)
</t>
<t tx="T449">def createTopFrame(self):
	
	"""Create the Tk.Toplevel widget for a leoDialog."""
	
	self.root = app.root

	self.top = Tk.Toplevel(self.root)
	attachLeoIcon(self.top)

	self.top.title(self.title)

	if not self.resizeable:
		self.top.resizable(0,0) # neither height or width is resizable.

	self.frame = Tk.Frame(self.top)
	self.frame.pack(side="top",expand=1,fill="both")</t>
<t tx="T450">def run (self,modal):
	
	"""Run a leoDialog."""

	self.modal = modal
	
	self.center() # Do this after all packing complete.

	if self.modal:
		self.top.grab_set() # Make the dialog a modal dialog.
		if self.focus_widget == None:
			self.focus_widget = self.top
		self.focus_widget.focus_set() # Get all keystrokes.	
		self.root.wait_window(self.top)
		return self.answer
	else:
		self.root.wait_window(self.top)
		return None</t>
<t tx="T451"></t>
<t tx="T452"></t>
<t tx="T453">def __init__(self):
	
	leoFindBase.__init__(self,"Leo Find/Change",resizeable=false)

	&lt;&lt; Initialize the leoFind ivars &gt;&gt;
	
	self.createFrame()</t>
<t tx="T454">self.dict = {}

# Order is important for compatibility with 3.x.  Sheesh.
self.intKeys = [
	"batch", "wrap", "whole_word", "ignore_case", "node_only",
	"pattern_match", "search_headline", "search_body",
	"suboutline_only", "mark_changes", "mark_finds", "reverse"]
self.newIntKeys = ["script_change"]
self.newStringKeys = ["radio-find-type", "radio-search-scope"]
# self.stringKeys = ["change_text","find_text"]

for key in self.intKeys:
	self.dict[key] = Tk.IntVar()
for key in self.newIntKeys:
	self.dict[key] = Tk.IntVar()
for key in self.newStringKeys:
	self.dict[key] = Tk.StringVar()
	
# The c.x_flag ivars contain the user preferences.
# These are updated just before executing any find/change command.

# Ivars containing internal state...
self.commands = None # The commander for this search.
self.v = None # The vnode being searched.  Never saved between searches!
self.in_headline = false # true: searching headline text.
self.wrapping = false # true: wrapping is enabled. _not_ the same as c.wrap_flag for batch searches.
self.s_text = Tk.Text() # Used by find.search()

@ Initializing a wrapped search is tricky.  The search() method will fail if v==wrapVnode and pos &gt;= wrapPos.  selectNextVnode() will fail if v == wrapVnode.  We set wrapPos on entry, before the first search.  We set wrapVnode in selectNextVnode after the first search fails.  We also set wrapVnode on exit if the first search suceeds.
@c
self.wrapVnode = None # The start of wrapped searches: persists between calls.
self.onlyVnode = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.</t>
<t tx="T455">def createFrame (self):
	
	# Create the find panel...
	outer = Tk.Frame(self.frame,relief="groove",bd=2)
	outer.pack(padx=2,pady=2)

	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
	
	self.find_text.bind  ("&lt;1&gt;", self.resetWrap)
	self.change_text.bind("&lt;1&gt;", self.resetWrap)
	self.find_text.bind  ("&lt;Key&gt;", self.resetWrap)
	self.change_text.bind("&lt;Key&gt;", self.resetWrap)
</t>
<t tx="T456">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7m",pady="2m") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
	columns.append(Tk.Frame(columnsFrame,bd=1))
	radioLists.append([])
	checkLists.append([])

for i in xrange(numberOfColumns):
	columns[i].pack(side="left",padx="1m") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
	(self.dict["radio-find-type"],"Plain Search","plain-search"),  
	(self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
	(self.dict["radio-find-type"],"Script Search",None)] #"script-search")]
checkLists[0] = [
	("Script Change",None)] # self.dict["script_change"]),]
checkLists[1] = [
	("Whole Word",  self.dict["whole_word"]),
	("Ignore Case", self.dict["ignore_case"]),
	("Wrap Around", self.dict["wrap"]),
	("Reverse",     self.dict["reverse"])]
radioLists[2] = [
	(self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
	(self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
	(self.dict["radio-search-scope"],"Node Only","snode-only"),           
	(self.dict["radio-search-scope"],"Selection Only",None)] # "selected-text-only")]
checkLists[2] = []
checkLists[3] = [
	("Search Headline Text", self.dict["search_headline"]),
	("Search Body Text",     self.dict["search_body"]),
	("Mark Finds",           self.dict["mark_finds"]),
	("Mark Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
	for var,name,val in radioLists[i]:
		box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
		box.pack(fill="x")
		box.bind("&lt;1&gt;", self.resetWrap)
		if val == None: box.configure(state="disabled")
	for name, var in checkLists[i]:
		box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
		box.pack(fill="x")
		box.bind("&lt;1&gt;", self.resetWrap)
		if var == None: box.configure(state="disabled")</t>
<t tx="T457">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_text   = ftxt = Tk.Text(fpane, height=10, width=80)
self.change_text = ctxt = Tk.Text(cpane, height=10, width=80)

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
	txt['yscrollcommand'] = bar.set
	bar['command'] = txt.yview
	bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="T458"># Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# Create the first row of buttons
findButton=Tk.Button(buttons,width=8,text="Find",command=self.findButton)
contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)

findButton.pack   (pady="1m",padx="25m",side="left")
contextBox.pack   (pady="1m",          side="left",expand=1)
findAllButton.pack(pady="1m",padx="25m",side="right",fill="x",)

# Create the second row of buttons
changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)

changeButton.pack    (pady="1m",padx="25m",side="left")
changeFindButton.pack(pady="1m",          side="left",expand=1)
changeAllButton.pack (pady="1m",padx="25m",side="right")</t>
<t tx="T459"></t>
<t tx="T460"></t>
<t tx="T461">def __init__ (self,c):
	
	Tk = Tkinter
	self.commands = c
	self.frame = c.frame
	self.default_font = "Courier"
	self.last_selected_font = None
	self.setRevertVars()
	# Variables to track values of style checkboxes.
	self.sizeVar = Tk.IntVar()
	self.boldVar = Tk.IntVar()
	self.italVar = Tk.IntVar()
	# Variables to track values of pane checkboxes.
	self.bodyVar = Tk.IntVar()
	self.logVar = Tk.IntVar()
	self.treeVar = Tk.IntVar()
	# Slots for callbacks
	self.listBoxIndex = 0
	self.family_list_box = None
	self.size_entry = None
	self.example_entry = None
	self.outer = None</t>
<t tx="T462">def create_outer(self):

	Tk = Tkinter
	top = self.top
	&lt;&lt; Create the organizer frames &gt;&gt;
	&lt;&lt; create the font pane &gt;&gt;
	&lt;&lt; create the checkboxes &gt;&gt;
	&lt;&lt; create the buttons &gt;&gt;</t>
<t tx="T463">self.outer = outer = Tk.Frame(top,bd=2,relief="groove",width="8i")
outer.pack(padx=2,pady=2,expand=1,fill="both")

upper = Tk.Frame(outer)
upper.pack(fill="both",expand=1)

lt = Tk.Frame(upper)
lt.pack(side="left",fill="both",expand=1)

rt = Tk.Frame(upper)
rt.pack(side="right",anchor="n",padx=4) # Not filling or expanding centers contents.

# Not filling or expanding centers contents.
# padx=20 gives more room to the Listbox in the lt frame!
lower = Tk.Frame(outer)
lower.pack(side="top",anchor="w",padx=20)</t>
<t tx="T464"># Create the list box and its scrollbar.
self.family_list_box = box = Tk.Listbox(lt,height=7)

# Fill the listbox to set the width.
names = tkFont.families()
names = list(names)
names.sort()
for name in names:
	box.insert("end", name)

box.pack(padx=4,pady=4,fill="both",expand=1)
box.bind("&lt;Double-Button-1&gt;", self.update)

bar = Tk.Scrollbar(box)
bar.pack(side="right", fill="y")

bar.config(command=box.yview)
box.config(yscrollcommand=bar.set)</t>
<t tx="T465"># Create the style checkboxes.
for text,var in (
	("Bold",self.boldVar),
	("Italic",self.italVar)):

	b = Tk.Checkbutton(rt,text=text,variable=var)
	b.pack(side="top",anchor="w")

# Create the size label and entry widget.
row = Tk.Frame(rt)
row.pack(side="top")

lab = Tk.Label(row,text="Size:")
lab.pack(side="left")

self.size_entry = e = Tk.Entry(row,width=4)
e.pack(side="left")
e.bind("&lt;Key&gt;",self.onSizeEntryKey)

# Create the pane checkboxes.
for text,var in (
	("Body",   self.bodyVar),
	("Outline",self.treeVar,),
	("Log",    self.logVar)):

	b = Tk.Checkbutton(rt,text=text,variable=var)
	b.pack(side="top",anchor="w")</t>
<t tx="T466">for name,command in (
	("Apply",self.onApply),
	("OK",self.onOk),
	("Cancel",self.onCancel),
	("Revert",self.onRevert)):
		
	b = Tk.Button(lower,width=7,text=name,command=command)
	b.pack(side="left",anchor="w",pady=6,padx=4,expand=0)</t>
<t tx="T467">def finishCreate (self):
	
	# self.commands.frame.top.resizable(0,0)
	
	# These do not get changed when reverted.
	self.bodyVar.set(1)
	self.logVar.set(0)
	self.treeVar.set(0)
	
	# All other vars do change when reverted.
	self.revertIvars()
	self.update()</t>
<t tx="T468"></t>
<t tx="T469">@ Returns a font corresponding to present visual state of the font panel.  As a benign side effect, this routine selects the font in the list box.

Alas, the selection in the list box may have been cleared.  In that case, we must figure out what it should be. We recreate the family name (and only the family name!) from self.last_selected_font, or in an emergency the font returned from getImpliedFont().
@c

def getActiveFont (self):

	box = self.family_list_box
	family = font = None

	# Get the family name if possible, or font otherwise.
	items = box.curselection()
	if len(items) == 0:
		# Nothing selected.
		if self.last_selected_font:
			font =self.last_selected_font
		else:
			font = self.getImpliedFont()
	else:
		try: # This shouldn't fail now.
			items = map(int, items)
			family = box.get(items[0])
		except:
			es("unexpected exception")
			es_exception()
			font = self.getImpliedFont()
	# At this point we either have family or font.
	assert(font or family)
	if not family:
		# Extract the family from the computed font.
		family,junk,junk,junk = self.getFontSettings(font)
	# At last we have a valid family name!
	# Get all other font settings from the font panel.
	bold = self.boldVar.get()
	ital = self.italVar.get()
	size = self.sizeVar.get()
	# trace(`size`)
	slant=choose(ital,"italic","roman")
	weight=choose(bold,"bold","normal")
	# Compute the font from all the settings.
	font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
	self.selectFont(font)
	return font</t>
<t tx="T470">def getFontSettings (self, font):

	name   = font.cget("family")
	size   = font.cget("size")
	slant  = font.cget("slant")
	weight = font.cget("weight")

	return name, size, slant, weight</t>
<t tx="T471"># If a single pane's checkbox is checked, select that pane's present font.
# Otherwise, select the present font of some checked pane, it doesn't much matter which.
# If none are check, select the body pane's present font.

def getImpliedFont (self):

	c = self.commands

	body = self.bodyVar.get()
	log  = self.logVar.get()
	tree = self.treeVar.get()
	
	fn = c.body.cget("font")
	bodyFont = tkFont.Font(font=fn)
	fn = c.log.cget("font")
	logFont = tkFont.Font(font=fn)
	treeFont = c.frame.getFont()
	
	if log and not body and not tree:
		font = logFont
	elif tree and not body and not log:
		font = treeFont
	elif body: font = bodyFont
	elif tree: font = treeFont
	elif log:  font = logFont # Exercise for the reader: prove this case will never happen.
	else:      font = bodyFont
	return font</t>
<t tx="T472">def hide (self):
	
	"""Hide the font panel."""
	
	c = self.commands
	
	# c.frame.top.resizable(1,1)
	
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		c.frame.fontPanel=None
		self.top.destroy()</t>
<t tx="T473">def revertIvars (self):
	
	c = self.commands
	# Revert the fonts themselves in the various panes.
	font = self.revertBodyFont
	c.body.configure(font=font)
	font = self.revertLogFont
	c.log.configure(font=font)
	font = self.revertTreeFont
	c.frame.setFont(font=font)
	# Revert the setting of the items in the font panel
	self.last_selected_font = None # Use the font for the selected panes.
	font = self.getImpliedFont()
	self.selectFont(font)
	try:
		name, size, slant, weight = self.getFontSettings(font)
		size=int(size)
	except: pass
	self.sizeVar.set(size)
	self.boldVar.set(choose(weight=="bold",1,0))
	self.italVar.set(choose(slant=="italic",1,0))
	
	e = self.size_entry
	e.delete(0,"end")
	e.insert(0,`size`)</t>
<t tx="T474">def run (self):
	
	Tk = Tkinter ; c = self.commands
	self.top = top = Tk.Toplevel(app.root)
	attachLeoIcon(top)
	top.title("Fonts for " + shortFileName(c.frame.title))
	top.protocol("WM_DELETE_WINDOW", self.onOk)
	self.create_outer()
	
	# This must be done _after_ the dialog has been built!
	w,h,x,y = center_dialog(top)
	top.wm_minsize(height=h,width=w)
	
	# Finish up after the dialog is frozen.
	self.outer.after_idle(self.finishCreate)

	if 0: # The pane now looks decent when resized!
		top.resizable(0,0)

	# Bring up the dialog.
	if 0: # It need not be modal: it will go away if the owning window closes!
		top.grab_set()
		top.focus_set() # Get all keystrokes.</t>
<t tx="T475">def setRevertVars (self):
	
	c = self.commands
	
	# Variables for revert.
	fn = c.body.cget("font")
	self.revertBodyFont = tkFont.Font(font=fn)
	
	fn = c.log.cget("font")
	self.revertLogFont = tkFont.Font(font=fn)
	
	self.revertTreeFont = c.frame.getFont()</t>
<t tx="T476"># Write all settings to the log panel.
# Note that just after a revert all three setting may be different.

def showSettings (self):
	c = self.commands
	es("---------------")
	# Body pane.
	fn = c.body.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("body font:" + name + "," + `size` + "," + slant + "," + weight)
	# Log pane.
	fn = c.log.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("log font:" + name + "," + `size` + "," + slant + "," + weight)
	# Tree pane.
	font = c.frame.getFont()
	name,size,slant,weight = self.getFontSettings(font)
	es("headline font:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="T477">def update (self,event=None):
	
	"""Update the body text to show the present settings."""
	
	c = self.commands
	size = self.sizeVar.get()
	&lt;&lt; insert the new text in the size box &gt;&gt;
	activeFont = self.getActiveFont()
	bodyChecked = self.bodyVar.get()
	logChecked = self.logVar.get()
	treeChecked = self.treeVar.get()

	if not bodyChecked and not logChecked and not treeChecked:
		es("no pane selected")
		return
	

	# c.frame.body.configure(setgrid=0) # Disable body resizes.
	c.beginUpdate()
	&lt;&lt; set the fonts in all panes &gt;&gt;
	c.endUpdate()
	# c.frame.body.configure(setgrid=1) # Enable body resizes.

	self.top.deiconify()
	self.top.lift()</t>
<t tx="T478">e = self.size_entry
e.delete(0,"end")
e.insert(0,`size`)</t>
<t tx="T479">font = choose(bodyChecked,activeFont,self.revertBodyFont)
c.body.configure(font=font)

font = choose(logChecked,activeFont,self.revertLogFont)
c.log.configure(font=font)

font = choose(treeChecked,activeFont,self.revertTreeFont)
c.frame.setFont(font=font)</t>
<t tx="T480"></t>
<t tx="T481">def __init__(self,title):

	# trace("LeoFrame")

	self.title = title
	LeoFrame.instances += 1

	&lt;&lt; set the LeoFrame ivars &gt;&gt;
	
	self.initVersion()
</t>
<t tx="T482">self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.

# These are set the first time a panel is opened.
# The panel remains open (perhaps hidden) until this frame is closed.
self.colorPanel = None 
self.fontPanel = None 
self.prefsPanel = None
self.comparePanel = None
	
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.saved=false # True if ever saved
self.startupWindow=false # True if initially opened window
self.openDirectory = ""
self.es_newlines = 0 # newline count for this log stream

self.splitVerticalFlag,self.ratio,self.secondary_ratio = self.initialRatios()

# Created in createLeoFrame and its allies.
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None # 5/20/02
self.iconFrame = None # 5/20/02
self.statusFrame = None # 5/20/02
self.statusText = None # 5/20/02
self.statusLabel = None # 5/20/02

self.menus = {} # Menu dictionary.
self.menuShortcuts = None # List of menu shortcuts for warnings.

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.recentFiles = [] # List of recent files
self.controlKeyIsDown = false # For control-drags

# Colors of log pane.
self.logColorTags = [] # list of color names used as tags in log window.
self.statusColorTags = [] # list of color names used as tags in status window.

# Previous row and column shown in the status area.
self.lastStatusRow = self.lastStatusCol = 0
self.tab_width = 0 # The tab width in effect in this pane.</t>
<t tx="T483">def createLeoFrame (self,top):

	Tk = Tkinter ; config = app.config
	
	self.outerFrame = outerFrame = Tk.Frame(top)
	self.outerFrame.pack(expand=1,fill="both")

	self.createIconBar()
	&lt;&lt; create both splitters &gt;&gt;
	&lt;&lt; create the body pane &gt;&gt;
	&lt;&lt; create the tree pane &gt;&gt;
	&lt;&lt; create the log pane &gt;&gt;
	self.reconfigurePanes()
	
	self.createStatusLine()
	self.putStatusLine("Welcome to Leo")
	
	if 0: # Causes the cursor not to blink.
		self.body.configure(insertofftime=0)</t>
<t tx="T484"># Splitter 1 is the main splitter containing splitter2 and the body pane.
f1,bar1,split1Pane1,split1Pane2 = self.createLeoSplitter(outerFrame, self.splitVerticalFlag)
self.f1,self.bar1 = f1,bar1
self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2
# Splitter 2 is the secondary splitter containing the tree and log panes.
f2,bar2,split2Pane1,split2Pane2 = self.createLeoSplitter(split1Pane1, not self.splitVerticalFlag)
self.f2,self.bar2 = f2,bar2
self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="T485"># A light selectbackground value is needed to make syntax coloring look good.
wrap = config.getBoolWindowPref('body_pane_wraps')
wrap = choose(wrap,"word","none")

# Setgrid=1 cause severe problems with the font panel.
self.body = body = Tk.Text(split1Pane2,name='body',
	bd=2,bg="white",relief="flat",
	setgrid=0,wrap=wrap, selectbackground="Gray80") 
self.setBodyFontFromConfig()

self.bodyBar = bodyBar = Tk.Scrollbar(split1Pane2,name='bodyBar')
body['yscrollcommand'] = bodyBar.set
bodyBar['command'] = body.yview
bodyBar.pack(side="right", fill="y")

# 8/30/03: Always create the horizontal bar.
self.bodyXBar = bodyXBar = Tk.Scrollbar(
	split1Pane2,name='bodyXBar',orient="horizontal")
body['xscrollcommand'] = bodyXBar.set
bodyXBar['command'] = body.xview

if wrap == "none":
	bodyXBar.pack(side="bottom", fill="x")
	
body.pack(expand=1, fill="both")</t>
<t tx="T486">scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = tree = Tk.Canvas(split2Pane1,name="tree",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

# The font is set in the tree code.

# These do nothing...
# selectborderwidth=0,selectforeground="white",selectbackground="white")
self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)
	
tree['yscrollcommand'] = self.setCallback
treeBar['command']     = self.yviewCallback

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	tree['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = tree.xview 
	treeXBar.pack(side="bottom", fill="x")
tree.pack(expand=1,fill="both")</t>
<t tx="T487">wrap = config.getBoolWindowPref('log_pane_wraps')
wrap = choose(wrap,"word","none")

self.log = log = Tk.Text(split2Pane2,name="log",
	setgrid=0,wrap=wrap,bd=2,bg="white",relief="flat")
	
self.setLogFontFromConfig()

self.logBar = logBar = Tk.Scrollbar(split2Pane2,name="logBar")

log['yscrollcommand'] = logBar.set
logBar['command'] = log.yview

logBar.pack(side="right", fill="y")
# rr 8/14/02 added horizontal elevator 
if wrap == "none": 
	logXBar = Tk.Scrollbar( 
		split2Pane2,name='logXBar',orient="horizontal") 
	log['xscrollcommand'] = logXBar.set 
	logXBar['command'] = log.xview 
	logXBar.pack(side="bottom", fill="x")
log.pack(expand=1, fill="both")</t>
<t tx="T488"></t>
<t tx="T489"></t>
<t tx="T490"></t>
<t tx="T491"></t>
<t tx="T492"></t>
<t tx="T493"></t>
<t tx="T494"></t>
<t tx="T495"></t>
<t tx="T496"></t>
<t tx="T497"></t>
<t tx="T498">def __init__ (self,c):

	Tk = Tkinter
	&lt;&lt; set ivars &gt;&gt;
	self.commands = c
	self.top = top = Tk.Toplevel()
	c.frame.prefsPanel = self
	head,tail = os.path.split(c.frame.title)
	self.top.title("Prefs for " + tail)
	
	# Create the outer frame
	outer = Tk.Frame(top,bd=2,relief="groove")
	outer.pack(fill="both",expand=1,padx=2,pady=2)
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
	&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0) # neither height or width is resizable.
	self.top.protocol("WM_DELETE_WINDOW", self.onCancel) # 1/31/03
	self.init(c)
	# es("Prefs.__init__")</t>
<t tx="T499"># These ivars have the same names as the corresponding ivars in commands class.

# Global options
self.page_width = default_page_width
self.tab_width = default_tab_width
self.tangle_batch_flag = 0
self.untangle_batch_flag = 0

self.replace_tabs_var = Tk.IntVar() # 1/30/03
self.tangle_batch_var = Tk.IntVar()
self.untangle_batch_var = Tk.IntVar()

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = 0
self.output_doc_flag = 0

self.use_header_var = Tk.IntVar()
self.output_doc_var = Tk.IntVar()

# Default Target Language
self.target_language = default_target_language
self.lang_var = Tk.StringVar()</t>
<t tx="T500"># Frame and title
w,glob = create_labeled_frame (outer,caption="Global Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Page width &amp; page width
f = Tk.Frame(glob)
f.pack(anchor="w", pady="1m", expand=1, fill="x")

lab = Tk.Label(f, anchor="w", padx="1m", text="Page width:")
self.pageWidthText = txt = Tk.Text(f, height=1, width=4)
lab.pack(side="left")
txt.pack(side="left")
txt.bind("&lt;Key&gt;", self.idle_set_ivars)

lab2 = Tk.Label(f, padx="1m", text="Tab width:")
self.tabWidthText = txt2 = Tk.Text(f, height=1, width=4)
lab2.pack(side="left")
txt2.pack(side="left")
txt2.bind("&lt;Key&gt;", self.idle_set_ivars)

# Batch Checkbuttons...
self.replaceTabsBox = replaceBox = Tk.Checkbutton(glob,anchor="w",
	text="Replace tabs with spaces",
	variable=self.replace_tabs_var,command=self.idle_set_ivars)
self.doneBox = doneBox = Tk.Checkbutton(glob,anchor="w",
	text="Run tangle_done.py after Tangle",
	variable=self.tangle_batch_var,command=self.idle_set_ivars)
self.unBox = unBox = Tk.Checkbutton(glob,anchor="w",
	text="Run untangle_done.py after Untangle",
	variable=self.untangle_batch_var,command=self.idle_set_ivars)

for box in (replaceBox, doneBox, unBox):
	box.pack(fill="x")</t>
<t tx="T501"># Frame and title
w,tangle = create_labeled_frame (outer,caption="Default Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Label and text
lab3 = Tk.Label(tangle, anchor="w", text="Default tangle directory")
self.tangleDirectoryText = txt3 = Tk.Text(tangle, height=1, width=30)
txt3.bind("&lt;Key&gt;", self.idle_set_ivars) # Capture the change immediately
lab3.pack(            padx="1m", pady="1m", fill="x")
txt3.pack(anchor="w", padx="1m", pady="1m", fill="x")

# Checkbuttons
self.headerBox = header = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs header line",
	variable=self.use_header_var,command=self.idle_set_ivars)
self.docBox = doc = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs document chunks",
	variable=self.output_doc_var,command=self.idle_set_ivars)
header.pack(fill="x")
doc.pack(fill="x")</t>
<t tx="T502">buttons = Tk.Frame(outer)
buttons.pack(padx=2,pady=2,expand=1,fill="x")

okButton = Tk.Button(buttons,text="OK",width=7,command=self.onOK)
cancelButton = Tk.Button(buttons,text="Cancel",width=7,command=self.onCancel)
revertButton = Tk.Button(buttons,text="Revert",width=7,command=self.onRevert)

okButton.pack(side="left",pady=7,expand=1)
cancelButton.pack(side="left",pady=7,expand=0)
revertButton.pack(side="left",pady=7,expand=1)</t>
<t tx="T503"></t>
<t tx="T504"></t>
<t tx="T505">def __init__(self,commands,frame,canvas):

	# Objects associated with this tree.
	self.commands = commands
	self.canvas = canvas
	self.frame = frame
	self.colorizer = leoColor.colorizer(commands)
	
	# State info.
	self.rootVnode = None
	self.topVnode = None

	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.active = false # true if tree is active
	self.revertHeadline = None # Previous headline text for abortEditLabel.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
	self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
	self.edit_text_dict = {} # New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
	self.widgets = [] # Widgets that must be destroyed when redrawing.

	# Controlling redraws
	self.updateCount = 0 # self.redraw does nothing unless this is zero.
	self.redrawCount = 0 # For traces
	self.redrawScheduled = false # true if redraw scheduled.

	# Selection ivars.
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.initing = false # true: opening file.
	
	# Drag and drop
	self.drag_v = None
	self.dragging = false # true: presently dragging.
	self.controlDrag = false # true: control was down when drag started.
	self.drag_id = None # To reset bindings after drag
	self.keyCount = 0 # For debugging.
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None
	
	# Incremental redraws:
	self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
	self.trace = false # true enabling of various traces.
	self.prevMoveToFrac = None
	self.visibleArea = None
	self.expandedVisibleArea = None
	self.forceFullRecolorFlag = false
	
	self.allocatedNodes = 0 # A crucial statistic.
		# Incremental drawing allocates visible nodes at most twice.
		# Non-incremetal drawing allocates all visible nodes once.
		
	if self.allocateOnlyVisibleNodes:
		self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)
	
	if not leoTree.callbacksInjected:
		leoTree.callbacksInjected = true
		self.injectCallbacks()</t>
<t tx="T506">def deleteBindings (self):
	
	"""Delete all tree bindings and all references to tree widgets."""
	
	# print "deleteBindings: %d, %d" % (len(self.tagBindings),len(self.bindings))

	count = 0
	# Unbind all the tag bindings.
	for id,id2,binding in self.tagBindings:
		self.canvas.tag_unbind(id,binding,id2)
		count += 1
	self.tagBindings = []
	# Unbind all the text bindings.
	for t,id,binding in self.bindings:
		t.unbind(binding,id)
		count += 1
	self.bindings = []
	# print("bindings freed:"+`count`)</t>
<t tx="T507"># canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
	
	"""Delete all widgets in the canvas"""
	
	self.icon_id_dict = {} # Delete all references to icons.
	self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
		
	# Fixes a _huge_ memory leak.
	for w in self.widgets:
		w.destroy() 
	self.widgets = []</t>
<t tx="T508">def injectCallbacks(self):
	
	if 0: # Works:  It's not clear that we really want to do this.
	
		import leoNodes
		&lt;&lt; define callbacks to be injected in the vnode class &gt;&gt;
		for f in (
			OnBoxClick,OnDrag,OnEndDrag,
			OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
			OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
			OnIconClick,OnIconDoubleClick,OnIconRightClick):
			# trace(f)
			funcToMethod(f,leoNodes.vnode)</t>
<t tx="T509"># N.B. These vnode methods are entitled to know about details of the leoTree class.

@others</t>
<t tx="T510"># Called when the box is clicked.

def OnBoxClick(self,event=None):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.commands
		if not doHook("boxclick1",c=c,v=v,event=event):
			c.frame.tree.OnBoxClick(v)
		doHook("boxclick2",c=c,v=v,event=event)
	except:
		es_event_exception("boxclick")</t>
<t tx="T511">def OnDrag(self,event=None):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.commands
		if c.frame.dragging():
			if not doHook("dragging1",c=c,v=v,event=event):
				c.frame.tree.OnDrag(v,event)
			doHook("dragging2",c=c,v=v,event=event)
		else:
			if not doHook("drag1",c=c,v=v,event=event):
				c.frame.tree.OnDrag(v,event)
			doHook("drag2",c=c,v=v,event=event)
	except:
		es_event_exception("drag")</t>
<t tx="T512">def OnEndDrag(self,event=None):
	
	"""Callback injected into vnode class."""
	
	# trace()

	try:
		v = self ; c = v.commands
		# 7/10/03: Always call frame.OnEndDrag, regardless of state.
		if not doHook("enddrag1",c=c,v=v,event=event):
			c.frame.tree.OnEndDrag(v,event)
		doHook("enddrag2",c=c,v=v,event=event)
	except:
		es_event_exception("enddrag")</t>
<t tx="T513">def OnHeadlineClick(self,event=None):
	"""Callback injected into vnode class."""
	#trace()
	try:
		v = self ; c = v.commands
		if not doHook("headclick1",c=c,v=v,event=event):
			c.frame.tree.OnActivate(v)
		doHook("headclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headclick")
	
def OnHeadlineRightClick(self,event=None):
	"""Callback injected into vnode class."""
	#trace()
	try:
		v = self ; c = v.commands
		if not doHook("headrclick1",c=c,v=v,event=event):
			c.frame.tree.OnActivate(v)
			c.frame.tree.OnPopup(self,event)
		doHook("headrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headrclick")</t>
<t tx="T514">def OnHeadlineKey (self,event=None):

	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("headkey1",c=c,v=v,event=event):
			c.frame.tree.OnHeadlineKey(v,event)
		doHook("headkey2",c=c,v=v,event=event)
	except:
		es_event_exception("headkey")</t>
<t tx="T515">def OnHyperLinkControlClick (self,event):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.commands
		if not doHook("hypercclick1",c=c,v=v,event=event):
			c.beginUpdate()
			c.selectVnode(v)
			c.endUpdate()
			c.body.mark_set("insert","1.0")
		doHook("hypercclick2",c=c,v=v,event=event)
	except:
		es_event_exception("hypercclick")</t>
<t tx="T516">def OnHyperLinkEnter (self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("hyperenter1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.body.tag_config(v.tagName,background="green")
		doHook("hyperenter2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperenter")</t>
<t tx="T517">def OnHyperLinkLeave (self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("hyperleave1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.body.tag_config(v.tagName,background="white")
		doHook("hyperleave2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperleave")</t>
<t tx="T518">def OnIconClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("iconclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconClick(v,event)
		doHook("iconclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconclick")
	
def OnIconRightClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("iconrclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconRightClick(v,event)
		doHook("iconrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")
</t>
<t tx="T519">def OnIconDoubleClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.commands
		if not doHook("icondclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconDoubleClick(self)
		doHook("icondclick2",c=c,v=v,event=event)
	except:
		es_event_exception("icondclick")
</t>
<t tx="T520"></t>
<t tx="T521"></t>
<t tx="T522"></t>
<t tx="T523">def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
	c = self.commands ; body = c.frame.body
	# Make the insertion cursor visible so bbox won't return an empty list.
	body.see("insert")
	# Find the coordinates of the cursor and set the new height.
	# There may be roundoff errors because character postions may not match exactly.
	ins =  body.index("insert")
	lines,char = scanf(ins,"%d.%d")
	x,y,junk,textH = body.bbox("insert")
	bodyW,bodyH = body.winfo_width(),body.winfo_height()
	junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
	# Make sure y is within text boundaries.
	if upOrDown == "up":
		if y &lt;= textH:
			body.yview("scroll",-1,"units")
		else: y = max(y-textH,0)
	else:
		if y &gt;= maxy:
			body.yview("scroll",1,"units")
		else: y = min(y+textH,maxy)
	# Position the cursor on the proper side of the characters.
	newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
	if x &gt; newx + width/2:
		x = newx + width + 1
	result = body.index("@%d,%d" % (x,y))
	body.mark_set("insert",result)
	# trace("entry:  %s.%s" % (lines,char))
	# trace("result:",result)
	# trace("insert:",body.index("insert"))
	return "break" # Inhibit further bindings.</t>
<t tx="T524"></t>
<t tx="T525"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,v,
	leading,trailing, # Number of matching leading &amp; trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo", # "undo" or "redo"
	undoType=None):

	u = self ; c = u.commands
	assert(v == c.currentVnode())

	&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
	&lt;&lt; Compute the result using v's body text &gt;&gt;
	#trace(`v`)
	#trace("old:"+`v.bodyString()`)
	v.t.setTnodeText(result)
	#trace("new:"+`v.bodyString()`)
	&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
	if textResult == result:
		if undoType in ("Cut","Paste"):
			# trace("non-incremental undo")
			c.frame.recolor(v,incremental=false)
		else:
			# trace("incremental undo:",leading,trailing)
			c.frame.recolor_range(v,leading,trailing)
	else: # 11/19/02: # Rewrite the pane and do a full recolor.
		if u.debug_print:
			&lt;&lt; print mismatch trace &gt;&gt;
		# trace("non-incremental undo")
		v.setBodyStringOrPane(result)
</t>
<t tx="T526"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
	c.frame.body.delete(str(1+leading)+".0","end")
	if leading &gt; 0:
		c.frame.body.insert("end",'\n')
	c.frame.body.insert("end",mid_text)
else:
	if new_mid_len &gt; 0:
		c.frame.body.delete(str(1+leading)+".0",
			str(leading+new_mid_len)+".0 lineend")
	elif leading &gt; 0:
		c.frame.body.insert(str(1+leading)+".0",'\n')
	c.frame.body.insert(str(1+leading)+".0",mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.get("1.0","end")
s = toUnicode(s,app.tkEncoding) # 2/25/03
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
	newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
	c.frame.body.delete("end-1c")
	newlines -= 1
if oldNewlines &gt; newlines:
	c.frame.body.insert("end",'\n'*(oldNewlines-newlines))
</t>
<t tx="T527"># Recreate the text using the present body text.
body = v.bodyString()
body = toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
	s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
	s.extend(oldMidLines)
if trailing &gt; 0:
	s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
	s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
	s = s + '\n' * oldNewlines
result = s
if u.debug_print:
	print "body:  ",`body`
	print "result:",`result`</t>
<t tx="T528">textResult = c.frame.body.get("1.0","end")
textResult = toUnicode(textResult,app.tkEncoding) # 2/25/03

if textResult != result:
	# Remove the newline from textResult if that is the only difference.
	if len(textResult) &gt; 0 and textResult[:-1] == result:
		textResult = result</t>
<t tx="T529">print "undo mismatch"
print "expected:",`result`
print "actual  :",`textResult`
</t>
<t tx="T530"></t>
<t tx="T531">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2097076
By: nobody

Using Jason's code for Rebol and a visual DIFF, I was able to quickly add the
keywords for the assembler I use. I'm wondering if there is a way to tell Leo
to ignore keyword case -- at the present, each keyword is entered twice. Not
a big problem with modern editors, but it _would_ be nicer...

--Rich
</t>
<t tx="T532"></t>
<t tx="T533">@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.</t>
<t tx="T534">@nocolor

How do we specify the secondary icon??

- add icon command.
- add icon to vnode or tnode</t>
<t tx="T535"></t>
<t tx="T536">- Deprecate @rawfile, @silentfile, @nosentinelfile.</t>
<t tx="T537">1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.</t>
<t tx="T538">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2107033
By: jasonic

Paul: "I could get away with a text box and a find button ... 

What about a plug-in (or built-in) which places a text box + "Go" button in
the top right edge of the button bar. Pressing the "Go" would do a find/find
next using the current Find panel settings."

I like this idea very much also. 
It's what I have on my wikilog website. 

The label word "find" - next to the text input box  can also double duty as
a button to open a more sophisticated find form. that ay find is always available
in the top menu toolbar. Entering text will get focus so hitting "Enter" does
te4h search directly. Else click "find" and open the find form with search string
in place. "Find Again" is essential for Leo use, so I guess we'd want an icon/button
for that too always available.

Wish I knew enough about writing Leo plugins to pitch in already. I still feel
I need a simple "Leo plugins for dummies" tutorial to get me going. Just missing
a few crucial starter steps..

Jason</t>
<t tx="T539">- Show changes:
	When a derived file is modified by an editor it would be very nice if Leo would:
	- flag the file as modified and,
	- flag (underline, color, diff, whatever) the parts that were modified.</t>
<t tx="T540">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2205285
By: nobody

From: Rich

Some of the things I'd like to see in Leo:

A note window for each node. This is similar to (1), but a little fancier
looking. I envision a short window at the bottom of the edit window that could
hold notes and comments about the code, such as "Test this harder" or "Find
a better way of phrasing this". This is currently available in uSoft Office
and the Eclipse IDE (http://www.eclipse.org). Perhaps a numeric reference, such
as "&lt;&lt;1&gt;&gt;" could be used.

(2) Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.</t>
<t tx="T541"></t>
<t tx="T542">@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
#@+leo 
#@+node:0::@file /tmp/firstcheck.py 
#@+body 
#@@first 
#@@first 
#@@first 
#@@first 
#@@first 
#@+doc 
# 
# How many firsts do I get? 

#@-doc 
#@@c 
Start code. 
#@-body 
#@-node:0::@file /tmp/firstcheck.py 
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first &lt;num&gt; 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius </t>
<t tx="T543">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2090601
By: jasonic

I'll be happy to run some test and report to you. But  I suspect from your post
a slight misunderstanding about Alt+Tab.

Alt+Tab just toggles the active window.
It works fine with Leo on Windows wherver I have tried it.

Resizing wondows via hotkeys is another matter.
The special "Windows" Key + m will minimize all windows. 

But unfortunately I've not yet discovered any opposite shortcut to  maximize
all windows :-(
I've tried various 3rd party hotkey utililties, but somehow always end up dropping
them.

&lt;rant&gt;
I really hate wasting any time dragging windows around and resizing them or
clicking to bring them into top focus. As I work mainly with graphics, and mult-task
intesenlty bwetn apps,  it is especially important to reduce visual clutter
on screen.

For many years the way to do this has been combining maximized [or minimized]
windows with  Alt+Tab. Alt+Tab  lets one jump rapidly betwen open apps and windows
without ever need to repostion or resize them.

As a consultant, its one of the first things I ever teach clients. Often it
transforms their perception of using Windows.

It is so painful to watch people dragging and rescaling  windows all over the
place. Ironically, I've witnessed some very smart programmers fly through vi
or emacs but then slow to tortoises when navigation mice and windows. I beleive
as long as we have the curertn wnidows UI paradigm,  use of Alt+Tab is an essential
part of  GUI 'litteracy' - an essentail skill all shoudl have. Alas its still
little known or discussed.

There is also a nice toggle feature so one can jump back to the last app/window
as its first "stop". Typically one is working between two apps for some specific
task, even though many are open.

Keeping one's finger on the 'Alt' key then tapping 'Tab' lets one hop along
the list.

Adding 'shift' to the mix helps one to go in reverse. 

Above all one can keep one hand on the mouse, the other on the keyboard [ALt+Tab]
and ones mind/eye on teh screen. For me it means left hand "plays" the bass
pattern using Alt+Tab along with the clipboard shortcuts [CTRL+ z,x,c,v] ,while
right hand on the mouse mouse  provides the melody.

I've been using variations on the above since 1987 when I bought an Amiga2000.
I seem to recall SGI had one also. And after learning about Alt+Tab on windows,
I  found a utility to work the same way on Macintosh.  I am very happy to discover
that MacOSX now has built-in ALt+Tab :-)
&lt;/rant&gt;

Meanwhile, Iam  still wondering how to set Leo [3.12 beta 1, Python 2.2.2, Tk
8.3.2] default to a maxmimized or minimized window size by itself.

And also to remember the last size/position it had. I vaguely remember that
it used to do that, but perhaps I am mistaking it for some other software ?

thanks
Jason
</t>
<t tx="T544"></t>
<t tx="T545">Need a good yaml parser first: I don't want to write another parser by hand.</t>
<t tx="T546"></t>
<t tx="T547">@nocolor

As recent experiments have shown, it is very difficult to make changes in the body key handlers.

Furthermore, emacs essentially takes over the handling of _all_ keystrokes.  I like this approach, and it is way too much to do in 3.11 or 4.0.</t>
<t tx="T548">@nocolor

How about a Emacs style meta-key(Esc?) followed by up or down? or F1/F2 ? anything to escape having to hold down three keys at the same time -- which seems to be common to other shortcut combinations too. so if you could put this in as an option in the preferences -- to turn on or off meta-key binding, that would let people choose what they prefer...

EKR:  This would require Leo to remember state in the event handlers.  It could be done, and having user-configurable shortcuts should reduce the need for this considerably.
</t>
<t tx="T549">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:
&gt;This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to &lt;Alt-KeyPress&gt;,
&lt;Shift-KeyPress&gt;, etc.  Tk chooses the most specific event it can find, so the
more general &lt;KeyPress&gt; handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

All this is just food for thought.  I don't know the details of Leo's code,
so it may not be very helpful.

Brian Theado

-----

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864584
By: btheado

If you don't already know about Tk's bindtags command, then check it out.  It
should make things like this easy.  It basically allows you to dynamically add
and remove a whole group of bindings all at once without affecting any other
bindings.

i.e. if you have a window called .text:

# Enter escape mode
bind .text &lt;Esc&gt; {
    # add EscapeMode to .text's list of bindings by
    # using the bindtags command (not shown)
}
bind EscapeMode &lt;Up&gt; {
    # Add special escape mode up handling code here
    break
}
bind EscapeMode &lt;Down&gt; {
    # Add special escape mode down handling code
    break
}
etc.

# Leave escape mode
bind EscapeMode &lt;Esc&gt; {
    # remove EscapeMode from .text's list of bindings
    # by using the bindtags command (not shown)
}

See (http://wiki.tcl.tk/bindtags) for a page with more information about bindtags
and a link to the bindtags man page.

I just wanted you to be aware of this functionality if and when you do tackle
this.  I have found Tk's event handling, bindtags functionality very powerful,
easy to use, and quite elegant for the coding I've done.

Brian Theado</t>
<t tx="T550">@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters. comint-mode.el serves as 
the basis for interactive modes for a number of languages--OCaml, 
Haskell, SML, among them. It allows for editing expressions in one 
buffer and triggering their evaluation in another buffer that has an 
interpreter running in it, along with entering commands in the 
interpreter buffer and moving back and forth through the history of 
their evaluation. Imagine being able to highlight a node in Leo, and 
have all the code in it and its children evaluated in an interpreter 
running in a separate window or pane, much as Leo can open a Python 
shell now. Users of those languages could build plug-ins specific to 
their language atop that layer, and the @language directive could 
activate that. I think that would be very cool.
</t>
<t tx="T551"></t>
<t tx="T552">Developers

 RE: tab spacing test   
2003-07-01 17:05  
Another thought that hit me last night. In vim for example, tabs are tabs until you're off the line if you've set expandtab. Never really thought about it before, but that's how it works. 

So you could do \t\t\t and then delete the entire space with 3 backspaces. But if you move the cursor off the line then it would take 12 backspaces (assuming you set the tabwidth to 4) because its been replaced with spaces. Its nice, and works well. 

- ordinarius  
</t>
<t tx="T553"></t>
<t tx="T554">Jonathan M. Gilligan

Calltips, as in IDLE. </t>
<t tx="T555">@ignore
@language python</t>
<t tx="T556">@nocolor

Writing an IDLE extension

An IDLE extension can define new key bindings and menu entries for IDLE
edit windows.  There is a simple mechanism to load extensions when IDLE
starts up and to attach them to each edit window. (It is also possible
to make other changes to IDLE, but this must be done by editing the IDLE
source code.)

The list of extensions loaded at startup time is configured by editing
the file config.txt; see below for details.

An IDLE extension is defined by a class.  Methods of the class define
actions that are invoked by those bindings or menu entries. Class (or
instance) variables define the bindings and menu additions; these are
automatically applied by IDLE when the extension is linked to an edit
window.

An IDLE extension class is instantiated with a single argument,
`editwin', an EditorWindow instance. The extension cannot assume much
about this argument, but it is guarateed to have the following instance
variables:

    text	a Text instance (a widget)
    io		an IOBinding instance (more about this later)
    flist	the FileList instance (shared by all edit windows)

(There are a few more, but they are rarely useful.)

The extension class must not bind key events.  Rather, it must define
one or more virtual events, e.g. &lt;&lt;zoom-height&gt;&gt;, and corresponding
methods, e.g. zoom_height_event(), and have one or more class (or instance)
variables that define mappings between virtual events and key sequences,
e.g. &lt;Alt-F2&gt;.  When the extension is loaded, these key sequences will
be bound to the corresponding virtual events, and the virtual events
will be bound to the corresponding methods.  (This indirection is done
so that the key bindings can easily be changed, and so that other
sources of virtual events can exist, such as menu entries.)

The following class or instance variables are used to define key
bindings for virtual events:

    keydefs		for all platforms
    mac_keydefs		for Macintosh
    windows_keydefs	for Windows
    unix_keydefs	for Unix (and other platforms)

Each of these variables, if it exists, must be a dictionary whose
keys are virtual events, and whose values are lists of key sequences.

An extension can define menu entries in a similar fashion.  This is done
with a class or instance variable named menudefs; it should be a list of
pair, where each pair is a menu name (lowercase) and a list of menu
entries. Each menu entry is either None (to insert a separator entry) or
a pair of strings (menu_label, virtual_event).  Here, menu_label is the
label of the menu entry, and virtual_event is the virtual event to be
generated when the entry is selected.  An underscore in the menu label
is removed; the character following the underscore is displayed
underlined, to indicate the shortcut character (for Windows).

At the moment, extensions cannot define whole new menus; they must
define entries in existing menus.  Some menus are not present on some
windows; such entry definitions are then ignored, but the key bindings
are still applied.  (This should probably be refined in the future.)

Here is a complete example example:

class ZoomHeight:

    menudefs = [
        ('edit', [
            None, # Separator
            ('_Zoom Height', '&lt;&lt;zoom-height&gt;&gt;'),
         ])
    ]

    windows_keydefs = {
        '&lt;&lt;zoom-height&gt;&gt;': ['&lt;Alt-F2&gt;'],
    }
    unix_keydefs = {
        '&lt;&lt;zoom-height&gt;&gt;': ['&lt;Control-z&gt;&lt;Control-z&gt;'],
    }

    def __init__(self, editwin):
        self.editwin = editwin

    def zoom_height_event(self, event):
        "...Do what you want here..."

The final piece of the puzzle is the file "config.txt", which is used
to to configure the loading of extensions.  For each extension,
you must include a section in config.txt (or in any of the other
configuration files that are consulted at startup: config-unix.txt,
config-win.txt, or ~/.idle).  A section is headed by the module name
in square brackets, e.g.

    [ZoomHeight]

The section may be empty, or it may define configuration options for
the extension.  (See ParenMatch.py for an example.)  A special option
is 'enable': including

    enable = 0

in a section disables that extension.  More than one configuration
file may specify options for the same extension, so a user may disable
an extension that is loaded by default, or enable an extension that is
disabled by default.

Extensions can define key bindings and menu entries that reference
events they don't implement (including standard events); however this is
not recommended (and may be forbidden in the future).

Extensions are not required to define menu entries for all events they
implement.

Note: in order to change key bindings, you must currently edit the file
keydefs.  It contains two dictionaries named and formatted like the
keydefs dictionaries described above, one for the Unix bindings and one
for the Windows bindings.  In the future, a better mechanism will be
provided.

</t>
<t tx="T557"># IDLE reads several config files to determine user preferences.  This 
# file is the default config file.  When IDLE starts, it will look in
# the following four files in order:
#     config.txt                      the default config file
#     config-[win/unix/mac].txt       the generic platform config file
#     config-[sys.platform].txt       the specific platform config file
#     ~/.idle                         the user config file
#
# The last definition of each option is used.  For example, you can
# override the default window size (80x24) by defining width and
# height options in the EditorWindow section of your ~/.idle file
#
# IDLE extensions can be enabled and disabled by adding them to one of
# the config files.  To enable an extension, create a section with the
# same name as the extension, e.g. the [ParenMatch] section below.  To
# disable an extension, either remove the section or add the 'enable'
# option with the value 0.  

[EditorWindow]
width= 80
height= 24
# fonts defined in config-[win/unix].txt

[Colors]
normal-foreground= black
normal-background= white
# These color types are not explicitly defined= sync, todo, stdin
keyword-foreground= #ff7700
comment-foreground= #dd0000
string-foreground= #00aa00
definition-foreground= #0000ff
hilite-foreground= #000068
hilite-background= #006868
break-foreground= #ff7777
hit-foreground= #ffffff
hit-background= #000000
stdout-foreground= blue
stderr-foreground= red
console-foreground= #770000
error-background= #ff7777
cursor-background= black

[SearchBinding]

[AutoIndent]

[AutoExpand]

[FormatParagraph]

[ZoomHeight]

[ScriptBinding]

[CallTips]

[ParenMatch]
enable= 0
style= expression
flash-delay= 500
bell= 1
hilite-foreground= black
hilite-background= #43cd80
</t>
<t tx="T558">@ignore
@language python

import string
import re

###$ event &lt;&lt;expand-word&gt;&gt;
###$ win &lt;Alt-slash&gt;
###$ unix &lt;Alt-slash&gt;

class AutoExpand:
	&lt;&lt; decls &gt;&gt;
	@others

</t>
<t tx="T559">keydefs = {
    '&lt;&lt;expand-word&gt;&gt;': ['&lt;Alt-slash&gt;'],
}

unix_keydefs = {
    '&lt;&lt;expand-word&gt;&gt;': ['&lt;Meta-slash&gt;', '&lt;Alt-slash&gt;'],
}

menudefs = [
    ('edit', [
        ('E_xpand word', '&lt;&lt;expand-word&gt;&gt;'),
     ]),
]

wordchars = string.ascii_letters + string.digits + "_"

</t>
<t tx="T560">def __init__(self, editwin):
    self.text = editwin.text
    self.state = None
</t>
<t tx="T561">def expand_word_event(self, event):
    curinsert = self.text.index("insert")
    curline = self.text.get("insert linestart", "insert lineend")
    if not self.state:
        words = self.getwords()
        index = 0
    else:
        words, index, insert, line = self.state
        if insert != curinsert or line != curline:
            words = self.getwords()
            index = 0
    if not words:
        self.text.bell()
        return "break"
    word = self.getprevword()
    self.text.delete("insert - %d chars" % len(word), "insert")
    newword = words[index]
    index = (index + 1) % len(words)
    if index == 0:
        self.text.bell()            # Warn we cycled around
    self.text.insert("insert", newword)
    curinsert = self.text.index("insert")
    curline = self.text.get("insert linestart", "insert lineend")
    self.state = words, index, curinsert, curline
    return "break"
</t>
<t tx="T562">def getwords(self):
    word = self.getprevword()
    if not word:
        return []
    before = self.text.get("1.0", "insert wordstart")
    wbefore = re.findall(r"\b" + word + r"\w+\b", before)
    del before
    after = self.text.get("insert wordend", "end")
    wafter = re.findall(r"\b" + word + r"\w+\b", after)
    del after
    if not wbefore and not wafter:
        return []
    words = []
    dict = {}
    # search backwards through words before
    wbefore.reverse()
    for w in wbefore:
        if dict.get(w):
            continue
        words.append(w)
        dict[w] = w
    # search onwards through words after
    for w in wafter:
        if dict.get(w):
            continue
        words.append(w)
        dict[w] = w
    words.append(word)
    return words</t>
<t tx="T563">def getprevword(self):

    line = self.text.get("insert linestart", "insert")
    i = len(line)
    while i &gt; 0 and line[i-1] in self.wordchars:
        i = i-1
    return line[i:]
</t>
<t tx="T564"># An IDLE extension that provides "Call Tips" - ie, a floating window that
# displays parameter information as you open parens.

import string,sys,types

class CallTips:
	&lt;&lt; class CallTips members &gt;&gt;

@others
</t>
<t tx="T565">@others</t>
<t tx="T566">menudefs = [ ]

keydefs = {
    '&lt;&lt;paren-open&gt;&gt;': ['&lt;Key-parenleft&gt;'],
    '&lt;&lt;paren-close&gt;&gt;': ['&lt;Key-parenright&gt;'],
    '&lt;&lt;check-calltip-cancel&gt;&gt;': ['&lt;KeyRelease&gt;'],
    '&lt;&lt;calltip-cancel&gt;&gt;': ['&lt;ButtonPress&gt;', '&lt;Key-Escape&gt;'],
}

windows_keydefs = { }

unix_keydefs = { }

</t>
<t tx="T567">def __init__(self, editwin):

    self.editwin = editwin
    self.text = editwin.text
    self.calltip = None

    if hasattr(self.text, "make_calltip_window"):
        self._make_calltip_window = self.text.make_calltip_window
    else:
        self._make_calltip_window = self._make_tk_calltip_window
</t>
<t tx="T568">def close(self):

    self._make_calltip_window = None
</t>
<t tx="T569"># Makes a Tk based calltip window.
# Used by IDLE, but not Pythonwin.
# See __init__ above for how this is used.

def _make_tk_calltip_window(self):

    import CallTipWindow
    return CallTipWindow.CallTip(self.text)
</t>
<t tx="T570">def _remove_calltip_window(self):
	
    if self.calltip:
        self.calltip.hidetip()
        self.calltip = None

</t>
<t tx="T571">def paren_open_event(self, event):

    self._remove_calltip_window()
    arg_text = get_arg_text(self.get_object_at_cursor())
    if arg_text:
        self.calltip_start = self.text.index("insert")
        self.calltip = self._make_calltip_window()
        self.calltip.showtip(arg_text)
    return "" #so the event is handled normally.
</t>
<t tx="T572">def paren_close_event(self, event):
	
    # Now just hides, but later we should check if other
    # paren'd expressions remain open.
    self._remove_calltip_window()
    return "" #so the event is handled normally.

</t>
<t tx="T573">def check_calltip_cancel_event(self, event):

    if self.calltip:
        # If we have moved before the start of the calltip,
        # or off the calltip line, then cancel the tip.
        # (Later need to be smarter about multi-line, etc)
        if self.text.compare("insert", "&lt;=", self.calltip_start) or \
           self.text.compare("insert", "&gt;", self.calltip_start + " lineend"):
            self._remove_calltip_window()

    return "" #so the event is handled normally.
</t>
<t tx="T574">def calltip_cancel_event(self, event):

    self._remove_calltip_window()
    return "" #so the event is handled normally.
</t>
<t tx="T575">def get_object_at_cursor(self,wordchars="._" + string.ascii_letters + string.digits):
    # Usage of ascii_letters is necessary to avoid UnicodeErrors
    # if chars contains non-ASCII.

    # XXX - This needs to be moved to a better place
    # so the "." attribute lookup code can also use it.
    text = self.text
    chars = text.get("insert linestart", "insert")
    i = len(chars)
    while i and chars[i-1] in wordchars:
        i = i-1
    word = chars[i:]
    if word:
        # How is this for a hack!
        import sys, __main__
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(word, namespace)
        except:
            pass
    return None # Can't find an object.
</t>
<t tx="T576">@ Given a class object, return a function object used for the constructor,
i.e., __init__() or None if we can't find one.
@c

def _find_constructor(class_ob):

    try:
        return class_ob.__init__.im_func

    except AttributeError:
        for base in class_ob.__bases__:
            rc = _find_constructor(base)
            if rc is not None: return rc

    return None
</t>
<t tx="T577">def get_arg_text(ob):

    # Get a string describing the arguments for the given object.
	argText = "" ; argOffset = 0
	if ob is not None:
		&lt;&lt; set fob depending on the type of ob &gt;&gt;
		&lt;&lt; get argText for functions and lambdas &gt;&gt;
		&lt;&lt; append the docstring if it exists &gt;&gt;
    return argText</t>
<t tx="T578">if type(ob)==types.ClassType:
    # Look for the highest __init__ in the class chain.
    fob = _find_constructor(ob)
    if fob is None:
        fob = lambda: None
    else:
        argOffset = 1

elif type(ob)==types.MethodType:
    # A hack for methods: turn it into a function but drop the "self" param.
    fob = ob.im_func
    argOffset = 1

else:
    fob = ob</t>
<t tx="T579">@ Examples

1. string.replace(  generates:

	(s, old, new, maxsplit=-1)
	replace (str, old, new[,maxsplit]) -&gt; string

2. d = {} ; d.get( generates:
	D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.

This last presumably comes from the docstring.
@c

# Try and build one for Python defined functions
if type(fob) in [types.FunctionType, types.LambdaType]:
    try:
        realArgs = fob.func_code.co_varnames[argOffset:fob.func_code.co_argcount]
        defaults = fob.func_defaults or []
		# Use "=value" for each value in defaults
        defaults = list(map(lambda name: "=%s" % name, defaults))
		# Use "" for all args without defaults.
        defaults = [""] * (len(realArgs)-len(defaults)) + defaults
		# Set items to a list of arg+deflt values.
        items = map(
			lambda arg, dflt: arg+dflt, realArgs, defaults )
	
        if fob.func_code.co_flags &amp; 0x4: items.append("...")
        if fob.func_code.co_flags &amp; 0x8: items.append("***")
        argText = string.join(items,", ")
        argText = "(%s)" % argText
    except:pass</t>
<t tx="T580">doc = getattr(ob, "__doc__", "")
if doc:
	# Remove all leading tabs, blanks and newlines.
    while doc[:1] in " \t\n":
        doc = doc[1:]
		
	# EKR: I would replace runs of whitespace by a single blank.
	doc = doc.replace("\t"," ")
	while 1:
		n = len(doc)
		doc = string.replace("  "," ")
		if n == len(doc): break

	# Take at most 70 characters of the docstring.
    pos = doc.find("\n")
    if pos &lt; 0 or pos &gt; 70: pos = 70

	# Append the result to argText.
    if argText: argText += "\n"
    argText += doc[:pos]</t>
<t tx="T581">if __name__=='__main__':

    def t1(): "()"
    def t2(a, b=None): "(a, b=None)"
    def t3(a, *args): "(a, ...)"
    def t4(*args): "(...)"
    def t5(a, *args): "(a, ...)"
    def t6(a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    class TC:
        "(a=None, ...)"
        def __init__(self, a=None, *b): "(a=None, ...)"
        def t1(self): "()"
        def t2(self, a, b=None): "(a, b=None)"
        def t3(self, a, *args): "(a, ...)"
        def t4(self, *args): "(...)"
        def t5(self, a, *args): "(a, ...)"
        def t6(self, a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    def test( tests ):
        failed=[]
        for t in tests:
            expected = t.__doc__ + "\n" + t.__doc__
            if get_arg_text(t) != expected:
                failed.append(t)
                print "%s - expected %s, but got %s" % (t, `expected`, `get_arg_text(t)`)
        print "%d of %d tests failed" % (len(failed), len(tests))

    tc = TC()
    tests = t1, t2, t3, t4, t5, t6, \
            TC, tc.t1, tc.t2, tc.t3, tc.t4, tc.t5, tc.t6

    test(tests)
</t>
<t tx="T582">@ We have _lots_ of object available while Leo is running, so it would be possible to pass those objects to the tooltip routines.  However, it is not clear how useful all those global names will be.
@c

from leoGlobals import *
#print app()
#import __main__
#print __main__
#print __main__.__dict__
print es</t>
<t tx="T583"></t>
<t tx="T584"></t>
<t tx="T585">@nocolor

need a delay on body display so alt+arrow keys arent slowed down while navigating.

EKR: Alt-Up and Alt-Down are bound to Go To Next/Prev visible.  The idea is that if we don't display the body text these keys will work faster.  </t>
<t tx="T586">@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
</t>
<t tx="T587"></t>
<t tx="T588"></t>
<t tx="T589">This is done automatically now!  I may have to use configure events.

&gt; When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
</t>
<t tx="T590">@nocolor
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2012136
By: dalcolmo

rST would be a good choice, at least for static HTML pages. It provides
a minimalistic markup language, which is very well readable (much less distracting
than LaTeX), and can in principle also be translated to LaTeX, OpenOffice.org
etc.

I say in principle, because only the HTML generator is in the current distribution,
the others are "sandboxes", with little or no documentation, not even an istallation
description (at least not for Windows). See

http://docutils.sourceforge.net

- Josef
</t>
<t tx="T591">@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list &amp; schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 
 
2. XML as a @language. (I set @comments and that works so maybe that is all I need)
 
3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

4. Integration with IDLEfork vs IDLE - not sure if this is important or even difficult but I like IDLEfork since I get to run my program in a separate thread. 

-marshall-  
</t>
<t tx="T592">Possible option: ignore all comments.
Possible option: recurse into subdirectories.
			
I had originally thought that the following options would be good to have. (leoComparePanel.browser would have brought up a panel with these options on it.)  I have my doubts now: it's easy enough for the user to create derived files in some directory.  It's probably best to separate file creation from file comparison.

radio box: Select file
radio box: Select all files in directory
radio box: Select all files in directory with extension: box
radio box: Use nodes from outline (give name)
	radio box: Use nodes in selected outline
	radio box: Use nodes in entire outline
	
	radio box: Use only @file nodes
	radio box: Use only @file nodes
	radio box: Use both @file and @root nodes</t>
<t tx="T593">I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new"&gt;ftp://user:pass@ftp.sd.org/python/foo.py&gt; 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?</t>
<t tx="T594">@nocolor

Developers
By: jasonic ( Jason Cunliffe ) 
 @dictionary   
2003-08-21 07:51  
Auto-completion dictionary files would be excellent.
Ideally each Leo language extension could just point to a separate .dict file. 

Hopefully we can build some Leo plugin utilities to generate these .dict files by parsing any file you'd like to use a 'source' for Leo dictionary. They might need manual cleanup, but vcould be big timesaver, especially for XML formats and the like. Great to be able to sahre these easily. 

Interesting uses for Leo dictionaries beyond just autocompletion. 
I am thinking they might open the door to some powerful macro/template behavior. 

For example, you load a special dictionary to help certain kinds of repetitive formatted content. CSS and XSLT could be good candidates, but also any kind of mild databases or lists. Documentation.

So first we need basic dicts for Leo supported languages: Python, Perl, Javascript etc..

Then we need to consider that any Leo Node could have its own dictionary defined inline..

@dictionary filepath-to-custom-leo-dict

With collaborative LeoN this would be very useful because connected Leo sessions could invoke each other's dictionaries!!

- Jason  
</t>
<t tx="T595"></t>
<t tx="T596">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name &lt;&lt;x&gt;&gt;. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not &lt;&lt;x&gt;&gt;, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler &amp; more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type &lt;&lt;name&gt;&gt;
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
</t>
<t tx="T597">By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
</t>
<t tx="T598"></t>
<t tx="T599"></t>
<t tx="T600"></t>
<t tx="T601">Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
</t>
<t tx="T602">Jonathan M. Gilligan

Autocompletion of some sort (like IDLE's edit/expand-word command). It would be
nice also to have an autocompletion for noweb node names, possibly also with
autocompletion of abbreviations (as many text editors do) and/or
language-specific keywords taken from a dictionary selected by @language.
</t>
<t tx="T603">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
</t>
<t tx="T604">I want to share a large Leo outline. New ideas come up aso people wnat ot keep adding fresh node headings and content. Often that content is clones from of toher distant parts of the tree. So one has to go off and search them, then create clone and drag it back to the new context wher yuo want to use it. I found quickly this is quite diffiucult to navigate. A lot of searching back an and forth and scrolling. Hard to keep a sequence. 

I tried using the 'mark' functions [ctrl+ m, alt+m] 
They are good,I cannot see how one can control them very well. ALT+m just keeps jumping one around the tree unitl it has visited all the marks. 

In many cases I imagine one simply needs to open a node, mark it and then jamp bacc to the last/previous node. Else do the same thing with marks. 

But what I am really looking for is a way to create a list of marks, and then be able to step through them sequentially. 

I think there is great uses for this. Your How-to for example lists a sequence of steps programmers need to follow. 

Imagine if one had an efficient 'Leo way' to help that How-to creation process. Or to preparare a review sequence to co-authors, colleagues, managers etc.. Or for tutorials and other Leo applications. 

Yes this is largely what Screenbook Maker XSLT does. But why not keep the functionality right within Leo. 

It could work along the lines of macro/history used in prgorams like photoshop. 

1. start sequence recorder, naming a sequence 
2. perform action, in this case navigate to the node you want. 
3. mark it to be added to the sequence 
4. go on to the next one 
5.repeat until done 
6. end sequence 

Using it 
7. Select "go to sequence" from menu or click on a Leo 'sequence' node. 
8. alt+something lets you jump through the list 
9. at the end you return to the beginning 

Editing 
10. It is important to be able to edit these on fly 
11. add delete reorder 
12. renaming shoudl also be allowed 

TreeSeqs 
13. Since this is Leo, people may naturally want to join sequences and thus add branches to existing sequences. This gets a little tricky becuase a sequence is by default a linear progression. 
So how best to enable the switch/troute action when it meets a branch? 

Status feedback 
14. Dedicated Leo sequence nodes should perhaps be a separate category with a graphic icon/fill color to help see them. Irefer to nodes which are a full set of sequences. 

15. likewise we should perhaps add an @seq symbol 

16. But also one may want to just embed seqs within other ergular Leo nodes, content. When we add a node to part of sequence how best to indicate. marked nodes geta little red vertical line. Sequenced marks should indicate, pehaps via its index number within the seqquence.The Leo log window coudl give more info. 

17. A sequence syntax might be: 
@seq seqname seqindex seqtitle 

seqname - unique name of leo sequence local to this .leo file 
examples: "howto33" or "gettingstarted" 

seqindex - unique integer controlling where this netry appears in the named Leo sequence 

seqtitle - text string which is more human readable than seqname' For the sequence itself this would be its disaplyed title. Wihtin a sequence for an entry, it woudl be the huam readbale idplasy title to ct as a metadata alais to its Leo node name. This improtant because the use context may change but we donlt want to fuck up the existing base Leo outline in any way. 

Conversions 
18. Sometimes you may want to take an exisiting bnode and sub-nodes and be able to do a "print-to-seq" on them. For example you already have 'diary' entries which have a clear historical order. But it might be useful to generate a Leo sequence of those. Then perhaps edit he sequence so it just highlights key events in the diary. Likewise any set of changes and extensions to a project. 

Implementation 
19. I imagine 90% of what I propose already exists in Leo. For many situation sequences are not suitable. People wil want ot be freeer. But for others, especially in project planning, management, presentation, training and fast review, I think they are invaluable. I see sequences as a full complent to Leo existing modes. 

20. I would be delighted to work on this, but need tmie as I am a complete Leo beginner. It is topic I spend a lot time with. Among possible tools to help prgram this there are sequential dictionaries. The module I like and have used in the past is by 'seqdict' by Wolfgang Grafen: 

http://home.germany.net/100-366919/Python/Modules/Modules.html 

I used it in conjucntion with the wonderful mxDateTime package for a Zope project about 2 years ago. 
http://www.egenix.com/files/python/mxDateTime.html 

./Jason 
</t>
<t tx="T605"></t>
<t tx="T606">I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
</t>
<t tx="T607">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1759009
By: davidmcnab

Hi,

I know I've put this one before, but as I use Leo more and more, the lack of
this is really pressing.

I tried your previous suggestion - opening another editor to have a view of
the file, but this is really painful, especially when I'm wanting to work on
two or more files simultaneously.

I've tried having files open in Emacs and writing them out, then doing a 'read
@file nodes', but this doesn't always work - the changes made in Emacs aren't
getting incorporated into the Leo tree (unless I quit/restart Leo).

(BTW - I'm using latest CVS of Leo).

What would make for Total Hacking Heaven is the ability to split a body pane
vertically or horizontally, and to be able to split the sub-panes
vertically/horizontally.

What that, hotkeys would move the cursor between panes (ie make different panes
'active'). Also, clicking on a node would display that node in the *currently
active* body pane.

This in place, as well as an accurage 'goto line number' feature would make
Leo even more of a killer app.

Cheers
David

</t>
<t tx="T608">@ignore

- Create these files in examples folder.

- Use Import commands to create Leo outlines.
</t>
<t tx="T609">Save the following code as "leo_interface.py". 


"""
This file implements an interface to XML generation,
so that the resulting file can be processed by leo.

It can be used to browse tree structured data in leo.

class file represents the whole leo file.
class leo_node has a headline and body text.

See the end of this file for a minimal example on
how to use these classes.
"""
class node:
    """
    
    Abstrace class for generating xml.
    
    """
    def __init__(self):
        self.children = []

    def gen(self, file):
        pass

    def add_child(self, child):
        self.children.append(child)

    def mark(self, file, marker, func, newline=True):
        file.write("&lt;%s&gt;" % marker)
        if newline:
            file.write("\n")
        func(file)
        file.write("&lt;/%s&gt;\n" % marker)
        
    def mark_with_attributes(self, file, marker, attribute_list, func, newline=True):
        write = file.write
        write("&lt;")
        write(marker)
        write(" ")
        for name, value in attribute_list:
            write('%s="%s" ' % (name, value))
        write("&gt;")
        if newline:
            write("\n")
        func(file)
        write("&lt;/%s&gt;" % marker)
        if newline:
            write("\n")
                      
    def mark_with_attributes_short(self, file, marker, attribute_list):
        write = file.write
        write("&lt;")
        write(marker)
        write(" ")
        for name, value in attribute_list:
            write('%s="%s" ' % (name, value))
        write("/&gt;\n")
                      
    def gen_children(self, file):
        for child in self.children:
            child.gen(file)
        
class file(node):
    """
    Leo specific class representing a file.
    """
    def header(self, file):
        self.mark_with_attributes_short(file, "leo_header",
                                  (("file_format", "1"),
                                   ("tnodes", `self.nr_tnodes()`),
                                   ("max_tnode_index", `self.max_tnode_index()`),
                                   ("clone_windows", "0")))

    def sss(self, file):
        file.write("sss")
        
    def preferences(self, file):
        pass

    def empty(self, file):
        pass
    
    def find_panel_settings(self, file):
        self.mark(file, "find_string", self.empty, newline=False)
        self.mark(file, "change_string", self.empty, newline=False)
    
    def gen(self, file):
        file.write('&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n')
        self.mark(file, "leo_file", self.gen1)

    def gen1(self, file):
        self.header(file)

        # This is a shortcut.
        file.write("""&lt;globals body_outline_ratio="0.5"&gt;
	&lt;global_window_position top="0" left="2" height="20" width="20"/&gt;
	&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
        """)
        self.mark(file, "preferences", self.preferences)
        self.mark(file, "find_panel_settings", self.find_panel_settings)
        self.mark(file, "vnodes", self.gen_vnodes)
        self.mark(file, "tnodes", self.gen_tnodes)

    def gen_vnodes(self, file):
        for child in self.children:
            child.gen_vnodes(file)

    def gen_tnodes(self, file):
        for child in self.children:
            child.gen_tnodes(file)

    def nr_tnodes(self):
        return leo_node.count
    
    def max_tnode_index(self):
        return leo_node.count
        
    
class leo_node(node):
    """
    Leo specific class representing a node.
    """
    count = 0
    
    def __init__(self, headline='', body=''):
        node.__init__(self)
        leo_node.count += 1
        self.nr = leo_node.count
        self.headline =  headline
        self.body = body

    def set_headline(self, headline):
        self.headline = headline

    def set_body(self, body):
        self.body = body

    def gen_vnodes(self, file):
        self.mark_with_attributes(file, "v", (
            ("t", "T" + `self.nr`),
            ), self.gen_vnodes1)

    def gen_vnodes1(self, file):
        self.mark(file, "vh", self.get_headline_escaped, newline=False)
        for child in self.children:
            child.gen_vnodes(file)

    def get_headline(self, file):
        file.write(self.headline) 
        
    def gen_tnodes(self, file):
        self.mark_with_attributes(file, "t", (
            ("tx", "T" + `self.nr`),
            ), self.gen_tnodes1, newline=False)
        for child in self.children:
            child.gen_tnodes(file)

    def gen_tnodes1(self, file):
        self.get_body_escaped(file)

    def get_body(self, file):
        file.write(self.body) 

    def get_headline_escaped(self, file):
        "For now, do not escape"
        self.get_headline(file)

    def get_body_escaped(self, file):
        "For now, do not escape"
        self.get_body(file)
        
def leotree():
    f = file()
    return f

if __name__ == "__main__":
    import sys
    f = leotree()
    r = leo_node("Some headline", "some Body")
    f.add_child(r)
    f.gen(sys.stdout)



Last modification date: Thursday 08 of May, 2003 [02:22:19 GMT] by anonymous



--------------------------------------------------------------------------------

print edit history backlinks similar 
</t>
<t tx="T610">Save the following text as "foldersize_leo.py". 


"""

Calculate the foldersizes; generate XML file for leo to display results.

Parameters:
   foldersize_leo.py &lt;xmlfile&gt; [directory] *
   
Returns for each directory:
    - size in bytes
    - number of files
    - number of subdirectories
    
Currently only works on Windows.

Does not take into account compression on Windows.

"""
import sys
import os
import string
import stat
import getopt

import leo_interface

comma = ','
intsize = 10

def normalize(filename):
   """This should probably be changed for Linux"""
   return string.replace(os.path.normpath(string.lower(filename)), '\\', '/')

def filesize(fullname):
   return long(os.stat(fullname) [stat.ST_SIZE])

def format(value, size):
    """Insert 'comma' into the representation of value for easier reading"""
    if value==0:
        result = '0'
    else:
        result = ''
        negative = value &lt; 0
        if negative:
            value = - value
        underbar = 4
        while value != 0:
            underbar = underbar - 1
            if underbar == 0:
                result = comma + result
                underbar = 3
            newvalue = value / 10
            rest     = int(value - newvalue*10)
            result = `rest` + result
            value = newvalue
        if negative:
            result = '-' + result
    if len(result) &lt; size:
        result = ' ' * (size - len(result)) + result
    return result
                        
files = {}

class TreeItem(leo_interface.leo_node):
    def __init__(self, path):
       leo_interface.leo_node.__init__(self)
       self.path = normalize(path)
       if files.has_key(self.path):
          el = files[self.path]
          self.filesize = el.filesize
       files[self.path] = self
       self.dircount = 1
       self.filecount = 0
       self.filesize = 0
       subdirs = self.GetSubList()
       if subdirs:
          for subdir in subdirs:
             self.filecount = self.filecount + subdir.filecount
             self.dircount = self.dircount + subdir.dircount
             self.filesize = self.filesize + subdir.filesize
             self.add_child(subdir)
       else:
          self.dircount = 0L
          self.filecount = 1L
          try:
             self.filesize = filesize(self.path)
          except EnvironmentError, value:
             print "Sorry:, could not stat %s" % self.path, value
             self.filesize = -1L
       self.set_headline(self.get_headline_text())

    def get_headline_text(self):
        name = os.path.basename(self.path) or self.path
        return ("%s %s %s %s" % (name,
                                 format(self.filesize, intsize),
                                 format(self.filecount, intsize),
                                 format(self.dircount, intsize)))

    def GetSubList(self):
        try:
            names = os.listdir(self.path)
        except os.error:
            return []
        sublist = []
        join = os.path.join
        for name in names:
            normpath = normalize(join(self.path, name))
            if files.has_key(normpath):
                item = files[normpath]
            else:
                item = TreeItem(join(self.path, name))
            sublist.append(item)
        sublist.sort(lambda a, b: cmp(b.filesize, a.filesize))
        return sublist

def test():
   try:
      opts, values = getopt.getopt(sys.argv[1:], '', [])
   except:
      print __doc__
      return
   
   if len(values) &lt; 1:
      print __doc__
      return
   
   resultfile = values[0]
   leotree  = leo_interface.leotree()
   roots = [TreeItem(root) for root in values[1:]]
   for root in roots:
      leotree.add_child(root)
   file = open(resultfile, "w")
   leotree.gen(file)
   file.close()

if __name__ == '__main__':
   test()
</t>
<t tx="T611">The following items might be nice, and they just don't seem very important to me.</t>
<t tx="T612"></t>
<t tx="T613">@nocolor

It might be very useful to have the option to include files from a list. For
example one could point it at an external text file called 'leolist.txt'

c:\rebol\view\downloads\
e:\leo\newideas.txt
d:\outlines\latestnotes\

and it would just pass all those in as if they were part of dir in the above script.

EKR: There is a script that can do this, and we can't change the Tk dialogs.</t>
<t tx="T614">This may not be possible in Python.

A "Recent Files" menu is sufficient.</t>
<t tx="T615">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1861038
By: korakot

I would like leo to have something similar to call tips
for the tree pane. It's always inconvenient that I must
resize the pane just to read the full headString.
Allowing horizontal scroll is an option, though I prefer
that leo could popup a call tip of the full headstring
when the full headstring could not be display.

Please see how 'windows explorer' do this. It help
my 'exploring' a lot.
</t>
<t tx="T616"></t>
<t tx="T617"></t>
<t tx="T618">Basically, javadoc in the following form: 

/** 
* Returns a JNDI context that can be used to lookup 
references 
* to EJB's. 
*/ 

appears like this after a save: 

/* 
* * Returns a JNDI context that can be 
used to lookup references * to EJB's. 
*/ </t>
<t tx="T619">Contract All keeps current text pane 

Leo/PC 1.13 Windows 98SE/J 

Category: Editor/Display 

Clicking on [-] of the root node in the LEO file displays the text pane of the root node. 
Contract All should probably do the same. It keeps open the text pane that was open before. 
</t>
<t tx="T620">Leo/PC 1.13 Windows 98SE/J 

Category: Editor/Clipboard

Make a node with empty header and empty body. 
With that header selected. 
Shift-Ctrl-C 
Shift-Ctrl-V 
Errors: 
1. The clipboard is not a valid Leo outline. 
2. The clipboard is not a valid LEO file. 

Type this in the header: head 
With that header selected. 
Shift-Ctrl-C 
Shift-Ctrl-V 
The same errors persists. 

Type this in the text: 
--- Top --- 
text 
--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 
--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 

--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 
@ 
--- End --- 
The node is now copied. 

Sometimes it is not possible to get out of this state when no node can be copied to the clipboard. 
I have to close the file and load it again to clear the problem. </t>
<t tx="T621">@ignore

Leo/PC 1.13 Windows 98SE/J 

Category: Tangle/Error handling

I copied a @root directive and forgot to change the file name. 
I had something like this: 

@root ./a.txt 
@ 

@root ./a.txt 
some text 
@ 

Ctrl-Shift-A resulted in a never ending Tangle run, 
with repeated line in the log window: 
Unchanged: ./a.txt 

I did not find a way to stop this. I had to shut down Windows. 
I am afraid to repeat this. If you cannot reproduce this problem, I will try again. </t>
<t tx="T622"></t>
<t tx="T623">@color

@ To do:
	
	- Play with re module: does r"\n" work?
	</t>
<t tx="T624">import re
from leoGlobals import *

s = """@doc line 0
line 1d
line 2
@c

# a comment

def abc(self): xx

after 1
after 2"""

pat = re.compile("""^(@$|@ |@doc)(.*?)$
^@c[ \t]*(.*?)$
^(def[ \t]*.*?:.*?)$
(.*)""", re.MULTILINE | re.DOTALL)

m = pat.match(s)
print "---"
if m:
	print "doc:   ", `m.group(2).strip()`
	print "blanks:", `m.group(3).strip()`
	print "def:   ", `m.group(4).strip()`
	print "rest:  ", `m.group(5).strip()`
else:
	print "no match"
</t>
<t tx="T625">import re
from leoGlobals import *

docPart = re.compile("""^(@$|@ |@doc)(.*)$
^@c[ \t]*(.*?)$
^(def[ \t]*.*?:.*?)$
(.*)""", re.MULTILINE | re.DOTALL)

@others

print __name__,

replaceDocParts()

</t>
<t tx="T626">def replaceDocPart(m):

	doc = m.group(2).strip()
	blanks = m.group(3).strip()
	if blanks: blanks += "\n\n"
	else: blanks = ""
	defLine = m.group(4)
	rest = m.group(5)
	docList = doc.split('\n')
	doc = string.join(docList,"\n\t")
	return blanks + defLine + '\n\n\t"""' + doc + '"""\n\n' + rest
</t>
<t tx="T627">def replaceDocParts(root=None):

	c = top()
	if not root: root = c.currentVnode()
	count = 0 ; found = 0 ; changed = 0
	v = root
	while v:
		s = v.bodyString()
		m = docPart.match(s)
		count += 1
		if m:
			found += 1
			s = replaceDocPart(m)
			if s:
				changed += 1
				#print ; print s
		v = v.threadNext()

	print "count, found, changed:", `count`,`found`,`changed`</t>
<t tx="T628">http://www.reportlab.com

import xml.sax
</t>
<t tx="T629"></t>
<t tx="T630"></t>
<t tx="T631"></t>
<t tx="T632">It will be a subcommander.</t>
<t tx="T633">@color</t>
<t tx="T634"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self, p):

	result = true # optimists get only unpleasant surprises.
	parent = self.parent()
	childIndex = self.childIndex()
	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	# Recursively validate all the children.
	child = self.firstChild()
	while child:
		r = child.validateOutlineWithParent ( self )
		if not r: result = false
		child = child.next()
	return result</t>
<t tx="T635">if parent != p:
	self.invalidOutline ( "Invalid parent link: " + parent.description() )</t>
<t tx="T636">if p:
	if childIndex &lt; 0:
		self.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex &gt;= p.numberOfChildren():
		self.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
	self.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="T637">if not self.t and p:
	self.invalidOutline ( "Empty t" )</t>
<t tx="T638">def createTopologyList (c=None,root=None,useHeadlines=false):
	
	"""Creates a list describing a node and all its descendents"""
	
	if not c: c = top()
	if not root: root = c.rootVnode()
	v = root
	if useHeadlines:
		aList = [(v.numberOfChildren(),v.headString()),]
	else:
		aList = [v.numberOfChildren()]
	child = v.firstChild()
	while child:
		aList.append(createTopologyList(c,child,useHeadlines))
		child = child.next()
	return aList</t>
<t tx="T639"></t>
<t tx="T640"></t>
<t tx="T641"></t>
<t tx="T642"></t>
<t tx="T643">@nocolor</t>
<t tx="T644"></t>
<t tx="T645">Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu. </t>
<t tx="T646"></t>
<t tx="T647">@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
</t>
<t tx="T648">abc bbb bbbxyz bbb</t>
<t tx="T649">def canPasteOutline (self,s=None):

	c = self
	if s == None:
		try:
			s = app.root.selection_get(selection="CLIPBOARD")
		except:
			return false

	# trace(s)
	if match(s,0,app.prolog_prefix_string):
		return true
	elif len(s) &gt; 0:
		return c.importCommands.stringIsValidMoreFile(s)
	else:
		return false</t>
<t tx="T650"></t>
<t tx="T651">def cutOutline(self):

	c = self
	if c.canDeleteHeadline():
		c.copyOutline()
		c.deleteHeadline("Cut Node")
		c.recolor()</t>
<t tx="T652">def copyOutline(self):

	c = self
	c.endEditing()
	c.fileCommands.assignFileIndices() # Revert to 3.11.1 code.
	s = c.fileCommands.putLeoOutline()
	# trace(`s`)
	app.root.clipboard_clear()
	app.root.clipboard_append(s)
	# Copying an outline has no undo consequences.
</t>
<t tx="T653">@ To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.
@c

def pasteOutline(self):

	c = self ; current = c.currentVnode()
	
	try:
		s = app.root.selection_get(selection="CLIPBOARD")
	except:
		s = None # This should never happen.

	if not s or not c.canPasteOutline(s):
		return # This should never happen.

	isLeo = match(s,0,app.prolog_prefix_string)

	# trace(`s`)
	if isLeo:
		v = c.fileCommands.getLeoOutline(s)
	else:
		v = c.importCommands.convertMoreStringToOutlineAfter(s,current)
	if v:
		c.endEditing()
		c.beginUpdate()
		if 1: # inside update...
			v.createDependents()# To handle effects of clones.
			c.validateOutline()
			c.selectVnode(v)
			v.setDirty()
			c.setChanged(true)
			# paste as first child if back is expanded.
			back = v.back()
			if back and back.isExpanded():
				v.moveToNthChildOf(back,0)
			c.undoer.setUndoParams("Paste Node",v)
		c.endUpdate()
		c.recolor()
	else:
		es("The clipboard is not a valid " + choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="T654"></t>
<t tx="T655">def bound_paragraph(t=None):
	"""Find the bounds of the text paragraph that contains the current cursor position.
	
t: a Tk.Text widget

Returns:
	None if the cursor is on a whitespace line or a delimeter line.
	Otherwise: (start,end,endsWithNL,wsFirst,wsSecond)

start: the paragraph starting position,
end: the paragraph ending position,
endsWithNL: true if the paragraph ends with a newline"""

	if not t: return None
	x=t.index("insert")
	
	# Return if the selected line is all whitespace or a Leo directive.
	s = t.get(x+"linestart",x+"lineend")
	s = toUnicode(s,app.tkEncoding) # 9/28/03
	if not s or s.isspace() or s[0] == '@':
		return None 

	# Point start and end at the start and end of the selected line.
	start = t.index(x+"linestart")
	tmpLine = int(float(start))
	end = str(tmpLine + 1) + ".0"
	
	# EKR: This is needlessly complex.
	# It would be much easier to use a list of lines,
	# rather than asking TK to do so much work.

	# Set start to the start of the paragraph.
	while (tmpLine &gt; 1):
		tmpLine -= 1
		tmp = str(tmpLine) + ".0"
		s = t.get(tmp,tmp+"lineend")
		if len(s)==0 or s.isspace() or s[0] == '@':
			break
		start = tmp

	# Set end to the end of the paragraph.
	tmpLine = int(float(end))
	bodyEnd = t.index("end")

	while end != bodyEnd:
		end = str(tmpLine) + ".0"
		s = t.get(end,end+"lineend")
		s = toUnicode(s,app.tkEncoding) # 9/28/03
		if not s or s.isspace() or s[0] == '@':
			break
		tmpLine += 1

	# do we insert a trailing NL?
	endsWithNL = len(t.get(end))

	return start, end, endsWithNL</t>
<t tx="T656">def getindex(text, index):
	
	"""Convert string index of the form line.col into a tuple of two ints."""
	
	return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="T657">def getAllText (t):
	
	"""Return all the text of Tk.Text t converted to unicode."""
	
	s = t.get("1.0","end")
	if s is None: s = u""
	return toUnicode(s,app.tkEncoding)

def getSelectedText (t):
	
	"""Return the selected text of Tk.Text t converted to unicode."""

	start, end = getTextSelection(t)
	if start and end and start != end:
		s = t.get(start,end)
		if s is None: s = u""
		return toUnicode(s,app.tkEncoding)
	else:
		return None</t>
<t tx="T658">def getTextSelection (t):
	
	"""Return a tuple representing the selected range of t, a Tk.Text widget.
	
	Return a tuple giving the insertion point if no range of text is selected."""

	# To get the current selection
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		return sel
	else:
		# 7/1/03: Return the insertion point if there is no selected text.
		insert = t.index("insert")
		return insert,insert</t>
<t tx="T659">@ t is a Tk.Text widget.  start and end are positions.  Selects from start to end.
@c

def setTextSelection (t,start,end): 

	if not start or not end:
		return

	if t.compare(start, "&gt;", end):
		start,end = end,start
		
	t.tag_remove("sel","1.0",start)
	t.tag_add("sel",start,end)
	t.tag_remove("sel",end,"end")
	t.mark_set("insert",end)</t>
<t tx="T660">@nocolor
Help forum
By: wgw ( W. Winder ) 
 Bug? Node only search and replace   
2003-08-16 18:23 

Leo Log Window...
Leo 3.12, Python 2.2.2, Tk 8.3.2

I tried to do a node-only search and replace, hit change all, and it replaced everything in the Leo file. 

Is this normal behaviour? (I.e. change all can be limited to a single node...)

My impression is that there is a bug in the search and replace function.

------------

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2164991
By: wgw

I have a work-around that solves the problem for me (and even allows regular
expressions if I want to tweak it). That's amazing coming from someone who doesn't
know python. A bit of a tribute to you and Leo -- it is well documented.

The solution is essentially a plugin, though I haven't yet figured out how to
add it to the plugin menu. (when the menu loads it says 8 loaded and 33
examined!)

My next job is to understand plugins better. For the moment they are a bit of
a mystery, but that is just because I haven't read the doc well enough.

In short, no rush for the bug fix; plugins will do it. 


from string import replace
from leoPlugins import *
from leoGlobals import *
# from leoNodes import *

# Return a list of v's children.
def children (v):
result = []
child = v.firstChild()
while child:
result.append(child)
child=child.next()
return result

def replace_headline(event=None):
c=top().rootVnode()  # get the commander for the topmost outline window.
#start at the current node (need safety features here to warn that suboutline
will be altered)
v=c.currentVnode() # get the current vnode.
d=children(v) 
for e in d:
e.setHeadStringOrHeadline(replace(e.headString(),'@file','@nosentinelsfile'),1
)



</t>
<t tx="T661"></t>
<t tx="T662"></t>
<t tx="T663">a

aa</t>
<t tx="T664">This node should not be searched.

a

aa</t>
<t tx="T665">This node should not be searched.

a

aa</t>
<t tx="T666"># Sets config ivars from c.

def setConfigFindIvars (self,c):
	
	findFrame = app.findFrame

	# N.B.: separate c.ivars are much more convenient than a dict.
	for s in findFrame.intKeys:
		val = getattr(c,s+"_flag")
		# trace(val,s+"_flag")
		self.setFindPref(s,val)
	
	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T667"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsFindIvars (self,c):
	
	if app.gui.guiName() != "tkinter":
		trace()
		return

	config = self ; findFrame = app.findFrame

	# N.B.: separate c.ivars are much more convenient than a dict.
	for s in findFrame.intKeys:
		val = config.getBoolFindPref(s)
		if val != None: # 10/2/03
			setattr(c,s+"_flag",val)
			# trace(s+"_flag",val)
			
	val = config.getStringFindPref("change_string")
	if val: c.change_text = val
	
	val = config.getStringFindPref("find_string")
	if val: c.find_text = val

	app.findFrame.init(c)</t>
<t tx="T668">def getFindPanelSettings (self):

	c = self.commands ; config = app.config ; findFrame = app.findFrame
	&lt;&lt; Set defaults of all flags &gt;&gt;
	if not self.getOpenTag("&lt;find_panel_settings"):
		while 1:
			if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
			elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
			elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
			elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
			elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
			elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
			elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
			elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
			elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
			elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
			elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
			elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
			else: break
					
		self.getTag("&gt;")
		#
		self.getTag("&lt;find_string&gt;")
		c.find_text = self.getEscapedString()
		self.getTag("&lt;/find_string&gt;")
		#
		self.getTag("&lt;change_string&gt;")
		c.change_text = self.getEscapedString()
		self.getTag("&lt;/change_string&gt;")
		#
		self.getTag("&lt;/find_panel_settings&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	config.setCommandsFindIvars(c)
	# Update the settings immediately.
	if app.gui.guiName() == "tkinter":
		app.findFrame.init(c)</t>
<t tx="T669">if app.gui.guiName() == "tkinter":

	for var in findFrame.intKeys:
		attr = "%s_flag" % (var)
		setattr(c,attr,false)
</t>
<t tx="T670">def putFindSettings (self):

	c = self.commands ; config = app.config

	self.put("&lt;find_panel_settings")
	
	&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/find_panel_settings&gt;") ; self.put_nl()</t>
<t tx="T671">if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put_flag(c.batch_flag,"batch")
	self.put_flag(c.ignore_case_flag,"ignore_case")
	self.put_flag(c.mark_changes_flag,"mark_changes")
	self.put_flag(c.mark_finds_flag,"mark_finds")
	self.put_flag(c.pattern_match_flag,"pattern_match")
	self.put_flag(c.reverse_flag,"reverse")
	self.put_flag(c.search_headline_flag,"search_headline")
	self.put_flag(c.search_body_flag,"search_body")
	self.put_flag(c.suboutline_only_flag,"suboutline_only")
	self.put_flag(c.whole_word_flag,"whole_word")
	self.put_flag(c.wrap_flag,"wrap")
	self.put_flag(c.node_only_flag,"node_only")

self.put("&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;find_string&gt;&lt;/find_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;find_string&gt;") ; self.putEscapedString(c.find_text)
	self.put("&lt;/find_string&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;change_string&gt;&lt;/change_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;change_string&gt;") ; self.putEscapedString(c.change_text)
	self.put("&lt;/change_string&gt;") ; self.put_nl()</t>
<t tx="T672"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

	c = self.commands

	if not c.search_headline_flag and not c.search_body_flag:
		return None, None

	if len(c.find_text) == 0:
		return None, None
		
	v = self.v
	while v:
		pos, newpos = self.search()
		if pos:
			if c.mark_finds_flag:
				v.setMarked()
				c.frame.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
			return pos, newpos
		elif c.node_only_flag:
			# We are only searching one node.
			return None,None
		else:
			v = self.v = self.selectNextVnode()
	return None, None</t>
<t tx="T673">@nocolor

https://sourceforge.net/forum/message.php?msg_id=1935163
By: nobody
Open Discussion

xyz.leo is not a valid Leo file: &lt;leoFileCommands.BadLeoFile instance at
0x01789A70&gt;

apparently there isnt any filtering done on save. that could be a problem if
people start embedding binary. I had a section in a body like this: 0000: c0 23
01 01 00 30 1a 75 | .#...0.u there was an actual 0x1a in the file which wrote
ok read incorrect if you can catch the exception maybe there is a possibilty to
recover and just xlate 0x1a to '~' and mark the node?</t>
<t tx="T674"></t>
<t tx="T675">import win32clipboard</t>
<t tx="T676">@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.</t>
<t tx="T677">@nocolor

 line-continuation backslash character problem   
2003-08-01 16:07
Help Forum

Hello, 

I imported as @file a python file, and there's a line with a line-continuation backslash that gets split in two parts, and then this causes a syntax error when running the program. To show what happened, I give first what the code should be, and then what it was when imported as @file in leo. The problem is with the line-continuation ending in "% self.__d" 

should be : 

******************** 
#@-body 
#@-node:1::__init__ 
#@+node:2::get_corner 
#@+body 
def get_corner(self): 
rootdir = self.__linkfixer.rootdir() 
return ''' 
&lt;center&gt; 
&lt;a href="%(rootdir)s/index.html"&gt; 
&lt;img border="0" src="%(rootdir)s/images/Yann_Le_Du.jpg"&gt;&lt;/a&gt;&lt;/center&gt;'''\ 
% self.__d 

#@-body 
#@-node:2::get_corner 
#@+node:3::get_corner_bgcolor 
#@+body 
def get_corner_bgcolor(self): 
return 'black' 
******************************************* 

was first interpreted as : 

******************************************** 
#@-body 
#@-node:1::__init__ 
#@+node:2::get_corner 
#@+body 
def get_corner(self): 
rootdir = self.__linkfixer.rootdir() 
return ''' 
&lt;center&gt; 
&lt;a href="%(rootdir)s/index.html"&gt; 
&lt;img border="0" src="%(rootdir)s/images/Yann_Le_Du.jpg"&gt;&lt;/a&gt;&lt;/center&gt;'''\ 

#@-body 
#@-node:2::get_corner 
#@+node:3::get_corner_bgcolor 
#@+body 
% self.__d 
def get_corner_bgcolor(self): 
return 'black' 

*********************************************** 

So I just manually changed the code in the leo windows, and it works fine now, but shouldn't it be automatic ? 

Thanks, 

Yann Le Du
</t>
<t tx="T678"></t>
<t tx="T679">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2106915
By: jasonic

Leo 3.12 beta 3, Python 2.2.2, Tk 8.3.2 [Win 98se]

I am finding 3.12b3 is behaving a litle oddly with regard to window
positioning.

I used LeoConfig.leo to set my windows to 1024x768 and locate at (0,0). Checked
to make sure this is ok in LeoConfig.txt

It was not working until I looked more closely in LeoConfig.txt 
Then I realized there are many values under [window options] section which are
not referred to in LeoConfig.leo.

For example for widnow positioning I was interested in the following, which
I 've change from the default:

initial_window_height = 768
initial_window_top = 0
initial_window_left = 0
initial_window_width = 1024

Those almost get it right. A nwe empty Leo proejct is now 1024x768 in the top
left corner. But it does not quite look right -- it's extending off the screen
or overklapping windows tool bar at teh bottom utnmil I click its 'maxmize'
button. then it sanps right into correct position.

I tested another common scenario --  
a. open a LEo project of mine 
b. mazximize it
c. save
d. quit
e. re-open

It opens at 1024x768 ok, but is off by 20 pixels top and left. Here's a
snapshot:
http://tranzilla.net/uploads/webform/leo_launch_position_000.gif

Whatever the interface to settign LeoConfig turns out to be, I think we really
need an option to spcify windows opening maximized or minimized, and to remember
their last size and location when you save them.

I know you've got a looong list of features and design changes to do already,
plus 312 finalalizing. So this is not critical path to the heart of Leo.

But for daily ease of use these details do matter. I suspect Tk may be a little
awkwards, or probably this is Win32-only issue. If you can shed any light on
the topic thus far, and perhaps point to where it might be fixed, I'll try to
take a look closer myself.


thanks again
Jason
</t>
<t tx="T680">@nocolor

I would add to this list, "remembering the outline/log window split position". </t>
<t tx="T681">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2106966
By: paulpaterson

&gt; I think we really need an option to spcify windows opening maximized or minimized,
and to remember their last size and location when you save them.

On a slightly different, but related, note - the Find window. There was some
discussion on this. The new window looks great but, for the common case of a
simple search is using way too much screen real estate!

For me, the common case of a search is,

1. I open the find
2. I type the word in the box
3. I leave all settings alone
4. I click "Find"
5. I click "Find again" ...

I could get away with a text box and a find button ... 

What about a plug-in (or built-in) which places a text box + "Go" button in
the top right edge of the button bar. Pressing the "Go" would do a find/find
next using the current Find panel settings.

1. Makes the common case very easy - no obscuring of the screen or find window
going behind the main one
2. CTRL-F could still go to the main find panel if you need more
3. The text box could be a combo box with previously used "quick find" words
in it.
4. Uses a common web idiom so should be immediately familiar to users and should
integrate well with LeoN

Paul

</t>
<t tx="T682"></t>
<t tx="T683">@nocolor</t>
<t tx="T684">By: edcdave ( David Harris ) 
 Extract lops leading slash from new headline   
2003-07-20 23:42
Developers

Leading slashes are removed from the headline created via Extract. Perhaps this was done for some historical reason, but I don't see any restrictions now when I manually type a headline. For example, I did an Extract on: 

/* this set of lines should be in a separate node */ 
first test line 
second test line 

The new node ended up with a headline of "* this set of lines should be in a separate node */". Leo should not be doing this. 

The responsible code is in leoCommands.py/Edit Body Text/extract/&lt;&lt; set headline for extract &gt;&gt;. It looks like: 

headline = string.strip(headline) 
while len(headline) &gt; 0 and headline[0] == '/': 
headline = headline[1:] 
headline = string.strip(headline) 

By the way, a very similar section of code occurs in &lt;&lt; set headline for extractSection &gt;&gt;, but minus the initial strip(): 

while len(headline) &gt; 0 and headline[0] == '/': 
headline = headline[1:] 
headline = string.strip(headline) 

Here, the '/' removal appears to be unwarranted, because the headline is supposed to be a section name. That is, the line must begin with '&lt;&lt;' (although the code also permits '@&lt;') 

Which leads to my third post on Extract (coming right up...) 
 
</t>
<t tx="T685">https://sourceforge.net/forum/message.php?msg_id=2112738
By: edcdave

Extract Section is enabled when it should not be. (But &lt;&lt; set headline
for extractSection &gt;&gt; saves the day by exiting when the mandatory section name
is not found.)

The User Manual says:

"The Extract Section command creates a new node whose headline is the first
line of selected text and whose body is @code followed by all the other lines
of selected text.  All selected text lines except the first line are deleted
from the original body text. This command is enabled only if the first line
contains a section name (enclosed in angle brackets), on a line by itself."

The Extract Section feature is enabled when ANY selection is made. It just does
nothing if the first selected line is not a section name.

The trouble seems to be that ExtractSection was not completely implemented in
'Enabling Menu Items'. The current code is:

def canExtract (self):

c = self
if c.body:
i, j = getTextSelection(c.body)
return i and j and c.body.compare(i, "!=", j)
else:
return false

canExtractSection = canExtract
canExtractSectionNames = canExtract

which enables ExtractSection based on the same requirements as enabling
Extract.
</t>
<t tx="T686">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2112703
By: edcdave

I was learning about Extract and got confused when I referred to the User Manual
in LeoDocs.py.

"Chapter 5/Edit menu/Creating nodes from body text" says:

"The Extract command creates a new node whose headline is the first line of
selected body text and whose body is all following lines of body text.  All
selected text is deleted from the original body text. This command is enabled
only if the first line contains a section name (enclosed in angle brackets)
on a line by itself."

The last sentence should be deleted - Extract does not require a section name
(that's what confused me most, I couldn't see what was the difference between
Extract and Extract Section.)

And the first sentence should make clear that only the selected lines will be
moved to the new node. "...all following lines of body text." should be replaced
with "...all the other lines of selected text."

[Two more postings on Extract to follow]
</t>
<t tx="T687">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2112787
By: edcdave

This one may seem a little malicious, but Extract Section started it. If I had
done the same thing manually, I would acknowledge my ineptitude.

Create a node with a headline '@file ctest.c'. Enter the body text:
@language C
&lt;&lt; pseudo-section
int i = 0;

Select the last two lines and use Extract Section to create a section node.
Only it isn't really a section node. It lacks the '&gt;&gt;' delimiter.

Close the leo file. Re-open it. An error message 'error reading @file ctest.c'
is displayed, and the outline tree is shown minus the psuedo-section, and the
text from the body of the pseudo-section is shown in the referencing node. Saving
the leo file again eliminates the pseudo-section node.

The Extract Section side of the problem could be handled by tightening up the
&lt;&lt; set headline for extractSection &gt;&gt; code. (Or better yet, tackling my earlier
posting about the incorrect enabling of Extract Section.) The following change
might be appropriate. Add:

if headline[-2:] != '&gt;&gt;': return

This test should be safe because we already know that 'headline' is at least
2 characters long (we passed the test for '&lt;&lt;') This still does not address
the self-inflicted side. But maybe the user should pay attention to the
documentation!</t>
<t tx="T688"></t>
<t tx="T689">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
</t>
<t tx="T690">This is a test line.</t>
<t tx="T691">This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


</t>
<t tx="T692">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2232767
By: railbaron60

I'm using 4.0 beta 3 on Windows 2000, with python 2.3.2. I'm never quite sure
what to expect when importing C source and header files.

Sometimes when I import a C source file to @root the body text is merely the
functions in the original file. Other times it looks more like:

@ignore
@root foo.c
@language c
#ifndef INCLUDED_FOO_H
&lt;&lt; foo #includes &gt;&gt;
&lt;&lt; foo functions &gt;&gt;

In the above case, if I remove the @ignore directive, then tangling will write
the "@language c" directive to foo.c.

Importing C header files results in body text that starts with:

@ignore
@root foo.h

and ends with the rest of the header file contents.</t>
<t tx="T693">@ This part of the tree shows views of the outline related to specific projects or tasks.  I put such headlines in parentheses, and that is just my convention.

I create a new view by cloning headlines that relate to its task, and moving the cloned headlines under the task headline.  This greatly increases my focus.  Any changes made in a task view to clone headlines affect the other clones scattered throughout the outline.  In particular, all @file nodes containing changed clones become marked as dirty, so they will be written when the entire outline is saved.
@c

@ignore
@language python
</t>
<t tx="T694"></t>
<t tx="T695">@ignore</t>
<t tx="T696">@nocolor

- While translating all this I learned a lot about Leo and found a little bug in 
menu manager. Maybe is it Tkinter's responsibility : when writing an 
ampersand right before the last character of a translated name, this 
character is not underlined but the area just following it, yes...

- Translating the "Tangle..." label differently from the "Tangle" one is 
impossible without modifying leo's source code (same thing for "Untangle..." 
and "Untangle").

- Couldn't translate either "Show Invisibles" and "Hide Invisibles". First 
toggle is OK then an error occurs after the second...

At least a couple of suggestions to improve Leo's ability to be used as a PIM:

- When you paste text from another software it would be very convenient :
1. to directly insert a new Node, copying the clipboard into the body pane, 
with a copy of the first, say 40, characters as a Headline
2. to be able, with a keyboard shortcut, to copy any selected text in the 
body pane into the headline, replacing existing one if any.

These two functionnalities are extremly useful. I found and used them in a 
little shareware called "NoteCenter" running exclusively under Windows. And 
that's when I left Windows for Linux that I actively looked after some 
software to replace it. So did I find your fabulous Leo and I actually don't 
miss NoteCenter anymore since then.

- As was made with urls, I would greatly appreciate that any reference to an 
external document could be activated by key+clicking on it. For example : 
key+clicking on file://d:\archiver\docs\bricolage\chauffe-eau-solaire.pdf 
would automatically launch Acrobat Reader or go to the appropriate folder in 
Konqueror or any other File Manager from where you could launch the 
appropriate software to view or edit the file.

Frdric Mommja</t>
<t tx="T697">@nocolor

Oh, and i also got the following message when launching leo:
duplicate shortcut: Alt+Shift+S &lt;Alt-S&gt; Go To Next &amp;Sibling</t>
<t tx="T698">@ignore

@ Used bind_all to set bindings throught the app.  

Well, everthing gets bound, but the old binding in the headline also has effect!  The fix is to bind to a workaround callback, OnControlT, which returns "break".  This has the effect of stamping out all other bindings.  Alas, it also means that Control-T can have no effect in headlines.

It looks like this is another Tk bug.  Nothing seems to reset the control-T binding.  Not bind("Control-T",""), not bind_all, not bind_class.</t>
<t tx="T699"></t>
<t tx="T700"></t>
<t tx="T701"></t>
<t tx="T702">@nocolor

Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1719215
By: nobody

Ok, it seems to be in the code I copied in. I tried it with a second Node, and
don't have the trouble.

Console Mode gives the following:

Traceback (most recent call last):
File "d:\language\literate programming\Leo\leoColor.py", line 830,
in colorizeAnyLanguage
    i,state = func(s,i,n)

File "d:\language\literate programming\Leo\leoColor.py", line 934,
in continueBlockComment
    j = string.find(s,self.block_comment_end,i)

File "D:\LANGUAGE\PYTHON\lib\string.py", line 174, in find
    return s.find(*args)

TypeError: expected a character buffer object

The line, "#define WIPEOUT 0 /* " seems to be the problem child -- if I move
the start-of-comment marker to the next line, the error message goes away; however,
the lines between the '/*' and '*/' are NOT comment-colored...

--Rich
</t>
<t tx="T703">@language c
@comment /* */
@path .
@ignore

&lt;&lt; Defines &gt;&gt;
&lt;&lt; Head &gt;&gt;</t>
<t tx="T704">@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="T705"></t>
<t tx="T706">@ Enabling or disabling @language or @comment now recolors entire text.
@c

@language c
 @comment /* */

/* comment */
# test</t>
<t tx="T707">@color
@language html
@ignore
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="T708">@language html
&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;</t>
<t tx="T709">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="T710">@language php
@ doc
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
</t>
<t tx="T711">"""python
string"""d

'this\
is</t>
<t tx="T712"># This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
        # Copy the headline and icon values v.copyNode(root,v)
        # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result
   </t>
<t tx="T713">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="T714"></t>
<t tx="T715">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1745015
By: jmgilligan

For the most part, I can get cweb mode to color both the tex and the c code
appropriately by using @language.

I have run into a small problem, though:

@language latex
blah blah blah

works fine, but

@language latex
@!@^memory allocation@&gt;
blah blah blah

does not. This causes leo to color all subsequent latex text as leo doc parts.

The control sequence @! means underline the following term in the index. @^foo
bar@&gt; means put the term "foo bar" in the index with a reference to the current
location.
</t>
<t tx="T716">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.</t>
<t tx="T717">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="T718">&lt;&lt; section def &gt;&gt;=

	my \c code goes here // This is \LaTeX text
	/* This is also \LaTeX text */</t>
<t tx="T719"></t>
<t tx="T720"> @ignore
@nocolor
	
idle-time hook that checks for dirty @file nodes that have been modified in an external editor since the last check.

@color

</t>
<t tx="T721">@nocolor

http://sourceforge.net/forum/message.php?msg_id=1847050
By: bwmulder

Maybe Leo could re-check the file system at each save. For each file, there are three possibilities:

[snip]

2. the file has been modified since the last check.

In this case, there was an external edit. If there was also a change within
leo, then we have a conflict which the user has to resolve somehow. Otherwise,
leo might offer the user to read the file and accept the internal edit.

[snip]</t>
<t tx="T722"></t>
<t tx="T723">test 1ab23 4bcdfghbe</t>
<t tx="T724"></t>
<t tx="T725"></t>
<t tx="T726"></t>
<t tx="T727">@ignore</t>
<t tx="T728">@nocolor</t>
<t tx="T729">This has impacts on event bindings and on what "the current node" means.

Anything that affects tree.select is a _major_ change.</t>
<t tx="T730"></t>
<t tx="T731"></t>
<t tx="T732">

- Script that copies old-style tree to new-style tree
	- Test speed of traversal.
	- Test memory usage.
		- Call gc to look for uncollected garbage.
	</t>
<t tx="T733">Revise the read/write code in both leoAtFile.py and leoFileCommands.py.

Typically, changing the internal representation of data structures is the _easy_ part.  The harder part is handling the repercussions of those changes on external data structures, i.e., file formats.  I suspect that Leo will ignore link vnodes when writing derived files, and will recreate those link vnodes when reading derived files.  This general approach _might_ be fully viable.  Perhaps link vnodes never will need gnx's.

</t>
<t tx="T734">Revise the format of .leo files to reflect the new internal organization.

There is no way around it: outlines with clones are _not_ plain OPML files: there must be a way to represent the sharing of target vnodes. Yes, we could duplicate shared vnode trees, but doing so would in effect change the semantics of the OPML file.  In any cases, important choices remain.

</t>
<t tx="T735">@nocolor</t>
<t tx="T736">While thinking about new representations in the vnode class, I am reminded of
another possible change to the vnode class: representing cloned trees as _shared
vnodes_.  In such a representation, v.threadNext() is not well defined.  Instead,
one must use iterators to traverse the tree.  Iterators allow us to visit shared
nodes many times, and allow us to determine which node follows the last node
of a share trees in the tree traversal.

There are several major advantages of using shared trees and iterators to represent
clones:

1.  Extremely important: there is no need for Leo to create and destroy "dependent"
trees when changing descendents of cloned trees.  This has the potential for
arbitrarily large performance improvements for large outlines containing many
clones.

2. Very important: there is no need for join links and no such things as joined
nodes.  Moving descendents of cloned nodes should be substantially faster.

3. Important: There would no longer be a need for separate vnodes and tnodes;
one of them would likely disappear entirely.  This would be the end of the debate
about what vnodes or tnodes should contain.  The new unified nodes would contain
everything, including gnx's, headlines and body text.  Naturally, all file formats
would change.

4. Minor, but still nice: There is no need to keep all joined vnodes in synch.
This would happen automatically.

Sharing vnode trees would be a huge change.  I am tempted to put it off until
(much?) later.  OTOH, it is not often that I contemplate _any_ changes to the
fundamental vnode and tnode classes, so perhaps now is the time to do everything.
On the one hand, it is important to get 4.0 out the door asap.  OTOH, it seems
a shame to change file formats and internal representations of nodes and then
do it all over again later.

There are important choices here.  Please tell me your thoughts.

Edward

P.S.  I'm going to see if I can prototype the shared vnode scheme quickly. 
In particular, I want to see how easy it will be to create a tree-traversal
iterator for trees containing shared nodes.  This prototype should be the work
of at most a day or so.  If it takes longer than that I'll probably abandon
the project for now.
</t>
<t tx="T737">Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2041042
By: paulpaterson

&gt; Your comments are important here! 

&gt;From the perspective of my Leo workflow and my current understanding of links,
if two properties were added to their behaviour I would not even be able to
tell the difference between them and clones!

The properties are,

1. Links could optionally take part in multiply derived files. (used at my own
risk!)

2. Deleting the master node would promote one (if there is one) link node to
be the new master node.

#2 is the thing that would make links indiscernable from clones. I don't know
if that property would make them less useful for their role in LeoN.

The promoted link would be chosen at random and then all other links would be
updated to point to it.

Paul
</t>
<t tx="T738">debug_positions = true # Enable debugging code in position class

class position:
	
	"""A class representing a position in a tree traversal"""
	
	&lt;&lt; about the position class &gt;&gt;
	&lt;&lt; about copying and memory allocation &gt;&gt;
	
	copies = 0
	@others
</t>
<t tx="T739">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

In particular, positions allow the notion of the parent of a shared vnode (an anchor vnode) to have meaning.

A simple picture guides the coding of these routines.  Think of an anchor vnode and all link vnodes that point to it as conceptually the _same_ vnode.  All these vnodes are in a "bag".  Each link vnode defines back, next and parent links for a particular position in the traversal.  The associated anchor vnode defines the firstChild link for all traversals.

With this picture firmly in mind, writing the traversal routines is straightforward.  Indeed, the routines in this class parallel the related routines in the vnode class:

- p.push() moves from a link vnode to an anchor vnode _within the same bag_.

- p.pop()  moves from an anchor vnode to a link vnode _within the same bag_.

- The push and pop routines contain asserts ensuring that anchor nodes are never link nodes, and link nodes are never anchor nodes.  Therefore, only a single call to push or pop is ever needed to get to the vnode that contains the desired parent, firstChild, back or next link.

- the p.next, p.back, p.parent and p.firstChild routines make all the nodes in the "bag" appear to be the same node.  That is, they access the corresponding ivar in the appropriate vnode, depending on the operation and the state of the traversal.  This is done by calling the push and pop routines as needed.

- The other position traversal are exactly like corresponding vnode routines.  In fact, the only difference between these routines and the corresponding vnode routines are the _value_ of self.  So we could actually use the _same_ vnode routines!  I haven't chosen to do so, and I might change my mind :-)
</t>
<t tx="T740">@  For compatibility with old scripts and traversal code within Leo, the default versions of the traversal methods _must_ leave all self objects unchanged.  Failure to follow this principle would result in chaos.

The copies of self have brief lifetimes.  I estimate that a full traversal of LeoPy.leo will create a few thousand bytes of garbage that is immediately available for collection.  This will _probably_ have no effect on Leo's performance.

The "safe" traversal routines are implemented using moveToX routines.  These moveToX routines could be used in key parts of Leo's code to improve performance:

- In the read/write code.
- In the the find/change code.

</t>
<t tx="T741">@  vnodes have two new fields:

- link: a pointer to a shared subtree of vnodes if the vnode is a link node.
- links: a list of link nodes pointing at the vnode if the vnode is an anchor node.

Note: we can always get the current commander from v, so we don't need a similar field here.

@c

def __init__ (self,v,parents=[]):

	"""Create a new position"""
	
	self.v = v
	self.parents = parents</t>
<t tx="T742">def __cmp__(self,other):
		
	trace(`self` + "," + `other`)
	
	p1 = self ; p2 = other
	
	if p1.link:
		p1 = p1.copy().push() # Allow no side effects.

	if p2.link:
		p2 = p2.copy().push() # Allow no side effects.

	parents1 = p1.parents
	parents2 = p2.parents

	if len(parents1) != len(parents2):
		return 1 # not equal
	
	i = 0
	while i &lt; len(parents1):
		if parents1[i] != parents2[i]:
			return 1 # not equal

	return 0 # equal
</t>
<t tx="T743">def copy (self):
	
	"""Return a copy of a position"""
	
	position.copies += 1
	
	return position(self.v,self.parents[:])</t>
<t tx="T744">@ The push and pop methods move within a bag, altering a position in place rather than returning a copy.
</t>
<t tx="T745">def linkV (self):
	
	"""Return self.v,  the link node's v if self a target node."""
	
	if p.v.links:
		v = p.parents[-1].v
	else:
		v = p.v
	
	assert(not p.v.links)
	return p.v
		
		
def targetV (self):
	
	"""Return self.v, or self.target.v if self is a link node."""
	
	if p.v.link:
		v = p.v.link
	else:
		v = p.v
		
	assert(not v.link)
	return v
</t>
<t tx="T746">def pop (self):
	
	"""Move from a target node to the link node on top of the parents stack"""

	linkv = p.parents.pop()
	p.v = linkv
	assert(linkv)
	
	if debug_positions: # debugging.

		# linkv is in fact a link node.
		assert(linkv.link)
		
		# Link nodes are never target nodes.
		assert(not linkv.links)
		
		# linkv links to a target node.
		target = linkv.link
		assert(target.links)

		# Target nodes are never link nodes.
		assert(not target.link)
	
		# The links are consistent.
		assert(linkv in target.links)

	return p</t>
<t tx="T747">def push (self,v):
	
	"""Move from a link node to its target node"""
	
	p = self
	
	if debug_positions: # debugging.

		# v is a link node.
		assert(v.link)
		
		# v actually points at a target node.
		target = v.link
		assert(target.links)
	
		# Target nodes are never link nodes.
		assert(not target.link)

	p.parents.append(p.v)
	p.v = v
	return p</t>
<t tx="T748">@ These routines cleverly preserve self's position without having to copy self.

Exception: p.isVisible and p.level call copy() in order to examine parent positions.
</t>
<t tx="T749"></t>
<t tx="T750">def childIndex (self):

	# This _is_ well defined.
	return self.linkV().childIndex()</t>
<t tx="T751"></t>
<t tx="T752"></t>
<t tx="T753"></t>
<t tx="T754">def hasBack (self):
	
	"""Return true if self has a previous sibling position"""

	return self.linkV().back() != None</t>
<t tx="T755">def hasChildren (self):

	return self.targetV().hasChildren()</t>
<t tx="T756">def hasNext (self):
	
	"""Return true if self has a next sibling position"""

	return self.linkV().next() != None</t>
<t tx="T757">def hasParent (self):
	
	"""Return true if self has a parent position"""

	return self.linkV().parent() != None
</t>
<t tx="T758"></t>
<t tx="T759">def isExpanded (self):
	
	"""Return true self's position is expanded"""

	return self.linkV().isExpanded()
</t>
<t tx="T760">def isValid (self):
	
	"""Return true if self is a non-empty position"""
	
	return self.v != None</t>
<t tx="T761">def isVisible (self):
	
	"""Returns true if all of self's parent positions are expanded"""
	
	if 0: # Calls copy.
		p = self.copy()
		p.moveToParent()
		while v.isValid():
			p.moveToParent()
			if v.isValid() and not p.isExpanded():
				return false
		return true

	else: # Does not call copy.
		p = self ; v = p.v
		while 1:
			v = v.parent()
			if not v and p.links:
				p = p.parents[-1]
				v = p.v.parent()
			if not v:
				return true
			if not v.isExpanded():
				return false</t>
<t tx="T762">def level (self):
	
	"""Return self's level.
	
	Top-level positions have level 0, their children have level 1, and so on.
	"""
	
	if 0: # Calls copy.
		p = self.copy()
		level = -1
		while p.isValid():
			level += 1
			p.moveToParent()
		return level

	else: # Does not call copy.
		p = self ; v = p.v ; level = -1
		while v:
			level += 1
			v = v.parent()
			if not v and p.links:
				p = p.parents[-1]
				v = p.v.parent()

		return level
</t>
<t tx="T763">def numberOfChildren (self):
	
	"""Return the number of self's children."""

	return self.targetV().numberOfChildren()</t>
<t tx="T764"># These routines preserve self's position.</t>
<t tx="T765">def back (self):
	
	"""Return the position of self's previous sibling, or None"""
	
	return self.copy().moveToBack()</t>
<t tx="T766">def firstChild (self):
	
	"""Return the position of self's first child, or None."""
	
	return self.copy().moveToFirstChild()
</t>
<t tx="T767"># childIndex and nthChild are zero-based.

def lastChild (self, n):
	
	"""Return the position of self's last child, or None."""
	
	return self.copy().moveToLastChild(n)
</t>
<t tx="T768">def lastNode (self):
	
	"""Return the position of the last node of self's tree."""
	
	return self.copy().moveToLastNode()</t>
<t tx="T769">def next (self):
	
	"""Return the position of self's next sibling, or None"""
	
	return self.copy().moveToNext()
</t>
<t tx="T770">def nodeAfterTree (self):
	
	"""Return the position following self's tree, or None."""
	
	return self.copy().moveToNodeAfterTree()
</t>
<t tx="T771"># childIndex and nthChild are zero-based.

def nthChild (self, n):
	
	"""Return the position of self's first child, or None."""
	
	return self.copy().moveToNthChild(n)
</t>
<t tx="T772">def parent (self):
	
	"""Return the position of self's parent, or None."""
	
	return self.copy().moveToParent()
</t>
<t tx="T773">def threadBack (self):
	
	"""Returns the position preceeding self in threading order, or None."""

	return self.copy().moveToThreadBack()
</t>
<t tx="T774">def threadNext (self):
	
	"""Returns the position following self in threading order, or None."""
	
	return self.copy().moveToThreadNext()</t>
<t tx="T775">def visBack (self):
	
	"""Returns the visible position preceeding self, or None"""
	
	return self.copy().moveToVisBack()
</t>
<t tx="T776">def visNext (self):
	
	"""Returns the visible position following self, or None"""
	
	return self.copy().moveToVisNext()</t>
<t tx="T777"># These routines change self's position to a new position.</t>
<t tx="T778">def finishMove (self):

	"""Complete a move by returning None if the move did not succeed"""

	p = self

	if p.v:
		# The move succeeded.
		return p
	else:
		# The move failed: delete the parents array immediately.
		p.parents = []
		return None
</t>
<t tx="T779">def moveToBack (self):
	
	"""Move self to the position of its previous sibling.
	
	Return self or None if there is no such position"""
	
	p = self()
	if p.v.links:
		p.pop()

	assert(not p.v.links)

	p.v = p.v.back()
	return p.finishMove()</t>
<t tx="T780">def moveToFirstChild (self):

	"""Move self to it's first child's position.
	
	Return self or None if there is no such position"""

	p = self
	if p.v.link:
		p.push()

	assert(not p.v.link)

	p.v = p.v.firstChild()
	return p.finishMove()
</t>
<t tx="T781">def moveToLastChild (self):
	
	p = self
	p.moveTofirstChild()

	while p.isValid() and p.hasNext():
		p.moveToNext()

	return p.finishMove() # Returns None if p does not exist.</t>
<t tx="T782">def moveToLastNode (self):
	
	"""Move self to the position of the last node of self's tree.
	
	Return self or None if there is no such position"""
	
	p = self
	level = p.level()
	result = None

	while 1:
		result = p
		p.moveToThreadNext()
		if not p.isValid() or p.level() &lt;= level:
			break

	return result</t>
<t tx="T783">def movBack (self):
	
	"""Move self to the position of its next sibling, if possible.
	
	Set p.v = None if there is no such position."""

	p = self
	if p.v.links:
		p.pop()

	assert(not p.v.links)

	p.v = p.v.next()
	return p.finishMove()

</t>
<t tx="T784">def moveToNodeAfterTree (self):
	
	"""Move self to the position of node after self's tree.
	
	Return self or None if there is no such position"""
	
	p = self

	while p.isValid():
		if p.hasNext():
			return p.moveToNext()
		p.moveToParent()

	return None
</t>
<t tx="T785"># childIndex and nthChild are zero-based.

def moveToNthChild (self, n):

	p = self
	p.moveToFirstChild()

	while p.isValid() and n &gt; 0:
		n -= 1
		p.moveToNext()
		
	return p.finishMove() # Returns None if p does not exist.</t>
<t tx="T786">def moveToParent (self):
	
	"""Move self to it's parent position.
	
	Return self or None if there is no such position"""

	p = self
	if p.v.links:
		p.pop()
		
	assert(not p.links)

	p.v = p.v.parent()
	return p.finishMove()</t>
<t tx="T787">def moveToThreadBack (self):
	
	"""Returns the position preceeding self in threading order, or None."""

	p = self

	if p.hasBack():
		p.moveToBack()
		if p.hasChildren():
			p.moveToLastChild()
			p.moveToLastNode()
		assert(p.exists)
		return p
	else:
		return p.moveToParent() # May return None.</t>
<t tx="T788">def moveToThreadNext (self):
	
	p = self

	if p.hasChildren():
		return p.moveToFirstChild()

	if p.hasNext():
		return p.moveToNext()

	p.moveToParent()
	while p.isValid():
		if p.hasNext():
			return p.moveToNext()
		p.moveToParent()

	return None # p.finishMove() has already been called.
</t>
<t tx="T789">def moveToVisBack (self):
	
	"""Move self to the position of the previous visible node.
	
	Return self or None if there is no such position"""

	p = self
	p.moveToThreadBack()

	while p.isValid() and not p.isVisible():
		p.moveToThreadBack()
		
	return p.finishMove() # Returns None if not p.isValid()</t>
<t tx="T790">def moveToVisNext (self):
	
	"""Move self to the position of the next visible node.
	
	Return self or None if there is no such position"""
	
	p = self
	p.moveToThreadNext()
	
	while p.isValid() and not p.isVisible():
		p.moveToThreadNext()

	return p.finishMove() # Returns None if not p.isValid()</t>
<t tx="T791"></t>
<t tx="T792">@ The old drawing code called this tree as follows:
	
	self.drawTree(self.rootVnode,root_left,root_top,0,0)
@c

def drawVxTree(self,v,x,y,h,level):
	
	hook_val = doHook("draw-sub-outline",tree=self,v=v,x=x,y=y,h=h,level=level)
	if hook_val != None: return hook_val

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.drawNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	&lt;&lt; draw vertical line &gt;&gt;
	return y</t>
<t tx="T793">id = self.canvas.create_line(
	x, yfirst-hline_y+4,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="T794">def drawNode(self,v,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	hook_val = doHook("draw-outline-node",tree=self,v=v,x=x,y=y)
	if hook_val != None: return hook_val

	self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")
	if v.firstChild():
		self.drawBox(v,x,y)

	icon_height = self.drawIcon(v,x+box_width,y)
	text_height = self.drawText(v,x+box_width+icon_width,y)
	return max(icon_height, text_height)
</t>
<t tx="T795">def drawVxText(self,v,x,y):
	
	"""draws text for v at x,y"""
	
	hook_val = doHook("draw-outline-text-box",tree=self,v=v,x=x,y=y)
	if hook_val != None: return hook_val
	
	x += text_indent
	if v.edit_text: # self.canvas.delete("all") may already have done this, but do it anyway.
		v.edit_text.destroy()
	v.edit_text = t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	t.insert("end", v.headString())
	&lt;&lt; configure the text depending on state &gt;&gt;
	id1 = t.bind("&lt;1&gt;", v.OnHeadlineClick)
	id2 = t.bind("&lt;3&gt;", v.OnHeadlineRightClick) # 9/11/02.
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("&lt;Double-1&gt;", v.OnBoxClick)
	id3 = t.bind("&lt;Key&gt;", v.OnHeadlineKey)
	id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
	# Remember the bindings so we can delete them by hand on redraws.
	if self.recycleBindings:
		self.bindings.append((t,id1,"&lt;1&gt;"),)
		self.bindings.append((t,id2,"&lt;3&gt;"),)
		self.bindings.append((t,id3,"&lt;Key&gt;"),)
		self.bindings.append((t,id4,"&lt;Control-t&gt;"),)
	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	if 0: # don't create this reference!
		v.edit_text_id = id
	self.canvas.tag_lower(id)

	return self.line_height</t>
<t tx="T796">@ To do:
	
- set ivars in setCallback describing the visible area on the screen.
- Allocate widgets only for visible nodes.
- Deallocate widgets for newly invisible nodes.
@c

class vxnode:
	
	"""A class representing a vnode during redraws"""
	
	&lt;&lt; about the vxnode class &gt;&gt;
	@others
</t>
<t tx="T797"></t>
<t tx="T798">def __init__ (self,v):
	
	# Links to other classes.
	self.c = v.commands
	self.v = v
	
	# Traversal.
	self.next = self.back = None
	self.level = None
	
	# Canvas items.
	self.iconx, self.icony = 0,0 # Coords of icon so icon can be redrawn separately.
	self.icon_id = None
	self.edit_text = None 
</t>
<t tx="T799">class newVnode:
	&lt;&lt; vnode constants &gt;&gt;
	@others</t>
<t tx="T800"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # true: vnode has clone mark.
# not used	 = 0x02
expandedBit = 0x04 # true: vnode is expanded.
markedBit	  = 0x08 # true: vnode is marked
orphanBit	  = 0x10 # true: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # true: vnode is current vnode.
topBit		    = 0x40 # true: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit	 = 0x100
</t>
<t tx="T801">def __init__ (self,commands):

	self.commands = commands # The commander for this vnode.

	# Structure links
	self.mParent = self.mFirstChild = self.mNext = self.mBack = None

	# Links between nodes in the same bag.
	self.link = None # The link to the target node.
	self.links = None # List of all link nodes having this node as a target.
	self.t = self # A dummy link for compatibility with old code.

	# Content.
	self.headString = "" # Headline text.
	self.bodyString = "" # Body text.
	self.statusBits = 0 # Status bits.

	# State information for the body pane
	self.selectionStart = 0 # The start of the selected body text.
	self.selectionLength = 0 # The length of the selected body text.
	self.insertSpot = None # Location of previous insert point.
	self.scrollBarSpot = None # Previous value of scrollbar position.

	# File stuff.
	self.gnx = None # Immutable global node index.
	self.fileIndex = None # An immutable file index: must always exist, even in 4.0.
</t>
<t tx="T802">@nocolor

The basic ideas:
	
- Precompute mThreadNext when linking nodes.

- It is optional to precompute mThreadBack: it is much less useful.

- threadNext() just returns mThreadNext.

- computeThreadNext() returns the new value for mThreadNext.

- unlinkThreadLinks() clears the thread links to and from a node _before_ the node is unlinked.

- updateThreadLinks() sets the thread links to and from a node _after_ the node is linked.

@color
</t>
<t tx="T803">@color

# Init stats.
from leoGlobals import *
clear_stats()

# Print stats.
from leoGlobals import *
print_stats()

# Saving LeoPy.leo generated 46740 calls to v.threadNext!

@nocolor

Statistics after reading LeoPy.leo:

linkAfter 4966
linkAsNthChild 1706
linkAsRoot 3
threadNext 37412
unlink 3

*** It's possible that precomputing threadNext might be useful.
*** Using a fast xml parser might speed up reads much more...</t>
<t tx="T804">@nocolor

Python 2.2.2 (#37, Oct 14 2002, 17:02:34) [MSC 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import leo
&gt;&gt;&gt; leo.profile()

(Opened LeoDocs.leo)

         281689 function calls (279448 primitive calls) in 13.433 CPU seconds

*** It's possible that precomputing threadNext might be useful.

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

     8893    0.313    0.000    0.465    0.000 leoNodes.py:1259(threadNext)  ****
      493    0.013    0.000    0.191    0.000 leoNodes.py:1244(threadBack)
       87    0.020    0.000    0.157    0.002 leoNodes.py:1173(lastNode)
      843    0.067    0.000    0.096    0.000 leoNodes.py:1197(level)
    16674    0.086    0.000    0.086    0.000 leoNodes.py:1210(next)
    11284    0.061    0.000    0.061    0.000 leoNodes.py:967(firstChild)
     8270    0.042    0.000    0.042    0.000 leoNodes.py:1235(parent)
      377    0.012    0.000    0.018    0.000 leoNodes.py:983(lastChild)

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 
  1779/11    0.296    0.000    1.732    0.157 leoFileCommands.py:765(getVnode) ****
    38430    0.609    0.000    0.986    0.000 leoFileCommands.py:293(matchTag) ********
     1365    0.151    0.000    0.804    0.001 leoFileCommands.py:714(getTnode) *
     1019    0.015    0.000    0.481    0.000 leoNodes.py:810(isAtIgnoreNode) 
     1019    0.128    0.000    0.466    0.000 leoGlobals.py:2507(is_special) *
    11223    0.146    0.000    0.433    0.000 leoFileCommands.py:274(getTag) *
     1779    0.072    0.000    0.410    0.000 leoFileCommands.py:76(createVnode)
    38430    0.377    0.000    0.377    0.000 leoFileCommands.py:910(skipWsAndNl) ****
     3146    0.077    0.000    0.330    0.000 leoFileCommands.py:358(getEscapedString)
     3146    0.117    0.000    0.225    0.000 leoFileCommands.py:1040(xmlUnescape) *
     8695    0.138    0.000    0.202    0.000 leoGlobals.py:2564(match_word) *
    21554    0.164    0.000    0.164    0.000 string.py:164(find) *
     7700    0.104    0.000    0.162    0.000 leoGlobals.py:2616(skip_line) *
     3134    0.038    0.000    0.160    0.000 leoFileCommands.py:210(getDquote) 
     2986    0.041    0.000    0.148    0.000 leoFileCommands.py:213(getIndex) 
     1387    0.042    0.000    0.142    0.000 leoNodes.py:1772(insertAfter)
    12659    0.109    0.000    0.109    0.000 string.py:362(replace) *
     2998    0.082    0.000    0.108    0.000 leoFileCommands.py:218(getLong)
     2012    0.037    0.000    0.104    0.000 leoNodes.py:712(afterHeadlineMatch)
     1365    0.038    0.000    0.098    0.000 leoFileCommands.py:926(newTnode)
     1006    0.013    0.000    0.096    0.000 leoNodes.py:765(isAtRawFileNode)
     1006    0.016    0.000    0.083    0.000 leoNodes.py:744(atRawFileNodeName)
     1006    0.013    0.000    0.062    0.000 leoNodes.py:755(isAtFileNode)
     3158    0.061    0.000    0.061    0.000 leoGlobals.py:3187(toUnicode)
     1782    0.025    0.000    0.055    0.000 leoNodes.py:1345(initHeadString)
     1365    0.019    0.000    0.050    0.000 leoNodes.py:351(setTnodeText)
     1006    0.013    0.000    0.049    0.000 leoNodes.py:738(atFileNodeName)
     2012    0.028    0.000    0.042    0.000 leoGlobals.py:2539(match)
      391    0.012    0.000    0.036    0.000 leoNodes.py:1801(insertAsNthChild)
     4055    0.035    0.000    0.035    0.000 leoFileCommands.py:895(skipWs)
     1801    0.023    0.000    0.033    0.000 leoNodes.py:1092(isDirty)
     1051    0.016    0.000    0.025    0.000 leoFileCommands.py:285(matchChar)
     3302    0.020    0.000    0.020    0.000 leoNodes.py:1688(setJoinList)
      485    0.014    0.000    0.019    0.000 leoNodes.py:1136(isVisible)
     3302    0.017    0.000    0.017    0.000 leoNodes.py:427(setJoinHead)
     1779    0.012    0.000    0.012    0.000 leoNodes.py:1445(clearOrphan)
     2291    0.012    0.000    0.012    0.000 leoNodes.py:1042(getJoinList)
     1801    0.011    0.000    0.011    0.000 leoNodes.py:309(isDirty)
</t>
<t tx="T805"></t>
<t tx="T806">def linkAfter (self,v):
	
	"""Link self after v"""

	self.mParent = v.mParent
	self.mBack = v
	self.mNext = v.mNext
	v.mNext = self
	if self.mNext:
		self.mNext.mBack = self

	self.updateThreadLinks()
</t>
<t tx="T807">def linkAsNthChild (self, p, n):

	"""Links self as the n'th child of p"""

	v = self
	# trace(`v` + ", " + `p` + ", " + `n`)
	v.mParent = p
	if n == 0:
		v.mBack = None
		v.mNext = p.mFirstChild
		if p.mFirstChild:
			p.mFirstChild.mBack = v
		p.mFirstChild = v
	else:
		prev = p.nthChild(n-1) # zero based
		assert(prev)
		v.mBack = prev
		v.mNext = prev.mNext
		prev.mNext = v
		if v.mNext:
			v.mNext.mBack = v
			
	v.updateThreadLinks()
</t>
<t tx="T808">def linkAsRoot(self, oldRoot = None):
	
	"""Link self as the root vnode.
	Link in the rest of the true only if oldRoot != None.
	Otherwise, create a pristine tree with self as the only node.
	"""

	v = self ; c = v.commands ; tree = c.tree
	v.mParent = None
	v.mBack = None
	if oldRoot:
		oldRoot.mBack = v
	v.mNext = oldRoot
	tree.rootVnode = v

	v.updateThreadLinks()
</t>
<t tx="T809">def unlink (self):

	"""Unlinks the receiver from the tree before moving or deleting."""
	v = self ; c = v.commands ; tree = c.tree

	# trace(`v.mParent`+", child:"+`v.mFirstChild`+", back:"+`v.mBack`+", next:"+`v.mNext`)
	
	# Special case the root
	if v == tree.rootVnode:
		if not v.mNext: return # Should never happen.
		tree.rootVnode = v.mNext
		
	# Unlink the thread links pointing at this node _before_ unlinking the node.
	v.unlinkThreadLinks()

	# Clear the links in other nodes
	if v.mBack:
		v.mBack.mNext = v.mNext
	if v.mNext:
		v.mNext.mBack = v.mBack
	if v.mParent and v == v.mParent.mFirstChild:
		v.mParent.mFirstChild = v.mNext

	# Clear the links in this node
	v.mParent = v.mNext = v.mBack = None
	v.mThreadNext = v.mThreadBack = None</t>
<t tx="T810">def unlinkThreadLinks (self):
	
	"""Unlink self from other nodes thread links"""
	
	if 0: # Set only mThreadNext fields.

		oldThreadNext = self.mThreadNext
		oldThreadBack = self.threadBack()
		if oldThreadNext:
			oldThreadNext.threadBack() = oldThreadBack
		if oldThreadBack:
			oldThreadBack.mThreadNext = oldThreadNext
			
	else: # Set mThreadNext and mThreadBack fields.
	
		oldThreadNext = self.mThreadNext
		oldThreadBack = self.mThreadBack
		if oldThreadNext:
			oldThreadNext.mThreadBack = oldThreadBack
		if oldThreadBack:
			oldThreadBack.mThreadNext = oldThreadNext</t>
<t tx="T811">def updateThreadLinks (self):
	
	"""Link self, a newly linked vnode, into the thread links"""
	
	if 0: # Set mThreadNext.
		# Set thread link out of this node.
		self.mThreadNext = self.computeThreadNext()
		# Set thread links into this node.
		back = self.computeThreadBack()
		if back:
			back.mThreadNext = self

	else: # Set mThreadNext and mThreadBack
		# Set new thread links out of this node.
		self.mThreadNext = self.computeThreadNext()
		self.mThreadBack = self.computeThreadBack()
		# Set new thread links into this node.
		if self.mThreadNext:
			self.mThreadNext.mThreadBack = self
		if self.mThreadBack:
			self.mThreadBack.mThreadNext = self</t>
<t tx="T812">def threadBack (self):
	
		"""Return the previous node, or None if at the start of the outline"""
		return self.mThreadBack
	
def computeThreadBack (self):
	
	"""Return the new value for self.mThreadBack"""
	v = self ; back = v.mBack
	if back:
		lastChild = back.lastChild()
		if lastChild:
			return lastChild.computeLastNodeForThreadBack()
		else:
			return back
	else:
		return v.mParent</t>
<t tx="T813">def threadNext (self):

	"""Returns node following the receiver in "threadNext" order."""
	return self.mThreadNext

def computeThreadNext (self):
	
	"""Return the new value for self.mThreadNext"""
	v = self
	if v.mFirstChild:
		return v.mFirstChild
	elif v.mNext:
		return v.mNext
	else:
		p = v.mParent
		while p:
			if p.mNext:
				return p.mNext
			p = p.mParent
		return None
</t>
<t tx="T814">def computeLastNodeForThreadBack (self):
	
	"""Return the last node of self's tree,
	_without_ calling threadNext() or threadBack(),
	and _without_ using mThreadNext or mThreadBack.
	"""

	v = self ; level = self.level()
	result = None
	while v:
		result = v
		# computeThreadNext doesn't call threadNext or threadBack, and
		# computeThreadNext doesn't use mThreadNext or mThreadBack.
		v = v.computeThreadNext()
		if not v or v.level() &lt;= level:
			break

	return result
</t>
<t tx="T815">@ignore
@nocolor

WARNING: partially written, completely untested code.

What I did:

- Replaced mFirstChild with mChildren.
- Partially replaced mBack and mNext fields.
- Assumed the existence of c.frame.dummyChildren array.

I abaondoned this code for the following reasons:

- It is not at all clear that the new code would be faster than the old code.
- Precomputing threadNext() and maybe threadBack() promises to be yield _much_ bigger gains.
- mBack, mNext and mFirstChild will in general take considerably less space because
  _all_ nodes would have an mChildren dictionary.

@color</t>
<t tx="T816"></t>
<t tx="T817">def children (self):
	
	return self.mChildren</t>
<t tx="T818"># childIndex and nthChild are zero-based.

def childIndex (self):

	parent=self.parent()
	if not parent: return 0
	
	if self.use_children_array:
		if self.mParent:
		# Throws an exception if self not in mChildren.
		return parent.mChildren.index(self)

	else: # old code
		child = parent.firstChild()
		n = 0
		while child:
			if child == self: return n
			n += 1 ; child = child.next()
		assert(false)</t>
<t tx="T819">def firstChild (self):
	
	if self.use_children_array:
		if len(self.mChildren) &gt; 0:
			return self.mChildren[0]
		else:
			return None

	else: # old code
		return self.mFirstChild</t>
<t tx="T820">def hasChildren (self):
	
	if self.use_children_array:
		return len(self.mChildren) &gt; 0
		
	else: # old code
		return self.firstChild() != None</t>
<t tx="T821">def lastChild (self):
	
	if self.use_children_array:
		n = len(self.mChildren)
		if n:
			return self.mChildren[n-1]
		else:
			return None
	
	else: # old code
		child = self.firstChild()
		while child and child.next():
			child = child.next()
		return child</t>
<t tx="T822"># childIndex and nthChild are zero-based.

def nthChild (self, n):
	
	if self.use_children_array:
		if n &lt;= len(self.mChildren):
			return self.mChildren[n-1]
		else:
			return None
			
	else: # old code
		child = self.firstChild()
		if not child: return None
		while n &gt; 0 and child:
			n -= 1
			child = child.next()
		return child</t>
<t tx="T823">def numberOfChildren (self):
	
	if self.use_children_array:
		return len(self.mChildren)
		
	else: # old code
		n = 0
		child = self.firstChild()
		while child:
			n += 1
			child = child.next()
		return n</t>
<t tx="T824"></t>
<t tx="T825">def back (self):
	
	if self.use_children_array:
		if self.mParent:
			children = self.mParent.mChildren
		else:
			children = self.commands.frame.dummyChildren
		n = children.index(self)
		
		if n &gt; 0:
			return children[n-1]
		else:
			return None
	else:
		return self.mBack</t>
<t tx="T826">def next (self):
	
	if self.use_children_array:
		if self.mParent:
			children = mParent.mChildren
		else:
			children = self.commands.frame.dummyChildren

		n = children.index(self)
		if n + 1 &lt; len(children):
			return children[n+1]
		else:
			return None

	else:
		return self.mNext</t>
<t tx="T827">def linkAsNthChild (self, p, n):

	"""Links the receiver as the n'th child of p"""

	v = self
	# # trace(`v` + ", " + `p` + ", " + `n`)
	v.mParent = p
	if n == 0:
		v.mBack = None
		firstChild = v.mNext = p.firstChild() # 5/4/03
		if firstChild:
			firstChild.mBack = v
		if self.use_children_array: # 5/4/03
			p.mChildren[0] = v
		else:
			p.mFirstChild = v
	else:
		prev = p.nthChild(n-1) # zero based
		assert(prev)
		v.mBack = prev
		v.mNext = prev.mNext
		prev.mNext = v
		if v.mNext:
			v.mNext.mBack = v
		if self.use_children_array: # 5/4/03
			p.mChildren = p.mChildren[:n] + v + p.mChilren[n:]</t>
<t tx="T828"># Links the receiver after v.

def linkAfter (self,v):
	
	# tick() ; # trace(`v`)
	self.mParent = v.mParent
	self.mBack = v
	self.mNext = v.mNext
	v.mNext = self
	if self.mNext:
		self.mNext.mBack = self</t>
<t tx="T829">def unlink (self):

	"""Unlinks the receiver from the tree before moving or deleting."""
	v = self ; c = v.commands ; tree = c.tree
	
	# Special case the root
	if v == tree.rootVnode:
		if not v.mNext: return # Should never happen.
		tree.rootVnode = v.mNext

	# Clear the links in other nodes
	if v.mBack:
		v.mBack.mNext = v.mNext
	if v.mNext:
		v.mNext.mBack = v.mBack
	if v.mParent and v == v.mParent.firstChild():
		if self.use_children_array: # 5/4/03
			v.mParent.mChildren.remove(self)
		else:
			v.mParent.mFirstChild = v.mNext

	# Clear the links in this node
	v.mParent = v.mNext = v.mBack = None
	self.mChildren = None</t>
<t tx="T830">@ Bug fix: 5/27/02.  We link in the rest of the tree only when oldRoot != None.  Otherwise, we are calling this routine from init code and we want to start with a pristine tree.
@c
def linkAsRoot(self, oldRoot = None):

	v = self ; c = v.commands
	
	if self.use_children_array:
		&lt;&lt; link v as the root vnode using c.frame.dummyChildren &gt;&gt;
	else:
		&lt;&lt; link v as the root vnode using mBack, mNext &gt;&gt;

	c.tree.rootVnode = v</t>
<t tx="T831">v.mParent = None
children = c.frame.dummyChildren

if oldRoot:
	children.insert(0,v)
else:
	children[0] = v</t>
<t tx="T832"># # trace(`v`)
# Bug fix 3/16/02:
# Clear all links except the child link.
# This allows a node with children to be moved up properly to the root position.

v.mParent = None
v.mBack = None
# 5/27/02
if oldRoot: oldRoot.mBack = v
v.mNext = oldRoot
</t>
<t tx="T833"></t>
<t tx="T834">@ignore
@color</t>
<t tx="T835">@nocolor

I have a base window class that I use for all my TK stuff which handles, especially, focus issues between windows.  I have not looked at ButtonQ to see to what extent it depends upon WindowQ, the base class.

Anyway, this might be usefull as-is.  If not, let me know.</t>
<t tx="T836">@ Setup a button so it is handled with a keyboard shortcut like MSWindows tools.  See if there is an ampersand in the string.  If so, we want to underline that character and make that character a hot key for this button.
@c

from Tkinter import *
from string import *

def ButtonQ (master, **kw):
	b = ButtonQ_ (master, kw)
	return b.button

class ButtonQ_ (Button):
	@others

## test
"""
from tkMessageBox import *
def buttonqcommand ():
	showinfo ("Title", "Button was pushed")

root = Tk ()
frame = Frame (root)
b = ButtonQ (frame, text = "&amp;Push Me", command = buttonqcommand)
b.grid ()
frame.grid (pady = 15)
"""
</t>
<t tx="T837">def __init__(self, master, kw = {}):

	&lt;&lt; get inputs to this method &gt;&gt;
	&lt;&lt; see if there is an ampersand in the string. &gt;&gt;
	&lt;&lt; make the button with the correct text &gt;&gt;
	&lt;&lt; bind the button &gt;&gt;

	# make the button available to the caller
	self.button = b</t>
<t tx="T838">_master = master
_text = kw['text']
_command = kw['command']
</t>
<t tx="T839">length = len (_text)
index = 0
text3 = _text

# Show there is no hot key yet
IsHot = 0
HotKey = None

while index &lt; length:
	if _text [index] == '&amp;':
		&lt;&lt; handle an ampersand &gt;&gt;
	index = += 1</t>
<t tx="T840"># if the word ends in an ampersand, we ignore it, and there is no hot key
if index == length - 1:
	break

# we have found a good hot key.  Remove the ampersand.
text1 = _text [0 : index]
text2 = _text [(index + 1) : 10000]
text3 = text1 + text2
IsHot = 1
HotKey = _text [index + 1]
break</t>
<t tx="T841">if IsHot:
	kw['text'] = text3
	kw['underline'] = index

b = Button (master, kw)
</t>
<t tx="T842">@ If there is a hot key, bind it to the window that owns the button.
Use the alt of both the lower case and upper case of the letter.
@c

if IsHot:
	HotKey = lower(HotKey)
	self.HotKey = HotKey
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)

	HotKey = upper(HotKey)
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)


</t>
<t tx="T843"># The hot key has been hit.  Call the button's command.

def callback (self, event):

	self.button.invoke ()
</t>
<t tx="T844">@ignore
@nocolor

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = true in tree.__init__.

To do:
	
- We might switch to a line-oriented scheme.
	- This might simplify the code and make the code more useful to users.
	- Conceivably this scheme might eliminate the need for the auto-scroll in the redraw code,
	and that might make a single-pass redraw scheme possible.

- The last line isn't always completely visible: this is clearly a bug.

@color</t>
<t tx="T845"></t>
<t tx="T846">def setCallback (self,*args,**keys):
	
	"""Callback to adjust the scrollbar.
	
	Args is a tuple of two floats describing the fraction of the visible area."""

	# if self.tree.trace: print "setCallback:",self.tree.redrawCount,`args`

	apply(self.treeBar.set,args,keys)

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.setVisibleArea(args)
		
def yviewCallback (self,*args,**keys):
	
	"""Tell the canvas to scroll"""
	
	# if self.tree.trace: print "vyiewCallback",`args`,`keys`

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.allocateNodesBeforeScrolling(args)

	apply(self.canvas.yview,args,keys)
	
	
</t>
<t tx="T847"></t>
<t tx="T848">def drawBox (self,v,x,y):
	
	y += 7 # draw the box at x, y+7

	tree = self
	iconname = choose(v.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y,image=image)
	
	if 1: # use vnode callbacks
		id1 = self.canvas.tag_bind(id, "&lt;1&gt;", v.OnBoxClick)
	else:
		&lt;&lt; define onBoxClickCallback &gt;&gt;
		id1 = self.canvas.tag_bind(id, "&lt;1&gt;", onBoxClickCallback)
	id2 = self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"&lt;1&gt;"),)
	self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)</t>
<t tx="T849">def onBoxClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("boxclick1",c=c,v=v,event=event):
			tree.OnBoxClick(v)
		doHook("boxclick2",c=c,v=v,event=event)
	except:
		es_event_exception("boxclick")</t>
<t tx="T850"># Draws icon for v at x,y

def drawIcon(self,v,x,y):

	tree = self
	v.iconx, v.icony = x,y
	y += 2 # draw icon at y + 2

	# Always recompute icon.
	val = v.iconVal = v.computeIcon()
	assert(0 &lt;= val &lt;= 15)
	
	# Compute the image name
	imagename = "box"
	if val &lt; 10: imagename += "0"
	imagename += `val`

	# Get the image
	image = self.getIconImage(imagename + ".GIF")
	id = self.canvas.create_image(x,y,anchor="nw",image=image)
	self.icon_id_dict[id] = v # Remember which vnode belongs to the icon.
	
	if 1: # use vnode callbacks.
		id1 = self.canvas.tag_bind(id,"&lt;1&gt;",v.OnIconClick)
		id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",v.OnIconDoubleClick)
		id3 = self.canvas.tag_bind(id,"&lt;3&gt;",v.OnIconRightClick)
	else:
		&lt;&lt; define icon click callbacks &gt;&gt;
		id1 = self.canvas.tag_bind(id,"&lt;1&gt;",onIconClickCallback)
		id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",onIconDoubleClickCallback)
		id3 = self.canvas.tag_bind(id,"&lt;3&gt;",onIconRightClickCallback)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"&lt;1&gt;"),)
	self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
	self.tagBindings.append((id,id3,"&lt;3&gt;"),)

	return 0 # dummy icon height</t>
<t tx="T851">def onIconClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("iconclick1",c=c,v=v,event=event):
			tree.OnIconClick(v,event)
		doHook("iconclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconclick")
		
def onIconDoubleClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("icondclick1",c=c,v=v,event=event):
			tree.OnIconDoubleClick(self)
		doHook("icondclick2",c=c,v=v,event=event)
	except:
		es_event_exception("icondclick")
	
def onIconRightClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("iconrclick1",c=c,v=v,event=event):
			tree.OnIconRightClick(v,event)
		doHook("iconrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")
</t>
<t tx="T852">def drawNode(self,v,x,y):

	"""Draw horizontal line from vertical line to icon"""

	self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(v,x,y)
	else:
		return self.line_height
	
def force_draw_node(self,v,x,y):

	self.allocatedNodes += 1
	if v.firstChild():
		self.drawBox(v,x,y)
	icon_height = self.drawIcon(v,x+box_width,y)
	text_height = self.drawText(v,x+box_width+icon_width,y)
	return max(icon_height, text_height)</t>
<t tx="T853"># draws text for v at x,y

def drawText(self,v,x,y):
	
	tree = self
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)
	self.edit_text_dict[v] = t # Remember which text widget belongs to v.
	
	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	&lt;&lt; configure the text depending on state &gt;&gt;

	if 1: # Use vnode callbacks.
		id1 = t.bind("&lt;1&gt;",v.OnHeadlineClick)
		id2 = t.bind("&lt;3&gt;",v.OnHeadlineRightClick)
	else:
		&lt;&lt; define the headline click callbacks &gt;&gt;
		id1 = t.bind("&lt;1&gt;",onHeadlineClickCallback)
		id2 = t.bind("&lt;3&gt;",onHeadlineRightClickCallback)
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("&lt;Double-1&gt;", v.OnBoxClick)
	id3 = t.bind("&lt;Key&gt;", v.OnHeadlineKey)
	id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"&lt;1&gt;"),)
	self.bindings.append((t,id2,"&lt;3&gt;"),)
	self.bindings.append((t,id3,"&lt;Key&gt;"),)
	self.bindings.append((t,id4,"&lt;Control-t&gt;"),)

	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	self.canvas.tag_lower(id)

	return self.line_height</t>
<t tx="T854">if v == self.currentVnode:
	# trace("editVnode",self.editVnode)
	if v == self.editVnode:
		self.setNormalLabelState(v) # 7/7/03
	else:
		self.setDisabledLabelState(v) # selected, disabled
else:
	self.setUnselectedLabelState(v) # unselected</t>
<t tx="T855">def onHeadlineClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("headclick1",c=c,v=v,event=event):
			tree.OnActivate(v)
		doHook("headclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headclick")
	
def onHeadlineRightClickCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("headrclick1",c=c,v=v,event=event):
			tree.OnActivate(v)
			tree.OnPopup(v,event)
		doHook("headrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headrclick")</t>
<t tx="T856">def drawTree(self,v,x,y,h,level):
	
	# Recursive routine, stat() not useful.
	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.drawNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	&lt;&lt; draw vertical line &gt;&gt;
	return y</t>
<t tx="T857">id = self.canvas.create_line(
	x, yfirst-hline_y+4,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="T858">def inVisibleArea (self,y1):
	
	if self.allocateOnlyVisibleNodes:
		if self.visibleArea:
			vis1,vis2 = self.visibleArea
			y2 = y1 + self.line_height
			return y2 &gt;= vis1 and y1 &lt;= vis2
		else: return false
	else:
		return true # This forces all nodes to be allocated on all redraws.
		
def inExpandedVisibleArea (self,y1):
	
	if self.expandedVisibleArea:
		vis1,vis2 = self.expandedVisibleArea
		y2 = y1 + self.line_height
		return y2 &gt;= vis1 and y1 &lt;= vis2
	else:
		return false</t>
<t tx="T859"></t>
<t tx="T860"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
	
	# trace()
	
	if self.updateCount == 0 and not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
</t>
<t tx="T861"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):

	# trace()

	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)</t>
<t tx="T862"># Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.
def redraw_now (self):

	# trace()

	self.idle_redraw()</t>
<t tx="T863">def idle_redraw (self):
	
	self.redrawScheduled = false # 7/10/03: Always do this here.

	frame = self.commands.frame
	if frame not in app.windowList or app.quitting:
		# trace("no frame")
		return
		
	if self.drag_v:
		# trace("dragging",self.drag_v)
		return

	# trace()
	# print_bindings("canvas",self.canvas)

	self.expandAllAncestors(self.currentVnode)
	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"
	self.allocatedNodes = 0
	if not doHook("redraw-entire-outline",c=self.commands):
		# Erase and redraw the entire tree.
		self.topVnode = None
		self.deleteBindings()
		self.canvas.delete("all")
		self.deleteWidgets()
		self.setVisibleAreaToFullCanvas()
		self.drawTree(self.rootVnode,root_left,root_top,0,0)
		# Set up the scroll region after the tree has been redrawn.
		x0, y0, x1, y1 = self.canvas.bbox("all")
		self.canvas.configure(scrollregion=(0, 0, x1, y1))
		# Do a scrolling operation after the scrollbar is redrawn
		# printGc()
		self.canvas.after_idle(self.idle_scrollTo)
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount, self.allocatedNodes
		doHook("after_redraw-outline",c=self.commands)

	self.canvas['cursor'] = oldcursor</t>
<t tx="T864">def idle_second_redraw (self):
	
	# trace()
		
	# Erase and redraw the entire tree the SECOND time.
	# This ensures that all visible nodes are allocated.
	self.topVnode = None
	args = self.canvas.yview()
	self.setVisibleArea(args)
	self.deleteBindings()
	self.canvas.delete("all")
	self.drawTree(self.rootVnode,root_left,root_top,0,0)
	
	if self.trace:
		print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes</t>
<t tx="T865">@ This scrolls the canvas so that v is in view.  This is done at idle time after a redraw so that treeBar.get() will return proper values.
@c

def idle_scrollTo(self,v=None):

	frame = self.commands.frame
	last = self.lastVisible()
	nextToLast = last.visBack()
	# print 'v,last',`v`,`last`
	if v == None:
		v = self.currentVnode
	h1 = self.yoffset(v)
	h2 = self.yoffset(last)
	if nextToLast: # 2/2/03: compute approximate line height.
		lineHeight = h2 - self.yoffset(nextToLast)
	else:
		lineHeight = 20 # A reasonable default.
	# Compute the fractions to scroll down/up.
	lo, hi = frame.treeBar.get()
	if h2 &gt; 0.1:
		frac = float(h1)/float(h2) # For scrolling down.
		frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
		frac2 = frac2 - (hi - lo)
	else:
		frac = frac2 = 0.0 # probably any value would work here.
	# 2/2/03: new logic for scrolling up.
	frac =  max(min(frac,1.0),0.0)
	frac2 = max(min(frac2,1.0),0.0)

	if frac &lt;= lo:
		if self.prevMoveToFrac != frac:
			self.prevMoveToFrac = frac
			self.canvas.yview("moveto",frac)
	elif frac2 + (hi - lo) &gt;= hi:
		if self.prevMoveToFrac != frac2:
			self.prevMoveToFrac = frac2
			self.canvas.yview("moveto",frac2)
			
	if self.allocateOnlyVisibleNodes:
		self.canvas.after_idle(self.idle_second_redraw)

	# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)</t>
<t tx="T866"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,v,updateBeadList=true):

	&lt;&lt; define vars and stop editing &gt;&gt;

	if not doHook("unselect1",c=c,new_v=v,old_v=old_v):
		&lt;&lt; unselect the old node &gt;&gt;
	else: old_body = u""

	doHook("unselect2",c=c,new_v=v,old_v=old_v)
	
	if not doHook("select1",c=c,new_v=v,old_v=old_v):
		&lt;&lt; select the new node &gt;&gt;
		if v and v != old_v: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(v)
			except: pass
		&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
		&lt;&lt; update c.visitedList &gt;&gt;

	&lt;&lt; set the current node and redraw &gt;&gt;
	doHook("select2",c=c,new_v=v,old_v=old_v)
	doHook("select3",c=c,new_v=v,old_v=old_v)
</t>
<t tx="T867">c = self.commands ; frame = c.frame ; body = frame.body
old_v = c.currentVnode()

# Unselect any previous selected but unedited label.
self.endEditLabel()
old = self.currentVnode
self.setUnselectedLabelState(old)</t>
<t tx="T868"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.body.index("insert")

# Remember the old body text
old_body = body.get("1.0","end")

if old and old != v and old.edit_text():
	old.t.scrollBarSpot = yview
	old.t.insertSpot = insertSpot
</t>
<t tx="T869">frame.setWrap(v)

# Delete only if necessary: this may reduce flicker slightly.
s = v.t.bodyString
s = toUnicode(s,"utf-8")
old_body = toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.recolor_now(v)

if v and v.t.scrollBarSpot != None:
	first,last = v.t.scrollBarSpot
	body.yview("moveto",first)

if v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.body.mark_set("insert",v.t.insertSpot)
	c.body.see(v.t.insertSpot)
else:
	c.body.mark_set("insert","1.0")</t>
<t tx="T870">if updateBeadList:
	if c.beadPointer &gt; -1:
		present_v = c.beadList[c.beadPointer]
	else:
		present_v = None
	
	if v != present_v:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(v)
</t>
<t tx="T871"># Make v the most recently visited node on the list.
if v in c.visitedList:
	c.visitedList.remove(v)
	
c.visitedList.insert(0,v)</t>
<t tx="T872">self.currentVnode = v
self.setSelectedLabelState(v)
self.scanForTabWidth(v) # 9/13/02 #GS I believe this should also get into the select1 hook
set_focus(c,c.body)
</t>
<t tx="T873"></t>
<t tx="T874">def allocateNodes(self,where,lines):
	
	"""Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
	
	assert(where in ("above","below"))

	# print "allocateNodes: %d lines %s visible area" % (lines,where)
	
	# Expand the visible area: a little extra delta is safer.
	delta = lines * (self.line_height + 4)
	y1,y2 = self.visibleArea

	if where == "below":
		y2 += delta
	else:
		y1 = max(0.0,y1-delta)

	self.expandedVisibleArea=y1,y2
	# print "expandedArea:   %5.1f %5.1f" % (y1,y2)
	
	# Allocate all nodes in expanded visible area.
	self.updatedNodeCount = 0
	self.updateTree(self.rootVnode,root_left,root_top,0,0)
	# if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
</t>
<t tx="T875">def allocateNodesBeforeScrolling (self, args):
	
	"""Calculate the nodes that will become visible as the result of an upcoming scroll.

	args is the tuple passed to the Tk.Canvas.yview method"""

	if not self.allocateOnlyVisibleNodes: return

	# print "allocateNodesBeforeScrolling:",self.redrawCount,`args`

	assert(self.visibleArea)
	assert(len(args)==2 or len(args)==3)
	kind = args[0] ; n = args[1]
	lines = 2 # Update by 2 lines to account for rounding.
	if len(args) == 2:
		assert(kind=="moveto")
		frac1,frac2 = args
		if float(n) != frac1:
			where = choose(n&lt;frac1,"above","below")
			self.allocateNodes(where=where,lines=lines)
	else:
		assert(kind=="scroll")
		linesPerPage = self.canvas.winfo_height()/self.line_height + 2
		n = int(n) ; assert(abs(n)==1)
		where = choose(n == 1,"below","above")
		lines = choose(args[2] == "pages",linesPerPage,lines)
		self.allocateNodes(where=where,lines=lines)</t>
<t tx="T876">def setVisibleArea (self,args):

	r1,r2 = args
	r1,r2 = float(r1),float(r2)
	# print "scroll ratios:",r1,r2

	try:
		s = self.canvas.cget("scrollregion")
		x1,y1,x2,y2 = scanf(s,"%d %d %d %d")
		x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
	except:
		self.visibleArea = None
		return
		
	scroll_h = y2-y1
	# print "height of scrollregion:", scroll_h

	vy1 = y1 + (scroll_h*r1)
	vy2 = y1 + (scroll_h*r2)
	self.visibleArea = vy1,vy2
	# print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
</t>
<t tx="T877">def setVisibleAreaToFullCanvas(self):
	
	if self.visibleArea:
		y1,y2 = self.visibleArea
		y2 = max(y2,y1 + self.canvas.winfo_height())
		self.visibleArea = y1,y2</t>
<t tx="T878">def updateTree (self,v,x,y,h,level):

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.updateNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	return y
</t>
<t tx="T879">@ To do:

- ** Use a general purpose XML parser to parse the jEdit mode files.
- ** Do incremental syntax coloring
	- Create lines table.
	- Initialize lines table when select new node.
- Use strings for states.
- Define colorizeLine method.
- Create self.state ivar
- Use a keyword lead-in table.
	- Use this for latex keywords and Leo keywords.
	- Add ignore-case ivar.
- Define @language xml.
- Defined syntax coloring for all jEdit token types:
	KEYWORD1,KEYWORD2,KEYWORD3,LABEL,LITERAL1,LITERAL2,MARKUP,OPERATOR
	Where do Leo keywords fit in?

</t>
<t tx="T880">@ignore

@ The following gives the general idea.

The self.known_languages dict contains all the data structures for a particular language.  This dict is created dynamically.  Each entry is a tuple of other info:
	
	"c"      : (dict1,...,dictM,list1,...,listN,etc.),
	"python" : (dict1,...,dictM,list1,...,listN,etc.),
	
These tuples, i.e., all the data structures, are created by the initialization routine.

@c
data = self.known_languages.get(self.language)
if not data:
	# Create all the data structures for the language.
	data = parse_xml_file(self.language) 
	if data: self.known_languages[language] = data
if data:
	self.dict1,...,self.listN=data

# The subsidiary data structures will be created from the xml files.
# The exact data structures used depends on the format of the xml files.

self.reserved_words1 = {} # Main language keywords: reserved words.
self.reserved_words2 = {} # Functions etc. to be colored separately.
self.keyword_chars1 = {} # Characters that appear as the first character of a keyword.
self.keyword_chars2 = {} # Characters that appear as second or following characters of a keyword.
self.string_start1,self.string.start2 # Opening characters of strings.

# The code might scan for keywords as follows:
n = len(s)
if i &lt; n and self.keywords1.get(s[i]):
	j = i ; i += 1
	while i &lt; n and self.keywords2.get(s[i]):
		i += 1
	word = s[j:i]
	if self.reserved_words1.get(word):
		# colorize the reserved word
	elif self.reserved_words2.get(word):
		# colorize the reserved word
</t>
<t tx="T881">special_keywords_dict = {
	'\\' : (latex_keywords_dict,"keyword"),
	'@' :  (leo_keywords_dict,"leoKeword") }
	
if &lt;&lt; ch is alphabetic &gt;&gt;:
	word = scan_c_word(s,i)
	kind = keywords_dict.get(word)
	if kind:
		&lt;&lt; colorize word using kind &gt;&gt;
else:
	data = special_keywords_dict.get(ch)
	if data:
		dict,kind = data
		word = scan_c_word(s,i+1)
		key = d.get(word)
		if key:
			&lt;&lt; colorize ch and word using kind &gt;&gt;</t>
<t tx="T882">@language html</t>
<t tx="T883">&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
	&lt;PROPS&gt;
		&lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
	&lt;/PROPS&gt;

	&lt;RULES&gt;
		&lt;&lt; general rules &gt;&gt;
	&lt;/RULES&gt;

	&lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
		&lt;&lt; math rules &gt;&gt;
	&lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="T884">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;$$&lt;/BEGIN&gt;
	&lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;$&lt;/BEGIN&gt;
	&lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;\[&lt;/BEGIN&gt;
	&lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="T885">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="T886">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
	&lt;PROPS&gt;
		&lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
		&lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
	&lt;/PROPS&gt;
	&lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
		&lt;&lt; comments &gt;&gt;
		&lt;&lt; literals &gt;&gt;
		&lt;&lt; operators &gt;&gt;
		&lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
		&lt;&lt; keywords &gt;&gt;
	&lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="T887">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="T888">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
	&lt;BEGIN&gt;"""&lt;/BEGIN&gt;
	&lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
	&lt;BEGIN&gt;'''&lt;/BEGIN&gt;
	&lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="T889">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
	&lt;BEGIN&gt;"&lt;/BEGIN&gt;
	&lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
	&lt;BEGIN&gt;'&lt;/BEGIN&gt;
	&lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="T890">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="T891">&lt;KEYWORDS&gt;
	&lt;&lt; reserved words &gt;&gt;
	&lt;&lt; builtins &gt;&gt;
	&lt;&lt; exceptions &gt;&gt;
	&lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="T892">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="T893">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="T894">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="T895">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="T896">@nocolor

</t>
<t tx="T897">Each mode definition must begin with the following: 

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt; 

Each mode definition must also contain exactly one MODE tag. All other tags (PROPS, RULES) must be placed inside the MODE tag. The MODE tag does not have any defined attributes. Here is an example: 

&lt;MODE&gt;
    ... mode definition goes here ...
&lt;/MODE&gt; 
</t>
<t tx="T898">The PROPS tag and the PROPERTY tags inside it are used to define mode-specific properties. Each PROPERTY tag must have a NAME attribute set to the property's name, and a VALUE attribute with the property's value. 

All buffer-local properties listed in the section called "Buffer-Local Properties" may be given values in edit modes. In addition, the following mode properties have no buffer-local equivalent: 

commentEnd - the comment end string, used by the Range Comment command. 

commentStart - the comment start string, used by the Range Comment command. 

lineComment - the line comment string, used by the Line Comment command. 

doubleBracketIndent - If a line matches the indentPrevLine regular expression and the next line contains an opening bracket, a level of indent will not be added to the next line, unless this property is set to "true". For example, with this property set to "false", Java code will be indented like so: 

while(objects.hasMoreElements())
{
        ((Drawable)objects.nextElement()).draw();
} 

On the other hand, settings this property to "true" will give the following result: 

while(objects.hasMoreElements())
        {
                ((Drawable)objects.nextElement()).draw();
        } 

indentCloseBrackets - A list of characters (usually brackets) that subtract indent from the current line. For example, in Java mode this property is set to "}".

indentOpenBrackets - A list of characters (usually brackets) that add indent to the next line. For example, in Java mode this property is set to "{".

indentPrevLine - When indenting a line, jEdit checks if the previous line matches the regular expression stored in this property. If it does, a level of indent is added. For example, in Java mode this regular expression matches language constructs such as "if", "else", "while", etc.

Here is the complete &lt;PROPS&gt; tag for Java mode: 

&lt;PROPS&gt;
    &lt;PROPERTY NAME="indentOpenBrackets" VALUE="{" /&gt;
    &lt;PROPERTY NAME="indentCloseBrackets" VALUE="}" /&gt;
    &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*(((if|while)
        \s*\(|else|case|default)[^;]*|for\s*\(.*)" /&gt;
    &lt;PROPERTY NAME="doubleBracketIndent" VALUE="false" /&gt;
    &lt;PROPERTY NAME="commentStart" VALUE="/*" /&gt;
    &lt;PROPERTY NAME="commentEnd" VALUE="*/" /&gt;
    &lt;PROPERTY NAME="blockComment" VALUE="//" /&gt;
    &lt;PROPERTY NAME="wordBreakChars" VALUE=",+-=&lt;&gt;/?^&amp;*" /&gt;
&lt;/PROPS&gt; 
</t>
<t tx="T899">RULES tags must be placed inside the MODE tag. Each RULES tag defines a ruleset.

A ruleset consists of a number of parser rules, with each parser rule specifying how to highlight a specific syntax token. There must be at least one ruleset in each edit mode. There can also be more than one, with different rulesets being used to highlight different parts of a buffer (for example, in HTML mode, one rule set highlights HTML tags, and another highlights inline JavaScript). For information about using more than one ruleset, see the section called "The SPAN Rule". 

The RULES tag supports the following attributes, all of which are optional: 

SET - the name of this ruleset. All rulesets other than the first must have a name. 

HIGHLIGHT_DIGITS - if set to TRUE, digits (0-9, as well as hexadecimal literals prefixed with "0x") will be highlighted with the DIGIT token type. Default is FALSE. 

IGNORE_CASE - if set to FALSE, matches will be case sensitive. Otherwise, case will not matter. Default is TRUE. 

DEFAULT - the token type for text which doesn't match any specific rule. Default is NULL. See the section called "Token Types" for a list of token types. 

Here is an example RULES tag: 

&lt;RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
    ... parser rules go here ...
&lt;/RULES&gt; 

Rule Ordering Requirements

You might encounter this very common pitfall when writing your own modes. 

Since jEdit checks buffer text against parser rules in the order they appear in the ruleset, more specific rules must be placed before generalized ones, otherwise the generalized rules will catch everything. 

This is best demonstrated with an example. The following is incorrect rule ordering: 

&lt;SPAN TYPE="MARKUP"&gt;
    &lt;BEGIN&gt;[&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="KEYWORD1"&gt;
    &lt;BEGIN&gt;[!&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt; 

If you write the above in a rule set, any occurrence of "[" (even things like "[!DEFINE", etc) will be highlighted using the first rule, because it will be the first to match. This is most likely not the intended behavior. 

The problem can be solved by placing the more specific rule before the general one: 

&lt;SPAN TYPE="KEYWORD1"&gt;
    &lt;BEGIN&gt;[!&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="MARKUP"&gt;
    &lt;BEGIN&gt;[&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt; 

Now, if the buffer contains the text "[!SPECIAL]", the rules will be checked in order, and the first rule will be the first to match. However, if you write "[FOO]", it will be highlighted using the second rule, which is exactly what you would expect. 

Per-Ruleset Properties

The PROPS tag (described in the section called "The PROPS Tag") can also be placed inside the RULES tag to define ruleset-specific properties. Only the following properties can be set on a per-ruleset basis: 

commentEnd - the comment end string. 

commentStart - the comment start string. 

lineComment - the line comment string. 

These properties are used by the commenting commands to implement context-sensitive comments; see the section called "Commenting Out Code". 

The TERMINATE Rule

The TERMINATE rule specifies that parsing should stop after the specified number of characters have been read from a line. The number of characters to terminate after should be specified with the AT_CHAR attribute. Here is an example: 

&lt;TERMINATE AT_CHAR="1" /&gt; 

This rule is used in Patch mode, for example, because only the first character of each line affects highlighting. 

The SPAN Rule

The SPAN rule highlights text between a start and end string. The start and end strings are specified inside child elements of the SPAN tag. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be highlighted, only the text between them will

NO_LINE_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it spans more than one line

NO_WORD_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it includes whitespace

DELEGATE - text inside the span will be highlighted with the specified ruleset. To delegate to a ruleset defined in the current mode, just specify its name. To delegate to a ruleset defined in another mode, specify a name of the form mode::ruleset. Note that the first (unnamed) ruleset in a mode is called "MAIN".

Here is a SPAN that highlights Java string literals, which cannot include line breaks: 

&lt;SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE"&gt;
   &lt;BEGIN&gt;"&lt;/BEGIN&gt;
   &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt; 

Here is a SPAN that highlights Java documentation comments by delegating to the "JAVADOC" ruleset defined elsewhere in the current mode: 

&lt;SPAN TYPE="COMMENT2" DELEGATE="JAVADOC"&gt;
   &lt;BEGIN&gt;/**&lt;/BEGIN&gt;
   &lt;END&gt;*/&lt;/END&gt;
&lt;/SPAN&gt; 

Here is a SPAN that highlights HTML cascading stylesheets inside &lt;STYLE&gt; tags by delegating to the main ruleset in the CSS edit mode: 

&lt;SPAN TYPE="MARKUP" DELEGATE="css::MAIN"&gt;
   &lt;BEGIN&gt;&amp;lt;style&amp;gt;&lt;/BEGIN&gt;
   &lt;END&gt;&amp;lt;/style&amp;gt;&lt;/END&gt;
&lt;/SPAN&gt; 

Tip
The &lt;END&gt; tag is optional. If it is not specified, any occurrence of the start string will cause the remainder of the buffer to be highlighted with this rule. 

This can be very useful when combined with delegation. 

The EOL_SPAN Rule
An EOL_SPAN is similar to a SPAN except that highlighting stops at the end of the line, not after the end sequence is found. The text to match is specified between the opening and closing EOL_SPAN tags. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start sequence will not be highlighted, only the text after it will

Here is an EOL_SPAN that highlights C++ comments: 

&lt;EOL_SPAN TYPE="COMMENT1"&gt;//&lt;/EOL_SPAN&gt; 

The MARK_PREVIOUS Rule
The MARK_PREVIOUS rule highlights from the end of the previous syntax token to the matched text. The text to match is specified between opening and closing MARK_PREVIOUS tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if it occurs at the beginning of the line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text before it will

Here is a rule that highlights labels in Java mode (for example, "XXX:"): 

&lt;MARK_PREVIOUS AT_LINE_START="TRUE"
    EXCLUDE_MATCH="TRUE"&gt;:&lt;/MARK_PREVIOUS&gt; 

The MARK_FOLLOWING Rule
The MARK_FOLLOWING rule highlights from the start of the match to the next syntax token. The text to match is specified between opening and closing MARK_FOLLOWING tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text after it will

Here is a rule that highlights variables in Unix shell scripts ("$CLASSPATH", "$IFS", etc): 

&lt;MARK_FOLLOWING TYPE="KEYWORD2"&gt;$&lt;/MARK_FOLLOWING&gt; 

The SEQ Rule
The SEQ rule highlights fixed sequences of text. The text to highlight is specified between opening and closing SEQ tags. The following attributes are supported: 

TYPE - the token type to highlight the sequence with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a line

The following rules highlight a few Java operators: 

&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt; 

The KEYWORDS Rule

There can only be one KEYWORDS tag per ruleset. The KEYWORDS rule defines keywords to highlight. Keywords are similar to SEQs, except that SEQs match anywhere in the text, whereas keywords only match whole words. 

The KEYWORDS tag does not define any attributes. 

Each child element of the KEYWORDS tag should be named after the desired token type, with the keyword text between the start and end tags. For example, the following rule highlights the most common Java keywords: 

&lt;KEYWORDS IGNORE_CASE="FALSE"&gt;
   &lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
   &lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
   &lt;KEYWORD3&gt;int&lt;/KEYWORD3&gt;
   &lt;KEYWORD3&gt;void&lt;/KEYWORD3&gt;
&lt;/KEYWORDS&gt; 

Token Types

Parser rules can highlight tokens using any of the following token types: 

NULL - no special highlighting is performed on tokens of type NULL 

COMMENT1 

COMMENT2 

FUNCTION 

INVALID - tokens of this type are automatically added if a NO_WORD_BREAK or NO_LINE_BREAK SPAN spans more than one word or line, respectively. 

KEYWORD1 

KEYWORD2 

KEYWORD3 

LABEL 

LITERAL1 

LITERAL2 

MARKUP 

OPERATOR 
</t>
<t tx="T900">@ignore
@ 5/1/03:  I have no idea what these routines are about.  They do not appear to be related to shared trees at all!</t>
<t tx="T901">@ The following methods are "middleware".  They stand between the "outer" code that executes commands, and the "raw" code that work only on a single tree or node at a time.

These routines act on the given node and all dependents joined to v's parent.</t>
<t tx="T902">def create_dependent_trees (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		if j != v:
			c = self.copyEntireTree(v) # Use old copyNode and copyTree to do this.
			c = linkAsNthChild(p,n)
</t>
<t tx="T903"># This destroys (i.e. unlinks) v and all dependent trees of v.
# Because of undo we _never_ actually destroy nodes.

def destroy_dependent_trees (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.unlink()
</t>
<t tx="T904">def move_dependent_trees_up (self,v):
	
	assert(v.next())
	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_down()
</t>
<t tx="T905"># Move lefts may destroy dependent trees.
# The caller is responsible for doing that.

def move_dependent_trees_left (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_left()
</t>
<t tx="T906"># Moving a node right may create dependent trees.
# The caller is responsible for doing that.
def move_dependent_trees_right (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_right()
</t>
<t tx="T907">def move_dependent_trees_up (self,v):
	
	assert(v.back()
	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_up()
		
</t>
<t tx="T908"></t>
<t tx="T909"></t>
<t tx="T910"></t>
<t tx="T911">@ignore</t>
<t tx="T912">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=1960386
By: riotnrrrd

There is a problem in keeping the temp files for 'Open With' up-to-date, which
manifests itself as follows:

1. Open a body text in an external editor. Close the editor without saving.

2. Edit the same text in the body text window of Leo.

3. Again open the same text in an external editor. Instead of opening the edited
text, the previous temp file is reopened.
</t>
<t tx="T913">@nocolor

I see what you are saying: if one changes a node and then uses Open With to reopen the temp file the old temp file is used if it exists.

I believe the solution is to do the following:

1. Compare the old temp file with what a "recreated" temp file would be.  This handles cases in which either the body text or the temp file has been changed.  There may be several ways of doing this: it probably doesn't matter which way is chosen.

2. Reopen the old temp file if no change has been made either to the body text or the temp file.

3. Raise a dialog if some change has been made: Leo must ask whether to use the version in the body text or the version in the temp file.  I don't believe it will be possible to do without this dialog: depending on circumstances either choice may be reasonable.</t>
<t tx="T914"></t>
<t tx="T915">@nocolor

https://sourceforge.net/forum/message.php?msg_id=1816654

Because the temp files are quietly created and are never removed, then whether I Open-With/Edit/Save every few minutes, or every few months, sooner or later Leo will freeze with no indication of what went wrong. 

It looks as if there is an attempt to create a new file name (which is where the "_0" comes in), but the
count never goes beyond 0. </t>
<t tx="T916">After a few (~5) temp files are opened in C:\windows\Temp, Windows (98) stops
opening temp files until I go in there and delete the temps Leo has left
behind. Perhaps a Temp directory in the Leo directory would be better, or
deleting the temp files once Leo is done with them. -- This would take a bit of
work, because when my editor does an auto-save, Leo pops up, wagging its tail
and announcing that the changed file has been re-loaded!

------

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1821895
By: nobody

I almost forgot about this...
I know that filling up the Windows\Temp directory can cause problems (I've had
them). However, when I forced the directory to C:\TEMP, I still have the problem.
Here's what I did to check it:

Open-With a node. The file created was
"c:\temp\LeoTemp_HoCo_Timer_Int._For_reference,.c" with a time of 10:57. Make
changes using my editor, and save them.

Open-With the same node. The file created was
"c:\temp\LeoTemp_HoCo_Timer_Int._For_reference,_0.c" with a time of 11:15. Make
changes using my editor, and save them.

Try to Open-With the same node. Leo froze until I deleted
"c:\temp\LeoTemp_HoCo_Timer_Int._For_reference,_0.c", then ran as expected.
The NEW temp file was also named
"c:\temp\LeoTemp_HoCo_Timer_Int._For_reference,_0.c".

--Rich</t>
<t tx="T917"></t>
<t tx="T918"></t>
<t tx="T919">@nocolor

Your tests confirm the bug: 

Roundtripping to/from leo seems to work fine, but the sentinels are illegal cweb control sequences. Cweb fails with errors: "Control codes are forbidden in control text." when I try to cweave/ctangle the .w file. 

When CWeave and CTangle parse the sentinel, they read (putting tokens in curly braces): 

{@q} {@@} {@c} olor {@&gt;} 

@c looks to cweb like a control code, and hence produces an error when weaving or tangling. 

To make the sentinel legal for cweave or ctangle, there can only be sequences of even numbers of @ signs in the @q ... @&gt; control sequence: 

Legal: 
@qcolor@&gt; 
@q@@color@&gt; 
@q@@@@color@&gt; 
etc. 

Illegal: 
@q@color@&gt; 
@q@@@color@&gt; 
etc. 
</t>
<t tx="T920">@ In cweb mode must double all @ signs in all directives, so putSentinel is the place to do this.</t>
<t tx="T921"></t>
<t tx="T922"># This method outputs s, a directive or reference, in a sentinel.

def putDirective(self,s,i):

	tag = "@delims"
	assert(i &lt; len(s) and s[i] == '@')
	k = i
	j = skip_to_end_of_line(s,i)
	directive = s[i:j]

	if match_word(s,k,tag):
		&lt;&lt; handle @delims &gt;&gt;
	else:
		self.putSentinel("@" + directive)

	i = skip_line(s,k)
	return i</t>
<t tx="T923"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = choose(j&lt;i, s[j:i], "")
else:
	self.writeError("Bad @delims directive")</t>
<t tx="T924">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c
def putSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.newline_pending = false # discard any pending newline.
	self.onl() ; self.putIndent(self.indent) # Start of sentinel.
	self.os(self.startSentinelComment)

	# 11/1/02: The cweb hack: if the opening comment delim ends in '@',
	# double all '@' signs except the first, which is "doubled" by the
	# trailing '@' in the opening comment delimiter.
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		assert(s and len(s)&gt;0 and s[0]=='@')
		s = s.replace('@','@@')[1:]

	self.os(s)
	self.os(self.endSentinelComment)
	if self.suppress_newlines:
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.</t>
<t tx="T925"></t>
<t tx="T926">def skipSentinelStart(self,s,i):

	start = self.startSentinelComment
	assert(start and len(start)&gt;0)

	if is_nl(s,i): i = skip_nl(s,i)
	i = skip_ws(s,i)
	assert(match(s,i,start))
	i += len(start)
	# 7/8/02: Support for REM hack
	i = skip_ws(s,i)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1
</t>
<t tx="T927">@ This method tells what kind of sentinel appears in line s.  Typically s will be an empty line before the actual sentinel, but it is also valid for s to be an actual sentinel line.

Returns (kind, s, emptyFlag), where emptyFlag is true if kind == noSentinel and s was an empty line on entry.
@c

sentinelDict = {
	"@comment" : startComment,
	"@delims" :  startDelims,
	"@verbatim": startVerbatim,
	"@verbatimAfterRef": startVerbatimAfterRef,
	"@+at":     startAt,     "@-at":     endAt,
	"@+body":   startBody,   "@-body":   endBody,
	"@+doc":    startDoc,    "@-doc":    endDoc,
	"@+leo":    startLeo,    "@-leo":    endLeo,
	"@+node":   startNode,   "@-node":   endNode,
	"@+others": startOthers, "@-others": endOthers }

def sentinelKind(self,s):

	# trace(s)
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment): 
		i += len(self.startSentinelComment)
	else:
		return atFile.noSentinel

	# 10/30/02: locally undo cweb hack here
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s = s[:i] + string.replace(s[i:],'@@','@')

	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return atFile.startRef
	if match(s,i,"@@"):   return atFile.startDirective
	if not match(s,i,'@'): return atFile.noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	key = s[j:i]
	if len(key) &gt; 0 and atFile.sentinelDict.has_key(key):
		# trace("found:",key)
		return atFile.sentinelDict[key]
	else:
		# trace("not found:",key)
		return atFile.noSentinel</t>
<t tx="T928"># 4/5/03: config.write_clone_indices no longer used.

def nodeSentinelText(self,v):
	
	if v == self.root or not v.parent():
		index = 0
	else:
		index = v.childIndex() + 1

	h = v.headString()
	&lt;&lt; remove comment delims from h if necessary &gt;&gt;

	return str(index) + '::' + h</t>
<t tx="T929">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = self.startSentinelComment
end = self.endSentinelComment

if end and len(end) &gt; 0:
	h = h.replace(start,"")
	h = h.replace(end,"")</t>
<t tx="T930"># Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(self.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	# 10/24/02: search from the right, not the left.
	k = s.rfind(self.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1
	
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if self.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')

# Set reference if it exists.
i = skip_ws(s,i)

if 0: # no longer used
	if match(s,i,"&lt;&lt;"):
		k = s.find("&gt;&gt;",i)
		if k != -1: ref = s[i:k+2]</t>
<t tx="T931">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(s,i,"&lt;&lt;"))

if len(self.endSentinelComment) == 0:
	line = s[i:-1] # No trailing newline
else:
	k = s.find(self.endSentinelComment,i)
	line = s[i:k] # No trailing newline, whatever k is.
		
# 10/30/02: undo cweb hack here
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	line = line.replace('@@','@')

out.append(line)</t>
<t tx="T932"># The first '@' has already been eaten.
assert(match(s,i,"@"))

if match_word(s,i,"@raw"):
	self.raw = true
elif match_word(s,i,"@end_raw"):
	self.raw = false

e = self.endSentinelComment
s2 = s[i:]
if len(e) &gt; 0:
	k = s.rfind(e,i)
	if k != -1:
		s2 = s[i:k] + '\n'
	
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	s2 = s2.replace('@@','@')
out.append(s2)
# trace(`s2`)</t>
<t tx="T933"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	n = len(s)
	if i &gt;= n or s[i] != '@':
		return atFile.noDirective

	table = (
		("@c",atFile.cDirective),
		("@code",atFile.codeDirective),
		("@doc",atFile.docDirective),
		("@end_raw",atFile.endRawDirective),
		("@others",atFile.othersDirective),
		("@raw",atFile.rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return choose(self.language=="cweb",
			atFile.noDirective,atFile.atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if self.language=="cweb" and (
		match_word(s,i,"@c") or
		i+1&gt;= n or s[i+1] not in string.letters):
		return atFile.noDirective

	for name,directive in table:
		if match_word(s,i,name):
			return directive
	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if match_word(s,i,name):
			return atFile.miscDirective

	return atFile.noDirective</t>
<t tx="T934">@nocolor

By: paulpaterson ( Paul Paterson ) 
 Bug?: tangle_done root_list   
2002-12-04 16:48

I wrote a tangle done routine to do some markup on some files and noticed that the file paths you get in the root_list are based on the default tangle directory and not the actual directory that the files were writen. 

To see this problem (on 3.9) put a @path directive in a node, then create a child @root node as below, 

Parent node: '@path c:\temp' 
Child node: '@root myfile.txt' 

Add some text to the child node and then tangle it. You get a c:\temp\myfile.txt file but the tangle_done.run function is called with a root_list of ["&lt;default leo tangle dir&gt;\myfile.txt"] 

You don't get this problem if you fully specify the path in the @root directive.</t>
<t tx="T935"></t>
<t tx="T936"></t>
<t tx="T937">@nocolor

Found redundancies in vnode clear/setDirty routines.  At present the dirty bit is kept in tnodes, so once it is set or cleared it is automatically cleared in all joined nodes.</t>
<t tx="T938">@nocolor

By: gilshwartz ( Gil Shwartz ) 
 save @file-nosent clones   
2003-01-31 21:27
Open Discussion

I have made @file-nosent clones under nodes with different @path directive. When saving (ctrl-s) I expected the file to be written to all places. It is only written once to the first place. While I can see the possible problem with @file clones on read, during write I see no problem in writing to all places. For read I do settle for reading any of the copies. 

Edward, do you think this is a reasonable behavior and change? 

Gil  

There was a bug in v.setAncestorAtFileNodeDirty that prevented cloned @file-nosent nodes from being marked dirty when another node was changed.  This was easily fixed.

However, you have unearthed a major stupidity involving dirty bits.  At present dirty bits in kept in _tnodes_, not vnodes, which means:

1. It is not possible to set or clear dirty bits in cloned vnodes individually and
2. The logic in v.setDirtyJoined is mostly redundant.

I'm going to think about this for a while.  It is imperitive that Leo sets dirty bits properly (which it does now, if stupidly), so any change here would be a major change.

In short, I agree that there is a bug here, and it may be a day or two before it gets fixed.

Edward</t>
<t tx="T939"></t>
<t tx="T940">@ignore</t>
<t tx="T941">@nocolor
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
	
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
	 a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="T942"></t>
<t tx="T943">@nocolor

Demote doesn't work properly on the top level, and undo doesn't restore the state.

Example:

- Select Bugs headline (collapsed)
- Choose Demote
  Not correct.
- Choose Undo
  Not correct.</t>
<t tx="T944">@nocolor

Removed a _huge_ performance bug in vnode.unjoinNode.

@color</t>
<t tx="T945">statistics at moveOutlineLeft (slow)

beginUpdate 31
childIndex 4
createDependents 1
destroyDependents 1
endUpdate 31
lastChild 13
linkAfter 1
moveAfter 1
moveOutlineLeft 1
nthChild 2
redraw 1
select 1
unjoinNode 10 ** (this was the cause of the slowdown!)
unjoinTree 2
unlink 3

statistics at undo (fast)

beginUpdate 13
childIndex 15
copyNode 8
copyTree 10
createDependents 1
destroyDependents 1
endUpdate 13
insertAfter 6
insertAsNthChild 4
isJoinedTo 13
isOnJoinListOf 10
joinNodeTo 10 **
joinTreeTo 10 **
lastChild 13
linkAfter 6
linkAsNthChild 5
moveToNthChildOf 1
nthChild 3
redraw 1
select 1
shouldBeClone 10
undo 1
unlink 1
</t>
<t tx="T946"></t>
<t tx="T947"></t>
<t tx="T948">@nocolor

The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.

Added the config.configsExist ivar to tell whether leoConfig.txt exists (as far as Leo is concerned).</t>
<t tx="T949"></t>
<t tx="T950"></t>
<t tx="T951">@ @first lines are handled at follows:
	
Reading
	
1. scanHeader ignores all lines preceding the @+leo line.  Such lines were presumably written as the result of @first directives.

2. @first directives get turned into @verbatim sentinels, so the read logic for @verbatim handles these directives as usual and turns them into body text.

Writing

1. atFile::write calls &lt;&lt; put @first lines in root &gt;&gt; to scan the body text looking for @first line.  Such lines are output.

2. atFile::write does the following to put the entire tree.

	self.putOpenLeoSentinel("@+leo")
	self.putOpenNodeSentinel(root)
	self.putBodyPart(root)
	...
	self.putCloseNodeSentinel(root)
	self.putSentinel("@-leo")
	
putBodyPart converts @first (and soon, @last) to @verbatim sentinels.

To implement @last we need only to the following:
	
1. putBodyPart and allies will handle @last like @first, namely by converting to @verbatim sentinels.

2. The read logic can just ignore anything after the @-leo sentinel.  Such code was presumably written by @last.</t>
<t tx="T952">@ Same as @file except puts no sentinels in the derived file.  Same as @silentfile except that section references and definitions are valid.
@c

</t>
<t tx="T953">@nocolor

By: travers ( Travers A. Hough ) 
 RE: @nosentinelsfile on CVS, was: could Leo...   
2002-11-29 06:33
 
It looks like @nsf may be injecting additional tabs at the beginning or end of body text.

see Extra Tabs.leo

-----

This is nasty code to get correct.  What I did:

- changed the following sections of putCodePart:

1. &lt;&lt; put the line &gt;&gt;
	Buffered characters to make tracing easier. (reduces calls to self.os)
	Don't write trailing indentation if not writing sentinels.

2. &lt;&lt; handle @others &gt;&gt;
	Skip the newline after @others if we aren't putting sentinels.

</t>
<t tx="T954">@nocolor

Changes made 9/25/02:
	
1. Attempt to create directory if config.path_directive_creates_directories is true.
2. Call getBaseDirectory to handle config.relative_path_base_directory option.

There are _way_ too many paths through this code!

@color</t>
<t tx="T955">@ignore</t>
<t tx="T956">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
ths continues */

More plain text.</t>
<t tx="T957"># The problem is that only the top-level directory is created.

@ignore</t>
<t tx="T958">@nocolor

By: davidmcnab ( David McNab ) 
 Feature Req: auto-create dirs for @file   
2002-11-17 06:33  
Hi, 

I'm getting fond of the practice of distributing source code as a tarball, containing only a .leo file, plus a README telling people to install Leo. 

There's presently one obstacle to this - when @file nodes exist for files in child directories, Leo doesn't (yet) create directories as needed. 

I humbly suggest that when writing out @file nodes, Leo creates all needed subdirectories that don't already exist.

------------------
 
I set create_nonexistent_directories=1 in leoConfig.txt, but Leo still won't create the needed subdirectories. 

</t>
<t tx="T959"># Allow test code...
@ignore</t>
<t tx="T960">@nocolor

The test code shows that all normal cases are handled correctly.  Nevertheless, we must prove that Leo can properly read and write @file nodes with nested @others directives.

Writing:

putAtOthers writes all nodes to be generated by @others.  inAtOthers returns false if the node has already been visited.  Nodes will not be visited when expanding the "outer" or "upper" @others, and will be visited thereafter.  Thus, nodes will be written at most once.

putAtOthers writes only sibling nodes and nodes descending from sibling nodes.  The expansion of inner @others nodes will never include parent nodes.  The expansion of an @others directive at @file node will write all unwritten nodes in the @file node.

In short,

1. all nodes in the "range" of an @others directive are written once and only once.
2. all nodes in the "range" of an @others directive are written enclosed in @+-others sentinels.
3. No orpan nodes are written.

Reading:

The read logic is unchanged.  Everything will work as before.  In particular, note that @+-others sentinels create trees under nodes containing the @others directive, just as before.  The read logic naturally handles nesting!</t>
<t tx="T961"></t>
<t tx="T962">@ignore</t>
<t tx="T963">@file-nosent
&lt;&lt; ref &gt;&gt;</t>
<t tx="T964">ref line</t>
<t tx="T965">@file-noref
&lt;&lt; ref &gt;&gt;</t>
<t tx="T966">ref line</t>
<t tx="T967">@file-asis
&lt;&lt; ref &gt;&gt;</t>
<t tx="T968">ref line</t>
<t tx="T969">@ignore</t>
<t tx="T970">@language perlpod
@path c:\prog\test</t>
<t tx="T971">@ Multi-line
doc part
@root perlpod.txt
&lt;&lt;ref&gt;&gt;</t>
<t tx="T972">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="T973">@comment REM_</t>
<t tx="T974">test 6</t>
<t tx="T975">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="T976">@ignore

line 1
@line 2
	@line 3
line 4</t>
<t tx="T977">if match (s,i,self.startSentinelComment + '@'):
	self.putSentinel("verbatim")</t>
<t tx="T978"></t>
<t tx="T979">This works in the log and body panes, and not in the outline pane.

proc mscroll {bindtag} {
      bind $bindtag &lt;Button-5&gt; [list %W yview scroll 5 units]
      bind $bindtag &lt;Button-4&gt; [list %W yview scroll -5 units]
      bind $bindtag &lt;Shift-Button-5&gt; [list %W yview scroll 1 units]
      bind $bindtag &lt;Shift-Button-4&gt; [list %W yview scroll -1 units]
      bind $bindtag &lt;Control-Button-5&gt; [list %W yview scroll 1 pages]
      bind $bindtag &lt;Control-Button-4&gt; [list %W yview scroll -1 pages]

from Tkinter import *

def roll(event):
    print event.delta

frame = Frame(width=200, height=200)
frame.pack()
frame.focus_set() # wheel events goes to focussed window
frame.bind("&lt;MouseWheel&gt;", roll)
</t>
<t tx="T980">@ This is very tricky code.  The new code appears to work well in all situations.</t>
<t tx="T981">@nocolor

Have the outline pane scroll by one line when focus moves to the first (or last) node in the pane.

Currently, moving focus up from the first node scrolls by one, but the first node on the screen may be partially off-screen, depending on the outline font. 

Moving focus down from the last node causes a page-down, after which the first node on the screen has focus, but this node may be partially off-screen. 
</t>
<t tx="T982"></t>
<t tx="T983"></t>
<t tx="T984">@nocolor
Here is the above code in a function, with definitions for missing functions min/max and with missing function lset replaced with calls to scan. The code has also been modified to correctly handle more than a screenful of text. This code still lacks the feature found in the default tkTextUpDownLine where the original column is maintained across repeated operations even though some lines passed through don't have enough columns -- Brian Theado:
@color
@language tcltk

 proc min args {lindex [lsort -real $args] 0}
 proc max args {lindex [lsort -real $args] end}
 
 proc moveUpDown {textWidget upOrDown} {
     # Make the insertion cursor visible so bbox doesn't return empty list
     $textWidget see insert

     # Find the coordinates of the cursor and set the new height
     # manually. Note: errors rounding off, since
     # coordinates don't match character positions exactly.
     scan [$textWidget index insert] {%d.%d} lines char
     scan [$textWidget bbox [$textWidget index insert]] {%d %d %d %d} x y textWidth textHeight
     scan [$textWidget bbox @[winfo width $textWidget],[winfo height $textWidget]] {%*d %d %*d %*d} maxy
     # When updating position, make sure y is within text boundaries
     switch -- $upOrDown {
       "up" {
           if {$y &lt;= $textHeight} {
               $textWidget yview scroll -1 units
           } else {
               set y [max [expr $y-$textHeight] 0]
           }
       }
       "down" {
           if {$y &gt;= $maxy} {
                $textWidget yview scroll 1 units
           } else {
                set y [min [expr $y+$textHeight] $maxy]
           }
       }
     }
     scan [$textWidget bbox [$textWidget index @$x,$y]] {%d %d %d %*d} newx newy width

     # Test on which side of the character
     # we should position the cursor
     if {$x&gt;[expr $newx+$width/2]} {
       set x [expr $newx+$width+1]
     }
     return [$textWidget index @$x,$y]
 }

 # Replace the default Text widget bindings to try it out
 bind Text &lt;Up&gt; {
    tkTextSetCursor %W [moveUpDown %W up]
 }
 bind Text &lt;Down&gt; {
    tkTextSetCursor %W [moveUpDown %W down]
 }</t>
<t tx="T985">@nocolor

&gt;Drat. There is some interaction between the new moveUpDown code and previous bindings... 

Note the code at http://wiki.tcl.tk/3082 is passing the result of moveUpDown to the function tkTextSetCursor, which both moves the insertion cursor and removes the selection (see lib/tk8.3/text.tcl in the Tcl/Tk distribution for the definition of this function). I notice in the leo code just moves the insertion cursor. 

Also, I just realized that Shift-Up and Shift-Down should probably rebound to use the new up/down code so stroking the selection is consistent with moving up and down. I updated the above referenced web page with this change. 

In Python the Shift-Up and Shift-Down is probably harder to incorporate in Python because it uses tkTextKeySelect which does more than tkTextSetCursor (have a look at text.tcl). I guess either more transliteration of Tcl ("greek") would be needed or maybe the tkTextKeySelect can be called from Python. 

Brian Theado </t>
<t tx="T986">@nocolor

https://sourceforge.net/forum/message.php?msg_id=1796317
By: nobody

I am a newbie to Leo, and not a programmer.
I intend to use it to write plain text, not code. I believe Leo is an ideal
writer's tool as well.

But there is one behaviour of the TkText widget that I find hard to swallow:
not to be able to move through a paragraph of text with the cursor keys.

To quote from the Leo documentation: 
"Line movement is by text lines terminated by hard returns (newlines), not by
displayed lines; if a text line is long and wraps across more than one display
line, then the Up and Down movement will skip the extra wrapped display lines."

This is probably fine for programming where a code line is usually shorter than
a screen line and so all lines are terminated by hard returns. But for plain
text in ordinary writing, most paragraphs are longer than a screen line. So
I am forced to use the mouse for every movement in the text. Unless I want to
go back word-by-word through the whole paragraph. Not very effective for writers
who mostly prefer the keyboard over the mouse.

If this cannot be changed, I would like to see MORE's 'hoist' command implemented:
hoisting the body pane text to a separate, preferrably full screen editor window
with a more navigable editor.
Actually I would like to see a 'hoist' command anyway. Working on my text on
the full screen is just nicer. But being able to bring the body pane size up
to full screen height with one command would be enough (if I could use cursor
keys for movement across screen lines...).

Ulrich
</t>
<t tx="T987">1 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
2 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
3 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk













4 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
5 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
6 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk</t>
<t tx="T988"></t>
<t tx="T989"></t>
<t tx="T990">def openOutputFile (self):
	
	if self.outputFileName == None:
		return
	dir,name = os.path.split(self.outputFileName)
	if len(dir) == 0:
		self.show("empty output directory")
		return
	if len(name) == 0:
		self.show("empty output file name")
		return
	if not os.path.exists(dir):
		self.show("output directory not found: " + dir)
	else:
		try:
			if self.appendOutput:
				self.show("appending to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"ab")
			else:
				self.show("writing to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"wb")
		except:
			self.outputFile = None
			self.show("exception opening output file")
			es_exception()</t>
<t tx="T991"># Rewrites the entire config file from ivars.
# This is called when a .leo file is written and when the preferences panel changes.

def update (self):
	
	# Do nothing if the file does not exist, or if read_only.
	if self.read_only:
		# print "Read only config file"
		return
	if not os.path.exists(self.configFileName):
		# print "No config file"
		return
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		# 9/1/02: apparently Linux requires w+ and XP requires w.
		mode = choose(sys.platform=="win32","wb","wb+")
		cf = open(self.configFileName,mode)
		config.readfp(cf)
		&lt;&lt; write recent files section &gt;&gt;
		for section,dict in self.sectionInfo:
			if dict:
				self.update_section(config,section,dict)
		config.write(cf)
		cf.flush()
		cf.close()
	except:
		es("exception writing: " + self.configFileName)
		es_exception()
	self.config = None</t>
<t tx="T992">section = self.recentFilesSection
files = self.recentFiles

if config.has_section(section):
	config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
	config.set(section,"recentFiles",files)
else: # easier to read in the config file.
	for i in xrange(len(files)):
		config.set(section, "file"+`i`, files[i])</t>
<t tx="T993">def flattenOutline (self,fileName):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		# 10/14/02: support for output_newline setting.
		mode = app.config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel)
			head = toEncodedString(head,self.encoding,reportErrors=true)
			file.write(head + nl)
			body = v.moreBody() # Inserts escapes.
			if len(body) &gt; 0:
				body = toEncodedString(body,self.encoding,reportErrors=true)
				file.write(body + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while flattening outline")
		es_exception()</t>
<t tx="T994">def outlineToWeb (self,fileName,webType):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if v == None: return
	self.setEncoding()
	self.webType = webType
	after = v.nodeAfterTree()
	try: # This can fail if the file is open by another app.
		# 10/14/02: support for output_newline setting.
		mode = app.config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		self.treeType = "@file"
		# Set self.treeType to @root if v or an ancestor is an @root node.
		while v:
			flag, junk = is_special(v.bodyString(),0,"@root")
			if flag:
				self.treeType = "@root" ; break
			else: v = v.parent()
		v = c.currentVnode()
		while v and v != after:
			s = self.convertVnodeToWeb(v)
			if len(s) &gt; 0:
				s = toEncodedString(s,self.encoding,reportErrors=true)
				file.write(s)
				if s[-1] != '\n':
					file.write(nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception in Outline To noweb command")
		es_exception()</t>
<t tx="T995">try:
	mode = app.config.output_newline
	mode = choose(mode=="platform",'w','wb')
	file = open(newFileName,mode)
	s = toEncodedString(s,self.encoding,reportErrors=true)
	file.write(s)
	file.close()
	es("creating: " + newFileName)
except:
	es("exception creating: " + newFileName)
	es_exception()</t>
<t tx="T996">try:
	# 10/14/02: support for output_newline setting.
	mode = app.config.output_newline
	mode = choose(mode=="platform",'w','wb')
	f = open(filename,mode)
	if not f: return
except:
	es("exception opening:" + filename)
	es_exception()
	return</t>
<t tx="T997">@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is true only changed roots are actually written.
@c

def put_all_roots(self):

	c = self.commands ; outline_name = c.mFileName

	for section in self.root_list:
	
		# trace(`section.name`)
		file_name = os.path.join(self.tangle_directory,section.name)
		file_name = os.path.normpath(file_name)
		temp_name = create_temp_name()
		if not temp_name:
			es("Can not create temp file")
			break
		# Set the output_file global.
		# Use "text" mode for platform-specific newlines.
		mode = app.config.output_newline
		mode = choose(mode=="platform",'w','wb')
		try:
			self.output_file = open(temp_name,mode)
			if not self.output_file:
				es("Can not create: " + temp_name)
				break
		except:
			es("Can not create: " + temp_name)
			break
		&lt;&lt;Get root specific attributes&gt;&gt;
		&lt;&lt;Put @first lines&gt;&gt;
		if self.use_header_flag and self.print_mode == "verbose":
			&lt;&lt; Write a banner at the start of the output file &gt;&gt;
		for part in section.parts:
			if part.is_root:
				self.tangle_indent = 0 # Initialize global.
				self.put_part_node(part,false) # output first lws
		self.onl() # Make sure the file ends with a cr/lf
		self.output_file.close()
		self.output_file = None
		if self.errors == 0:
			update_file_if_changed(file_name,temp_name)
		else:
			es("unchanged:  " + file_name)
			&lt;&lt; Erase the temporary file &gt;&gt;</t>
<t tx="T998"># Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines</t>
<t tx="T999"># Stephen P. Schaefer 9/13/2002
if self.first_lines:
	self.os(self.first_lines)</t>
<t tx="T1000">if self.single_comment_string:
	self.os(self.single_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
	self.os(self.start_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.oblank() ; self.os(self.end_comment_string)
	self.onl() ; self.onl()
</t>
<t tx="T1001">try: # Just delete the temp file.
	os.remove(temp_name)
except: pass
</t>
<t tx="T1002">@ It does not appear that &lt; &lt; scan @delims &gt; &gt; was _ever_ executed!</t>
<t tx="T1003">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1722358
By: nobody

Like a few other folks who have posted in this forum, I'm trying to embed Javascript
in XML.  Leo is a great tool for writing XSLT, and will be even better after
a few bugs are stamped out. :-)

The following text in an @file node can't be roundtripped (i.e., does not survive
a Leo exit and restart) unless the derived file is deleted before the restart.

@language HTML
@delims /* */     
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;

  // Hi Mom!

@delims &lt;!-- --&gt;

&lt;/script&gt;

Upon restart, the second @delims directive appears in Leo as:

/*@@delims &lt;!-- --&gt; */

If one then makes a trivial change and resaves the document, it cannot be reopened
by Leo unless the derived file is deleted.  The error messages in this case are:

reading: C:\users\mjs\tmp\delimsRoundTrip.leo
reading: @file delimsRoundTrip.xml
----- error reading @file delimsRoundTrip.xml
Unexpected end of file. Expecting @-bodysentinel
exceptions openingC:\users\mjs\tmp\delimsRoundTrip.leo
AssertionError


Note that without the leading @language directive, we skip the partially successful
roundtrip and go straight to the errors.  Changing this directive from HTML
to java has no effect that I can see on the outcome.

I'm using the Leo code from CVS, up to date as of 18 Oct 2002, 14:30ish MDT.

Is this a reasonable way to use @delims?  My reading of the other forum threads
might not have been accurate.

Thanks again,
--Michael Stevens
  mstevens at transgenomic dot com
</t>
<t tx="T1004">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1723814
By: nobody

&lt;&lt;intro&gt;&gt;

So, after reading the forums and then the documentation for the @delims directive,
I said, "Oh, that's what I was supposed to use," and instead wrote:

@delims /* */
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[
@others
]]&gt;
@delims &lt;!-- --&gt;
&lt;/script&gt;


(The first @delims directive has to go before the &lt;script&gt; tag, or else the
sentinel comment for the @delims directive itself appears in the script region
delimited by XML comment delimiters.)

This does the right thing in the derived file:

#@+leo
#@+node:0::@file delimsRoundTrip.xml
#@+body
#@@delims /* */ 
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[

/*@+others*/
/*@+node:1::subnode*/
/*@+body*/

function sendUpFlare() {
  alert("Hi Mom!");
}

/*@-body*/
/*@-node:1::subnode*/
/*@-others*/

]]&gt;

/*@@delims &lt;!-- --&gt; */
&lt;/script&gt;

&lt;!--@-body--&gt;
&lt;!--@-node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@-leo--&gt;


The contents of the &lt;script&gt;&lt;/script&gt; region will now pass muster with the Javascript
interpreter.  (I'm ignoring the leading # comments for now -- they shouldn't
be a problem if I use @language html somewhere upstream, right?)

But this derived file cannot be read back in by the Leo code in CVS as of Sunday
afternoon:

reading: C:\users\mjs\tmp\delimsRoundTrip.leo
reading: @file delimsRoundTrip.xml
----- error reading @file delimsRoundTrip.xml
Unexpected end of file. Expecting @-bodysentinel
exceptions openingC:\users\mjs\tmp\delimsRoundTrip.leo
AssertionError

Looks to my untrained eye as though the @@delims sentinel marking the return
to XML comment delimiters isn't being processed correctly in the @file reading
code. (?)  Wish I were better at reading Python. :-(

Regarding my earlier comment about mutations of the second @delims directives:
that may be a symptom of this @file parsing issue, rather than a bug in its
own right.

--Michael</t>
<t tx="T1005">Okay, maybe Friday was one of my marginal-competence days. :-)  Looking back,
my first post described the situation a couple of attempted workarounds away
from the straightforward approach, and didn't explain my goal well at all.

The goal is to maintain (in Leo) an XSLT stylesheet, elements of which generate
Javascript functions which are included inside &lt;script&gt;&lt;/script&gt; tags in the
SVG document which is the product of the stylesheet.

Imagine this as the content of an @file node:

&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[
@language java

@others

@language html
]]&gt;
&lt;/script&gt;


where the subnodes all contain modules of Javascript.  For this example, there
is a single subnode containing a single Javascript function, sendUpFlare().
(In the real application, there's a lot more stuff going on, and the &lt;script&gt;
element is a couple levels down from the @file node, but I think this test case
is still a valid demonstration of the problem I'm having).

When I try this, the @language java directive appears to have no effect on the
derived file.  The sentinel comments are still delimited in XML style with &lt;!--
and --&gt;, which causes problems for the Javascript interpreter:

&lt;!--@+leo--&gt;
&lt;!--@+node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@+body--&gt;
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[

&lt;!--@@language java--&gt;


&lt;!--@+others--&gt;
&lt;!--@+node:1::subnode--&gt;
&lt;!--@+body--&gt;

function sendUpFlare() {
  alert("Hi Mom!");
}

&lt;!--@-body--&gt;
&lt;!--@-node:1::subnode--&gt;
&lt;!--@-others--&gt;



&lt;!--@@language html--&gt;
]]&gt;
&lt;/script&gt;

&lt;!--@-body--&gt;
&lt;!--@-node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@-leo--&gt;



What I [perhaps erroneously] expected was that Leo would begin using Java style
comment delimiters for sentinel comments after the @language java directive,
so that the region of the derived file between the &lt;script&gt;&lt;/script&gt; tags would
be syntactically-acceptable Javascript (except for typos/thinkos therein --
not Leo's problem!).  But it doesn't.</t>
<t tx="T1006">assert(match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = skip_ws(s,i-1+7)
	
# Get the first delim.
j = i
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1

if j &lt; i:
	self.startSentinelComment = s[j:i]
	# print "delim1:", self.startSentinelComment

	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	end = choose(j&lt;i,s[j:i],"")
	i2 = skip_ws(s,i)
	if end == self.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
		self.endSentinelComment = "" # Not really two params.
		line = s[i0:j]
		line = line.rstrip()
		out.append(line+'\n')
	else:
		self.endSentinelComment = end
		# print "delim2:",end
		line = s[i0:i]
		line = line.rstrip()
		out.append(line+'\n')
else:
	self.readError("Bad @delims")
	# Append the bad @delims line to the body text.
	out.append("@delims")</t>
<t tx="T1007"></t>
<t tx="T1008">@nocolor

Bugs item #642952, was opened at 2002-11-23 19:38
You can respond by visiting: 
https://sourceforge.net/tracker/?func=detail&amp;atid=103458&amp;aid=642952&amp;group_id=3458

Initial Comment: XML GLITCHES - ELEMENT COLLAPSE IS BAD

Converting an empty &lt;tnodes&gt;&lt;/tnodes&gt; element to a "collapsed" &lt;tnodes /&gt;
element will cause the LEO editor to interpret the file as a bad leo file.
Generally, it appears that collapsing any expanded tags, or expanding any
collapsed tags, will cause the 'bad file' error. This makes it impossible to
edit a .leo file in any XML editor that automatically converts empty elements
to either all-collapsed or all expanded (like XMLSpy does). Technically,
collapsed elements do not violate the 'well-formed' standard of XML 1.0 (the
standard treats collapsed and expanded tags as syntactically identical), but
apparently well-formed XML is not enough for the LEO editor, or whatever it
uses to parse XML.</t>
<t tx="T1009">@ignore</t>
<t tx="T1010"># N.B. No longer crashes, but will not work as expected.
# The end of the &lt; &lt; Raw on &gt; &gt; node will reset raw mode.

	&lt;&lt; Raw ON &gt;&gt; 
	&lt;&lt;Stuff&gt;&gt; 
	&lt;&lt; Raw OFF &gt;&gt; 
</t>
<t tx="T1011">@raw

	</t>
<t tx="T1012">@end_raw 
</t>
<t tx="T1013">asfdasdfrdshfyhbsdfdewgs 
fwsgdfgsdfsd</t>
<t tx="T1014">def putBodyPart(self,v):
	
	""" Generate the body enclosed in sentinel lines."""

	# trace(`v`)
	s = v.t.bodyString
	i = skip_ws_and_nl(s, 0)
	if i &gt;= len(s): return

	s = removeTrailingWs(s) # don't use string.rstrip!
	self.putSentinel("@+body")
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	self.putSentinel("@-body")</t>
<t tx="T1015">i = 0 ; n = len(s)
firstLastHack = 1

if firstLastHack:
	&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
while i &lt; n:
	kind = self.directiveKind(s,i)
	if firstLastHack:
		&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
	j = i
	if kind == atFile.docDirective or kind == atFile.atDirective:
		i = self.putDoc(s,i,kind)
	elif ( # 10/16/02
		kind == atFile.miscDirective or
		kind == atFile.rawDirective or
		kind == atFile.endRawDirective ):
		if firstLastHack:
			&lt;&lt; handle misc directives &gt;&gt;
		else:
			i = self.putDirective(s,i)
	elif kind == atFile.noDirective or kind == atFile.othersDirective:
		i = self.putCodePart(s,i,v)
	elif kind == atFile.cDirective or kind == atFile.codeDirective:
		i = self.putDirective(s,i)
		i = self.putCodePart(s,i,v)
	else: assert(false) # We must handle everything that directiveKind returns
	assert(n == len(s))
	assert(j &lt; i) # We must make progress.

if firstLastHack:
	&lt;&lt; put out the last directives, if any &gt;&gt;</t>
<t tx="T1016"># 14-SEP-2002 DTHEIN: If this is the root node, then handle all @first directives here
lookingForLast = 0
lookingForFirst = 0
initialLastDirective = -1
lastDirectiveCount = 0
if (v == self.root):
	lookingForLast = 1
	lookingForFirst = 1</t>
<t tx="T1017"># 14-SEP-2002 DTHEIN: If first directive isn't @first, then stop looking for @first
if lookingForFirst:
	if kind != atFile.miscDirective:
		lookingForFirst = 0
	elif not match_word(s,i,"@first"):
		lookingForFirst = 0

if lookingForLast:
	if initialLastDirective == -1:
		if (kind == atFile.miscDirective) and match_word(s,i,"@last"):
			# mark the point where the last directive was found
			initialLastDirective = i
	else:
		if (kind != atFile.miscDirective) or (not match_word(s,i,"@last")):
			# found something after @last, so process the @last directives
			# in 'ignore them' mode
			i, initialLastDirective = initialLastDirective, -1
			lastDirectiveCount = 0
			kind = self.directiveKind(s,i)</t>
<t tx="T1018">if lookingForFirst: # DTHEIN: can only be true if it is @first directive
	i = self.putEmptyDirective(s,i)
elif (initialLastDirective != -1) and match_word(s,i,"@last"):
	# DTHEIN: can only be here if lookingForLast is true
	# skip the last directive ... we'll output it at the end if it
	# is truly 'last'
	lastDirectiveCount += 1
	i = skip_line(s,i)
else:
	i = self.putDirective(s,i)</t>
<t tx="T1019"># 14-SEP-2002 DTHEIN
if initialLastDirective != -1:
	d = initialLastDirective
	for k in range(lastDirectiveCount):
		d = self.putEmptyDirective(s,d)</t>
<t tx="T1020">@ In scanText I moved code from the @+node logic to the @+body logic.  I also removed code in atFile::read that set the body text.

So now body text is updated only as the direct result of @+body, so the presence or absence of @+node sentinels can have no effect.

The code is very similar to the old code; it is simply in a new place.  However, this is no guarantee of correctness or completelness.</t>
<t tx="T1021">@ignore</t>
<t tx="T1022">@language html
before
@ Out-of-control comment.
Not.
@c 
after</t>
<t tx="T1023"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc(self,file,s,i,out,kind):

	endKind = choose(kind == atFile.startDoc, atFile.endDoc, atFile.endAt)
	single = len(self.endSentinelComment) == 0
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	nextLine = None ; kind = atFile.noSentinel
	while len(s) &gt; 0:
		&lt;&lt; set kind, nextLine &gt;&gt;
		if kind == endKind: break
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to out &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = self.readLine(file)
	if kind != endKind:
		self.readError("Missing " + self.sentinelName(endKind) + " sentinel")
	&lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="T1024">assert(match(s,i,choose(kind == atFile.startDoc, "+doc", "+at")))

out.append(choose(kind == atFile.startDoc, "@doc", "@"))
s = self.readLine(file)
</t>
<t tx="T1025">if not single:
	j = skip_ws(s,0)
	if match(s,j,self.startSentinelComment):
		s = self.readLine(file)</t>
<t tx="T1026">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	j = skip_ws(s,0)
	blankLine = s[j] == '\n'
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
	if blankLine and nextKind == endKind:
		kind = endKind # stop the scan now
</t>
<t tx="T1027"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment):
		i += len(self.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = self.skipIndent(s,0, self.indent)
</t>
<t tx="T1028"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
	# no trailing whitespace: the newline is real.
	out.append(line + '\n')
else:
	# trailing whitespace: the newline is not real.
	out.append(line)
</t>
<t tx="T1029"># This code will typically only be executed for HTML files.

if not single:

	delim = self.endSentinelComment
	n = len(delim)
	
	# Remove delim and possible a leading newline.
	s = string.join(out,"")
	s = s.rstrip()
	if s[-n:] == delim:
		s = s[:-n]
	if s[-1] == '\n':
		s = s[:-1]
		
	# Rewrite out in place.
	del out[:]
	out.append(s)
</t>
<t tx="T1030">@ignore
@nocolor

The problem is that a node may contain clones.  It is not enough to the node N dirty, we must call setAncestorAtFileNodeDirty for all cloned nodes in N's tree!  But we only should do that when deleting a node.

Note that the undo and redo cases handle this automatically because they call c.doDelete.

@color</t>
<t tx="T1031">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to the caller.

This marks v dirty and all cloned nodes in v's tree.

2/1/03: I don't see how this can possibly be correct.
Why is it needed?? If it is needed, what about undo??
@c
def setAncestorsOfClonedNodesInTreeDirty(self):

	# Look up the tree for an ancestor @file node.
	v = self ; redraw_flag = false
	
	if v == None:
		return redraw_flag
		
	flag = v.setAncestorAtFileNodeDirty()
	if flag: redraw_flag = true
		
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isCloned() and not v.isDirty():
			flag = v.setAncestorAtFileNodeDirty()
			if flag: redraw_flag = true
			for v2 in v.t.joinList:
				if v2 != v:
					flag = v2.setAncestorAtFileNodeDirty()
					if flag: redraw_flag = true
		v = v.threadNext()

	return redraw_flag</t>
<t tx="T1032">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to c.endUpdate().

This is called from v.setDirty, so we avoid further calls to v.setDirty here.  The caller, that is, v.setDirty itself, handles all clones.

@c
def setAncestorAtFileNodeDirty(self):

	# Look up the tree for an ancestor @file node.
	v = self ; c = v.commands
	redraw_flag = false
	c.beginUpdate()
	while v:
		if not v.isDirty() and v.isAnyAtFileNode():
			# trace(v)
			redraw_flag = true
			v.t.setDirty() # Do not call v.setDirty here!
		v = v.parent()
	c.endUpdate(redraw_flag) # A crucial optimization: does nothing if inside nested begin/endUpdate.
	return redraw_flag # Allow caller to do the same optimization.</t>
<t tx="T1033">@ v.setDirty now ensures that all cloned nodes are marked dirty and that all ancestor @file nodes are marked dirty.  It is much safer to do it this way.
@c

def setDirty (self):

	v = self ; c = v.commands
	# trace(`v`)
	changed = false
	c.beginUpdate()
	if not v.t.isDirty():
		v.t.setDirty()
		changed = true
	# This must _always_ be called, even if v is already dirty.
	if v.setAncestorAtFileNodeDirty():
		changed = true
	for v2 in v.t.joinList:
		if v2 != v:
			assert(v2.t.isDirty())
			# Again, must always be called.
			if v2.setAncestorAtFileNodeDirty():
				changed = true
	c.endUpdate(changed)
	return changed
	
def setDirtyDeleted (self):
	self.setDirty()
	return

def initDirtyBit (self):
	self.t.setDirty()</t>
<t tx="T1034">def sortChildren(self):

	c = self ; v = c.currentVnode()
	if not v or not v.hasChildren(): return
	&lt;&lt; Set the undo info for sortChildren &gt;&gt;
	c.beginUpdate()
	c.endEditing()
	v.sortChildren()
	v.setDirty()
	c.setChanged(true)
	c.endUpdate()
	
def sortSiblings (self):
	
	c = self ; v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent:
		c.sortTopLevel()
	else:
		&lt;&lt; Set the undo info for sortSiblings &gt;&gt;
		c.beginUpdate()
		c.endEditing()
		parent.sortChildren()
		parent.setDirty()
		c.setChanged(true)
		c.endUpdate()</t>
<t tx="T1035"># Get the present list of children.
children = []
child = v.firstChild()
while child:
	children.append(child)
	child = child.next()
c.undoer.setUndoParams("Sort Children",v,sort=children)</t>
<t tx="T1036"># Get the present list of siblings.
sibs = []
sib = parent.firstChild()
while sib:
	sibs.append(sib)
	sib = sib.next()
c.undoer.setUndoParams("Sort Siblings",v,sort=sibs)</t>
<t tx="T1037">def sortChildren (self):

	# Create a list of (headline,vnode) tuples
	v = self ; pairs = []
	child = v.firstChild()
	if not child: return
	while child:
		pairs.append((string.lower(child.headString()), child))
		child = child.next()
	# Sort the list on the headlines.
	pairs.sort()
	# Move the children.
	index = 0
	for headline,child in pairs:
		child.moveToNthChildOf(v,index)
		index += 1</t>
<t tx="T1038"># Compatibility routine for scripts

def moveToNthChildOf (self, p, n):

	"""Moves the receiver to the nth child of p"""

	v = self ; c = self.commands

	v.destroyDependents()
	v.unlink()
	v.linkAsNthChild(p, n)
	v.createDependents()
	
	# 5/27/02: Moving a node can create a new root node.
	if not p.parent() and not p.back():
		c.frame.setRootVnode(p)</t>
<t tx="T1039"># Deletes the current vnode and dependent nodes. Does nothing if the outline would become empty.

def deleteHeadline (self,op_name="Delete Outline"):

	c = self ; v = c.currentVnode()
	if not v: return
	vBack = v.visBack()
	# Bug fix: 1/18/00: if vBack is NULL we are at the top level,
	# the next node should be v.next(), _not_ v.visNext();
	if vBack: newNode = vBack
	else: newNode = v.next()
	if not newNode: return
	c.endEditing()# Make sure we capture the headline for Undo.
	c.beginUpdate()
	v.setDirtyDeleted() # 8/3/02: Mark @file nodes dirty for all clones in subtree.
	# Reinsert v after back, or as the first child of parent, or as the root.
	c.undoer.setUndoParams(op_name,v,select=newNode)
	v.doDelete(newNode) # doDelete destroys dependents.
	c.setChanged(true)
	c.endUpdate()
	c.validateOutline()</t>
<t tx="T1040">@ignore</t>
<t tx="T1041">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="T1042">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="T1043">@ignore</t>
<t tx="T1044">@language c</t>
<t tx="T1045">@root c:/prog/test/MemoryBuffer.txt

&lt;&lt; MemoryBuffer declarations &gt;&gt;
&lt;&lt; MemoyrBuffer classes &gt;&gt;
</t>
<t tx="T1046">@c

package net.javacoding.gfx.core.buffer.memory;



/* javacoding imports */
import net.javacoding.gfx.core.buffer.Buffer;
</t>
<t tx="T1047">@ *
 *  Default implementation of a MemoryBuffer, this abstract class will be
 *  overloaded by different framebuffers for each type of color model
 *  ( Palettized, RGB, Planed RGB, ... ).
 *  
 *  @author  G?nther Van Roey
 *  @version 2001/07/18
 *  @since   0.0.1
&lt;&lt; MemoyrBuffer classes &gt;&gt;=

public abstract class MemoryBuffer implements Buffer {
	&lt;&lt; class MemoryBuffer declarations &gt;&gt;
	&lt;&lt; class MemoryBuffer methods &gt;&gt;



  /**
   *  This one will create the buffers.  Can be overloaded.
   */
  protected abstract void instantiate ( );
  
  

  /**
   *  For a palettized buffer.
   *  @return byte array representing the palette index values forming the image.
   */
  public abstract byte[] getPalettizedBuffer ( );



  /**
   *  Returns palette color components array for RED component.
   *  byte array holding the RED component of the color value.
   */
  public abstract byte[] getRPalette ( );



  /**
   *  Returns palette color components array for GREEN component.
   *  byte array holding the GREEN component of the color value.
   */
  public abstract byte[] getGPalette ( );



  /**
   *  Returns palette color components array for BLUE component.
   *  byte array holding the BLUE component of the color value.
   */
  public abstract byte[] getBPalette ( );



  /**
   *  Returns an int buffer holding the RGB image data.
   *  @int array representing the RGB values of all pixels
   */
  public abstract int[] getRGBBuffer ( );



  /**
   *  Red component data structure in planed RGB mode.
   *  @return byte array holding the red components of each pixel.
   */
  public abstract byte[] getPlanedRBuffer ( );



  /**
   *  Green component data structure in planed RGB mode.
   *  @return byte array holding the green components of each pixel.
   */
  public abstract byte[] getPlanedGBuffer ( );



  /**
   *  Blue component data structure in planed RGB mode.
   *  @return byte array holding the blue components of each pixel.
   */
  public abstract byte[] getPlanedBBuffer ( );
  
}</t>
<t tx="T1048">@c

  /** the width of the buffer. */
  protected int width  = 0;

  /** the height of the buffer. */
  protected int height = 0;
</t>
<t tx="T1049">@ *
   *  Constructor that takes the wanted memorybuffer dimensions as parameters.
   *  @param width the wanted width for the buffer
   *  @param height the wanted height for the buffer
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public MemoryBuffer ( int width, int height ) {
    negotiateDimensions ( width, height );
    instantiate ( );
  }
</t>
<t tx="T1050">@ *
   * Will be called by the gfx producer after each frame.
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public abstract void update ( );



  /**
   *  Returns the buffer's height.
   *  @return the buffer's height
   */
  public final int getHeight ( ) {
    return height;
  }
</t>
<t tx="T1051">@ *
   *  Returns the buffer's width.
   *  @return the buffer's width
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public final int getWidth ( ) {
    return width;
  }
</t>
<t tx="T1052">@ *
   *  Can be overloaded by buffers that need to have specific values for dimensions or
   *  specific relationships between the width and height values.
   *  @param width the wanted width for the buffer
   *  @param height the wanted height for the buffer
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

protected void negotiateDimensions ( int width, int height ) {
    this.width  = width;
    this.height = height;
  }
</t>
<t tx="T1053"># Cutting a node definitely does not set the ancestor @file node dirty!</t>
<t tx="T1054">@ignore</t>
<t tx="T1055"></t>
<t tx="T1056">this is a test</t>
<t tx="T1057">@ this is a test
@root Icons/test2.txt
more test</t>
<t tx="T1058">@nocolor

Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.

@color</t>
<t tx="T1059">@ignore</t>
<t tx="T1060">multiple read test.</t>
<t tx="T1061">@ It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="T1062"></t>
<t tx="T1063">assert(match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = ""
&lt;&lt; Set headline and ref &gt;&gt;

# print childIndex,headline

if childIndex == 0: # The root node.
	&lt;&lt; Check the filename in the sentinel &gt;&gt;
	# Put the text of the root node in the current node.
	self.scanText(file,v,out,atFile.endNode)
	v.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
else:
	# NB: this call to createNthChild is the bottleneck!
	child = self.createNthChild(childIndex,v,headline)
	child.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
	self.scanText(file,child,out,atFile.endNode)

&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</t>
<t tx="T1064">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i:
	self.readError("Implicit child index in @+node")
	childIndex = 0
else:
	childIndex = int(s[j:i])

if match(s,i,':'):
	i += 1 # Skip the ":".
else:
	self.readError("Bad child index in @+node")</t>
<t tx="T1065">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T1066">h = headline.strip()

if h[:5] == "@file":
	i,junk,junk = scanAtFileOptions(h)
	fileName = string.strip(h[i:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
	fileName = string.strip(h[8:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")
</t>
<t tx="T1067">s = self.readLine(file)
kind = self.sentinelKind(s)

if len(s) &gt; 1 and kind == atFile.startVerbatimAfterRef:
	s = self.readLine(file)
	# trace("verbatim:"+`s`)
	out.append(s)
elif len(s) &gt; 1 and self.sentinelKind(s) == atFile.noSentinel:
	out.append(s)
else:
	nextLine = s # Handle the sentinel or blank line later.
</t>
<t tx="T1068">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c
def putCodePart(self,s,i,v):

	c = self.commands
	atOthersSeen = false # true: at-others has been expanded.
	while i &lt; len(s):
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;

	# Raw code parts can only end at the end of body text.
	self.raw = false
	return i</t>
<t tx="T1069">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

leading_nl = (s[i] == body_newline) # 9/27/02: look ahead before outputting newline.
if leading_nl:
	i = skip_nl(s,i)
	self.onl() # 10/15/02: simpler to do it here.

#leading_ws1 = i # 1/27/03
j,delta = skip_leading_ws_with_indent(s,i,self.tab_width)
#leading_ws2 = j # 1/27/03
kind1 = self.directiveKind(s,i)
kind2 = self.directiveKind(s,j)
if self.raw:
	if kind1 == atFile.endRawDirective:
		&lt;&lt; handle @end_raw &gt;&gt;
else:
	if kind1 == atFile.othersDirective or kind2 == atFile.othersDirective:
		&lt;&lt; handle @others &gt;&gt;
	elif kind1 == atFile.rawDirective:
		&lt;&lt; handle @raw &gt;&gt;
	elif kind1 == atFile.noDirective:
		&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
	else:
		break # all other directives terminate the code part.</t>
<t tx="T1070"># This skips all indent and delta whitespace, so putAtOthers must generate it all.

if 0: # 9/27/02: eliminates the newline preceeding the @+others sentinel.
	# This does not seem to be a good idea.
	i = skip_line(s,i) 
else:
	i = skip_to_end_of_line(s,i)

if atOthersSeen:
	self.writeError("@others already expanded in: " + v.headString())
else:
	atOthersSeen = true
	self.putAtOthers(v, delta)
	
	# 12/8/02: Skip the newline _after_ the @others.
	if not self.sentinels and is_nl(s,i):
		i = skip_nl(s,i)
</t>
<t tx="T1071">self.raw = true
self.putSentinel("@@raw")
i = skip_line(s,i)</t>
<t tx="T1072">self.raw = false
self.putSentinel("@@end_raw")
i = skip_line(s,i)</t>
<t tx="T1073">if not self.raw:
	# 12/8/02: Don't write trailing indentation if not writing sentinels.
	if self.sentinels or j &lt; len(s):
		self.putIndent(self.indent)

newlineSeen = false
# 12/8/02: we buffer characters here for two reasons:
# 1) to make traces easier to read and 2) to increase speed.
buf = i # Indicate the start of buffered characters.
while i &lt; len(s) and not newlineSeen:
	ch = s[i]
	if ch == body_newline:
		break
	elif ch == body_ignored_newline:
		i += 1
	elif ch == '&lt;' and not self.raw:
		&lt;&lt; put possible section reference &gt;&gt;
	else:
		i += 1
# Output any buffered characters.
self.putBuffered(s[buf:i])</t>
<t tx="T1074">isSection, j = self.isSectionName(s, i)

if isSection:
	# Output the buffered characters and clear the buffer.
	s2 = s[buf:i] ; buf = i
	# 7/9/03: don't output trailing indentation if we aren't generating sentinels.
	if not self.sentinels:
		while len(s2) and s2[-1] in (' ','\t'):
			s2 = s2[:-1]
	self.putBuffered(s2)
	# Output the expansion.
	name = s[i:j]
	j,newlineSeen = self.putRef(name,v,s,j,delta)
	assert(j &gt; i) # isSectionName must have made progress
	i = j ; buf = i
else:
	# This is _not_ an error.
	i += 1</t>
<t tx="T1075">@ Returns true if v should be included in the expansion of the at-others directive in the body text of v's parent.

7/30/02: v will not be included if it is a definition node or if its body text contains an @ignore directive. Previously, a "nested" @others directive would also inhibit the inclusion of v.
@c
def inAtOthers(self,v):

	# Return false if this has been expanded previously.
	if  v.isVisited(): return false
	# Return false if this is a definition node.
	h = v.headString()
	i = skip_ws(h,0)
	isSection, j = self.isSectionName(h,i)
	if isSection: return false
	# Return false if v's body contains an @ignore or at-others directive.
	if 1: # 7/29/02: New code.  Amazingly, this appears to work!
		return not v.isAtIgnoreNode()
	else: # old &amp; reliable code
		return not v.isAtIgnoreNode() and not v.isAtOthersNode()</t>
<t tx="T1076"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

	if not match(s,i,"&lt;&lt;"):
		return false, -1
	i = find_on_line(s,i,"&gt;&gt;")
	if i:
		return true, i + 2
	else:
		return false, -1</t>
<t tx="T1077">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c
def putAtOthers(self,v,delta):

	self.indent += delta
	self.putSentinel("@+others")

	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putSentinel("@-others")
	self.indent -= delta</t>
<t tx="T1078">def putAtOthersChild(self,v):
	
	# trace("%d %s" % (self.indent,`v`))
	self.putOpenNodeSentinel(v)
	
	# Insert the expansion of v.
	v.setVisited() # Make sure it is never expanded again.
	self.putBodyPart(v)

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putCloseNodeSentinel(v)
</t>
<t tx="T1079">def putRef (self,name,v,s,i,delta):

	newlineSeen = false
	ref = findReference(name, v)
	if not ref:
		self.writeError("undefined section: " + name +
			"\n\treferenced from: " + v.headString())
		return i,newlineSeen

	# trace(self.indent,delta,s[i:])
	&lt;&lt; Generate the expansion of the reference &gt;&gt;

	# The newlineSeen allows the caller to break out of the loop.
	return i,newlineSeen</t>
<t tx="T1080"># Adjust indent here so sentinel looks better.
self.indent += delta

self.putSentinel("@" + name)
self.putOpenSentinels(v,ref)
self.putBodyPart(ref)
self.putCloseSentinels(v,ref)
&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;

self.indent -= delta
ref.setVisited()</t>
<t tx="T1081">j = skip_ws(s,i)
if j &lt; len(s) and match(s,j,self.startSentinelComment + '@'):
	self.putSentinel("@verbatimAfterRef")
	# 9/27/02: Put the line immediately, before the @-node sentinel.
	k = skip_to_end_of_line(s,i)
	self.putBuffered(s[i:k])
	i = k ; newlineSeen = false</t>
<t tx="T1082">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * abs(n))

def onl(self):
	self.os(self.output_newline)

def os(self,s):
	if s is None or len(s) == 0: return
	if self.suppress_newlines and self.newline_pending:
		self.newline_pending = false
		s = self.output_newline + s
	if self.outputFile:
		try:
			s = toEncodedString(s,self.encoding,reportErrors=true)
			self.outputFile.write(s)
		except:
			es("exception writing:" + `s`)
			es_exception()

def otabs(self,n):
	self.os('\t' * abs(n))</t>
<t tx="T1083"></t>
<t tx="T1084"></t>
<t tx="T1085">assert(self.outputFile == None)

if os.path.exists(self.targetFileName): 
	if filecmp.cmp(self.outputFileName, self.targetFileName):
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName)
			es_exception()
		es("unchanged: " + self.shortFileName)
	else:
		try:
			# 10/6/02: retain the access mode of the previous file,
			# removing any setuid, setgid, and sticky bits.
			mode = (os.stat(self.targetFileName))[0] &amp; 0777
		except:
			mode = None
		try: # Replace target file with temp file.
			os.remove(self.targetFileName)
			utils_rename(self.outputFileName, self.targetFileName)
			if mode: # 10/3/02: retain the access mode of the previous file.
				os.chmod(self.targetFileName,mode)
			es("writing: " + self.shortFileName)
		except:
			self.writeError("exception removing and renaming:" + self.outputFileName +
				" to " + self.targetFileName)
			es_exception()
else:
	try:
		# os.rename(self.outputFileName, self.targetFileName)
		utils_rename(self.outputFileName, self.targetFileName)
		es("creating: " + self.targetFileName)
	except:
		self.writeError("exception renaming:" + self.outputFileName +
			" to " + self.targetFileName)
		es_exception()</t>
<t tx="T1086"></t>
<t tx="T1087">@ This function compares two files. If they are different, we replace file_name with temp_name. Otherwise, we just delete temp_name.  Both files should be closed.
@c

def update_file_if_changed(file_name,temp_name):

	if os.path.exists(file_name):
		import filecmp
		if filecmp.cmp(temp_name, file_name):
			try: # Just delete the temp file.
				os.remove(temp_name)
			except: pass
			es("unchanged: " + file_name)
		else:
			try:
				# 10/6/02: retain the access mode of the previous file,
				# removing any setuid, setgid, and sticky bits.
				mode = (os.stat(file_name))[0] &amp; 0777
			except:
				mode = None
			try: # Replace file with temp file.
				os.remove(file_name)
				utils_rename(temp_name, file_name)
				if mode: # 10/3/02: retain the access mode of the previous file.
					os.chmod(file_name,mode)
				es("***updating: " + file_name)
			except:
				es("Rename failed: no file created!",color="red")
				es(`file_name` + " may be read-only or in use")
				es_exception()
	else:
		try:
			# os.rename(temp_name, file_name)
			utils_rename(temp_name, file_name)
			es("creating: " + file_name)
		except:
			es("rename failed: no file created!",color="red")
			es(`file_name` + " may be read-only or in use")
			es_exception()</t>
<t tx="T1088">@ignore</t>
<t tx="T1089"></t>
<t tx="T1090">def getBool (self):
	self.skipWs() # guarantees at least one more character.
	ch = self.fileBuffer[self.fileIndex]
	if ch == '0':
		self.fileIndex += 1 ; return false
	elif ch == '1':
		self.fileIndex += 1 ; return true
	else:
		raise BadLeoFile("expecting bool constant")
		
def getDqBool (self):
	self.getDquote() ; val = self.getBool() ; self.getDquote()
	return val
	
def getDqString (self): # 7/10/02
	self.getDquote()
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'"',i)
	if j == -1: raise BadLeoFile("unterminated double quoted string")
	s = self.fileBuffer[i:j]
	self.getDquote()
	return s

def getDouble (self):
	self.skipWs()
	i = self.fileIndex ; buf = self.fileBuffer
	floatChars = string.digits + 'e' + 'E' + '.' + '+' + '-'
	n = len(buf)
	while i &lt; n and buf[i] in floatChars:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting float constant")
	val = float(buf[self.fileIndex:i])
	self.fileIndex = i
	return val

def getDquote (self):
	self.getTag('"')
	
def getIndex (self):
	val = self.getLong()
	if val &lt; 0: raise BadLeoFile("expecting index")
	return val
	
def getLong (self):
	self.skipWs() # guarantees at least one more character.
	i = self.fileIndex
	if self.fileBuffer[i] == '-':
		i += 1
	n = len(self.fileBuffer)
	while i &lt; n and self.fileBuffer[i] in string.digits:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting int constant")
	val = int(self.fileBuffer[self.fileIndex:i])
	self.fileIndex = i
	return val
		
def getStringToTag (self,tag):
	buf = self.fileBuffer
	blen = len(buf) ; tlen = len(tag)
	i = j = self.fileIndex
	while i &lt; blen:
		if tag == buf[i:i+tlen]:
			self.fileIndex = i
			return buf[j:i]
		else: i += 1
	raise BadLeoFile("expecting string terminated by " + tag)
	return ""
	
# Look ahead for collapsed tag: tag may or may not end in "&gt;"
# Skips tag and /&gt; if found, otherwise does not alter index.
def getOpenTag (self,tag):
	if tag[-1] == "&gt;":
		# Only the tag itself or a collapsed tag are valid.
		if self.matchTag(tag):
			return false # Not a collapsed tag.
		elif self.matchTag(tag[:-1]):
			# It must be a collapsed tag.
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
		print "getOpenTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
	else:
		# The tag need not be followed by "/&gt;"
		if self.matchTag(tag):
			old_index = self.fileIndex
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
			else:
				self.fileIndex = old_index
				return false
		else:
			print "getOpenTag(", tag, ") failed:"
			raise BadLeoFile("expecting" + tag)
	
# 11/24/02: Look ahead for closing /&gt;
# Return true if found.
def getTag (self,tag):
	if self.matchTag(tag):
		return
	else:
		print "getTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
		
def getUnknownTag(self):
	
	self.skipWsAndNl() # guarantees at least one more character.
	tag = self.getStringToTag('=')
	if not tag:
		print "getUnknownTag failed"
		raise BadLeoFile("unknown tag not followed by '='")
	self.fileIndex += 1
	val = self.getDqString()
	trace(tag,val)
	return tag,val
	</t>
<t tx="T1091">def matchChar (self,ch):
	self.skipWs() # guarantees at least one more character.
	if ch == self.fileBuffer[self.fileIndex]:
		self.fileIndex += 1 ; return true
	else: return false

# Warning: does not check for end-of-word,
# so caller must match prefixes first.
def matchTag (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	if tag == self.fileBuffer[i:i+len(tag)]:
		self.fileIndex += len(tag)
		return true
	else:
		return false

def matchTagWordIgnoringCase (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	tag = string.lower(tag)
	j = skip_c_id(self.fileBuffer,i)
	word = self.fileBuffer[i:j]
	word = string.lower(word)
	if tag == word:
		self.fileIndex += len(tag)
		return true
	else:
		return false
</t>
<t tx="T1092">def putProlog (self):

	c = self.commands ; config = app.config

	&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;
	&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;

	self.put("&lt;leo_file&gt;") ; self.put_nl()</t>
<t tx="T1093"># 1/22/03: use self.leo_file_encoding encoding.
self.put(app.prolog_prefix_string)
self.put_dquote() ; self.put(self.leo_file_encoding) ; self.put_dquote()
self.put(app.prolog_postfix_string) ; self.put_nl()</t>
<t tx="T1094">if config.stylesheet or c.frame.stylesheet:
	
	# The stylesheet in the .leo file takes precedence over the default stylesheet.
	if c.frame.stylesheet:
		s = c.frame.stylesheet
	else:
		s = config.stylesheet
		
	tag = "&lt;?xml-stylesheet "
	# print "writing:", tag + s + "?&gt;"
	self.put(tag) ; self.put(s) ; self.put("?&gt;") ; self.put_nl()
</t>
<t tx="T1095">@ Parses the optional xml stylesheet string, and sets the corresponding config option.

For example, given: &lt;?xml_stylesheet s?&gt;
the config option is s.
@c

def getXmlStylesheetTag (self):
	
	c = self.commands
	tag = "&lt;?xml-stylesheet "

	if self.matchTag(tag):
		s = self.getStringToTag("?&gt;")
		# print "reading:", tag + s + "?&gt;"
		c.frame.stylesheet = s
		self.getTag("?&gt;")
</t>
<t tx="T1096">@ignore</t>
<t tx="T1097"></t>
<t tx="T1098"></t>
<t tx="T1099">@path new
@root test1.txt

test1.txt</t>
<t tx="T1100">@root new/test2.txt

test2.txt</t>
<t tx="T1101"></t>
<t tx="T1102">@path c:/prog/test
@root test3.txt

test3.txt</t>
<t tx="T1103">@root c:/prog/test/test4.txt

test4.txt</t>
<t tx="T1104"># make sure the simplest case still works!

@root test5.txt

test5 text</t>
<t tx="T1105">@ This code skips the file name used in @root directives.  i points after the @root directive.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.  If a file name is not enclosed be these delimiters it continues until the next newline.
@c
def setRootFromText(self,s,err_flag):
	
	# trace(`s`)
	self.root_name = None
	i,self.start_mode = scanAtRootOptions(s,0)
	i = skip_ws(s,i)
	
	if i &gt;= len(s): return i
	# Allow &lt;&gt; or "" as delimiters, or a bare file name.
	if s[i] == '"':
		i += 1 ; delim = '"'
	elif s[i] == '&lt;':
		i += 1 ; delim = '&gt;'
	else: delim = body_newline

	root1 = i # The name does not include the delimiter.
	while i &lt; len(s) and s[i] != delim and not is_nl(s,i):
		i += 1
	root2 = i

	if delim != body_newline and not match(s,i,delim):
		if err_flag:
			scanError("bad filename in @root " + s[:i])
	else:
		self.root_name = string.strip(s[root1:root2])
	return i</t>
<t tx="T1106">@ The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].
@c

def get_directives_dict(s,root=None):
	
	"""Scans root for @directives found in globalDirectivesList
	Returns a dict containing pointers to the start of each directive"""

	if root: root_node = root[0]
	dict = {}
	i = 0 ; n = len(s)
	while i &lt; n:
		if s[i] == '@' and i+1 &lt; n:
			&lt;&lt; set dict for @ directives &gt;&gt;
		elif root and match(s,i,"&lt;&lt;"):
			&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;
		i = skip_line(s,i)
	return dict</t>
<t tx="T1107">j = skip_c_id(s,i+1)
word = s[i+1:j]
if word in globalDirectiveList:
	dict [word] = i
</t>
<t tx="T1108">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
	i = skip_ws(s,i+1) # Skip the '*'
	if match(s,i,"&gt;&gt;="):
		# &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
		i += 3
		if root_node:
			dict["root"]=0 # value not immportant
		else:
			es(angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="T1109">@ Platform-independent rename.

os.rename may fail on some Unix flavors if src and dst are on different filesystems.
@c

def utils_rename(src,dst):
	
	head,tail=os.path.split(dst)
	if head and len(head) &gt; 0:
		makeAllNonExistentDirectories(head)
	
	if sys.platform=="win32":
		os.rename(src,dst)
	else:
		from distutils.file_util import move_file
		move_file(src,dst)</t>
<t tx="T1110"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory():

	base = app.config.relative_path_base_directory

	if base and base == "!":
		base = app.loadDir
	elif base and base == ".":
		base = top().openDirectory

	# trace(`base`)
	if base and len(base) &gt; 0 and os.path.isabs(base):
		return base # base need not exist yet.
	else:
		return "" # No relative base given.
</t>
<t tx="T1111">@language c
@comment /* */
@ignore</t>
<t tx="T1112">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836344
By: nobody

From: Rich

I've noticed that when I save an @file-nosent file, the first line in expanded
nodes is indented by 1 tab. That is, given body text like this:

stuff
&lt;&lt;wonderful stuff&gt;&gt;
hot air

with &lt;&lt; wonderful stuff &gt;&gt; defined as

Oh,no
chill out
the @file expansion (I'm not gonna try to imitate the sentinels!!) looks like
this:

stuff
Oh,no
chill out
hot air

but the @file-nosent expansion looks like this:

stuff
...Oh,no
chill out
hot air

where the "...." is a TAB.

I've got @language C and @comment /* */ (OLD compiler)

--Rich

P.S. - I forgot to mention that putting a blank line at the top of the sub-node
(&lt;&lt; wonderful stuff &gt;&gt;) alleviates this problem.

--Rich

</t>
<t tx="T1113">	line 1
	&lt;&lt;ref&gt;&gt;
	line 2</t>
<t tx="T1114">ref line 1
	indented ref line 2
ref line 3</t>
<t tx="T1115">@language python</t>
<t tx="T1116"></t>
<t tx="T1117"></t>
<t tx="T1118">def rawWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atRawFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		&lt;&lt; write root's tree &gt;&gt;
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T1119">next = root.nodeAfterTree()

if 0: # Clone indices are no longer used.
	self.updateCloneIndices(root, next)

&lt;&lt; put all @first lines in root &gt;&gt;
self.putOpenLeoSentinel("@+leo")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

v = root
while v and v != next:
	&lt;&lt; Write v's node &gt;&gt;
	v = v.threadNext()

self.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T1120">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.putBuffered(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T1121">s2 = app().config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)&gt; 0:
			self.putSentinel("@comment " + line)
</t>
<t tx="T1122">self.putOpenNodeSentinel(v)
	
s = v.bodyString()
if s and len(s) &gt; 0:
	self.putSentinel("@+body")
	if self.newline_pending:
		self.newline_pending = false
		self.onl()
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)
	self.putSentinel("@-body")
	
self.putCloseNodeSentinel(v)
</t>
<t tx="T1123">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="T1124">def silentWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atSilentFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		v = root
		while v and v != next:
			&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;
			&lt;&lt; Write v's body &gt;&gt;
			v = v.threadNext()
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T1125">s = v.headString()
if match(s,0,"@@"):
	s = s[2:]
	if s and len(s) &gt; 0:
		s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
		self.outputFile.write(s)
</t>
<t tx="T1126">s = v.bodyString()
if s and len(s) &gt; 0:
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)</t>
<t tx="T1127"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false):

	c = self.commands
	self.sentinels = not nosentinels
	&lt;&lt; initialize &gt;&gt;
	try:
		&lt;&lt; open the file; return on error &gt;&gt;
		&lt;&lt; write then entire @file tree &gt;&gt;
		self.closeWriteFile()
		&lt;&lt; warn about @ignored and orphans &gt;&gt;
		&lt;&lt; finish writing &gt;&gt;
	except:
		self.handleWriteException()</t>
<t tx="T1128">self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
self.raw = false
c.endEditing() # Capture the current headline.</t>
<t tx="T1129">if nosentinels:
	self.targetFileName = root.atNoSentinelsFileNodeName()
else:
	self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root)
if not ok: return</t>
<t tx="T1130"># unvisited nodes will be orphans, except in cweb trees.
root.clearVisitedInTree()
next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="T1131">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="T1132"># 10/26/02: Always warn, even when language=="cweb"

next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		self.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		self.writeError("@ignore node: " + v.headString())
	v = v.threadNext()
</t>
<t tx="T1133">@ We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(self.outputFileName) # Delete the temp file.
	es("Not written: " + self.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	self.replaceTargetFileIfDifferent()</t>
<t tx="T1134">def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	c = self.commands
	self.initIvars()
	writtenFiles = [] # Files that might be written again.

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		v = c.currentVnode()
		after = v.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		v = c.rootVnode()
		after = None

	&lt;&lt; Clear all orphan bits &gt;&gt;
	while v and v != after:
		# trace(`v`)
		if v.isAnyAtFileNode() or v.isAtIgnoreNode():
			&lt;&lt; handle v's tree &gt;&gt;
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()

	&lt;&lt; say the command is finished &gt;&gt;</t>
<t tx="T1135">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

v2 = v
while v2 and v2 != after:
	v2.clearOrphan()
	v2 = v2.threadNext()</t>
<t tx="T1136"># This code is a little tricky: @ignore not recognised in @silentfile nodes.

if v.isDirty() or writeAtFileNodesFlag or v.t in writtenFiles:

	if v.isAtSilentFileNode():
		self.silentWrite(v)
	elif v.isAtIgnoreNode():
		pass
	elif v.isAtRawFileNode():
		self.rawWrite(v)
	elif v.isAtNoSentinelsFileNode():
		self.write(v,nosentinels=true)
	elif v.isAtFileNode():
		self.write(v)

	if not v.isAtIgnoreNode():
		writtenFiles.append(v.t)</t>
<t tx="T1137">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) &gt; 0:
		es("finished")
	elif writeAtFileNodesFlag:
		es("no @file nodes in the selected tree")
	else:
		es("no dirty @file nodes")</t>
<t tx="T1138">def writeMissing(self,v):

	self.initIvars()
	writtenFiles = false
	after = v.nodeAfterTree()
	while v and v != after:
		if v.isAtSilentFileNode() or (v.isAnyAtFileNode() and not v.isAtIgnoreNode()):
			missing = false ; valid = true
			self.targetFileName = v.anyAtFileNodeName()
			&lt;&lt; set missing if the file does not exist &gt;&gt;
			if valid and missing:
				&lt;&lt; create self.outputFile &gt;&gt;
				if self.outputFile:
					&lt;&lt; write the @file node &gt;&gt;
			v = v.nodeAfterTree()
		elif v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	
	if writtenFiles &gt; 0:
		es("finished")
	else:
		es("no missing @file node in the selected tree")</t>
<t tx="T1139"># This is similar, but not the same as, the logic in openWriteFile.

valid = self.targetFileName and len(self.targetFileName) &gt; 0

if valid:
	try:
		# Creates missing directives if option is enabled.
		self.scanAllDirectives(v)
		valid = self.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false

if valid:
	try:
		fn = self.targetFileName
		self.shortFileName = fn # name to use in status messages.
		self.targetFileName = os.path.join(self.default_directory,fn)
		self.targetFileName = os.path.normpath(self.targetFileName)
		path = self.targetFileName # Look for the full name, not just the directory.
		valid = path and len(path) &gt; 0
		if valid:
			missing = not os.path.exists(path)
	except:
		es("exception creating path:" + fn)
		es_exception()
		valid = false</t>
<t tx="T1140">try:
	self.outputFileName = self.targetFileName + ".leotmp"
	self.outputFile = open(self.outputFileName,'wb')
	if self.outputFile == None:
		self.writeError("can not open " + self.outputFileName)
except:
	es("exception opening:" + self.outputFileName)
	es_exception()
	self.outputFile = None
</t>
<t tx="T1141">if v.isAtSilentFileNode():
	self.silentWrite(v)
elif v.isAtRawFileNode():
	self.rawWrite(v)
elif v.isAtNoSentinelsFileNode():
	self.write(v,nosentinels=true)
elif v.isAtFileNode():
	self.write(v)
else: assert(0)

writtenFiles = true
</t>
<t tx="T1142"></t>
<t tx="T1143">def closeWriteFile (self):
	
	if self.outputFile:
		if self.suppress_newlines and self.newline_pending:
			self.newline_pending = false
			self.onl() # Make sure file ends with a newline.
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
</t>
<t tx="T1144">def handleWriteException (self,root=None):
	
	es("exception writing:" + self.targetFileName)
	es_exception()
	
	if self.outputFile:
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
	
	if self.outputFileName != None:
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName)
			es_exception()

	if root:
		# Make sure we try to rewrite this file.
		root.setOrphan()
		root.setDirty()</t>
<t tx="T1145"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root):

	try:
		self.scanAllDirectives(root)
		valid = self.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false
	
	if valid:
		try:
			fn = self.targetFileName
			self.shortFileName = fn # name to use in status messages.
			self.targetFileName = os.path.join(self.default_directory,fn)
			self.targetFileName = os.path.normpath(self.targetFileName)
			path = os.path.dirname(self.targetFileName)
			if path and len(path) &gt; 0:
				valid = os.path.exists(path)
				if not valid:
					self.writeError("path does not exist: " + path)
			else:
				valid = false
		except:
			es("exception creating path:" + fn)
			es_exception()
			valid = false
	
	if valid:
		if os.path.exists(self.targetFileName):
			try:
				read_only = not os.access(self.targetFileName,os.W_OK)
				if read_only:
					es("read only: " + self.targetFileName)
					valid = false
			except:
				pass # os.access() may not exist on all platforms.
		
	if valid:
		try:
			self.outputFileName = self.targetFileName + ".tmp"
			self.outputFile = open(self.outputFileName,'wb')
			valid = self.outputFile != None
			if not valid:
				self.writeError("can not open " + self.outputFileName)
		except:
			es("exception opening:" + self.outputFileName)
			es_exception()
			valid = false
	
	if not valid:
		root.setOrphan()
		root.setDirty()
	
	return valid</t>
<t tx="T1146">def putInitialComment (self):
	
	s2 = app().config.output_initial_comment
	if s2:
		lines = string.split(s2,"\\n")
		for line in lines:
			line = line.replace("@date",time.asctime())
			if len(line)&gt; 0:
				self.putSentinel("@comment " + line)</t>
<t tx="T1147">def replaceTargetFileIfDifferent (self):
	
	assert(self.outputFile == None)
	
	if os.path.exists(self.targetFileName):
		if filecmp.cmp(self.outputFileName,self.targetFileName):
			&lt;&lt; delete the output file &gt;&gt;
		else:
			&lt;&lt; replace the target file with the output file &gt;&gt;
	else:
		&lt;&lt; rename the output file to be the target file &gt;&gt;
</t>
<t tx="T1148">try: # Just delete the temp file.
	os.remove(self.outputFileName)
except:
	es("exception deleting:" + self.outputFileName)
	es_exception()

es("unchanged: " + self.shortFileName)</t>
<t tx="T1149">try:
	# 10/6/02: retain the access mode of the previous file,
	# removing any setuid, setgid, and sticky bits.
	mode = (os.stat(self.targetFileName))[0] &amp; 0777
except:
	mode = None

try: # Replace target file with temp file.
	os.remove(self.targetFileName)
	try:
		utils_rename(self.outputFileName,self.targetFileName)
		if mode != None: # 10/3/02: retain the access mode of the previous file.
			try:
				os.chmod(self.targetFileName,mode)
			except:
				es("exception in os.chmod(%s)" % (self.targetFileName))
		es("writing: " + self.shortFileName)
	except:
		# 6/28/03
		self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
		es_exception()
except:
	self.writeError("exception removing:" + self.targetFileName)
	es_exception()
	try: # Delete the temp file when the deleting the target file fails.
		os.remove(self.outputFileName)
	except:
		es("exception deleting:" + self.outputFileName)
		es_exception()</t>
<t tx="T1150">try:
	utils_rename(self.outputFileName,self.targetFileName)
	es("creating: " + self.targetFileName)
except:
	self.writeError("exception renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	es_exception()</t>
<t tx="T1151"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

	# Calling self.onl() runs afoul of queued newlines.
	self.os(s.replace('\n',self.output_newline))</t>
<t tx="T1152">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c
def putDoc(self,s,i,kind):

	if kind == atFile.atDirective:
		i += 1 ; tag = "at"
	elif kind == atFile.docDirective:
		i += 4 ; tag = "doc"
	else: assert(false)
	# Set j to the end of the doc part.
	n = len(s) ; j = i
	while j &lt; n:
		j = skip_line(s, j)
		kind = self.directiveKind(s, j)
		if kind == atFile.codeDirective or kind == atFile.cDirective:
			break
	self.putSentinel("@+" + tag)
	self.putDocPart(s[i:j])
	self.putSentinel("@-" + tag)
	return j</t>
<t tx="T1153"># Puts a comment part in comments.
# Note: this routine is _never_ called in cweb mode,
# so noweb section references are _valid_ in cweb doc parts!

def putDocPart(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	c = self.commands
	single = len(self.endSentinelComment) == 0
	if not single:
		self.putIndent(self.indent)
		self.os(self.startSentinelComment) ; self.onl()
	# Put all lines.
	i = 0 ; n = len(s)
	while i &lt; n:
		self.putIndent(self.indent)
		leading = self.indent
		if single:
			self.os(self.startSentinelComment) ; self.oblank()
			leading += len(self.startSentinelComment) + 1
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	if not single:
		# This comment is like a sentinel.
		self.onl() ; self.putIndent(self.indent)
		self.os(self.endSentinelComment)
		self.onl() # Note: no trailing whitespace.</t>
<t tx="T1154">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

line = i # Start of the current line.
while i &lt; n:
	word = i # Start of the current word.
	# Skip the next word and trailing whitespace.
	i = skip_ws(s, i)
	while i &lt; n and not is_nl(s,i) and not is_ws(s[i]):
		i += 1
	i = skip_ws(s,i)
	# Output the line if no more is left.
	if i &lt; n and is_nl(s,i):
		break
	# Split the line before the current word if needed.
	lineLen = i - line
	if line == word or leading + lineLen &lt; self.page_width:
		word = i # Advance to the next word.
	else:
		# Write the line before the current word and insert a newline.
		theLine = s[line:word]
		self.os(theLine)
		self.onl() # This line must contain trailing whitespace.
		line = i = word  # Put word on the next line.
		break
# Remove trailing whitespace and output the remainder of the line.
theLine = string.rstrip(s[line:i]) # from right.
self.os(theLine)
if i &lt; n and is_nl(s,i):
	i = skip_nl(s,i)
	self.onl() # No inserted newline and no trailing whitespace.</t>
<t tx="T1155"></t>
<t tx="T1156">def putBuffered (self,s):
	
	"""Put s, converting all tabs to blanks as necessary."""
	
	if s:
		w = self.tab_width
		if w &lt; 0:
			#trace(s)
			lines = s.split('\n')
			for i in xrange(len(lines)):
				line = lines[i]
				line2 = ""
				for j in xrange(len(line)):
					ch = line[j]
					if ch == '\t':
						w2 = computeWidth(s[:j],w)
						w3 = (abs(w) - (w2 % abs(w)))
						line2 += ' ' * w3
					else:
						line2 += ch
				lines[i] = line2
			s = string.join(lines,'\n')
		#trace(s)
		self.os(s)</t>
<t tx="T1157"># 14-SEP-2002 DTHEIN
# added for use by putBodyPart()

# This method outputs the directive without the parameter text
def putEmptyDirective(self,s,i):

	assert(i &lt; len(s) and s[i] == '@')
	
	endOfLine = s.find('\n',i)
	# 21-SEP-2002 DTHEIN: if no '\n' then just use line length
	if endOfLine == -1:
		endOfLine = len(s)
	token = s[i:endOfLine].split()
	directive = token[0]
	self.putSentinel("@" + directive)

	i = skip_line(s,i)
	return i</t>
<t tx="T1158">def putIndent(self,n):
	
	"""Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

	if n != 0:
		# trace(n)
		w = self.tab_width
		if w &gt; 1:
			q,r = divmod(n,w) 
			self.otabs(q) 
			self.oblanks(r)
		else:
			self.oblanks(n)</t>
<t tx="T1159"></t>
<t tx="T1160">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
	
	if shortcut == None or len(shortcut) == 0:
		return None,None
	s = shortcut.strip().lower()
	has_alt   = s.find("alt") &gt;= 0
	has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
	has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
	&lt;&lt; set the last field, preserving case &gt;&gt;
	&lt;&lt; canonicalize the last field &gt;&gt;
	&lt;&lt; synthesize the shortcuts from the information &gt;&gt;
	# print shortcut,bind_shortcut,menu_shortcut
	return bind_shortcut,menu_shortcut</t>
<t tx="T1161">bind_last = menu_last = last
if len(last) == 1:
	ch = last[0]
	if ch in string.ascii_letters:
		menu_last = string.upper(last)
		if has_shift:
			bind_last = string.upper(last)
		else:
			bind_last = string.lower(last)
	elif ch in string.digits:
		bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
	else:
		&lt;&lt; define dict of Tk bind names &gt;&gt;
		if ch in dict.keys():
			bind_last = dict[ch]
elif len(last) &gt; 0:
	&lt;&lt; define dict of special names &gt;&gt;
	last2 = string.lower(last)
	if last2 in dict.keys():
		bind_last,menu_last = dict[last2]</t>
<t tx="T1162"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
dict = {
	"!" : "exclam",
	'"' : "quotedbl",
	"#" : "numbersign",
	"$" : "dollar",
	"%" : "percent",
	"&amp;" : "ampersand",
	"'" : "quoteright",
	"(" : "parenleft",
	")" : "parenright",
	"*" : "asterisk",
	"+" : "plus",
	"," : "comma",
	"-" : "minus",
	"." : "period",
	"/" : "slash",
	":" : "colon",
	";" : "semicolon",
	"&lt;" : "less",
	"=" : "equal",
	"&gt;" : "greater",
	"?" : "question",
	"@" : "at",
	"[" : "bracketleft",
	"\\": "backslash",
	"]" : "bracketright",
	"^" : "asciicircum",
	"_" : "underscore",
	"`" : "quoteleft",
	"{" : "braceleft",
	"|" : "bar",
	"}" : "braceright",
	"~" : "asciitilde" }</t>
<t tx="T1163"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

dict = {
	"bksp"    : ("BackSpace","BkSp"),
	"esc"     : ("Escape","Esc"),
	# Arrow keys...
	"dnarrow" : ("Down", "DnArrow"),
	"ltarrow" : ("Left", "LtArrow"),
	"rtarrow" : ("Right","RtArrow"),
	"uparrow" : ("Up",   "UpArrow"),
	# Page up/down keys...
	"pageup"  : ("Prior","PgUp"),
	"pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="T1164">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
	s2 = string.replace(s2,"-","+")
	s2 = s2[:-1] + "-"
else:
	s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
	if not app.menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None

last = fields[-1]
if last == None or len(last) == 0:
	if not app.menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None</t>
<t tx="T1165">bind_head = menu_head = ""

if has_shift:
	menu_head = "Shift+"
	if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
		bind_head = "Shift-"
	# else: print "no shift: last:", `last`

if has_alt:
	bind_head = bind_head + "Alt-"
	menu_head = menu_head + "Alt+"

if has_ctrl:
	bind_head = bind_head + "Control-"
	menu_head = menu_head + "Ctrl+"
	
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="T1166">def createMenuBar(self, top):

	c = self.commands
	Tk = Tkinter
	topMenu = Tk.Menu(top,postcommand=self.OnMenuClick)
	self.setMenu("top",topMenu)
	self.menuShortcuts = []
	# To do: use Meta rathter than Control for accelerators for Unix
	&lt;&lt; create the file menu &gt;&gt;
	&lt;&lt; create the edit menu &gt;&gt;
	&lt;&lt; create the outline menu &gt;&gt;
	doHook("create-optional-menus",c=c)
	&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;
	top.config(menu=topMenu) # Display the menu.
	app.menuWarningsGiven = true
</t>
<t tx="T1167">editMenu = self.createNewMenu("&amp;Edit")
&lt;&lt; create the first top-level edit entries &gt;&gt;
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
&lt;&lt; create the last top-level edit entries &gt;&gt;
</t>
<t tx="T1168">table = (
	("Can't Undo","Ctrl+Z",self.OnUndo), # &amp;U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",self.OnRedo), # &amp;R reserved for Redo
	("-",None,None),
	("Cu&amp;t","Ctrl+X",self.OnCutFromMenu), 
	("Cop&amp;y","Ctrl+C",self.OnCopyFromMenu),
	("&amp;Paste","Ctrl+V",self.OnPasteFromMenu),
	("&amp;Delete",None,self.OnDelete),
	("Select &amp;All","Ctrl+A",self.OnSelectAll),
	("-",None,None))

self.createMenuEntries(editMenu,table)
</t>
<t tx="T1169">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

table = (
	("Extract &amp;Section","Shift+Ctrl+E",self.OnExtractSection),
	("Extract &amp;Names","Shift+Ctrl+N",self.OnExtractNames),
	("&amp;Extract","Shift+Ctrl+D",self.OnExtract),
	("-",None,None),
	("Convert All B&amp;lanks",None,self.OnConvertAllBlanks),
	("Convert All T&amp;abs",None,self.OnConvertAllTabs),
	("Convert &amp;Blanks","Shift+Ctrl+B",self.OnConvertBlanks),
	("Convert &amp;Tabs","Shift+Ctrl+J",self.OnConvertTabs),
	("Insert Body Time/&amp;Date","Shift+Ctrl+G",self.OnInsertBodyTime),
	("&amp;Reformat Paragraph","Shift+Ctrl+P",self.OnReformatParagraph),
	("-",None,None),
	("&amp;Indent","Ctrl+]",self.OnIndent),
	("&amp;Unindent","Ctrl+[",self.OnDedent),
	("&amp;Match Brackets","Ctrl+K",self.OnFindMatchingBracket))
	
self.createMenuEntries(editBodyMenu,table)

</t>
<t tx="T1170">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

table = (
	("Edit &amp;Headline","Ctrl+H",self.OnEditHeadline),
	("&amp;End Edit Headline","Escape",self.OnEndEditHeadline),
	("&amp;Abort Edit Headline","Shift-Escape",self.OnAbortEditHeadline),
	("Insert Headline Time/&amp;Date","Shift+Ctrl+H",self.OnInsertHeadlineTime))
	
	# 5/16/03 EKR: I dislike this command.
	#("Toggle Angle Brackets","Ctrl+B",self.OnToggleAngleBrackets)
	
self.createMenuEntries(editHeadlineMenu,table)

</t>
<t tx="T1171">findMenu = self.createNewMenu("&amp;Find...","Edit")

table = (
	("&amp;Find Panel","Ctrl+F",self.OnFindPanel),
	("-",None,None),
	("Find &amp;Next","F3",self.OnFindNext),
	("Find &amp;Previous","F4",self.OnFindPrevious),
	("&amp;Replace","Ctrl+=",self.OnReplace),
	("Replace, &amp;Then Find","Ctrl+-",self.OnReplaceThenFind))

self.createMenuEntries(findMenu,table)
</t>
<t tx="T1172">label = choose(c.frame.getColorizer().showInvisibles,"Hide In&amp;visibles","Show In&amp;visibles")

table = (
	("&amp;Go To Line Number","Alt+G",self.OnGoToLineNumber),
	("&amp;Execute Script","Alt+Shift+E",self.OnExecuteScript),
	("Set Fon&amp;t...","Shift+Alt+T",self.OnFontPanel),
	("Set &amp;Colors...","Shift+Alt+C",self.OnColorPanel),
	(label,"Alt+V",self.OnViewAllCharacters),
	("-",None,None),
	("Prefere&amp;nces","Ctrl+Y",self.OnPreferences))

self.createMenuEntries(editMenu,table)</t>
<t tx="T1173">fileMenu = self.createNewMenu("&amp;File")
&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the recent files submenu &gt;&gt;
fileMenu.add_separator()
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
fileMenu.add_separator()
# Create the last entries.
exitTable = (("E&amp;xit","Ctrl-Q",self.OnQuit),)
self.createMenuEntries(fileMenu,exitTable)

</t>
<t tx="T1174">@ leo.py will probably never have a Print command.  Instead, export text files that may be formatted and printed as desired.
@c

table = (
	("&amp;New","Ctrl+N",self.OnNew),
	("&amp;Open...","Ctrl+O",self.OnOpen))
self.createMenuEntries(fileMenu,table)

# 7/1/03: Create a new menu rather than call OnOpenWith.
self.createNewMenu("Open &amp;With...","File")

table = (
	("-",None,None),
	("&amp;Close","Ctrl+W",self.OnClose),
	("&amp;Save","Ctrl+S",self.OnSave),
	("Save &amp;As","Shift+Ctrl+S",self.OnSaveAs),
	("Save To",None,self.OnSaveTo), # &amp;Tangle
	("Re&amp;vert To Saved",None,self.OnRevert)) # &amp;Read/Write
self.createMenuEntries(fileMenu,table)</t>
<t tx="T1175">self.createNewMenu("Recent &amp;Files...","File")
self.recentFiles = app.config.getRecentFiles()
self.createRecentFilesMenuItems()

if 0: # now in Recent Files menu.
	table = (("Clear Recent Files",None,self.OnClearRecentFiles),)
	self.createMenuEntries(fileMenu,table)</t>
<t tx="T1176">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

table = (
		("&amp;Read Outline Only","Shift+Ctrl+R",self.OnReadOutlineOnly),
		("Read @file &amp;Nodes",None,self.OnReadAtFileNodes),
		("-",None,None),
		("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",self.OnWriteDirtyAtFileNodes),
		("Write &amp;Missing @file Nodes",None,self.OnWriteMissingAtFileNodes),
		("Write &amp;Outline Only",None,self.OnWriteOutlineOnly),
		("&amp;Write @file Nodes","Shift+Ctrl+W",self.OnWriteAtFileNodes),
		("-",None,None),
		("Write 4.x Derived Files",None,self.OnWriteNewDerivedFiles),
		("Write 3.x Derived Files",None,self.OnWriteOldDerivedFiles))

self.createMenuEntries(readWriteMenu,table)</t>
<t tx="T1177">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

table = (
	("Tangle &amp;All","Shift+Ctrl+A",self.OnTangleAll),
	("Tangle &amp;Marked","Shift+Ctrl+M",self.OnTangleMarked),
	("&amp;Tangle","Shift+Ctrl+T",self.OnTangle))

self.createMenuEntries(tangleMenu,table)

</t>
<t tx="T1178">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

table = (
	("Untangle &amp;All",None,self.OnUntangleAll),
	("Untangle &amp;Marked",None,self.OnUntangleMarked),
	("&amp;Untangle","Shift+Ctrl+U",self.OnUntangle))
	
self.createMenuEntries(untangleMenu,table)

</t>
<t tx="T1179">importMenu = self.createNewMenu("&amp;Import...","File")

table = (
	("Import Derived File",None,self.OnImportDerivedFile),
	("Import To @&amp;file","Shift+Ctrl+F",self.OnImportAtFile),
	("Import To @&amp;root",None,self.OnImportAtRoot),
	("Import &amp;CWEB Files",None,self.OnImportCWEBFiles),
	
	("Import &amp;noweb Files",None,self.OnImportNowebFiles),
	("Import Flattened &amp;Outline",None,self.OnImportFlattenedOutline))
	
self.createMenuEntries(importMenu,table)

</t>
<t tx="T1180">exportMenu = self.createNewMenu("&amp;Export...","File")

table = [
	("Export &amp;Headlines",None,self.OnExportHeadlines),
	("Outline To &amp;CWEB",None,self.OnOutlineToCWEB),
	("Outline To &amp;Noweb",None,self.OnOutlineToNoweb),
	("&amp;Flatten Outline",None,self.OnFlattenOutline),
	("&amp;Remove Sentinels",None,self.OnRemoveSentinels),
	("&amp;Weave",None,self.OnWeave)]

self.createMenuEntries(exportMenu,table)
</t>
<t tx="T1181">outlineMenu = self.createNewMenu("&amp;Outline")
&lt;&lt; create top-level outline menu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="T1182">table = (
	("C&amp;ut Node","Shift+Ctrl+X",self.OnCutNode),
	("C&amp;opy Node","Shift+Ctrl+C",self.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",self.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",self.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",self.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",self.OnCloneNode),
	("Sort C&amp;hildren",None,self.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",self.OnSortSiblings),
	("-",None,None))

self.createMenuEntries(outlineMenu,table)</t>
<t tx="T1183">expandMenu = self.createNewMenu("&amp;Expand/Contract...","Outline")

table = (
	("&amp;Contract All","Alt+-",self.OnContractAll),
	("Contract &amp;Node","Alt+[",self.OnContractNode),
	("Contract &amp;Parent","Alt+0",self.OnContractParent),
	("-",None,None),
	("Expand P&amp;rev Level","Alt+.",self.OnExpandPrevLevel),
	("Expand N&amp;ext Level","Alt+=",self.OnExpandNextLevel),
	("-",None,None),
	("Expand To Level &amp;1","Alt+1",self.OnExpandToLevel1),
	("Expand To Level &amp;2","Alt+2",self.OnExpandToLevel2),
	("Expand To Level &amp;3","Alt+3",self.OnExpandToLevel3),
	("Expand To Level &amp;4","Alt+4",self.OnExpandToLevel4),
	("Expand To Level &amp;5","Alt+5",self.OnExpandToLevel5),
	("Expand To Level &amp;6","Alt+6",self.OnExpandToLevel6),
	("Expand To Level &amp;7","Alt+7",self.OnExpandToLevel7),
	("Expand To Level &amp;8","Alt+8",self.OnExpandToLevel8),
	# ("Expand To Level &amp;9","Alt+9",self.OnExpandToLevel9),
	("-",None,None),
	("Expand &amp;All","Alt+9",self.OnExpandAll),
	("Expand N&amp;ode","Alt+]",self.OnExpandNode))


self.createMenuEntries(expandMenu,table)</t>
<t tx="T1184">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

table = (
	("Move &amp;Down", "Ctrl+D",self.OnMoveDown),
	("Move &amp;Left", "Ctrl+L",self.OnMoveLeft),
	("Move &amp;Right","Ctrl+R",self.OnMoveRight),
	("Move &amp;Up",   "Ctrl+U",self.OnMoveUp),
	("-",None,None),
	("&amp;Promote","Ctrl+{",self.OnPromote),
	("&amp;Demote", "Ctrl+}",self.OnDemote))
	
self.createMenuEntries(moveSelectMenu,table)
</t>
<t tx="T1185">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

table = (
	("&amp;Mark","Ctrl-M",self.OnMark),
	("Mark &amp;Subheads","Alt+S",self.OnMarkSubheads),
	("Mark Changed &amp;Items","Alt+C",self.OnMarkChangedItems),
	("Mark Changed &amp;Roots","Alt+R",self.OnMarkChangedRoots),
	("Mark &amp;Clones","Alt+K",self.OnMarkClones),
	("&amp;Unmark All","Alt+U",self.OnUnmarkAll))
	
self.createMenuEntries(markMenu,table)
</t>
<t tx="T1186">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

table = (
	("Go Back",None,self.OnGoPrevVisitedNode), # Usually use buttons for this.
	("Go Forward",None,self.OnGoNextVisitedNode),
	("-",None,None),
	("Go To Next &amp;Marked","Alt+M",self.OnGoToNextMarked),
	("Go To Next C&amp;hanged","Alt+D",self.OnGoToNextChanged),
	("Go To Next &amp;Clone","Alt+N",self.OnGoToNextClone),
	("-",None,None),
	("Go To &amp;First Node","Alt+Shift+G",self.OnGoToFirstNode),
	("Go To &amp;Last Node","Alt+Shift+H",self.OnGoToLastNode),
	("Go To &amp;Parent","Alt+Shift+P",self.OnGoToParent),
	("Go To P&amp;rev Sibling","Alt+Shift+R",self.OnGoToPrevSibling),
	("Go To Next &amp;Sibling","Alt+Shift+S",self.OnGoToNextSibling),
	("-",None,None),
	("Go To Prev V&amp;isible","Alt-UpArrow",self.OnGoPrevVisible),
	("Go To Next &amp;Visible","Alt-DnArrow",self.OnGoNextVisible),
	("Go To Prev Node","Alt-Shift+UpArrow",self.OnGoBack),
	("Go To Next Node","Alt-Shift-DnArrow",self.OnGoNext))
	
self.createMenuEntries(gotoMenu,table)
</t>
<t tx="T1187">windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow),
	("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)

</t>
<t tx="T1188">helpMenu = self.createNewMenu("&amp;Help")

table = (
	("&amp;About Leo...",None,self.OnAbout),
	("Online &amp;Home Page",None,self.OnLeoHome),
	("-",None,None),
	("Open Online &amp;Tutorial",None,self.OnLeoTutorial))

self.createMenuEntries(helpMenu,table)

if sys.platform=="win32":
	table = (("Open &amp;Offline Tutorial",None,self.OnLeoHelp),)
	self.createMenuEntries(helpMenu,table)

table = (
	("Open Leo&amp;Docs.leo",None,self.OnLeoDocumentation),
	("-",None,None),
	("Open Leo&amp;Config.leo",None,self.OnLeoConfig),
	("Apply &amp;Settings",None,self.OnApplyConfig))

self.createMenuEntries(helpMenu,table)</t>
<t tx="T1189">@ Executes the given command, invoking hooks and catching exceptions.
Command handlers no longer need to return "break".  Yippee!

The code assumes that the "command1" hook has completely handled the command if doHook("command1") returns false.  This provides a very simple mechanism for overriding commands.
@c

def doCommand (self,command,label,event=None):
	
	# A horrible kludge: set app.log to cover for a possibly missing activate event.
	app.setLog(self,"doCommand")

	if label == "cantredo": label = "redo"
	if label == "cantundo": label = "undo"
	app.commandName = label
	c = self.commands ; v = c.currentVnode() # 2/8/03
	if not doHook("command1",c=c,v=v,label=label):
		try:
			command(event)
		except:
			es("exception executing command")
			print "exception executing command"
			es_exception()
	
	doHook("command2",c=c,v=v,label=label)
			
	return "break" # Inhibit all other handlers.
</t>
<t tx="T1190">def getMenu (self,menuName):

	cmn = canonicalizeMenuName(menuName)
	return self.menus.get(cmn)
	
def setMenu (self,menuName,menu):
	
	cmn = canonicalizeMenuName(menuName)
	self.menus [cmn] = menu
	
def destroyMenu (self,menuName):
	
	cmn = canonicalizeMenuName(menuName)
	del self.menus[cmn]
</t>
<t tx="T1191"></t>
<t tx="T1192"></t>
<t tx="T1193"></t>
<t tx="T1194">def OnNew (self,event=None):

	c,frame = app.gui.newLeoCommanderAndFrame(fileName=None)
	top = frame.top
	
	# 5/16/03: Needed for hooks.
	doHook("new",old_c=self,new_c=c)
	
	# Use the config params to set the size and location of the window.
	frame.setInitialWindowGeometry()
	top.deiconify()
	top.lift()
	frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
	
	c.beginUpdate()
	if 1: # within update
		t = leoNodes.tnode()
		v = leoNodes.vnode(c,t)
		v.initHeadString("NewHeadline")
		v.moveToRoot()
		c.editVnode(v)
	c.endUpdate()
	
	set_focus(c,frame.body)</t>
<t tx="T1195">def OnOpen(self,event=None):

	c = self.commands
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	# trace(`closeFlag`)

	fileName = tkFileDialog.askopenfilename(
		title="Open",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if fileName and len(fileName) &gt; 0:
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app.destroyWindow(self)</t>
<t tx="T1196">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T1197">@ This routine handles the items in the Open With... menu.
These items can only be created by createOpenWithMenuFromTable().
Typically this would be done from the "open2" hook.
@c

def OnOpenWith(self,data=None):
	
	c = self.commands ; v = c.currentVnode()
	if not data or len(data) != 3: return # 6/22/03
	try:
		# print "OnOpenWith:",`data`
		openType,arg,ext=data
		if not doHook("openwith1",c=c,v=v,openType=openType,arg=arg,ext=ext):
			&lt;&lt; set ext based on the present language &gt;&gt;
			&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
			&lt;&lt; execute a command to open path in external editor &gt;&gt;
		doHook("openwith2",c=c,v=v,openType=openType,arg=arg,ext=ext)
	except:
		es("exception in OnOpenWith")
		es_exception()

	return "break"</t>
<t tx="T1198">if not ext:
	dict = scanDirectives(c)
	language = dict.get("language")
	ext = app.language_extension_dict.get(language)
	# print language,ext
	if ext == None:
		ext = "txt"
	
if ext[0] != ".":
	ext = "."+ext
	
# print "ext",`ext`</t>
<t tx="T1199">dict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to v.t &gt;&gt;
if path:
	&lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
	path = self.createOpenWithTempFile(v,ext)

if not path:
	return # An error has occured.</t>
<t tx="T1200">searchPath = self.openWithTempFilePath(v,ext)

if os.path.exists(searchPath):
	for dict in app.openWithFiles:
		if v.t == dict.get("v") and searchPath == dict.get("path"):
			path = searchPath
			break
</t>
<t tx="T1201">@ We test for changes in both v and the temp file:

- If only v's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = dict.get("encoding")
old_body = dict.get("body")
new_body = v.bodyString()
new_body = toEncodedString(new_body,encoding,reportErrors=true)

old_time = dict.get("time")
try:
	new_time=os.path.getmtime(path)
except:
	new_time=None
	
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
	&lt;&lt; Raise dialog about conflict and set result &gt;&gt;
	if result == "cancel": return
	rewrite = result == "outline"
else:
	rewrite = body_changed
		
if rewrite:
	path = self.createOpenWithTempFile(v,ext)
else:
	es("reopening: " + shortFileName(path),color="blue")</t>
<t tx="T1202">message = (
	"Conflicting changes in outline and temp file\n\n" +
	"Do you want to use the code in the outline or the temp file?\n\n")

result = leoDialog.askYesNoCancel(
	"Conflict!", message,
	yesMessage = "Outline",
	noMessage = "File",
	defaultButton = "Cancel").run(modal=1)

</t>
<t tx="T1203">try:
	if arg == None: arg = ""
	shortPath = path # shortFileName(path)
	if openType == "os.system":
		command  = "os.system("+arg+shortPath+")"
		os.system(arg+path)
	elif openType == "os.startfile":
		command    = "os.startfile("+arg+shortPath+")"
		os.startfile(arg+path)
	elif openType == "exec":
		command    = "exec("+arg+shortPath+")"
		exec arg+path in {} # 12/11/02
	elif openType == "os.spawnl":
		filename = os.path.basename(arg)
		command = "os.spawnl("+arg+","+filename+','+ shortPath+")"
		apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
	elif openType == "os.spawnv":
		filename = os.path.basename(arg)
		command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
		apply(os.spawnl,(os.P_NOWAIT,arg,(filename,path)))
	else:
		command="bad command:"+str(openType)
	# This seems a bit redundant.
	# es(command)
except:
	es("exception executing: "+command)
	es_exception()</t>
<t tx="T1204">def createOpenWithTempFile (self, v, ext):
	
	c = self.commands
	path = self.openWithTempFilePath(v,ext)
	try:
		if os.path.exists(path):
			es("recreating:  " + shortFileName(path),color="red")
		else:
			es("creating:  " + shortFileName(path),color="blue")
		file = open(path,"w")
		# 3/7/03: convert s to whatever encoding is in effect.
		s = v.bodyString()
		dict = scanDirectives(self.commands,v=v)
		encoding = dict.get("encoding",None)
		if encoding == None:
			encoding = app.config.default_derived_file_encoding
		s = toEncodedString(s,encoding,reportErrors=true) 
		file.write(s)
		file.flush()
		file.close()
		try:    time=os.path.getmtime(path)
		except: time=None
		# es("time: " + str(time))
		# 4/22/03: add body and encoding entries to dict for later comparisons.
		dict = {"body":s, "c":c, "encoding":encoding, "f":file, "path":path, "time":time, "v":v}
		&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt; # 4/22/03
		app.openWithFiles.append(dict)
		return path
	except:
		file = None
		es("exception creating temp file",color="red")
		es_exception()
		return None</t>
<t tx="T1205">for d in app.openWithFiles[:]: # 6/30/03
	v2 = d.get("v")
	if v.t == v2.t:
		print "removing previous entry in app.openWithFiles for",v
		app.openWithFiles.remove(d)</t>
<t tx="T1206">def openWithTempFilePath (self,v,ext):
	
	"""Return the path to the temp file corresponding to v and ext."""

	name = "LeoTemp_" + str(id(v.t)) + '_' + sanitize_filename(v.headString()) + ext
	td = os.path.abspath(tempfile.gettempdir())
	path = os.path.join(td,name)
	
	# print "openWithTempFilePath",path
	return path</t>
<t tx="T1207">def OpenWithFileName(self,fileName):
	
	return openWithFileName(fileName,self.commands)</t>
<t tx="T1208">def OnClose(self,event=None):
	
	"""Handle the File-Close command."""
	
	app.closeLeoWindow(self)</t>
<t tx="T1209">def OnSave(self,event=None):

	c = self.commands
	
	# Make sure we never pass None to the ctor.
	if not c.mFileName:
		self.title = ""
		c.mFileName = ""

	if c.mFileName != "":
		c.fileCommands.save(c.mFileName)
		c.setChanged(false)
		return

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = c.mFileName,
		title="Save",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		c.mFileName = ensure_extension(fileName, ".leo")
		self.title = c.mFileName
		self.top.title(computeWindowTitle(c.mFileName)) # 3/25/03
		c.fileCommands.save(c.mFileName)
		self.updateRecentFiles(c.mFileName)</t>
<t tx="T1210">def OnSaveAs(self,event=None):
	
	c = self.commands

	# Make sure we never pass None to the ctor.
	if not c.mFileName:
		self.title = ""
		
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = c.mFileName,
		title="Save As",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		c.mFileName = ensure_extension(fileName, ".leo")
		self.title = c.mFileName
		self.top.title(computeWindowTitle(c.mFileName)) # 3/25/03
		self.commands.fileCommands.saveAs(c.mFileName)
		self.updateRecentFiles(c.mFileName)</t>
<t tx="T1211">def OnSaveTo(self,event=None):
	
	c = self.commands

	# Make sure we never pass None to the ctor.
	if not c.mFileName:
		self.title = ""

	# set local fileName, _not_ c.mFileName
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = c.mFileName,
		title="Save To",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		fileName = ensure_extension(fileName, ".leo")
		self.commands.fileCommands.saveTo(fileName)
		self.updateRecentFiles(c.mFileName)
</t>
<t tx="T1212">def OnRevert(self,event=None):
	
	c = self.commands

	# Make sure the user wants to Revert.
	if not c.mFileName:
		return

	reply = leoDialog.askYesNo("Revert",
		"Revert to previous version of " + c.mFileName + "?").run(modal=true)

	if reply=="no":
		return

	# Kludge: rename this frame so OpenWithFileName won't think it is open.
	fileName = c.mFileName ; c.mFileName = ""

	# Create a new frame before deleting this frame.
	ok, frame = self.OpenWithFileName(fileName)
	if ok:
		frame.deiconify()
		app.destroyWindow(self)
	else:
		c.mFileName = fileName
</t>
<t tx="T1213">def OnQuit(self,event=None):
	
	app.onQuit()</t>
<t tx="T1214">def updateRecentFiles (self, fileName):
	
	if not fileName or len(fileName) == 0:
		return
	
	# Update the recent files list in all windows.
	normFileName = os.path.normcase(fileName)
	
	for frame in app.windowList:
		# Remove all versions of the file name.
		for name in frame.recentFiles:
			name2 = os.path.normcase(name)
			name2 = os.path.normpath(name2)
			if normFileName == name2:
				frame.recentFiles.remove(name)
		frame.recentFiles.insert(0,fileName)
		# Recreate the Recent Files menu.
		frame.createRecentFilesMenuItems()
		
	# Update the config file.
	app.config.setRecentFiles(frame.recentFiles)
	app.config.update()</t>
<t tx="T1215"></t>
<t tx="T1216">def OnClearRecentFiles (self,event=None):
	
	"""Clear the recent files list, then add the present file."""
	
	f = self ; c = f.commands
	
	recentFilesMenu = f.getMenu("Recent Files...")
	recentFilesMenu.delete(0,len(f.recentFiles))
	f.recentFiles = []
	f.createRecentFilesMenuItems()
	f.updateRecentFiles(c.mFileName)</t>
<t tx="T1217">def OnOpenRecentFile(self,name=None):
	
	c = self.commands ; v = c.currentVnode()
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	if not name:
		return

	fileName = name
	if not doHook("recentfiles1",c=c,v=v,fileName=fileName,closeFlag=closeFlag):
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app.destroyWindow(self)
			app.setLog(frame,"OnOpenRecentFile") # Sets the log stream for es()

	doHook("recentfiles2",c=c,v=v,fileName=fileName,closeFlag=closeFlag)</t>
<t tx="T1218">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T1219">def createRecentFilesMenuItems (self):
	
	f = self ; c = f.commands
	recentFilesMenu = f.getMenu("Recent Files...")
	
	# Delete all previous entries.
	recentFilesMenu.delete(0,len(f.recentFiles)+2)
	
	# Create the first two entries.
	table = (
		("Clear Recent Files",None,self.OnClearRecentFiles),
		("-",None,None))
	self.createMenuEntries(recentFilesMenu,table)
	
	# Create all the other entries.
	i = 3
	for name in f.recentFiles:
		callback = lambda f=f,name=name:f.OnOpenRecentFile(name)
		label = "%d %s" % (i-2,computeWindowTitle(name))
		recentFilesMenu.add_command(label=label,command=callback,underline=0)
		i += 1</t>
<t tx="T1220"></t>
<t tx="T1221">def OnReadOutlineOnly (self,event=None):

	fileName = tkFileDialog.askopenfilename(
		title="Read Outline Only",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if not fileName:
		return
		
	try:
		file = open(fileName,'r')
		c,frame = app.gui.newLeoCommanderAndFrame(fileName)
		frame.deiconify()
		frame.lift()
		app.root.update() # Force a screen redraw immediately.
		c.fileCommands.readOutlineOnly(file,fileName) # closes file.
	except:
		es("can not open:" + fileName)</t>
<t tx="T1222">def OnReadAtFileNodes (self,event=None):

	c = self.commands ; v = c.currentVnode()

	# Create copy for undo.
	v_copy = c.undoer.saveTree(v)
	oldText = getAllText(c.body)
	oldSel = getTextSelection(c.body)

	c.fileCommands.readAtFileNodes()

	newText = getAllText(c.body)
	newSel = getTextSelection(c.body)

	c.undoer.setUndoParams("Read @file Nodes",
		v,select=v,oldTree=v_copy,
		oldText=oldText,newText=newText,
		oldSel=oldSel,newSel=newSel)</t>
<t tx="T1223">def OnWriteDirtyAtFileNodes (self,event=None):

	self.commands.fileCommands.writeDirtyAtFileNodes()
</t>
<t tx="T1224">def OnWriteMissingAtFileNodes (self,event=None):

	self.commands.fileCommands.writeMissingAtFileNodes()
</t>
<t tx="T1225">def OnWriteOutlineOnly (self,event=None):

	self.commands.fileCommands.writeOutlineOnly()
</t>
<t tx="T1226">def OnWriteAtFileNodes (self,event=None):

	self.commands.fileCommands.writeAtFileNodes()
</t>
<t tx="T1227"></t>
<t tx="T1228">def OnImportDerivedFile (self,event=None):
	
	"""Create a new outline from a 4.0 derived file."""
	
	frame = self ; c = frame.commands ; v = c.currentVnode()
	at = c.atFileCommands
	
	if v.isAtFileNode():
		fileName = v.atFileNodeName()
		c.importCommands.importDerivedFiles(v,fileName)
	else:
		es("not an @file node",color="blue")</t>
<t tx="T1229">def OnWriteNewDerivedFiles (self,event=None):
	
	c = self.commands

	c.atFileCommands.writeNewDerivedFiles()
	es("auto-saving outline",color="blue")
	self.OnSave() # Must be done to preserve tnodeList.
	
def OnWriteOldDerivedFiles (self,event=None):
	
	c = self.commands
	c.atFileCommands.writeOldDerivedFiles()
	es("auto-saving outline",color="blue")
	self.OnSave() # Must be done to clear tnodeList.</t>
<t tx="T1230"></t>
<t tx="T1231">def OnTangleAll(self,event=None):

	self.commands.tangleCommands.tangleAll()
</t>
<t tx="T1232">def OnTangleMarked(self,event=None):

	self.commands.tangleCommands.tangleMarked()
</t>
<t tx="T1233">def OnTangle (self,event=None):

	self.commands.tangleCommands.tangle()
</t>
<t tx="T1234"></t>
<t tx="T1235">def OnUntangleAll(self,event=None):

	c = self.commands
	c.tangleCommands.untangleAll()
	c.undoer.clearUndoState()
</t>
<t tx="T1236">def OnUntangleMarked(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangleMarked()
	c.undoer.clearUndoState()
</t>
<t tx="T1237">def OnUntangle(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangle()
	c.undoer.clearUndoState()
</t>
<t tx="T1238"></t>
<t tx="T1239">def OnExportHeadlines (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Export Headlines",filetypes=filetypes,
		initialfile="headlines.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		self.commands.importCommands.exportHeadlines(fileName)
</t>
<t tx="T1240">def OnFlattenOutline (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Flatten Outline",filetypes=filetypes,
		initialfile="flat.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.flattenOutline(fileName)
</t>
<t tx="T1241">def OnImportAtRoot (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]

	fileName = tkFileDialog.askopenfilename(
		title="Import To @root",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@root")
</t>
<t tx="T1242">def OnImportAtFile (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
			
	fileName = tkFileDialog.askopenfilename(
		title="Import To @file",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@file")
</t>
<t tx="T1243">def OnImportCWEBFiles (self,event=None):
	
	filetypes = [
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import CWEB Files",filetypes=filetypes,
		defaultextension=".w")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"cweb")
</t>
<t tx="T1244">def OnImportFlattenedOutline (self,event=None):
	
	types = [("Text files","*.txt"), ("All files","*")]
		
	fileName = tkFileDialog.askopenfilename(
		title="Import MORE Text",
		filetypes=types,
		defaultextension=".py")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFlattenedOutline(paths)
</t>
<t tx="T1245">def OnImportNowebFiles (self,event=None):
	
	filetypes = [
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import Noweb Files",filetypes=filetypes,
		defaultextension=".nw")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"noweb")
</t>
<t tx="T1246">def OnOutlineToCWEB (self,event=None):
	
	filetypes=[
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To CWEB",filetypes=filetypes,
		initialfile="cweb.w",defaultextension=".w")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"cweb")
</t>
<t tx="T1247">def OnOutlineToNoweb (self,event=None):
	
	filetypes=[
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To Noweb",filetypes=filetypes,
		initialfile=self.outlineToNowebDefaultFileName,defaultextension=".nw")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"noweb")
		self.outlineToNowebDefaultFileName = fileName
</t>
<t tx="T1248">def OnRemoveSentinels (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
		
	fileName = tkFileDialog.askopenfilename(
		title="Remove Sentinels",filetypes=types)

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		# alas, askopenfilename returns only a single name.
		c.importCommands.removeSentinelsCommand (fileName)</t>
<t tx="T1249">def OnWeave (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Weave",filetypes=filetypes,
		initialfile="weave.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.weave(fileName)
</t>
<t tx="T1250"></t>
<t tx="T1251"></t>
<t tx="T1252">def OnUndo(self,event=None):

	self.commands.undoer.undo()
</t>
<t tx="T1253">def OnRedo(self,event=None):

	self.commands.undoer.redo()
</t>
<t tx="T1254"></t>
<t tx="T1255">def OnCut (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.tree.forceFullRecolor()
	self.tree.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self,event=None):

	w = self.getFocus()
	self.tree.forceFullRecolor()
	w.event_generate(virtual_event_name("Cut"))
	
	# 11/2/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	c.frame.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T1256">def OnCopy (self,event=None):

	# Copy never changes dirty bits or syntax coloring.
	pass
	
def OnCopyFromMenu (self,event=None):

	# trace()
	w = self.getFocus()
	w.event_generate(virtual_event_name("Copy"))
</t>
<t tx="T1257">def OnPaste (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.tree.forceFullRecolor()
	self.tree.onBodyWillChange(v,"Paste")
	
def OnPasteFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Paste"))
	
	# 10/23/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	self.tree.forceFullRecolor()
	c.frame.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T1258">def OnDelete(self,event=None):

	c = self.commands ; v = c.currentVnode()
	first, last = oldSel = getTextSelection(self.body)
	if first and last and first != last:
		self.body.delete(first,last)
		c.frame.onBodyChanged(v,"Delete",oldSel=oldSel)
</t>
<t tx="T1259">@ This executes body text as a Python script.  We execute the selected text, or the entire body text if no text is selected.
@c

def OnExecuteScript(self,event=None,v=None):
	
	c = self.commands ; body = self.body ; s = None
	if v == None:
		v = c.currentVnode()

	&lt;&lt; get script into s &gt;&gt;
	&lt;&lt; redirect output if redirect_execute_script_output_to_log_pane &gt;&gt;

	if s:
		s += '\n' # Make sure we end the script properly.
		try:
			exec s in {} # Use {} to get a pristine environment!
		except:
			es("exception executing script")
			es_exception(full=false)
	else:
		es("no script selected")</t>
<t tx="T1260"># Assume any selected body text is a script.

start,end = getTextSelection(body)

if start and end and start != end:
	s = getSelectedText(body) # 9/28/03
else:
	s = getAllText(body)
if s:
	s = s.strip()</t>
<t tx="T1261">if app.config.redirect_execute_script_output_to_log_pane:

	from leoGlobals import redirectStdout,redirectStderr
	redirectStdout() # Redirect stdout
	redirectStderr() # Redirect stderr</t>
<t tx="T1262">def OnGoToLineNumber (self,event=None):

	c = self.commands
	&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;
	&lt;&lt; read the file into lines &gt;&gt;
	&lt;&lt; get n, the line number, from a dialog &gt;&gt;
	# trace("n:"+`n`)
	if n==1:
		v = root ; n2 = 1 ; found = true
	elif n &gt;= len(lines):
		v = root ; found = false
		n2 = v.bodyString().count('\n')
	elif root.isAtSilentFileNode():
		&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;
	else:
		vnodeName,childIndex,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root)
		found = true
		if not vnodeName:
			es("invalid derived file: " + fileName)
			return
		&lt;&lt; set v to the node given by vnodeName and childIndex or n &gt;&gt;
	&lt;&lt; select v and make it visible &gt;&gt;
	&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="T1263">v = c.currentVnode()
fileName = None

# Search the present node first.
j = v.t.joinList
if v in j:
	j.remove(v)
j.insert(0,v)

# 10/15/03: search joined nodes if first search fails.
for v in j:
	while v and not fileName:
		if v.isAtFileNode():
			fileName = v.atFileNodeName()
		elif v.isAtSilentFileNode():
			fileName = v.atSilentFileNodeName()
		elif v.isAtRawFileNode():
			fileName = v.atRawFileNodeName()
		else:
			v = v.parent()

root = v
if not root:
	es("Go to line number: ancestor must be @file node")
	return</t>
<t tx="T1264"># 1/26/03: calculate the full path.
d = scanDirectives(c)
path = d.get("path")
fileName = os.path.join(path,fileName)

try:
	file=open(fileName)
	lines = file.readlines()
	file.close()
except:
	es("not found: " + fileName)
	return
	
</t>
<t tx="T1265">d = leoDialog.askOkCancelNumber("Enter Line Number","Line number:")
n = d.run(modal=true)
if n == -1:
	return</t>
<t tx="T1266">v = lastv = root ; after = root.nodeAfterTree()
prev = 0 ; found = false
while v and v != after:
	lastv = v
	s = v.bodyString()
	lines = s.count('\n')
	if len(s) &gt; 0 and s[-1] != '\n':
		lines += 1
	# print lines,prev,v
	if prev + lines &gt;= n:
		found = true ; break
	prev += lines
	v = v.threadNext()

v = lastv
n2 = max(1,n-prev)</t>
<t tx="T1267">after = root.nodeAfterTree()

if childIndex == -1:
	&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
	&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="T1268"># This is about the best that can be done without replicating the entire atFile write logic.

ok = true

if not hasattr(root,"tnodeList"):
	s = "no child index for " + root.headString()
	print s ; es(s, color="red") ; ok = false

if ok:
	tnodeList = root.tnodeList
	&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
	tnodeIndex = max(0,tnodeIndex)
	&lt;&lt; set v to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;
			
if not ok:
	# Fall back to the old logic.
	&lt;&lt; set v to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="T1269">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
	if scanned &gt;= n:
		break
	i = skip_ws(s,0)
	if match(s,i,delim):
		i += len(delim)
		if match(s,i,"+node"):
			# trace(tnodeIndex,s.rstrip())
			tnodeIndex += 1
	scanned += 1</t>
<t tx="T1270">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks v = t.joinList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
	t = tnodeList[tnodeIndex]
	# Find the first vnode whose tnode is t.
	v = root
	while v and v != after:
		if v.t == t:
			break
		v = v.threadNext()
	if not v:
		s = "tnode not found for " + vnodeName
		print s ; es(s, color="red") ; ok = false
	elif v.headString().strip() != vnodeName:
		s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (v.headString(),vnodeName)
		print s ; es(s, color="red") ; ok = false
else:
	s = "Invalid computed tnodeIndex: %d" % tnodeIndex
	print s ; es(s, color = "red") ; ok = false</t>
<t tx="T1271">v = root
while v and v != after:
	if v.matchHeadline(vnodeName):
		break
	v = v.threadNext()

if not v or v == after:
	s = "not found: " + vnodeName
	print s ; es(s, color="red")
	return</t>
<t tx="T1272">v = root
while v and v != after:
	if v.matchHeadline(vnodeName):
		if childIndex &lt;= 0 or v.childIndex() + 1 == childIndex:
			break
	v = v.threadNext()

if not v or v == after:
	es("not found: " + vnodeName, color="red")
	return</t>
<t tx="T1273">c.beginUpdate()
c.frame.expandAllAncestors(v)
c.selectVnode(v)
c.endUpdate()</t>
<t tx="T1274">if found:
	c.frame.body.mark_set("insert",str(n2)+".0 linestart")
else:
	c.frame.body.mark_set("insert","end-1c")
	es("%d lines" % len(lines), color="blue")
c.frame.body.see("insert")</t>
<t tx="T1275">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set v to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within v of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
	
	"""Convert a line number n to a vnode name, child index and line number."""
	
	childIndex = 0 ; newDerivedFile = false
	&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
	if not delim:
		es("bad @+leo sentinel")
		return None,None,None,None
	&lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
	if nodeSentinelLine == -1:
		# The line precedes the first @+node sentinel
		# trace("before first line")
		return root.headString(),0,1,delim # 10/13/03
	s = lines[nodeSentinelLine]
	# trace(s)
	&lt;&lt; set vnodeName and childIndex from s &gt;&gt;
	# trace("childIndex,offset",childIndex,offset,vnodeName)
	return vnodeName,childIndex,offset,delim</t>
<t tx="T1276"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
	i += 1
leoLine = i # Index of the line containing the leo sentinel
# trace("leoLine:"+`leoLine`)

delim = None # All sentinels start with this.
if leoLine &lt; len(lines):
	# The opening comment delim is the initial non-whitespace.
	s = lines[leoLine]
	i = skip_ws(s,0)
	j = s.find(tag)
	newDerivedFile = match(s,j,"@+leo-ver=4")
	delim = s[i:j]
	if len(delim)==0:
		delim=None
	else:
		delim += '@'</t>
<t tx="T1277">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
	s = lines[line]
	# trace(`s`)
	i = skip_ws(s,0)
	if match(s,i,delim):
		&lt;&lt; handle delim while scanning backward &gt;&gt;
	else:
		offset += 1 # Assume the line is real.  A dubious assumption.
	line -= 1</t>
<t tx="T1278">if line == n:
	es("line "+str(n)+" is a sentinel line")
i += len(delim)

if match(s,i,"-node"):
	# The end of a nested section.
	line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif match(s,i,"+node"):
	nodeSentinelLine = line
	break
elif match(s,i,"&lt;&lt;") or match(s,i,"@first"):
	offset += 1 # Count these as a "real" lines.</t>
<t tx="T1279">if newDerivedFile:
	# vnode name is everything following the first ':'
	# childIndex is -1 as a flag for later code.
	i = s.find(':')
	if i &gt; -1: vnodeName = s[i+1:].strip()
	else: vnodeName = None
	childIndex = -1
else:
	# vnode name is everything following the third ':'
	i = 0 ; colons = 0
	while i &lt; len(s) and colons &lt; 3:
		if s[i] == ':':
			colons += 1
			if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
				junk,childIndex = skip_long(s,i+1)
		i += 1
	vnodeName = s[i:].strip()
	
# trace("vnodeName:",vnodeName)
if not vnodeName:
	vnodeName = None
	es("bad @+node sentinel")
</t>
<t tx="T1280">def skipToMatchingNodeSentinel (self,lines,n,delim):
	
	s = lines[n]
	i = skip_ws(s,0)
	assert(match(s,i,delim))
	i += len(delim)
	if match(s,i,"+node"):
		start="+node" ; end="-node" ; delta=1
	else:
		assert(match(s,i,"-node"))
		start="-node" ; end="+node" ; delta=-1
	# Scan to matching @+-node delim.
	n += delta ; level = 0
	while 0 &lt;= n &lt; len(lines):
		s = lines[n] ; i = skip_ws(s,0)
		if match(s,i,delim):
			i += len(delim)
			if match(s,i,start):
				level += 1
			elif match(s,i,end):
				if level == 0: break
				else: level -= 1
		n += delta # bug fix: 1/30/02
		
	# trace(n)
	return n</t>
<t tx="T1281">def OnSelectAll(self,event=None):

	setTextSelection(self.body,"1.0","end")
</t>
<t tx="T1282">def OnFontPanel(self,event=None):

	if self.fontPanel:
		# trace()
		self.fontPanel.top.deiconify()
		self.fontPanel.top.lift()
	else:
		self.fontPanel = fp =  leoFontPanel.leoFontPanel(self.commands)
		fp.run()
</t>
<t tx="T1283">def OnColorPanel(self,event=None):
	
	if self.colorPanel:
		# trace()
		self.colorPanel.top.deiconify()
		self.colorPanel.top.lift()
	else:
		self.colorPanel = cp = leoColor.leoColorPanel(self.commands)
		cp.run()

</t>
<t tx="T1284">def OnViewAllCharacters (self, event=None):

	c = self.commands ; v = c.currentVnode() ; colorizer = c.frame.getColorizer()
	colorizer.showInvisibles = choose(colorizer.showInvisibles,0,1)
	# print `colorizer.showInvisibles`

	# It is much easier to change the menu name here than in the menu updater.
	menu = self.getMenu("Edit")
	if colorizer.showInvisibles:
		setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
	else:
		setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

	c.frame.recolor_now(v)
</t>
<t tx="T1285">def OnPreferences(self,event=None):
	
	c = self.commands
	if self.prefsPanel:
		# trace()
		self.prefsPanel.top.deiconify()
		self.prefsPanel.top.lift()
	else:
		self.prefsPanel = prefs = leoPrefs.LeoPrefs(c)
		top = prefs.top
		center_dialog(top)

		if 0: # No need to make this modal
			top.grab_set() # Make the dialog a modal dialog.
			top.focus_set() # Get all keystrokes.
			app.root.wait_window(top)
</t>
<t tx="T1286"></t>
<t tx="T1287">def OnConvertBlanks(self,event=None):

	self.commands.convertBlanks()

	
def OnConvertAllBlanks(self,event=None):

	self.commands.convertAllBlanks()
</t>
<t tx="T1288">def OnConvertTabs(self,event=None):

	self.commands.convertTabs()
	
def OnConvertAllTabs(self,event=None):

	self.commands.convertAllTabs()

def OnReformatParagraph(self,event=None):
	
	self.commands.reformatParagraph()
</t>
<t tx="T1289">def OnDedent (self,event=None):

	self.commands.dedentBody()
</t>
<t tx="T1290">def OnExtract(self,event=None):

	self.commands.extract()
</t>
<t tx="T1291">def OnExtractNames(self,event=None):

	self.commands.extractSectionNames()
</t>
<t tx="T1292">def OnExtractSection(self,event=None):

	self.commands.extractSection()
</t>
<t tx="T1293">def OnFindMatchingBracket (self,event=None):
	
	c = self ; body = c.body
	brackets = "()[]{}&lt;&gt;"
	ch1 = body.get("insert -1c")
	ch1 = toUnicode(ch1,app.tkEncoding) # 9/28/03
	ch2 = body.get("insert")
	ch2= toUnicode(ch2,app.tkEncoding) # 9/28/03

	# Prefer to match the character to the left of the cursor.
	if ch1 in brackets:
		ch = ch1 ; index = body.index("insert -1c")
	elif ch2 in brackets:
		ch = ch2 ; index = body.index("insert")
	else:
		return
	
	index2 = self.findMatchingBracket(ch,body,index)
	if index2:
		if body.compare(index,"&lt;=",index2):
			setTextSelection(self.body,index,index2+"+1c")
		else:
			setTextSelection(self.body,index2,index+"+1c")
		body.mark_set("insert",index2+"+1c")
		body.see(index2+"+1c")
	else:
		es("unmatched " + `ch`)
</t>
<t tx="T1294"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracket(self,ch,body,index):

	open_brackets  = "([{&lt;"
	close_brackets = ")]}&gt;"
	brackets = open_brackets + close_brackets
	matching_brackets = close_brackets + open_brackets
	forward = ch in open_brackets
	# Find the character matching the initial bracket.
	for n in xrange(len(brackets)):
		if ch == brackets[n]:
			match_ch = matching_brackets[n]
			break
	level = 0
	while 1:
		if forward and body.compare(index,"&gt;=","end"):
			# trace("not found")
			return None
		ch2 = body.get(index)
		ch2 = toUnicode(ch2,app.tkEncoding) # 9/28/03
		if ch2 == ch:
			level += 1 #; trace(level,index)
		if ch2 == match_ch:
			level -= 1 #; trace(level,index)
			if level &lt;= 0:
				return index
		if not forward and body.compare(index,"&lt;=","1.0"):
			# trace("not found")
			return None
		index = index + choose(forward,"+1c","-1c")
		index = body.index(index)
	return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="T1295">def OnIndent(self,event=None):

	self.commands.indentBody()
</t>
<t tx="T1296">def OnInsertBodyTime (self,event=None):
	
	c = self.commands ; v = c.currentVnode()
	sel1,sel2 = oldSel = getTextSelection(c.body)
	if sel1 and sel2 and sel1 != sel2: # 7/7/03
		c.body.delete(sel1,sel2)
	c.body.insert("insert",self.getTime(body=true))
	c.frame.onBodyChanged(v,"Typing",oldSel=oldSel)
	
def OnInsertHeadlineTime (self,event=None):

	c = self.commands ; v = c.currentVnode()
	s = v.headString() # Remember the old value.

	if v.edit_text():
		sel1,sel2 = getTextSelection(v.edit_text())
		if sel1 and sel2 and sel1 != sel2: # 7/7/03
			v.edit_text().delete(sel1,sel2)
		v.edit_text().insert("insert",self.getTime(body=false))
		c.frame.idle_head_key(v)
		
	# A kludge to get around not knowing whether we are editing or not.
	if s.strip() == v.headString().strip():
		es("Edit headline to append date/time")</t>
<t tx="T1297">def getTime (self,body=true):

	config = app.config
	default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
	
	# Try to get the format string from leoConfig.txt.
	if body:
		format = config.getWindowPref("body_time_format_string")
		gmt = config.getBoolWindowPref("body_gmt_time")
	else:
		format = config.getWindowPref("headline_time_format_string")
		gmt = config.getBoolWindowPref("headline_gmt_time")

	if format == None:
		format = default_format

	try:
		if gmt:
			s = time.strftime(format,time.gmtime())
		else:
			s = time.strftime(format,time.localtime())
	except:
		es_exception() # Probably a bad format string in leoConfig.txt.
		s = time.strftime(default_format,time.gmtime())
	return s
</t>
<t tx="T1298"></t>
<t tx="T1299">def OnEditHeadline(self,event=None):

	tree = self.tree
	tree.editLabel(tree.currentVnode)</t>
<t tx="T1300">def OnEndEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.endEditLabelCommand()
</t>
<t tx="T1301">def OnAbortEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.abortEditLabelCommand()
</t>
<t tx="T1302">def OnToggleAngleBrackets (self,event=None):
	
	c = self.commands ; v = c.currentVnode()
	s = v.headString().strip()
	if (s[0:2] == "&lt;&lt;"
		or s[-2:] == "&gt;&gt;"): # Must be on separate line.
		if s[0:2] == "&lt;&lt;": s = s[2:]
		if s[-2:] == "&gt;&gt;": s = s[:-2]
		s = s.strip()
	else:
		s = angleBrackets(' ' + s + ' ')
	
	c.frame.editLabel(v)
	if v.edit_text():
		v.edit_text().delete("1.0","end")
		v.edit_text().insert("1.0",s)
		c.frame.onHeadChanged(v)
</t>
<t tx="T1303"></t>
<t tx="T1304">def OnFindPanel(self,event=None):

	c = self.commands

	find = app.findFrame
	# 15-SEP-2002 DTHEIN: call withdraw() to force findFrame to top after 
	#                     opening multiple Leo files.
	find.top.withdraw()
	find.top.deiconify()
	find.top.lift()
	
	t = find.find_text
	set_focus(c,t)
	setTextSelection (t,"1.0","end") # Thanks Rich.
	find.commands = self
</t>
<t tx="T1305">def OnFindNext(self,event=None):

	c = self.commands
	app.findFrame.findNextCommand(c)
</t>
<t tx="T1306">def OnFindPrevious(self,event=None):

	c = self.commands
	app.findFrame.findPreviousCommand(c)
</t>
<t tx="T1307">def OnReplace(self,event=None):

	c = self.commands
	app.findFrame.changeCommand(c)
</t>
<t tx="T1308">def OnReplaceThenFind(self,event=None):

	c = self.commands
	app.findFrame.changeThenFindCommand(c)
</t>
<t tx="T1309"></t>
<t tx="T1310"></t>
<t tx="T1311">def OnCutNode(self,event=None):

	self.commands.cutOutline()
</t>
<t tx="T1312">def OnCopyNode(self,event=None):

	self.commands.copyOutline()
</t>
<t tx="T1313">def OnPasteNode(self,event=None):

	self.commands.pasteOutline()
</t>
<t tx="T1314">def OnDeleteNode(self,event=None):

	self.commands.deleteHeadline()
</t>
<t tx="T1315">def OnInsertNode(self,event=None):

	self.commands.insertHeadline()</t>
<t tx="T1316">def OnCloneNode(self,event=None):

	self.commands.clone()
</t>
<t tx="T1317">def OnSortChildren(self,event=None):

	self.commands.sortChildren()
	
def OnSortSiblings(self,event=None):

	self.commands.sortSiblings()</t>
<t tx="T1318"></t>
<t tx="T1319"></t>
<t tx="T1320">def OnContractChildren(self,event=None):

	self.commands.contractSubheads()
</t>
<t tx="T1321">def OnContractAllChildren(self,event=None):

	self.commands.contractAllSubheads()
</t>
<t tx="T1322">def OnExpandAllChildren(self,event=None):

	self.commands.expandAllSubheads()
</t>
<t tx="T1323">def OnExpandChildren(self,event=None):

	self.commands.expandSubheads()
</t>
<t tx="T1324">def OnContractAll(self,event=None):

	self.commands.contractAllHeadlines()
</t>
<t tx="T1325">def OnContractNode(self,event=None):

	self.commands.contractNode()
</t>
<t tx="T1326">def OnContractParent(self,event=None):

	self.commands.contractParent()
</t>
<t tx="T1327">def OnExpandAll(self,event=None):

	self.commands.expandAllHeadlines()
</t>
<t tx="T1328">def OnExpandNextLevel(self,event=None):

	self.commands.expandNextLevel()
</t>
<t tx="T1329">def OnExpandNode(self,event=None):

	self.commands.expandNode()
</t>
<t tx="T1330">def OnExpandPrevLevel(self,event=None):

	self.commands.expandPrevLevel()
</t>
<t tx="T1331">def OnExpandToLevel1(self,event=None): self.commands.expandLevel1()
def OnExpandToLevel2(self,event=None): self.commands.expandLevel2()
def OnExpandToLevel3(self,event=None): self.commands.expandLevel3()
def OnExpandToLevel4(self,event=None): self.commands.expandLevel4()
def OnExpandToLevel5(self,event=None): self.commands.expandLevel5()
def OnExpandToLevel6(self,event=None): self.commands.expandLevel6()
def OnExpandToLevel7(self,event=None): self.commands.expandLevel7()
def OnExpandToLevel8(self,event=None): self.commands.expandLevel8()
def OnExpandToLevel9(self,event=None): self.commands.expandLevel9()
</t>
<t tx="T1332"></t>
<t tx="T1333">def OnMoveDown(self,event=None):

	self.commands.moveOutlineDown()
</t>
<t tx="T1334">def OnMoveLeft(self,event=None):

	self.commands.moveOutlineLeft()
</t>
<t tx="T1335">def OnMoveRight(self,event=None):

	self.commands.moveOutlineRight()
</t>
<t tx="T1336">def OnMoveUp(self,event=None):

	self.commands.moveOutlineUp()
</t>
<t tx="T1337">def OnPromote(self,event=None):

	self.commands.promote()
</t>
<t tx="T1338">def OnDemote(self,event=None):

	self.commands.demote()
</t>
<t tx="T1339">def OnGoPrevVisible(self,event=None):

	self.commands.selectVisBack()
</t>
<t tx="T1340">def OnGoNextVisible(self,event=None):

	self.commands.selectVisNext()
</t>
<t tx="T1341">def OnGoBack(self,event=None):

	self.commands.selectThreadBack()
</t>
<t tx="T1342">def OnGoNext(self,event=None):

	self.commands.selectThreadNext()
</t>
<t tx="T1343"></t>
<t tx="T1344">def OnGoPrevVisitedNode(self,event=None):
	
	c = self.commands

	while c.beadPointer &gt; 0:
		c.beadPointer -= 1
		v = c.beadList[c.beadPointer]
		if v.exists(c):
			c.beginUpdate()
			c.frame.expandAllAncestors(v)
			c.selectVnode(v,updateBeadList=false)
			c.endUpdate()
			c.frame.idle_scrollTo(v)
			return
</t>
<t tx="T1345">def OnGoNextVisitedNode(self,event=None):
	
	c = self.commands

	while c.beadPointer + 1 &lt; len(c.beadList):
		c.beadPointer += 1
		v = c.beadList[c.beadPointer]
		if v.exists(c):
			c.beginUpdate()
			c.frame.expandAllAncestors(v)
			c.selectVnode(v,updateBeadList=false)
			c.endUpdate()
			c.frame.idle_scrollTo(v)
			return</t>
<t tx="T1346">def OnGoToFirstNode(self,event=None):
	
	c = self.commands
	v = c.rootVnode()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T1347">def OnGoToLastNode(self,event=None):
	
	c = self.commands
	v = c.rootVnode()
	while v and v.threadNext():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.frame.expandAllAncestors(v)
		c.selectVnode(v)
		c.endUpdate()

</t>
<t tx="T1348">def OnGoToNextChanged(self,event=None):

	self.commands.goToNextDirtyHeadline()
</t>
<t tx="T1349">def OnGoToNextClone(self,event=None):

	self.commands.goToNextClone()
</t>
<t tx="T1350">def OnGoToNextMarked(self,event=None):

	self.commands.goToNextMarkedHeadline()
</t>
<t tx="T1351">def OnGoToNextSibling(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	next = v.next()
	if next:
		c.beginUpdate()
		c.selectVnode(next)
		c.endUpdate()</t>
<t tx="T1352">def OnGoToParent(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	p = v.parent()
	if p:
		c.beginUpdate()
		c.selectVnode(p)
		c.endUpdate()
</t>
<t tx="T1353">def OnGoToPrevSibling(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	back = v.back()
	if back:
		c.beginUpdate()
		c.selectVnode(back)
		c.endUpdate()
</t>
<t tx="T1354">def OnMark(self,event=None):

	self.commands.markHeadline()
</t>
<t tx="T1355">def OnMarkChangedItems(self,event=None):

	self.commands.markChangedHeadlines()
</t>
<t tx="T1356">def OnMarkChangedRoots(self,event=None):

	self.commands.markChangedRoots()
</t>
<t tx="T1357">def OnMarkClones(self,event=None):

	self.commands.markClones()
</t>
<t tx="T1358">def OnMarkSubheads(self,event=None):

	self.commands.markSubheads()
</t>
<t tx="T1359">def OnUnmarkAll(self,event=None):

	self.commands.unmarkAll()
</t>
<t tx="T1360"></t>
<t tx="T1361">def OnEqualSizedPanes(self,event=None):

	frame = self

	frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="T1362">def OnToggleActivePane (self,event=None):

	# trace(`event`)
	c = self.commands

	if self.getFocus() == self.body:
		set_focus(c,self.canvas)
	else:
		set_focus(c,self.body)</t>
<t tx="T1363"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def OnToggleSplitDirection(self,event=None):
	# Abbreviations.
	frame = self
	bar1 = self.bar1 ; bar2 = self.bar2
	split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
	split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
	# Switch directions.
	verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
	orientation = choose(verticalFlag,"vertical","horizontal")
	app.config.setWindowPref("initial_splitter_orientation",orientation)
	# Reconfigure the bars.
	bar1.place_forget()
	bar2.place_forget()
	self.configureBar(bar1,verticalFlag)
	self.configureBar(bar2,not verticalFlag)
	# Make the initial placements again.
	self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
	self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
	# Adjust the log and body panes to give more room around the bars.
	self.reconfigurePanes()
	# Redraw with an appropriate ratio.
	vflag,ratio,secondary_ratio = frame.initialRatios()
	self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="T1364">def OnCascade(self,event=None):
	
	x,y,delta = 10,10,10
	for frame in app.windowList:
		top = frame.top
		# Compute w,h
		top.update_idletasks() # Required to get proper info.
		geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
		dim,junkx,junky = string.split(geom,'+')
		w,h = string.split(dim,'x')
		w,h = int(w),int(h)
		# Set new x,y and old w,h
		geom = "%dx%d%+d%+d" % (w,h,x,y)
		frame.setTopGeometry(geom) # frame.top.geometry("%dx%d%+d%+d" % (w,h,x,y))
		# Compute the new offsets.
		x += 30 ; y += 30
		if x &gt; 200:
			x = 10 + delta ; y = 40 + delta
			delta += 10
</t>
<t tx="T1365">def OnMinimizeAll(self,event=None):

	self.minimize(app.findFrame)
	self.minimize(app.pythonFrame)
	for frame in app.windowList:
		self.minimize(frame)
	
def minimize(self, frame):

	if frame and frame.top.state() == "normal":
		frame.top.iconify()</t>
<t tx="T1366">def OnHideLogWindow (self):
	
	c = self.commands ; frame = c.frame
	frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="T1367">def OnOpenCompareWindow (self,event=None):
	
	c = self.commands
	cp = self.comparePanel
	
	if cp:
		cp.top.deiconify()
		cp.top.lift()
	else:
		cmp = leoCompare.leoCompare(c)
		self.comparePanel = cp =  leoCompare.leoComparePanel(c,cmp)
		cp.run()</t>
<t tx="T1368">def OnOpenPythonWindow(self,event=None):

	if sys.platform == "linux2":
		&lt;&lt; open idle in Linux &gt;&gt;
	else:
		&lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="T1369"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
	pathToLeo = os.path.join(app.loadDir,"leo.py")
	sys.argv = [pathToLeo]
	from idlelib import idle
	if app.idle_imported:
		reload(idle)
	app.idle_imported = true
except:
	try:
		es("idlelib could not be imported.")
		es("Probably IDLE is not installed.")
		es("Run Tools/idle/setup.py to build idlelib.")
		es("Can not import idle")
		es_exception() # This can fail!!
	except: pass
</t>
<t tx="T1370"># Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo","-t","leo"]

ok = false
&lt;&lt; Try to open idle in pre-Python 2.3 systems&gt;&gt;

if not ok:
	&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;

if not ok:
	es("Can not import idle")
	if idle_dir and idle_dir not in sys.path:
		es("Please add '%s' to sys.path" % idle_dir)</t>
<t tx="T1371">try:
	executable_dir = os.path.dirname(sys.executable)
	idle_dir=os.path.join(executable_dir,"Tools","idle")

	if idle_dir not in sys.path:
		sys.path.append(idle_dir)

	import PyShell
		
	if app.idle_imported:
		reload(idle)
		app.idle_imported = true
		
	if 1: # Mostly works, but causes problems when opening other .leo files.
		PyShell.main()
	else: # Doesn't work: destroys all of Leo when Idle closes.
		self.leoPyShellMain()
	ok = true
except:
	ok = false
	# es_exception()</t>
<t tx="T1372">try:
	idle_dir = None
	
	import idlelib.PyShell

	if app.idle_imported:
		reload(idle)
		app.idle_imported = true
		
	idlelib.PyShell.main()
	ok = true

except:
	ok = false
	es_exception()</t>
<t tx="T1373">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
	
	import PyShell
	root = app.root
	PyShell.fixwordbreaks(root)
	flist = PyShell.PyShellFileList(root)
	shell = PyShell.PyShell(flist)
	flist.pyshell = shell
	shell.begin()</t>
<t tx="T1374"></t>
<t tx="T1375">def OnAbout(self,event=None):
	
	# Don't use triple-quoted strings or continued strings here.
	# Doing so would add unwanted leading tabs.
	version = self.getSignOnLine() + "\n\n"
	copyright = (
		"Copyright 1999-2003 by Edward K. Ream\n" +
		"All Rights Reserved\n" +
		"Leo is distributed under the Python License")
	url = "http://webpages.charter.net/edreamleo/front.html"
	email = "edreamleo@charter.net"

	leoDialog.aboutLeo(version,copyright,url,email).run(modal=false)
</t>
<t tx="T1376">def OnLeoDocumentation (self,event=None):

	fileName = os.path.join(app.loadDir,"..","doc","LeoDocs.leo")
	try:
		self.OpenWithFileName(fileName)
	except:
		es("not found: LeoDocs.leo")
</t>
<t tx="T1377">def OnLeoHome (self,event=None):
	
	import webbrowser

	url = "http://webpages.charter.net/edreamleo/front.html"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1378">def OnLeoHelp (self,event=None):
	
	file = os.path.join(app.loadDir,"..","doc","sbooks.chm")
	if os.path.exists(file):
		os.startfile(file)
	else:
		answer = leoDialog.askYesNo(
			"Download Tutorial?",
			"Download tutorial (sbooks.chm) from SourceForge?").run(modal=true)

		if answer == "yes":
			try:
				if 0: # Download directly.  (showProgressBar needs a lot of work)
					url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
					import urllib
					self.scale = None
					urllib.urlretrieve(url,file,self.showProgressBar)
					if self.scale:
						self.scale.destroy()
						self.scale = None
				else:
					url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
					import webbrowser
					os.chdir(app.loadDir)
					webbrowser.open_new(url)
			except:
				es("exception dowloading sbooks.chm")
				es_exception()</t>
<t tx="T1379">def showProgressBar (self,count,size,total):

	# trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
	if self.scale == None:
		&lt;&lt; create the scale widget &gt;&gt;
	self.scale.set(count*size)
	self.scale.update_idletasks()</t>
<t tx="T1380">Tk = Tkinter
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="T1381">def OnLeoTutorial (self,event=None):
	
	import webbrowser

	if 1: # new url
		url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
	else:
		url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1382">def OnLeoConfig (self,event=None):

	# 4/21/03 new code suggested by fBechmann@web.de
	loadDir = app.loadDir
	configDir = app.config.configDir
	# Look in configDir first.
	fileName = os.path.join(configDir, "leoConfig.leo")
	ok, frame = self.OpenWithFileName(fileName)
	if not ok:
		if configDir == loadDir:
			es("leoConfig.leo not found in " + loadDir)
		else:
			# Look in loadDir second.
			fileName = os.path.join(loadDir,"leoConfig.leo")
			ok, frame = self.OpenWithFileName(fileName)
			if not ok:
				es("leoConfig.leo not found in " + configDir + " or " + loadDir)
	
def OnApplyConfig (self,event=None):

	app.config.init()
	self.commands.frame.reconfigureFromConfig()</t>
<t tx="T1383">@ The following convenience routines make creating menus easier.

The Plugins section gives examples of how to use these routines to create custom menus and to add items to the Open With menu.
</t>
<t tx="T1384">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=0):
	
	for label,accel,command in table:
		if label == None or command == None or label == "-":
			menu.add_separator()
		else:
			&lt;&lt; set name to the label for doCommand &gt;&gt;
			&lt;&lt; set accel to the shortcut for name &gt;&gt;
			&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;
			&lt;&lt; define callback function &gt;&gt;
			&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;

			menu.add_command(label=realLabel,accelerator=menu_shortcut,
				command=callback,underline=amp_index)

			if bind_shortcut:
				&lt;&lt; handle bind_shorcut &gt;&gt;</t>
<t tx="T1385">name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
	if ch in string.ascii_letters or ch in string.digits:
		name2 = name2 + ch
name = name2
</t>
<t tx="T1386">config = app.config
accel2 = config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
	pass # Use default shortcut, if any.
elif accel2.lower() == "none":
	accel = None # Remove the default shortcut.
else:
	accel = accel2 # Override the default shortcut.</t>
<t tx="T1387">bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("linux1","linux2"):
	if bind_shortcut in ("&lt;Control-c&gt;","&lt;Control-v&gt;","&lt;Control-x&gt;"):
		bind_shortcut = None</t>
<t tx="T1388">@ Tkinter will call the callback function with:

	- one event argument if the user uses a menu shortcut.
	- no arguments otherwise.

Therefore, the first parameter must be event, and it must default to None.
@c

if openWith:
	def callback(event=None,self=self,data=command):
		# print "event",`event` ; print "self",`self` ; print "data",`data`
		return self.OnOpenWith(data=data)
		
else:
	def callback(event=None,self=self,command=command,label=name):
		# print "event",`event` ; print "self",`self` ; print "command",`command`
		return self.doCommand(command,label,event)</t>
<t tx="T1389">realLabel = app.getRealMenuName(label)
amp_index = realLabel.find("&amp;")
realLabel = realLabel.replace("&amp;","")
if not menu_shortcut:
	menu_shortcut = ""</t>
<t tx="T1390">if bind_shortcut in self.menuShortcuts:
	if not app.menuWarningsGiven:
		es("duplicate shortcut:", accel, bind_shortcut, label,color="red")
		print "duplicate shortcut:", accel, bind_shortcut, label
else:
	self.menuShortcuts.append(bind_shortcut)
	try:
		self.body.bind(bind_shortcut,callback)
		self.top.bind (bind_shortcut,callback)
	except: # could be a user error
		if not app.menuWarningsGiven:
			print "exception binding menu shortcut..."
			print bind_shortcut
			es_exception()
			app.menuWarningsGive = true</t>
<t tx="T1391">def createMenuItemsFromTable (self,menuName,table,openWith=0):
	
	try:
		menu = self.getMenu(menuName)
		if menu == None:
			print "menu does not exist: ", menuName
			es("menu does not exist: " + `menuName`)
			return
		self.createMenuEntries(menu,table,openWith)
	except:
		print "exception creating items for ", menuName," menu"
		es("exception creating items for " + `menuName` + " menu")
		es_exception()</t>
<t tx="T1392">def createNewMenu (self,menuName,parentName="top",before=None):

	try:
		parent = self.getMenu(parentName)
		if parent == None:
			es("unknown parent menu: " + parentName)
			return None
			
		menu = self.getMenu(menuName)
		if menu:
			es("menu already exists: " + menuName,color="red")
		else:
			menu = Tkinter.Menu(parent,tearoff=0)
			self.setMenu(menuName,menu)
			label=app.getRealMenuName(menuName)
			amp_index = label.find("&amp;")
			label = label.replace("&amp;","")
			if before: # Insert the menu before the "before" menu.
				index_label=app.getRealMenuName(before)
				amp_index = index_label.find("&amp;")
				index_label = index_label.replace("&amp;","")
				index = parent.index(index_label)
				parent.insert_cascade(index=index,label=label,menu=menu,underline=amp_index)
			else:
				parent.add_cascade(label=label,menu=menu,underline=amp_index)
			return menu
	except:
		es("exception creating " + menuName + " menu")
		es_exception()
		return None</t>
<t tx="T1393">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

	app.openWithTable = table # Override any previous table.
	# Delete the previous entry.
	parent = self.getMenu("File")
	label=app.getRealMenuName("Open &amp;With...")
	amp_index = label.find("&amp;")
	label = label.replace("&amp;","")
	try:
		index = parent.index(label)
		parent.delete(index)
	except:
		try:
			index = parent.index("Open With...")
			parent.delete(index)
		except: return
	# Create the "Open With..." menu.
	openWithMenu = Tkinter.Menu(parent,tearoff=0)
	self.setMenu("Open With...",openWithMenu)
	parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
	# Populate the "Open With..." menu.
	shortcut_table = []
	for triple in table:
		if len(triple) == 3: # 6/22/03
			shortcut_table.append(triple)
		else:
			es("createOpenWithMenuFromTable: invalid data",color="red")
			return
			
	# for i in shortcut_table: print i
	self.createMenuItemsFromTable("Open &amp;With...",shortcut_table,openWith=1)
</t>
<t tx="T1394">def deleteMenu (self,menuName):

	try:
		menu = self.getMenu(menuName)
		if menu:
			menu.destroy()
			self.destroyMenu(menuName)
		else:
			es("can't delete menu: " + menuName)
	except:
		es("exception deleting " + menuName + " menu")
		es_exception()</t>
<t tx="T1395"># Delete itemName from the menu whose name is menuName.
def deleteMenuItem (self,itemName,menuName="top"):

	try:
		menu = self.getMenu(menuName)
		if menu:
			realItemName=app.getRealMenuName(itemName)
			menu.delete(realItemName)
		else:
			es("menu not found: " + menuName)
	except:
		es("exception deleting " + itemName + " from " + menuName + " menu")
		es_exception()</t>
<t tx="T1396">def setRealMenuNamesFromTable (self,table):

	try:
		app.setRealMenuNamesFromTable(table)
	except:
		es("exception in setRealMenuNamesFromTable")
		es_exception()
</t>
<t tx="T1397"></t>
<t tx="T1398"># This is the Tk "postcommand" callback.  It should update all menu items.

def OnMenuClick (self):
	
	# A horrible kludge: set app.log to cover for a possibly missing activate event.
	app.setLog(self,"OnMenuClick")
	
	# Allow the user first crack at updating menus.
	c = self.commands ; v = c.currentVnode() # 2/8/03
	if not doHook("menu2",c=c,v=v):
		self.updateFileMenu()
		self.updateEditMenu()
		self.updateOutlineMenu()

</t>
<t tx="T1399"># Returns true if text in the outline or body text is selected.

def hasSelection (self):

	if self.body:
		first, last = getTextSelection(self.body)
		return first != last
	else:
		return false</t>
<t tx="T1400">def updateFileMenu (self):
	
	c = self.commands
	if not c: return

	try:
		menu = self.getMenu("File")
		enableMenu(menu,"Revert To Saved", c.canRevert())

		# openWithMenu = self.getMenu("Open With...")
		enableMenu(menu,"Open With...", app.hasOpenWithMenu)

	except:
		es("exception updating File menu")
		es_exception()
</t>
<t tx="T1401">def updateEditMenu (self):

	c = self.commands
	if not c: return
	try:
		# Top level Edit menu...
		menu = self.getMenu("Edit")
		c.undoer.enableMenuItems()
		if 0: # Always on for now.
			enableMenu(menu,"Cut",c.canCut())
			enableMenu(menu,"Copy",c.canCut())
			enableMenu(menu,"Paste",c.canPaste())
		if 0: # Always on for now.
			menu = self.getMenu("Find...")
			enableMenu(menu,"Find Next",c.canFind())
			flag = c.canReplace()
			enableMenu(menu,"Replace",flag)
			enableMenu(menu,"Replace, Then Find",flag)
		# Edit Body submenu...
		menu = self.getMenu("Edit Body...")
		enableMenu(menu,"Extract Section",c.canExtractSection())
		enableMenu(menu,"Extract Names",c.canExtractSectionNames())
		enableMenu(menu,"Extract",c.canExtract())
		enableMenu(menu,"Match Brackets",c.canFindMatchingBracket())
	except:
		es("exception updating Edit menu")
		es_exception()</t>
<t tx="T1402">def updateOutlineMenu (self):

	c = self.commands ; v = c.currentVnode()
	if not c: return
	try:
		# Top level outline menu...
		menu = self.getMenu("Outline")
		enableMenu(menu,"Cut Node",c.canCutOutline())
		enableMenu(menu,"Delete Node",c.canDeleteHeadline())
		enableMenu(menu,"Paste Node",c.canPasteOutline())
		enableMenu(menu,"Sort Siblings",c.canSortSiblings())
		# Expand/Contract submenu...
		menu = self.getMenu("Expand/Contract...")
		hasChildren = v.hasChildren()
		isExpanded = v.isExpanded()
		enableMenu(menu,"Contract Parent",c.canContractParent())
		enableMenu(menu,"Contract Node",hasChildren and isExpanded)
		enableMenu(menu,"Expand Node",hasChildren and not isExpanded)
		enableMenu(menu,"Expand Prev Level",hasChildren and isExpanded)
		enableMenu(menu,"Expand Next Level",hasChildren)
		enableMenu(menu,"Expand To Level 1",hasChildren and isExpanded)
		for i in xrange(2,9):
			enableMenu(menu,"Expand To Level " + str(i), hasChildren)
		# Move submenu...
		menu = self.getMenu("Move...")
		enableMenu(menu,"Move Down",c.canMoveOutlineDown())
		enableMenu(menu,"Move Left",c.canMoveOutlineLeft())
		enableMenu(menu,"Move Right",c.canMoveOutlineRight())
		enableMenu(menu,"Move Up",c.canMoveOutlineUp())
		enableMenu(menu,"Promote",c.canPromote())
		enableMenu(menu,"Demote",c.canDemote())
		# Go To submenu
		menu = self.getMenu("Go To...")
		enableMenu(menu,"Go Back",c.beadPointer &gt; 1)
		enableMenu(menu,"Go Forward",c.beadPointer + 1 &lt; len(c.beadList))
		enableMenu(menu,"Go To Prev Visible",c.canSelectVisBack())
		enableMenu(menu,"Go To Next Visible",c.canSelectVisNext())
		enableMenu(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
		enableMenu(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
		enableMenu(menu,"Go To Next Clone",v.isCloned())
		enableMenu(menu,"Go To Prev Node",c.canSelectThreadBack())
		enableMenu(menu,"Go To Next Node",c.canSelectThreadNext())
		enableMenu(menu,"Go To Parent",v.parent() != None)
		enableMenu(menu,"Go To Prev Sibling",v.back() != None)
		enableMenu(menu,"Go To Next Sibling",v.next() != None)
		# Mark submenu
		menu = self.getMenu("Mark/Unmark...")
		label = choose(v and v.isMarked(),"Unmark","Mark")
		setMenuLabel(menu,0,label)
		enableMenu(menu,"Mark Subheads",(v and v.hasChildren()))
		enableMenu(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
		enableMenu(menu,"Mark Changed Roots",c.canMarkChangedRoots())
		enableMenu(menu,"Mark Clones",v.isCloned())
	except:
		es("exception updating Outline menu")
		es_exception()</t>
<t tx="T1403">@nocolor

The following sections contain convenience routines that hooks may call to create menus and to schedule events.

@color

@ignore

</t>
<t tx="T1404">@ When the "idle" hook is enabled, Leo will call the "idle" hook periodically.

You scripts should call only enableIdleTimeHook and disableIdleTimeHook.  The idleTimeHookHandler is used to dispatch the "idle" hook.  Your code should not call it directly.</t>
<t tx="T1405">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every idleTimeDelay milliseconds.
@c
def enableIdleTimeHook(idleTimeDelay=100):
	app.idleTimeHook = true
	app.idleTimeDelay = idleTimeDelay # Delay in msec.
	app.root.after_idle(idleTimeHookHandler)
	
# Disables the "idle" hook.
def disableIdleTimeHook():
	app.idleTimeHook = false
	
# An internal routine used to dispatch the "idle" hook.
def idleTimeHookHandler(*args):
	
	# New for Python 2.3: may be called during shutdown.
	if app.killed:
		return
	c = top()
	if c: v = c.currentVnode()
	else: v = None
	doHook("idle",c=c,v=v)
	# Requeue this routine after 100 msec.
	# Faster requeues overload the system.
	if app.idleTimeHook:
		app.afterHandler = app.root.after(app.idleTimeDelay,idleTimeHookHandler)
	else:
		app.afterHandler = None</t>
<t tx="T1406">def module_date (mod,format=None):
	file = os.path.join(app.loadDir,mod.__file__)
	root,ext = os.path.splitext(file) 
	return file_date(root + ".py",format=format)

def plugin_date (plugin_mod,format=None):
	file = os.path.join(app.loadDir,"..","plugins",plugin_mod.__file__)
	root,ext = os.path.splitext(file) 
	return file_date(root + ".py",format=format)

def file_date (file,format=None):
	if file and len(file)and os.path.exists(file):
		try:
			import time
			n = os.path.getmtime(file)
			if format == None:
				format = "%m/%d/%y %H:%M:%S"
			return time.strftime(format,time.gmtime(n))
		except: pass
	return ""
</t>
<t tx="T1407">def plugin_signon(module_name,verbose=false):
	
	exec("import %s ; m = %s" % (module_name,module_name))
	
	if verbose:
		es("...%s.py v%s: %s" % (
			m.__name__, m.__version__, plugin_date(m)))

		print m.__name__, m.__version__
		
	# Increment a global count.
	import leoPlugins
	leoPlugins.count += 1
</t>
<t tx="T1408">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
</t>
<t tx="T1409">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="T1410">def idle_body_key (self,v,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
	
	"""Update the body pane at idle time."""

	if 0:
		if ch: trace(ch,ord(ch))
		else: trace(`ch`)

	c = self.commands
	if not c or not v or v != c.currentVnode():
		return "break"
	if doHook("bodykey1",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType):
		return "break" # The hook claims to have handled the event.
	body = v.bodyString()
	if not newSel:
		newSel = getTextSelection(c.body)
	if oldText != None:
		s = oldText
	else:
		s = getAllText(c.body)
	&lt;&lt; return if nothing has changed &gt;&gt;
	&lt;&lt; set removeTrailing &gt;&gt;
	if ch in ('\n','\r'):
		&lt;&lt; Do auto indent &gt;&gt;
	elif ch == '\t' and c.tab_width &lt; 0:
		&lt;&lt; convert tab to blanks &gt;&gt;
	&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
	if undoType:
		c.undoer.setUndoTypingParams(v,undoType,body,s,oldSel,newSel,oldYview=oldYview)
	v.t.setTnodeText(s)
	v.t.insertSpot = c.body.index("insert")
	&lt;&lt; recolor the body &gt;&gt;
	if not c.changed:
		c.setChanged(true)
	&lt;&lt; redraw the screen if necessary &gt;&gt;
	doHook("bodykey2",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType)
	return "break"</t>
<t tx="T1411"># 6/22/03: Make sure we handle delete key properly.

if ch not in ('\n','\r',chr(8)):

	if s == body:
		return "break"
	
	# Do nothing for control characters.
	if (ch == None or len(ch) == 0) and body == s[:-1]:
		return "break"
	
# print `ch`,len(body),len(s)</t>
<t tx="T1412">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
	# There is no newline to remove.  Probably will never happen.
	# trace("false: no newline to remove")
	removeTrailing = false
elif len(old) == 0:
	# Ambigous case.
	# trace("false: empty old")
	removeTrailing = ch != '\n' # false
elif old == new[:-1]:
	# A single trailing character has been added.
	# trace("false: only changed trailing.")
	removeTrailing = false
else:
	# The text didn't have a newline, and now it does.
	# Moveover, some other change has been made to the text,
	# So at worst we have misreprented the user's intentions slightly.
	# trace("true")
	removeTrailing = true
	
# trace(`ch`+","+`removeTrailing`)


</t>
<t tx="T1413"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.colorizer.useSyntaxColoring(v) and undoType != "Change":
	# Get the previous line.
	s=c.body.get("insert linestart - 1 lines","insert linestart -1c")
	# Add the leading whitespace to the present line.
	junk,width = skip_leading_ws_with_indent(s,0,c.tab_width)
	if s and len(s) &gt; 0 and s[-1]==':':
		# For Python: increase auto-indent after colons.
		if self.colorizer.scanColorDirectives(v) == "python":
			width += abs(c.tab_width)
	if app.config.getBoolWindowPref("smart_auto_indent"):
		# Added Nov 18 by David McNab, david@rebirthing.co.nz
		# Determine if prev line has unclosed parens/brackets/braces
		brackets = [width]
		tabex = 0
		for i in range(0, len(s)):
			if s[i] == '\t':
				tabex += c.tab_width - 1
			if s[i] in '([{':
				brackets.append(i+tabex + 1)
			elif s[i] in '}])' and len(brackets) &gt; 1:
				brackets.pop()
		width = brackets.pop()
		# end patch by David McNab
	ws = computeLeadingWhitespace (width,c.tab_width)
	if ws and len(ws) &gt; 0:
		c.body.insert("insert", ws)
		removeTrailing = false # bug fix: 11/18</t>
<t tx="T1414"># Do nothing if we are executing a Change command.
if undoType != "Change":
	
	# Get the characters preceeding the tab.
	prev=c.body.get("insert linestart","insert -1c")
	
	if 1: # 6/26/03: Convert tab no matter where it is.

		w = computeWidth(prev,c.tab_width)
		w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
		# print "prev w:" + `w` + ", prev chars:" + `prev`
		c.body.delete("insert -1c")
		c.body.insert("insert",' ' * w2)
	
	else: # Convert only leading tabs.
	
		# Get the characters preceeding the tab.
		prev=c.body.get("insert linestart","insert -1c")

		# Do nothing if there are non-whitespace in prev:
		all_ws = true
		for ch in prev:
			if ch != ' ' and ch != '\t':
				all_ws = false
		if all_ws:
			w = computeWidth(prev,c.tab_width)
			w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
			# print "prev w:" + `w` + ", prev chars:" + `prev`
			c.body.delete("insert -1c")
			c.body.insert("insert",' ' * w2)</t>
<t tx="T1415">s = getAllText(c.body) # 9/28/03
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
	s = s[:-1]</t>
<t tx="T1416"># if self.forceFullRecolorFlag: trace(undoType,"full recolor")

self.scanForTabWidth(v)
incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.recolor_now(v,incremental=incremental)
self.forceFullRecolorFlag = false</t>
<t tx="T1417">redraw_flag = false

c.beginUpdate()

# Update dirty bits.
if not v.isDirty() and v.setDirty(): # Sets all cloned and @file dirty bits
	redraw_flag = true
	
# Update icons.
val = v.computeIcon()
if val != v.iconVal:
	v.iconVal = val
	redraw_flag = true

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="T1418"># Called by command handlers that have already changed the text.

def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
	
	"""Handle a change to the body pane."""
	
	c = self.commands
	if not v:
		v = c.currentVnode()

	if not oldSel:
		oldSel = getTextSelection(c.body)

	self.idle_body_key(v,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
</t>
<t tx="T1419">def OnBodyKey (self,event):
	
	"""Handle any key press event in the body pane."""

	c = self.commands ; v = c.currentVnode() ; ch = event.char
	oldSel = getTextSelection(c.body)

	if 0:
		self.keyCount += 1
		if ch and len(ch)&gt;0: print "%4d %s" % (self.keyCount,repr(ch))
		
	# We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)</t>
<t tx="T1420"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,v,undoType,oldSel=None,oldYview=None):
	
	"""Queue the body changed idle handler."""
	
	c = self.commands
	if not v: v = c.currentVnode()
	if not oldSel:
		oldSel = getTextSelection(c.body)
	  
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,undoType,oldYview)

</t>
<t tx="T1421">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others</t>
<t tx="T1422">def onHeadChanged (self,v):
	
	"""Handle a change to headline text."""

	self.commands.body.after_idle(self.idle_head_key,v)


</t>
<t tx="T1423">def OnHeadlineKey (self,v,event):
	
	"""Handle a key event in a headline."""

	ch = event.char
	self.commands.body.after_idle(self.idle_head_key,v,ch)

</t>
<t tx="T1424">def idle_head_key (self,v,ch=None):
	
	"""Update headline text at idle time."""

	c = self.commands
	if not v or not v.edit_text() or v != c.currentVnode():
		return "break"
	if doHook("headkey1",c=c,v=v,ch=ch):
		return "break" # The hook claims to have handled the event.

	&lt;&lt; set s to the widget text &gt;&gt;
	&lt;&lt; set head to vnode text &gt;&gt;
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",v,newText=s,oldText=head)
	index = v.edit_text().index("insert")
	if changed:
		&lt;&lt; update v and all nodes joined to v &gt;&gt;
	&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;
	&lt;&lt; update the screen &gt;&gt;

	doHook("headkey2",c=c,v=v,ch=ch)
	return "break"</t>
<t tx="T1425">s = v.edit_text().get("1.0","end")
s = toUnicode(s,app.tkEncoding) # 2/25/03
if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# trace(`s`)
</t>
<t tx="T1426">head = v.headString()
if head == None:
	head = u""
head = toUnicode(head,"utf-8")
</t>
<t tx="T1427">c.beginUpdate()

# Update changed bit.
if not c.changed:
	c.setChanged(true)

# Update all dirty bits.
v.setDirty()

# Update v.
v.initHeadString(s)
v.edit_text().delete("1.0","end")
v.edit_text().insert("end",s)
v.edit_text().mark_set("insert",index)

# Update all joined nodes.
for v2 in v.t.joinList:
	if v2 != v:
		v2.initHeadString(s)
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().delete("1.0","end")
			v2.edit_text().insert("end",s)

c.endUpdate(false) # do not redraw now.</t>
<t tx="T1428"># Reconfigure v's headline.
if done:
	self.setDisabledLabelState(v)

v.edit_text().configure(width=self.headWidth(v))

# Reconfigure all joined headlines.
for v2 in v.t.joinList:
	if v2 != v:
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().configure(width=self.headWidth(v2))</t>
<t tx="T1429">if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(v,v.iconx,v.icony) # just redraw the icon.</t>
<t tx="T1430">@nocolor

I tried several unsuccessful experiments:

1. This does not work because we must _always_ call idle_body_key in order to delete spurious newlines.

@color
if ch and len(ch) &gt; 0:
    self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)
    
@nocolor
2. This does not work when bound to KeyRelease events because of timing problems when releasing the control and s keys.

@color
def OnBodyKeyRelease (self,event):
    c = self.commands ; v = c.currentVnode() ; ch = event.char
    oldSel = getTextSelection(c.body)
    self.idle_body_key(v,oldSel,"Typing",ch)</t>
<t tx="T1431">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.</t>
<t tx="T1432">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	&lt;&lt; Set ivars &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="T1433">self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app().config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="T1434"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) &gt; 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
</t>
<t tx="T1435"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T1436">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e</t>
<t tx="T1437"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")</t>
<t tx="T1438">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
</t>
<t tx="T1439"># We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			&lt;&lt; handle absolute path &gt;&gt;
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="T1440">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)</t>
<t tx="T1441"># path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
</t>
<t tx="T1442">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w &gt; 0:
		self.page_width = w</t>
<t tx="T1443">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

</t>
<t tx="T1444"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""</t>
<t tx="T1445"># Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""</t>
<t tx="T1446"># Called by __init__

def init_ivars(self):

	c = self.commands
	&lt;&lt; init tangle ivars &gt;&gt;
	&lt;&lt; init untangle ivars &gt;&gt;
	
# Called by scanAllDirectives

def init_directive_ivars (self):

	c = self.commands
	&lt;&lt; init directive ivars &gt;&gt;</t>
<t tx="T1447"># Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = true # true if tangling, false if untangling.
self.path_warning_given = false # true: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
	self.file_name = c.mFileName # The file name (was a bridge function)
else:
	self.file_name = "&lt;unknown file name&gt;"
self.v = None # vnode being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
	self.head_root = None
	self.code = None
	self.doc = None
	self.header_name = None
	self.header = None
	self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is valid to continue a section definition.
@c
self.code_seen = false # true if @code seen in body text.

# Support of output_newline option
self.output_newline = getOutputNewline()</t>
<t tx="T1448">@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.</t>
<t tx="T1449">if 0: # not used in this version of Leo
	self.allow_rich_text = default_allow_rich_text
	self.extended_noweb_flag = default_extended_noweb_flag
	self.target_language = default_target_language # uses c.target_lanuage instead
	
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = set_delims_from_language(self.language)
# print `delim1`,`delim2`,`delim3`

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
	self.use_cweb_flag = false
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
	self.use_cweb_flag = self.language == "cweb"
	self.raw_cweb_flag = false # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = app.config.default_derived_file_encoding # 2/21/03
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="T1450">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,v,require_path_flag,issue_error_flag):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding tangle ivars and globals.
	"""

	c = self.commands
	# trace(`v`)
	old = {} ; print_mode_changed = false
	self.init_directive_ivars()
	if v:
		s = v.bodyString()
		&lt;&lt; Collect @first attributes &gt;&gt;
	while v:
		s = v.bodyString()
		dict = get_directives_dict(s)
		# trace("dict:" + `dict`, ", " + `v`)
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for print modes directives &gt;&gt;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @root &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set self.tangle_directory &gt;&gt;</t>
<t tx="T1451">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
	# DTHEIN 13-OCT-2002: directives must start at beginning of a line
	if not match_word(s,i,tag):
		i = skip_line(s,i)
	else:
		i = i + len(tag)
		j = i = skip_ws(s,i)
		i = skip_to_end_of_line(s,i)
		if i&gt;j:
			self.first_lines += s[j:i] + '\n'
		i = skip_nl(s,i)
	if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
		break

</t>
<t tx="T1452">if old.has_key("comment") or old.has_key("language"):
	 pass # Do nothing more.

elif dict.has_key("comment"):

	i = dict["comment"]
	delim1,delim2,delim3 = set_delims_from_string(s[i:])
	if delim1 or delim2:
		self.single_comment_string = delim1
		self.start_comment_string = delim2
		self.end_comment_string = delim3
		# @comment effectively disables Untangle.
		self.language = "unknown"
	else:
		if issue_error_flag:
			es("ignoring: " + s[i:])

elif dict.has_key("language"):

	i = dict["language"]
	language,delim1,delim2,delim3 = set_language(s,i)
	self.language = language
	self.single_comment_string = delim1
	self.start_comment_string = delim2
	self.end_comment_string = delim3
	if 0:
		trace(`self.single_comment_string` + "," +
			`self.start_comment_string` + "," +
			`self.end_comment_string`)
		
	# 10/30/02: These ivars must be updated here!
	# trace(`self.language`)
	self.use_noweb_flag = true
	self.use_cweb_flag = false # Only raw cweb mode is ever used.
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="T1453">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
</t>
<t tx="T1454">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
</t>
<t tx="T1455">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
	for name in ("verbose","terse","quiet","silent"):
		if dict.has_key(name):
			self.print_mode = name
			print_mode_changed = true
			break
</t>
<t tx="T1456">if require_path_flag and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
	if len(dir) &gt; 0:
		base = getBaseDirectory() # May return "".
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir):
				&lt;&lt; handle absolute @path &gt;&gt;
			elif issue_error_flag and not self.path_warning_given:
				self.path_warning_given = true # supress future warnings
				self.error("ignoring relative path in @path:" + dir)
	elif issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true # supress future warnings
		self.error("ignoring empty @path")
</t>
<t tx="T1457">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

dir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	dir = os.path.join(app.loadDir,dir)

# trace("dir: " + dir)</t>
<t tx="T1458">if os.path.exists(dir):
	self.tangle_directory = dir
else: # 11/19/02
	self.tangle_directory = makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		if issue_error_flag and not self.path_warning_given:
			self.path_warning_given = true # supress future warnings
			self.error("@path directory does not exist: " + dir)
			if base and len(base) &gt; 0:
				es("relative_path_base_directory: " + base)
			if relative_path and len(relative_path) &gt; 0:
				es("relative path in @path directive: " + relative_path)</t>
<t tx="T1459">if not old.has_key("pagewidth") and dict.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag)
	if w and w &gt; 0:
		self.page_width = w</t>
<t tx="T1460">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and dict.has_key("root"):

	i = dict["root"]
	# i += len("@root")
	self.setRootFromText(s[i:],issue_error_flag)</t>
<t tx="T1461">if not old.has_key("tabwidth") and dict.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag)
	if w and w != 0:
		self.tab_width = w
</t>
<t tx="T1462">if old.has_key("header") or old.has_key("noheader"):
	pass # Do nothing more.
	
elif dict.has_key("header") and dict.has_key("noheader"):
	if issue_error_flag:
		es("conflicting @header and @noheader directives")

elif dict.has_key("header"):
	self.use_header_flag = true

elif dict.has_key("noheader"):
	self.use_header_flag = false
</t>
<t tx="T1463">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be os.path.join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
	if self.root_name and len(self.root_name) &gt; 0:
		root_dir = os.path.dirname(self.root_name)
	else:
		root_dir = None
	# print "root_dir:", root_dir

	table = ( # This is a precedence table.
		(root_dir,"@root"), 
		(c.tangle_directory,"default tangle"), # Probably should be eliminated.
		(c.frame.openDirectory,"open"))

	base = getBaseDirectory() # May return "".

	for dir2, kind in table:
		if dir2 and len(dir2) &gt; 0:
			# print "base,dir:",`base`,`dir`
			dir = os.path.join(base,dir2)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				&lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
	self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="T1464">if os.path.exists(dir):
	if kind == "@root" and not os.path.isabs(root_dir):
		self.tangle_directory = base
	else:
		self.tangle_directory = dir 
	break
else: # 9/25/02
	self.tangle_directory = makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		# 10/27/02: It is an error for this not to exist now.
		self.error("@root directory does not exist:" + dir)
		if base and len(base) &gt; 0:
			es("relative_path_base_directory: " + base)
		if dir2 and len(dir2) &gt; 0:
			es(kind + " directory: " + dir2)
</t>
<t tx="T1465"># Similar to code in scanAllDirectives.

def scanForTabWidth (self, v):
	
	c = self.commands ; w = c.tab_width

	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; set w and break on @tabwidth &gt;&gt;
		v = v.parent()

	c.frame.setTabWidth(w)</t>
<t tx="T1466">if dict.has_key("tabwidth"):
	
	val = scanAtTabwidthDirective(s,dict,issue_error_flag=false)
	if val and val != 0:
		w = val
		break</t>
<t tx="T1467">def scanColorDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for @color and @nocolor directives,
	setting corresponding colorizer ivars.
	"""

	c = self.commands
	if c == None:
		return # self.commands may be None for testing.

	language = c.target_language
	self.language = language # 2/2/03
	self.comment_string = None
	self.rootMode = None # None, "code" or "doc"
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
		v = v.parent()
	return self.language # For use by external routines.
</t>
<t tx="T1468"># 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
	k = dict["comment"]
	self.comment_string = s[k:]

if dict.has_key("language"):
	i = dict["language"]
	language,junk,junk,junk = set_language(s,i)
	self.language = language # 2/2/03

if dict.has_key("comment") or dict.has_key("language"):
	break</t>
<t tx="T1469">if dict.has_key("root") and not self.rootMode:

	k = dict["root"]
	if match_word(s,k,"@root-code"):
		self.rootMode = "code"
	elif match_word(s,k,"@root-doc"):
		self.rootMode = "doc"
	else:
		doc = app.config.at_root_bodies_start_in_doc_mode
		self.rootMode = choose(doc,"doc","code")
</t>
<t tx="T1470"></t>
<t tx="T1471"></t>
<t tx="T1472"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

	val = app.language_delims_dict.get(language)
	if val:
		delim1,delim2,delim3 = set_delims_from_string(val)
		if delim2 and not delim3:
			return None,delim1,delim2
		else: # 0,1 or 3 params.
			return delim1,delim2,delim3
	else:
		return None, None, None # Indicate that no change should be made
</t>
<t tx="T1473">@ Returns (delim1, delim2, delim2), the delims following the @comment directive.

This code can be called from @languge logic, in which case s can point at @comment
@c

def set_delims_from_string(s):
	
	# trace(`s`)

	# Skip an optional @comment
	tag = "@comment"
	i = 0
	if match_word(s,i,tag):
		i += len(tag)
		
	count = 0 ; delims = [None, None, None]
	while count &lt; 3 and i &lt; len(s):
		i = j = skip_ws(s,i)
		while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
			i += 1
		if j == i: break
		delims[count] = s[j:i]
		count += 1
		
	# 'rr 09/25/02
	if count == 2: # delims[0] is always the single-line delim.
		delims[2] = delims[1]
		delims[1] = delims[0]
		delims[0] = None

	# 7/8/02: The "REM hack": replace underscores by blanks.
	# 9/25/02: The "perlpod hack": replace double underscores by newlines.
	for i in xrange(0,3):
		if delims[i]:
			delims[i] = string.replace(delims[i],"__",'\n') 
			delims[i] = string.replace(delims[i],'_',' ')

	return delims[0], delims[1], delims[2]</t>
<t tx="T1474">def set_language(s,i,issue_errors_flag=false):
	
	"""Scan the @language directive that appears at s[i:].

	Returns (language, delim1, delim2, delim3)
	"""

	tag = "@language"
	# trace(`get_line(s,i)`)
	assert(i != None)
	assert(match_word(s,i,tag))
	i += len(tag) ; i = skip_ws(s, i)
	# Get the argument.
	j = i ; i = skip_c_id(s,i)
	# Allow tcl/tk.
	arg = string.lower(s[j:i])
	if app.language_delims_dict.get(arg):
		language = arg
		delim1, delim2, delim3 = set_delims_from_language(language)
		return language, delim1, delim2, delim3
	
	if issue_errors_flag:
		es("ignoring: " + get_line(s,i))

	return None, None, None, None,</t>
<t tx="T1475">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

	after = root.nodeAfterTree()
	v = root.firstChild()
	while v and v != after:
		if v.matchHeadline(name) and not v.isAtIgnoreNode():
			return v
		v = v.threadNext()
	return None
</t>
<t tx="T1476">def getOutputNewline (lineending = None):
	
	"""Convert the name of a line ending to the line ending itself.
	Use the output_newline configuration option if no lineending is given.
	"""
	
	if lineending:
		s = lineending
	else:
		s = app.config.output_newline
	s = string.lower(s)
	if s in ( "nl","lf","platform"): s = '\n'
	elif s == "cr": s = '\r'
	elif s == "crlf": s = "\r\n"
	else: s = '\n' # Default for erroneous values.
	return s</t>
<t tx="T1477">def scanAtEncodingDirective(s,dict):
	
	"""Scan the @encoding directive at s[dict["encoding"]:].

	Returns the encoding name or None if the encoding name is invalid.
	"""

	k = dict["encoding"]
	i = skip_to_end_of_line(s,k)
	j = len("@encoding")
	encoding = s[k+j:i].strip()
	if isValidEncoding(encoding):
		# trace(encoding)
		return encoding
	else:
		es("invalid @encoding:"+encoding,color="red")
		return None</t>
<t tx="T1478">def scanAtLineendingDirective(s,dict):
	
	"""Scan the @lineending directive at s[dict["lineending"]:].

	Returns the actual lineending or None if the name of the lineending is invalid.
	"""

	k = dict["lineending"]
	i = skip_to_end_of_line(s,k)
	j = len("@lineending")
	j = skip_ws(s,j)
	e = s[k+j:i].strip()

	if e in ("cr","crlf","lf","nl","platform"):
		lineending = getOutputNewline(e)
		# trace(`e`,`lineending`)
		return lineending
	else:
		# es("invalid @lineending directive:"+e,color="red")
		return None</t>
<t tx="T1479">def scanAtPagewidthDirective(s,dict,issue_error_flag=false):
	
	"""Scan the @pagewidth directive at s[dict["pagewidth"]:].

	Returns the value of the width or None if the width is invalid.
	"""
	
	k = dict["pagewidth"]
	j = i = k + len("@pagewidth")
	i, val = skip_long(s,i)
	if val != None and val &gt; 0:
		# trace(val)
		return val
	else:
		if issue_error_flag:
			j = skip_to_end_of_line(s,k)
			es("ignoring " + s[k:j],color="red")
		return None
</t>
<t tx="T1480">def scanAtTabwidthDirective(s,dict,issue_error_flag=false):
	
	"""Scan the @tabwidth directive at s[dict["tabwidth"]:].

	Returns the value of the width or None if the width is invalid.
	"""
	
	k = dict["tabwidth"]
	i = k + len("@tabwidth")
	i, val = skip_long(s, i)
	if val != None and val != 0:
		# trace(`val`)
		return val
	else:
		if issue_error_flag:
			i = skip_to_end_of_line(s,k)
			es("Ignoring " + s[k:i],color="red")
		return None

</t>
<t tx="T1481">@ A general-purpose routine that scans v and its ancestors for directives.  It returns a dict containing the settings in effect as the result of the @comment, @language, @lineending, @pagewidth, @path and @tabwidth directives.  This code does not check on the existence of paths, and issues no error messages.

Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,v=None):
	
	"""Scan vnode v and v's ancestors looking for directives.

	Returns a dict containing the results, including defaults.
	"""

	if c == None or top() == None:
		return {} # 7/16/03: for unit tests.
	if v == None: v = c.currentVnode()

	# trace(`v`)
	&lt;&lt; Set local vars &gt;&gt;
	old = {}
	pluginsList = [] # 5/17/03: a list of items for use by plugins.
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		&lt;&lt; Test for @wrap and @nowrap &gt;&gt;
		doHook("scan-directives",c=c,v=v,s=s,
			old_dict=old,dict=dict,pluginsList=pluginsList)
		old.update(dict)
		v = v.parent()

	if path == None: path = getBaseDirectory()

	return {
		"delims"    : (delim1,delim2,delim3),
		"encoding"  : encoding,
		"language"  : language,
		"lineending": lineending,
		"pagewidth" : page_width,
		"path"      : path,
		"tabwidth"  : tab_width,
		"pluginsList": pluginsList,
		"wrap"      : wrap }

</t>
<t tx="T1482">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.</t>
<t tx="T1483"># @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	delim1,delim2,delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T1484">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		encoding = e
</t>
<t tx="T1485">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	e = scanAtLineendingDirective(s,dict)
	if e:
		lineending = e
</t>
<t tx="T1486">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict)
	if w and w &gt; 0:
		page_width = w</t>
<t tx="T1487">if not path and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)</t>
<t tx="T1488">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(app.loadDir,path)</t>
<t tx="T1489">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict)
	if w and w &gt; 0:
		tab_width = w</t>
<t tx="T1490">if not old.has_key("wrap") and not old.has_key("nowrap"):
	
	if dict.has_key("wrap"):
		wrap = true
	elif dict.has_key("nowrap"):
		wrap = false</t>
<t tx="T1491">@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8</t>
<t tx="T1492">line 1
line 2
last line (no newline)</t>
<t tx="T1493">node 1 line 1
node 1 line 2
node 1 line 3 (newline)
</t>
<t tx="T1494">node 2 line 1
node 2 line 2
node 2 line 3 (no newline)</t>
<t tx="T1495">line 1
line 2
last line (no newline)</t>
<t tx="T1496">@root c:\prog\test\tangleTest.txt

line 1 
line 2
&lt;&lt; ref &gt;&gt;
line 3</t>
<t tx="T1497">&lt;&lt; ref &gt;&gt;=
ref line 1
ref line 2</t>
<t tx="T1498"></t>
<t tx="T1499"></t>
<t tx="T1500">@encoding iso-8859-15
@nocolor

https://sourceforge.net/forum/message.php?msg_id=1915561
By: dalcolmo

I tried to write out text containing characters like:
        
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.
This was with a pristine 3.11b3 installation, e.g. without any modifications.
Setting the encoding for derived files to latin-1 does not change anything.

- Josef

@color</t>
<t tx="T1501">@nocolor

http://sourceforge.net/forum/message.php?msg_id=1914029

From: Rich
LEO version: 3.10, build 1.180
  I've noticed that every time I use "OpenWith" on a node, the temp file's extension
is ".txt". This means that my editor's "colorization" isn't coloring properly.
 I even tried a simple .Leo file like this:
Headline: @file test.c
Body: @language c

The default language is also set to c.

Tracking it down in LEOPY.LEO, I found the difficulty to be in FRAME.PY, node
&lt;&lt; set ext based on the present language &gt;&gt;. On entry, ext is always set to
"txt". Because of this, the test in the first line (if ext == None or len(ext)
== 0:) fails, and the extension is not changed.
By commenting out the first line, the extension is always reset, which fixes
the problem.

--Rich


______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/monitor.php?forum_id=10227
</t>
<t tx="T1502">@nocolor
https://sourceforge.net/forum/message.php?msg_id=1916142
By: riotnrrrd

In 3.11b3, when I do 'open with' with a node that has non-ascii characters in
it's body text, I get:

exception opening temp file
UnicodeError: ASCII encoding error: ordinal not in range(128)

in log window,

Traceback (most recent call last):
  File "./leoFrame.py", line 1585, in OnOpenWith
    file.write(v.bodyString())
UnicodeError: ASCII encoding error: ordinal not in range(128)

as traceback and nothing happens. When I retry, I get 

reopening: LeoTemp_139725700_koe.txt

in log window, no traceback and the editor opens with an empty file.

In the leoConfig.txt I have 

new_leo_file_encoding = iso-8859-15
default_derived_file_encoding = iso-8859-15

Changing them to UTF-8 has no effect.
</t>
<t tx="T1503">@nocolor
https://sourceforge.net/forum/message.php?msg_id=1952587
Developers

I still get encoding problems when reopening a file:
1. create a new leo file and add an accented character in a body panel
2. save the file
3. open the file
4. accented character is shown as expectd
5. add a second accented character and save
6. reopen the file: the second accented character is ok, but the first is shown
as ascii garbage (2 bytes).

Running 
from leoGlobals import app,es 
es(app().tkEncoding,color="red")

gives me cp1252.

Changing default_derived_file_encoding, new_leo_file_encoding and tk_encoding
does not change this misbehaviour.

I use new_leo_file_encoding = iso-8859-1
default_derived_file_encoding = iso-8859-1,
tk_encoding=

This is exactly the same behaviour as in beta3.</t>
<t tx="T1504"></t>
<t tx="T1505"></t>
<t tx="T1506">def __init__(self):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.globalWindows = []
	self.gui = None # The gui class.
	self.guiDispatcher = None # Class used to dispatch gui calls to proper object.
	self.hasOpenWithMenu = false # True: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.killed = false # true: we are about to destroy the root window.
	self.loadDir = None # The directory from which Leo was loaded.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.nodeIndices = None # Singleton node indices instance.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # True if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = None # The hidden main window. Set later.
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8"
	self.unicodeErrorGiven = false # true: suppres unicode tracebacks.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	&lt;&lt; Define global constants &gt;&gt;
	&lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="T1507">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
</t>
<t tx="T1508"># Called when the gApp global has been defined.

def finishCreate(self):
	
	app = self
	
	# New 4.0 stuff.
	if 0: # Not using leoID.txt is more convenient for the user.
		app.setLeoID()
		app.nodeIndices = leoNodes.nodeIndices()</t>
<t tx="T1509"></t>
<t tx="T1510">def update_section (self,config,section,dict):
	
	if config.has_section(section):
		config.remove_section(section)
	config.add_section(section)
	
	keys = dict.keys()
	keys.sort() # Not effective.
	for name in keys:
		val = dict [name]
		val = toEncodedString(val,"utf-8")
		config.set(section,name,val)
</t>
<t tx="T1511">@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
	"at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
	
self.create_nonexistent_directories = self.initBooleanConfigParam(
	"create_nonexistent_directories",self.create_nonexistent_directories)
	
encoding = self.initConfigParam(
	"default_derived_file_encoding",self.default_derived_file_encoding)

if isValidEncoding(encoding):
	self.default_derived_file_encoding = encoding
else:
	es("bad default_derived_file_encoding: " + encoding)
	
self.load_derived_files_immediately = self.initBooleanConfigParam(
	"load_derived_files_immediately",self.load_derived_files_immediately)
	
encoding = self.initConfigParam(
	"new_leo_file_encoding",
	self.new_leo_file_encoding)

if isValidEncoding(encoding):
	self.new_leo_file_encoding = encoding
else:
	es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
	"output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
	"output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
	"read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
	"relative_path_base_directory",self.relative_path_base_directory)
	
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
	"redirect_execute_script_output_to_log_pane",
	self.redirect_execute_script_output_to_log_pane)
	
self.remove_sentinels_extension = self.initConfigParam(
	"remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
	"save_clears_undo_buffer",self.save_clears_undo_buffer)
	
self.stylesheet = self.initConfigParam(
	"stylesheet",self.stylesheet)
	
self.thin_at_file_trees = self.initBooleanConfigParam(
	"thin_at_file_trees",self.thin_at_file_trees)
	
encoding = self.initConfigParam(
	"tk_encoding",self.tkEncoding)
	
if encoding and len(encoding) &gt; 0: # May be None.
	if isValidEncoding(encoding):
		self.tkEncoding = encoding
	else:
		es("bad tk_encoding: " + encoding)
	
self.use_plugins = self.initBooleanConfigParam(
	"use_plugins",self.use_plugins)
	
self.write_old_format_derived_files = self.initBooleanConfigParam(
	"write_old_format_derived_files",self.write_old_format_derived_files)
</t>
<t tx="T1512">find = self.findDict.get("find_string")
if find:
	# Leo always writes utf-8 encoding, but users may not.
	find = toUnicode(find,"utf-8")
	self.findDict["find_string"] = find

change = self.findDict.get("change_string")
if change:
	# Leo always writes utf-8 encoding, but users may not.
	change = toUnicode(change,"utf-8")
	self.findDict["change_string"] = change
</t>
<t tx="T1513"></t>
<t tx="T1514">def __init__(self,theCommander):
	
	# trace("topLevelDerivedFile.__init__")
	
	at = self
	at.commands = theCommander
	at.fileCommands = self.commands.fileCommands
	
	# Create subcommanders to handler old and new format derived files.
	at.old_df = oldDerivedFile(theCommander)
	at.new_df = newDerivedFile(theCommander)
	
	# Set by scanDefaultDirectory.
	at.default_directory = None
	at.errors = 0

	# Set by scanHeader when reading. Set by scanAllDirectives...
	at.encoding = None
	at.endSentinelComment = None
	at.startSentinelComment = None
</t>
<t tx="T1515"></t>
<t tx="T1516"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

	tag = "@first"
	foundAtFirstYet = 0
	outRange = range(len(out))
	j = 0
	for k in outRange:
		# skip leading whitespace lines
		if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @first directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtFirstYet = 1
		# quit if no leading lines to apply
		if j &gt;= len(firstLines): break
		# make the new @first directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
		leadingLine = " " + firstLines[j]
		out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="T1517"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

	tag = "@last"
	foundAtLastYet = 0
	outRange = range(-1,-len(out),-1)
	j = -1
	for k in outRange:
		# skip trailing whitespace lines
		if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @last directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtLastYet = 1
		# quit if no trailing lines to apply
		if j &lt; -len(lastLines): break
		# make the new @last directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
		trailingLine = " " + lastLines[j]
		out[k] = tag + trailingLine.rstrip() ; j -= 1
</t>
<t tx="T1518">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild(self,n,parent,headline):

	assert(n &gt; 0)

	# Create any needed dummy children.
	dummies = n - parent.numberOfChildren() - 1
	if dummies &gt; 0:
		if 0: # CVS produces to many errors for this to be useful.
			es("dummy created")
		self.structureErrors += 1
	while dummies &gt; 0:
		dummies -= 1
		dummy = parent.insertAsLastChild(leoNodes.tnode())
		# The user should never see this headline.
		dummy.initHeadString("Dummy")

	if n &lt;= parent.numberOfChildren():
		&lt;&lt; check the headlines &gt;&gt;
	else:
		# This is using a dummy; we should already have bumped structureErrors.
		result = parent.insertAsLastChild(leoNodes.tnode())
	result.initHeadString(headline)
	
	result.setVisited() # Suppress all other errors for this node.
	return result</t>
<t tx="T1519"># 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
	start = self.startSentinelComment
	end = self.endSentinelComment
	if end and len(end) &gt; 0:
		# 1/25/03: The kludgy fix.
		# Compare the headlines without the delims.
		h1 =   headline.replace(start,"").replace(end,"")
		h2 = resulthead.replace(start,"").replace(end,"")
		if h1.strip() == h2.strip():
			# 1/25/03: Another kludge: use the headline from the outline, not the derived file.
			headline = resulthead
		else:
			self.structureErrors += 1
	else:
		self.structureErrors += 1
</t>
<t tx="T1520">def handleLinesFollowingSentinel (self,lines,sentinel,comments = true):
	
	"""convert lines following a sentinel to a single line"""
	
	m = " following" + sentinel + " sentinel"
	start = self.startSentinelComment
	end   = self.endSentinelComment
	
	if len(lines) == 1: # The expected case.
		s = lines[0]
	elif len(lines) == 5:
		self.readError("potential cvs conflict" + m)
		s = lines[1]
		es("using " + s)
	else:
		self.readError("unexpected lines" + m)
		es(len(lines), " lines" + m)
		s = "bad " + sentinel
		if comments: s = start + ' ' + s

	if comments:
		&lt;&lt; remove the comment delims from s &gt;&gt;
		
	# Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
	if start[-1:] == '@':
		s = s.replace('@@','@')

	return s</t>
<t tx="T1521"># Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if match(s,0,comment):
	s = s[len(comment):]
else:
	self.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
	s = string.strip(s[:-1])
else:
	k = s.rfind(end)
	s = string.strip(s[:k]) # works even if k == -1</t>
<t tx="T1522">def readLine (self,file):
	"""Reads one line from file using the present encoding"""
	
	s = readlineForceUnixNewline(file)
	u = toUnicode(s,self.encoding)
	return u

</t>
<t tx="T1523"># We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,file):
	
	"""	read lines following multiline sentinels"""
	
	lines = []
	start = self.startSentinelComment + '@ '
	nextLine = self.readLine(file)
	while nextLine and len(nextLine) &gt; 0:
		if len(lines) == 0:
			lines.append(nextLine)
			nextLine = self.readLine(file)
		else:
			# 5/1/03: looser test then calling sentinelKind.
			s = nextLine ; i = skip_ws(s,0)
			if match(s,i,start):
				lines.append(nextLine)
				nextLine = self.readLine(file)
			else: break

	return nextLine,lines</t>
<t tx="T1524">@ This method sets self.startSentinelComment and self.endSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!

7/8/02: Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.

14-SEP-2002 DTHEIN:  Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.
@c
def scanHeader(self,file):

	valid = true
	tag = "@+leo" ; version_tag = "-ver="
	encoding_tag = "-encoding="
	&lt;&lt; skip any non @+leo lines &gt;&gt;
	&lt;&lt; make sure we have @+leo &gt;&gt;
	&lt;&lt; read optional version param &gt;&gt;
	&lt;&lt; read optional encoding param &gt;&gt;
	&lt;&lt; set the closing comment delim &gt;&gt;
	if not valid:
		self.readError("Bad @+leo sentinel in " + self.targetFileName)
	return firstLines</t>
<t tx="T1525">firstLines = [] # The lines before @+leo.
s = self.readLine(file)
while len(s) &gt; 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = self.readLine(file)
n = len(s)
valid = n &gt; 0
# s contains the tag
i = j = skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i &lt; n and not match(s,i,tag) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
else: valid = false</t>
<t tx="T1526">if 0:# 7/8/02: make leading whitespace significant.
	i = skip_ws(s,i)

if match(s,i,tag):
	i += len(tag)
else: valid = false</t>
<t tx="T1527">using_gnx = match(s,i,version_tag)

if using_gnx:
	trace("reading gnx file",self.targetFileName)
	i += len(version_tag)
	# Skip to the next minus sign or end-of-line
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] != '-':
		i += 1
	if j &lt; i:
		version = s[j:i]
	else:
		valid = false

	
</t>
<t tx="T1528"># 1/20/03: EKR: Read optional encoding param, e.g., -encoding=utf-8,

# Set the default encoding
self.encoding = app().config.default_derived_file_encoding

if match(s,i,encoding_tag):
	i += len(encoding_tag)
	# Skip to the next comma
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] not in (',','.'):
		i += 1
	if match(s,i,',') or match(s,i,'.'):
		encoding = s[j:i]
		i += 1
		# print "@+leo-encoding=",encoding
		if isValidEncoding(encoding):
			self.encoding = encoding
		else:
			es("bad encoding in derived file:",encoding)
	else:
		valid = false
</t>
<t tx="T1529"># The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
self.endSentinelComment = s[j:i]</t>
<t tx="T1530">@ This method is the read code.

scanText reads lines from the file until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.

@c
def scanText (self,file,v,out,endSentinelKind,nextLine=None):

	a = app() ; c = self.commands ; config = a.config
	lastLines = [] # The lines after @-leo
	lineIndent = 0 ; linep = 0 # Changed only for sentinels.
	while 1:
		&lt;&lt; put the next line into s &gt;&gt;
		&lt;&lt; set kind, nextKind &gt;&gt;
		if kind != atFile.noSentinel:
			&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
			i = self.skipSentinelStart(s,0)
		&lt;&lt; handle the line in s &gt;&gt;
	&lt;&lt; handle unexpected end of text &gt;&gt;
	assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
	return lastLines # We get here only if there are problems.</t>
<t tx="T1531">if nextLine:
	s = nextLine ; nextLine = None
else:
	s = self.readLine(file)
	if len(s) == 0: break

# trace(`s`)</t>
<t tx="T1532">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
else:
	nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText returns.</t>
<t tx="T1533">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if self.raw: # 10/15/02
	linep =0
else:
	linep = self.skipIndent(s,0,self.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': lineIndent += (abs(self.tab_width) - (lineIndent % abs(self.tab_width)))
	elif s[i] == ' ': lineIndent += 1
	else: break
	i += 1
# trace("lineIndent:" +`lineIndent` + ", " + `s`)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="T1534"># Issue the error.
name = self.sentinelName(endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T1535">if kind == atFile.noSentinel:
	&lt;&lt; append non-sentinel line &gt;&gt;
&lt;&lt; handle common sentinels &gt;&gt;
&lt;&lt; handle rare sentinels &gt;&gt;
else:
	&lt;&lt; warn about unknown sentinel &gt;&gt;</t>
<t tx="T1536"># We don't output the trailing newline if the next line is a sentinel.
if self.raw: # 10/15/02
	i = 0
else:
	i = self.skipIndent(s,0,self.indent)

assert(nextLine != None)

if nextKind == atFile.noSentinel:
	line = s[i:]
	out.append(line)
else:
	line = s[i:-1] # don't output the newline
	out.append(line)
</t>
<t tx="T1537">elif kind in (
	atFile.endAt,  atFile.endBody, atFile.endDoc,
	atFile.endLeo, atFile.endNode, atFile.endOthers):
		&lt;&lt; handle an ending sentinel &gt;&gt;
elif kind == atFile.startBody:
	&lt;&lt; scan @+body &gt;&gt;
elif kind == atFile.startNode:
	&lt;&lt; scan @+node &gt;&gt;
elif kind == atFile.startRef:
	&lt;&lt; scan old ref &gt;&gt;
elif kind == atFile.startAt:
	&lt;&lt; scan @+at &gt;&gt;
elif kind == atFile.startDoc:
	&lt;&lt; scan @+doc &gt;&gt;
elif kind == atFile.startOthers:
	&lt;&lt; scan @+others &gt;&gt;</t>
<t tx="T1538"># trace("end sentinel:", self.sentinelName(kind))

if kind == endSentinelKind:
	if kind == atFile.endLeo:
		# Ignore everything after @-leo.
		# Such lines were presumably written by @last.
		while 1:
			s = self.readLine(file)
			if len(s) == 0: break
			lastLines.append(s) # Capture all trailing lines, even if empty.
	elif kind == atFile.endBody:
		self.raw = false
	# nextLine != None only if we have a non-sentinel line.
	# Therefore, nextLine == None whenever scanText returns.
	assert(nextLine==None)
	return lastLines # End the call to scanText.
else:
	# Tell of the structure error.
	name = self.sentinelName(kind)
	expect = self.sentinelName(endSentinelKind)
	self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="T1539">assert(match(s,i,"+at"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T1540">assert(match(s,i,"+body"))

child_out = [] ; child = v # Do not change out or v!
oldIndent = self.indent ; self.indent = lineIndent
self.scanText(file,child,child_out,atFile.endBody)

if 0:
	if child.isOrphan():
		self.readError("Replacing body text of orphan: " + child.headString())

# Set the body, removing cursed newlines.
# Note:  This code must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
child.t.setTnodeText(body)
self.indent = oldIndent</t>
<t tx="T1541">assert(match(s,i,"+doc"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T1542">assert(match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

self.scanText(file,v,out,atFile.endOthers)</t>
<t tx="T1543">elif kind == atFile.startComment:
	&lt;&lt; scan @comment &gt;&gt;
elif kind == atFile.startDelims:
	&lt;&lt; scan @delims &gt;&gt;
elif kind == atFile.startDirective:
	&lt;&lt; scan @@ &gt;&gt;
elif kind == atFile.startLeo:
	&lt;&lt; scan @+leo &gt;&gt;
elif kind == atFile.startVerbatim:
	&lt;&lt; scan @verbatim &gt;&gt;</t>
<t tx="T1544">assert(match(s,i,"+leo"))
self.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T1545">assert(match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
</t>
<t tx="T1546">assert(match(s,i,"verbatim"))

# Skip the sentinel.
s = self.readLine(file) 

# Append the next line to the text.
i = self.skipIndent(s,0,self.indent)
out.append(s[i:])
</t>
<t tx="T1547">j = i
i = skip_line(s,i)
line = s[j:i]
self.readError("Unknown sentinel: " + line)</t>
<t tx="T1548">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c
def putOpenLeoSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.os(self.startSentinelComment)
	self.os(s)
	encoding = self.encoding.lower()
	if encoding != "utf-8":
		self.os("-encoding=")
		self.os(encoding)
		self.os(".")
	self.os(self.endSentinelComment)
	if self.suppress_newlines: # 9/27/02
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.
</t>
<t tx="T1549"></t>
<t tx="T1550">def set_ivars (self,c):
	
	# N.B.: separate c.ivars are much more convenient than a dict.
	for key in self.intKeys:
		val = self.dict[key].get()
		setattr(c, key + "_flag", val)
		# trace(key,val)

	# Set ivars from radio buttons. 10/2/01: convert these to 1 or 0.
	c.pattern_match_flag   = choose(self.dict["radio-find-type"].get()    == "pattern-search",1,0)
	c.suboutline_only_flag = choose(self.dict["radio-search-scope"].get() == "suboutline-only",1,0)

	s = self.find_text.get("1.0","end - 1c") # Remove trailing newline
	s = toUnicode(s,app.tkEncoding) # 2/25/03
	c.find_text = s

	s = self.change_text.get("1.0","end - 1c") # Remove trailing newline
	s = toUnicode(s,app.tkEncoding) # 2/25/03
	c.change_text = s</t>
<t tx="T1551"></t>
<t tx="T1552">def exportHeadlines (self,fileName):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		mode = app.config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel,useVerticalBar=true)
			head = toEncodedString(head,self.encoding,reportErrors=true)
			file.write(head + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while exporting headlines")
		es_exception()</t>
<t tx="T1553">def setEncoding (self):
	
	# scanDirectives checks the encoding: may return None.
	dict = scanDirectives(self.commands)
	encoding = dict.get("encoding")
	if encoding and isValidEncoding(encoding):
		self.encoding = encoding
	else:
		self.encoding = app.tkEncoding # 2/25/03

	# print self.encoding
</t>
<t tx="T1554">def weave (self,filename):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	&lt;&lt; open filename to f, or return &gt;&gt;
	after = v.nodeAfterTree()
	while v and v != after:
		s = v.bodyString()
		s2 = string.strip(s)
		if s2 and len(s2) &gt; 0:
			f.write("-" * 60) ; f.write(nl)
			&lt;&lt; write the context of v to f &gt;&gt;
			f.write("-" * 60) ; f.write(nl)
			s = toEncodedString(s,self.encoding,reportErrors=true) # 2/25/03
			f.write(string.rstrip(s) + nl)
		v = v.threadNext()
	f.flush()
	f.close()</t>
<t tx="T1555"># write the headlines of v, v's parent and v's grandparent.
context = [] ; v2 = v
for i in xrange(3):
	if not v2: break
	context.append(v2.headString())
	v2 = v2.parent()

context.reverse()
indent = ""
for line in context:
	f.write(indent)
	indent += '\t'
	line = toEncodedString(line,self.encoding,reportErrors=true)
	f.write(line)
	f.write(nl)
</t>
<t tx="T1556"></t>
<t tx="T1557"></t>
<t tx="T1558"># Parses the encoding string, and sets self.leo_file_encoding.

def getXmlVersionTag (self):

	self.getTag(app.prolog_prefix_string)
	encoding = self.getDqString()
	self.getTag(app.prolog_postfix_string)

	if isValidEncoding(encoding):
		self.leo_file_encoding = encoding
		es("File encoding: " + encoding, color="blue")
	else:
		es("invalid encoding in .leo file: " + encoding, color="red")
</t>
<t tx="T1559"></t>
<t tx="T1560"># All output eventually comes here.
def put (self,s):
	if s and len(s) &gt; 0:
		if self.outputFile:
			s = toEncodedString(s,self.leo_file_encoding,reportErrors=true)
			self.outputFile.write(s)
		elif self.outputString != None: # Write to a string
			self.outputString += s

def put_dquote (self):
	self.put('"')
		
def put_dquoted_bool (self,b):
	if b: self.put('"1"')
	else: self.put('"0"')
		
def put_flag (self,a,b):
	if a:
		self.put(" ") ; self.put(b) ; self.put('="1"')
		
def put_in_dquotes (self,a):
	self.put('"')
	if a: self.put(a) # will always be true if we use backquotes.
	else: self.put('0')
	self.put('"')

def put_nl (self):
	self.put("\n")
	
def put_tab (self):
	self.put("\t")
	
def put_tabs (self,n):
	while n &gt; 0:
		self.put("\t")
		n -= 1</t>
<t tx="T1561"></t>
<t tx="T1562">@nocolor
https://sourceforge.net/forum/message.php?msg_id=1923127
By: dalcolmo
Open Discussion

What is the encoding to be used for messages sent to the log pane?

If I send a unicode string to the log pane with es(&lt;string&gt;) it appears als
u'&lt;string&gt;' in the log pane. Should es() accept unicode, or do I have to convert
the string?

@color

if 0: #test
	from leoGlobals import es ; es(u"this is a test")</t>
<t tx="T1563"># All output to the log stream eventually comes here.

def put (self,s,color=None):
	# print `app.quitting`,`self.log`
	if app.quitting: return
	if self.log:
		if type(s) == type(u""): # 3/18/03
			s = toEncodedString(s,app.tkEncoding)
		if color:
			if color not in self.logColorTags:
				self.logColorTags.append(color)
				self.log.tag_config(color,foreground=color)
			self.log.insert("end",s)
			self.log.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
			if "black" not in self.logColorTags:
				self.logColorTags.append("black")
				self.log.tag_config("black",foreground="black")
			self.log.tag_add("black","end")
		else:
			self.log.insert("end",s)
		self.log.see("end")
		self.log.update_idletasks()
	else:
		app.logWaiting.append((s,color),) # 2/25/03
		print "Null log"
		if type(s) == type(u""): # 3/18/03
			s = toEncodedString(s,"ascii")
		print s

def putnl (self):
	if app.quitting: return
	if self.log:
		self.log.insert("end",'\n')
		self.log.see("end")
		self.log.update_idletasks()
	else:
		app.logWaiting.append(('\n',"black"),) # 6/28/03
		print "Null log"
		print</t>
<t tx="T1564">def ecnl():
	ecnls(1)

def ecnls(n):
	log = app.log
	if log:
		while log.es_newlines &lt; n:
			enl()

def enl():
	log = app.log
	if log:
		log.es_newlines += 1
		log.putnl()

def es(s,*args,**keys):
	newline = keys.get("newline",true)
	color = keys.get("color",None)
	if type(s) != type("") and type(s) != type(u""): # 1/20/03
		s = repr(s)
	for arg in args:
		if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
			arg = repr(arg)
		s = s + ", " + arg
	log = app.log
	if log:
		# print s
		log.put(s,color=color)
		# 6/2/02: This logic will fail if log is None.
		for ch in s:
			if ch == '\n': log.es_newlines += 1
			else: log.es_newlines = 0
		if newline:
			ecnl() # only valid here
	elif newline:
		app.logWaiting.append((s+'\n',color),) # 2/16/03
		print s
	else:
		app.logWaiting.append((s,color),) # 2/16/03
		print s,</t>
<t tx="T1565"></t>
<t tx="T1566"></t>
<t tx="T1567"></t>
<t tx="T1568">def appendStringToBody (self,s,encoding="utf-8"):

	if not s: return
	
	# Make sure the following concatenation doesn't fail.
	assert(isUnicode(self.t.bodyString)) # 9/28/03
	s = toUnicode(s,encoding) # 9/28/03

	body = self.t.bodyString + s
	self.setBodyStringOrPane(body,encoding)
</t>
<t tx="T1569">def setBodyStringOrPane (self,s,encoding="utf-8"):

	v = self ; c = v.commands
	if not c or not v: return
	
	s = toUnicode(s,encoding)
	if v == c.currentVnode():
		# This code destoys all tags, so we must recolor.
		c.frame.body.delete("1.0","end")
		c.frame.body.insert("1.0",s) # Replace the body text with s.
		c.recolor()
		
	# Keep the body text in the tnode up-to-date.
	if v.t.bodyString != s:
		v.t.setTnodeText(s)
		v.t.setSelection(0,0)
		v.setDirty()
		if not c.isChanged():
			c.setChanged(true)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="T1570">def setHeadString (self,s,encoding="utf-8"):

	self.initHeadString(s,encoding) # 6/28/03
	self.setDirty()

def initHeadString (self,s,encoding="utf-8"):

	s = toUnicode(s,encoding,reportErrors=true)
	self.t.headString = s
</t>
<t tx="T1571"># Compatibility routine for scripts

def setHeadStringOrHeadline (self,s,encoding="utf-8"):

	c = self.commands
	c.endEditing()
	self.setHeadString(s,encoding)
</t>
<t tx="T1572">The fileCommands logic calls t.setTnodeText(s)</t>
<t tx="T1573"></t>
<t tx="T1574"># This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
	
	s = toUnicode(s,encoding,reportErrors=true)
	self.bodyString = s
</t>
<t tx="T1575">def setSelection (self,start,length):

	self.selectionStart = start
	self.selectionLength = length</t>
<t tx="T1576"></t>
<t tx="T1577">def oblank (self):
	self.oblanks(1)

def oblanks (self,n):
	if abs(n) &gt; 0:
		self.output_file.write(' ' * abs(n))
		
def onl(self):
	# 3/18/03: Don't mess with body_ignored_newline.
	# self.os(self.output_newline)
	s = self.output_newline
	s = toEncodedString(s,self.encoding,reportErrors=true)
	self.output_file.write(s)

def os (self,s):
	s = string.replace(s,body_ignored_newline,body_newline)
	s = toEncodedString(s,self.encoding,reportErrors=true)
	self.output_file.write(s)

def otab (self):
	self.otabs(1)

def otabs (self,n):
	if abs(n) &gt; 0:
		self.output_file.write('\t' * abs(n))</t>
<t tx="T1578"></t>
<t tx="T1579">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,v,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
	
	# trace(undo_type)

	u = self ; c = u.commands
	if u.redoing or u.undoing: return None
	if undo_type == None:
		return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	if oldText == newText:
		# trace("no change")
		return None
	# Clear all optional params.
	for ivar in optionalIvars:
		setattr(u,ivar,None)
	# Set the params.
	u.undoType = undo_type
	u.v = v
	&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
	&lt;&lt; save undo text info &gt;&gt;
	u.oldSel = oldSel ; u.newSel = newSel
	# 11/13/02: Remember the scrolling position.
	if oldYview:
		u.yview = oldYview
	else:
		u.yview = c.frame.body.yview()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)`)
	u.setUndoTypes() # Recalculate the menu labels.
	return d
</t>
<t tx="T1580">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading = i

if leading == new_len:
	# This happens when we remove lines from the end.
	# The new text is simply the leading lines from the old text.
	trailing = 0
else:
	i = 0
	while i &lt; min_len - leading:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing = i
	
# NB: the number of old and new middle lines may be different.
if trailing == 0:
	old_middle_lines = old_lines[leading:]
	new_middle_lines = new_lines[leading:]
else:
	old_middle_lines = old_lines[leading:-trailing]
	new_middle_lines = new_lines[leading:-trailing]
	
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
	old_newlines += 1
	i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
	new_newlines += 1
	i -= 1

if u.debug_print:
	trace()
	print "lead,trail",leading,trailing
	print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
	print "new mid,nls:",len(new_middle_lines),new_newlines,newText
	#print "lead,trail:",leading,trailing
	#print "old mid:",old_middle_lines
	#print "new mid:",new_middle_lines
	print "---------------------"</t>
<t tx="T1581">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
	if u.debug:
		# Remember the complete text for comparisons...
		u.oldText = oldText
		u.newText = newText
		# Compute statistics comparing old and new ways...
		# The old doesn't often store the old text, so don't count it here.
		u.old_mem += len(newText)
		s1 = string.join(old_middle_lines,'\n')
		s2 = string.join(new_middle_lines,'\n')
		u.new_mem += len(s1) + len(s2)
	else:
		u.oldText = None
		u.newText = None
else:
	u.oldText = oldText
	u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines</t>
<t tx="T1582"></t>
<t tx="T1583">def isUnicode(s):
	
	return s is None or type(s) == type(u' ')</t>
<t tx="T1584">def isValidEncoding (encoding):
	
	try:
		if len(encoding) == 0:
			return false
		unicode("a",encoding)
		return true
	except:
		return false
</t>
<t tx="T1585">def reportBadChars (s,encoding):

	errors = 0
	if type(s) == type(u""):
		for ch in s:
			try: ch.encode(encoding,"strict")
			except: errors += 1
		if errors:
			# import traceback ; traceback.print_stack()
			es("%d errors converting %s to %s" % 
				(errors, s.encode(encoding,"replace"),encoding))

	elif type(s) == type(""):
		for ch in s:
			try: unicode(ch,encoding,"strict")
			except: errors += 1
		if errors:
			es("%d errors converting %s (%s encoding) to unicode" % 
				(errors, unicode(s,encoding,"replace"),encoding)) # 10/23/03</t>
<t tx="T1586">def toUnicode (s,encoding,reportErrors=false):
	
	if s is None:
		s = u""
	if type(s) == type(""):
		try:
			s = unicode(s,encoding,"strict")
		except:
			if reportErrors:
				reportBadChars(s,encoding)
			s = unicode(s,encoding,"replace")
	return s
	
def toEncodedString (s,encoding,reportErrors=false):

	if type(s) == type(u""):
		try:
			s = s.encode(encoding,"strict")
		except:
			if reportErrors:
				reportBadChars(s,encoding)
			s = s.encode(encoding,"replace")
	return s</t>
<t tx="T1587">try:
	# Use Python's version of getpreferredencoding if it exists.
	# It is new in Python 2.3.
	import locale
	getpreferredencoding = locale.getpreferredencoding
except:
	# Use code copied from locale.py in Python 2.3alpha2.
	if sys.platform in ('win32', 'darwin', 'mac'):
		&lt;&lt; define getpreferredencoding using _locale &gt;&gt;
	else:
		&lt;&lt; define getpreferredencoding for *nix &gt;&gt;
</t>
<t tx="T1588"># On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = true):
	"""Return the charset that the user is likely using."""
	try:
		import _locale
		return _locale._getdefaultlocale()[1]
	except:
		return None</t>
<t tx="T1589"># On Unix, if CODESET is available, use that.
try:
	local.CODESET
except NameError:
	# Fall back to parsing environment variables :-(
	def getpreferredencoding(do_setlocale = true):
		"""Return the charset that the user is likely using,
		by looking at environment variables."""
		try:
			return locale.getdefaultlocale()[1]
		except:
			return None
else:
	def getpreferredencoding(do_setlocale = true):
		"""Return the charset that the user is likely using,
		according to the system configuration."""
		try:
			if do_setlocale:
				oldloc = locale.setlocale(LC_CTYPE)
				locale.setlocale(LC_CTYPE, "")
				result = locale.nl_langinfo(CODESET)
				locale.setlocale(LC_CTYPE, oldloc)
				return result
			else:
				return locale.nl_langinfo(CODESET)
		except:
			return None</t>
<t tx="T1590">@nocolor</t>
<t tx="T1591">The previous message focused on the details.  In this posting I'd like to focus on the big picture. This should make clear that the new code is actually quite easy to understand.

The key principles are:

1. Leo converts to unicode strings a) when reading files b) when passing strings to or from Tk.Text widgets or c) when passing file names to the system.   The typical code is simply:

s = toUnicode(s,encoding)

2. Leo converts to plain strings when writing data to files.  Like this:

s = toString(s,encoding)

What encoding is actually used depends on context.  utf-8 is the default, and may be overridden by the @encoding directive or by the settings remembered when reading .leo or derived files. Another post will discuss which encodings Leo uses in various contexts.

If we follow these principles Python will never automatically try to promote a plain Python string to a unicode string.  This is important because automatic promotions on strings containing non-ascii characters might throw an exception.

That's just about all there is to it.  The new code is just much simpler than the old.

Edward

P.S. The code above silently replaces characters invalid in an encoding by '?' characters.  This should not be a problem now that derived files can specify the encoding used to write them.  And besides, the old error messages did no good anyway.

EKR</t>
<t tx="T1592">This posting discusses the encodings Leo will use when converting to and from unicode strings. The present CVS codes does _not_ work this way.  It will be a day or so before all these changes are in place.

The present code is in transition.  I'm not going to discuss what Leo did, or presently does.  Both are wrong.  Here is what is about to happen:

I. Encodings of .leo files

1. You will soon be able to specify the encoding to be used in all _new_ .leo files with the leo_new_file_encoding setting in leoConfig.leo.  Leo will use UTF-8 by default (in upper case for compatibility with older versions of Leo).

This is clumsy: the natural place to specify the encoding would be in the dialog put up by Leo's "New" command.  Alas, there is no good way to way to customize Tk dialogs.  So there isn't a good way to provide as much flexibility as we all would like.  In an emergency you could open the .leo file in a plain text editor and change UTF-8 to your desired encoding.  Example:

&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;

Leo will silently change all characters not valid in the encoding into '?', so for goodness sakes if you change the encoding by hand please do it just after creating the file.

2. Leo will remember the encoding specified in the &lt;?xml...?&gt; line and use that encoding when reading and writing the .leo file.  In other words, once Leo creates a .leo file the only way to change the encoding in that file is the change the &lt;?xml...?&gt; line by hand.

While not perfect, this scheme will provide enough flexibility for most situations.

II. Encodings of derived files.

Here matters are much simpler.  Leo now reads derived files using the encoding given -encoding= part of the @+leo sentinel at the start of each derived file.  Leo uses utf-8 by default.  When writing a derived file Leo uses the encoding given by the @encoding directive, again using utf-8 by default.

III. Encodings used when importing and exporting files.

As in the case of .leo files, it would be best to specify encodings in the import/export dialogs, but that can not be done.  Unlike with .leo files, we can use the @encoding directive as a kludge to specify encodings.

When importing files Leo will assume that the files use the encoding specified by the applicable @encoding directive, or utf-8 if no @encoding directive is in effect.  When exporting files, Leo will write non-ascii characters using the encoding specified by the @encoding directive, or utf-8 if no such directive is in effect.

It would be possible to specify default_import_encoding and default_export_encoding settings in leoConfig.leo, but I won't do that unless there is a clamor for those settings.  It should be easy enough to use the @encoding directive...

Edward</t>
<t tx="T1593">Just to set things straight, here is a quick (informal) Unicode summary

First there was ASCII. This is 0-127 (some control up to 31, space 32, and the rest A-Za-z0-9 and other printable special characters, e.g. !@#$%).

Then came the codepages. This is 0-255, where 0-127 is ASCII and 128-255 is some special codepage specific characters, e.g. foreign letters (like in Hebrew) and punctuated letters (like apostrophe). These are the iso-8859-x family of encoding schemes.

Then came Unicode. This is 0-65535, with most characters in the world, always double byte, i.e. every character takes 2 bytes.

Then came Unicode encodings like UTF-8, which specifically is backward compatible with ASCII. UTF-8 is a variable length encoding scheme. For ASCII it is single byte, so all ASCII only files can be treated as UTF-8 Unicode. Most of the other Unicode characters are double bytes, and some are triple bytes and even 4 bytes long.

While UTF-8 encoding can represent ANY Unicode character, codepage encoding can only represent a subset of Unicode which is included in the codepage. Therefore conversion errors may occur because a character may not have a representation. Errors (exceptions) can be avoided if unmapped characters are mapped to a replacement character (typically '?').

For an excellent background read

	http://www.python.org/workshops/1997-10/proceedings/loewis.html

For thorough description of the implementation read

	http://www.egenix.com/files/python/unicode-proposal.txt
</t>
<t tx="T1594"></t>
<t tx="T1595">http://effbot.org/zone/unicode-objects.htm
http://www.jorendorff.com/articles/unicode/python.html
http://www.reportlab.com/i18n/python_unicode_tutorial.html
http://www.python.org/doc/current/ref/strings.html
</t>
<t tx="T1596">@nocolor

Fact: u"a" + "a" results in u"aa", so Python promotes strings to unicode as needed. 

Question:  could this promotion ever throw an exception?  Is so, how and when?

Answer:  I believe we must assume the "default encoding" is "ascii", so if the plain string character isn't ascii this _will_ throw an exception.  The solution is simple: all literals must be ascii literals, unless they are converted to unicode to unicode using escape sequences.  For example:

&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getdefaultencoding()
'ascii'
&gt;&gt;&gt; print ""
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = ""
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = u""
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = unicode("")
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = unicode("","utf-8")
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = decode("","utf-8")
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; e = u"\u00cb"
&gt;&gt;&gt; e
u'\xcb'
&gt;&gt;&gt; print e


- Is there any reason not to use utf-8 for LeoPy.leo?
- Should all strings in Leo be unicode strings?</t>
<t tx="T1597">&gt; # Tk always uses utf-8 encoding.

You may get that impression, but it is slightly wrong. It is more
reliable if you pass Unicode strings to Tk, instead of UTF-8 encoded
byte strings.

For a byte string, Tk will guess the encoding. If it looks like UTF-8,
it is taken treated UTF-8. Otherwise, it is treated as the locale's
encoding. Unfortunately, if you ever manage to mix the two, you get
byte salad that you can't ever chew. By using Unicode strings to
interface with Tk only, you can avoid those problems.

&gt; print `s`,"tk"
&gt; s = s.encode("utf-8") # result is a string.
&gt; print `s`,"utf-8"
&gt; s = s.decode(xml_encoding) # result is unicode.
&gt; s = s.encode(xml_encoding) # result is a string.

Since xml_encoding is iso-8859-1, you are making a mistake here. You
have UTF-8 data, but you are decoding them as Latin-1. This will
succeed, but it will give an incorrect result. It will succeed since
iso-8859-1 is an single-byte code where every byte value is valid.
That means an arbitrary byte sequence can be interpreted as Latin-1,
but for many byte sequences, the resulting string is non-sense
(mojibake, as the Japanese say).

&gt; BTW, with out the first encode/decode pair I can take exceptions in
&gt; the last encode.

Nevertheless, this is the correct processing. If you have a Unicode
object, as originally obtained from Tk, you should encode as Latin-1
using

s = s.encode("iso-8859-1")

Now, for this specific string (u'a\u0102\xdf\xc9\n'), you will get a
Unicode error. The reason is that one character (\u0102) is not
supported in Latin-1 - this encoding supports only the first 256
Unicode characters.

So, when saving this as XML, the proper representation would be

'a&amp;#x102;\xdf\xc9\n'

i.e. you'll have to use a character reference. Python 2.2 does not
support generating such text very well - you'll have to catch the
Unicode error yourself, find the offending character, encode it as a
character reference, and encode all other characters as requested.

Alternatively, you can refuse encoding a document in a certain
encoding (such as Latin-1), and fall back to UTF-8.

PEP 293 (http://www.python.org/peps/pep-0293.html) will provide a
mechanism to generate character references more conveniently - in
Python 2.3, you can specify

  s.encode('iso-8859-1',errors='xmlcharrefreplace')

HTH,
Martin</t>
<t tx="T1598">By: dthein ( Dave Hein ) 
 ALTERNATE SUGGESTION FOR UNICODE  
2002-12-22 21:16  
Actually, I think differently. 

UTF-8 is suitable as a file format ... but it is not suitable for internal use. This is because UTF-8 uses a variable length character encoding format, so it is not possible to use array indexing of strings that are in UTF-8 format -- this invalidates most text processing routines within Leo. 

What we want to do, instead, I think, is: 

1. use UTF-8 for the Leo files. Why? Unicode is the canonical character encoding, so it make sense that the Leo files be in that canonical encoding. And UTF-8 is the most efficient storage mechanism for XML files. 

2. Convert the Leo file from UTF-8 to a Python Unicode string as it is read in, and from Python Unicode strings to UTF-8 as it is written out. The Python Unicode strings have the same methods and behavior as Python ASCII strings. You can do indexing, tokenizing, search/replace, triming, et cetera. A Python unicode string behaves exactly like a standard python string. It is important to use this encoding internally, rather than UTF-8. 

3. We need to add a directive to indicate the encoding of the derived files (@file files and @root files). Why? Many tools (compilers, scripts engines, text editors) will not handle UTF-8 or other Unicode encodings. They will expect ASCII or CP1252 or ISO-8859-1 or some other 128-character or 256-character encoding. We must understand what the derived file encoding is, so that we can convert to and from Unicode when writing and reading the derived files. 

I suggest adding the directive @encoding (with parameter "ascii", or "utf-8", or "iso-8859-15", or whatever) as a valid directive in @file or @root nodes. 

4. Then there is the Tk widgets. As far as I can tell, if you send them a Python Unicode string, they will handle it as Unicode characters -- and if you have a valid Unicode font, they will be properly displayed. If you send the widgets a standard Python string, then they'll assume a 256-character encoding -- and, again, if you have specified a valid 256-character font, they will be properly displayed. 

The Tk widgets won't properly handle a standard string containing UTF-8 because they'll assume a 256-character encoding, not a Unicode encoding. 

So, it seems that Leo needs to know the encoding of the fonts specified for outline, body, and log. If the font encoding is Unicode, then they can pass the internal Unicode strings directly to the widgets. But if the font encoding is something else, then Leo should convert to from the internal Unicode to the encoding associated with the font. How it handles characters that cannot be converted is debatable, but I guess I'd prefer using a substitution character, like a "?". And maybe warning the user that the specified fonts cannot display all the characters. 

5. There is also the clipboard to worry about -- the encoding of the text in the clipboard must be determined or well-guessed, and converted to the internal Unicode format. 

6. Oh yeah, and if one has to write out sentinels in a derived file, and the derived file encoding doesn't include some of the characters in the heading (sentinel), then we should use some sort of Unicode escape to specify the 'unprintable' characters. 

Note: I am trying my hand at implementing these ideas. It is tedious, but not difficult. Probably a couple programmer days of effort. 
 
</t>
<t tx="T1599">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1805325
By: gilshwartz

I think you have good points, and I can see pros and cons for Unicode vs. UTF-8.
Keep in mind that Leo so far, has used UTF-8 as default and with quite a success,
so I guess using UTF-8 internally is not so bad. Also it saves conversions when
we interact with TK.

However, Unicode is a good choice too, and definitely the points you raise have
a good weight. There is the added advantage that it interacts better with the
OS for non ASCII filenames.

With respect to TK (actually Tkinter), it accepts Unicode strings when getting
double byte text (Unicode), and UTF-8 when getting a single byte text (YES,
it gets UTF-8 - I have check in the docs and tested myself). When reading a
text widget one also gets UTF-8, that can easily be decoded to Unicode.

There is a lot of sense using UTF-8 for the Leo file, as all XML parsers should
be aware of the encoding. I am not sure we need a new @encoding directive, as
the encoding preference can be used to the determine the preferred encoding
for the derived files. However, I do not see any harm in using @encoding, which
will override the encoding preference.

I have looked at the code myself, but would prefer more input before committing
to such a major change in Leo.

In Thin-Thin we may have a problem if the derived files are not encoded well,
because there will not be a backup in the Leo file. In this case error handling
should possibly force the Leo file to stay "unsaved" so that a thick Leo can
be saved.

There a probably more things to think about, but a uniform internal encoding
seems very attractive.

Gil
</t>
<t tx="T1600">Following is a list of issues and options that need to be considered for an
overall Unicode solution for Leo. I tried to present all the options I could
think of, with my recommendation, and encourage comments/additions/corrections.
Some of the arguments were initially raised by Gilles Lenfant and by Dave Hein.

...

There you are, the end at last. I hope it is useful. 

Gil</t>
<t tx="T1601">1. Leo internal representation. 

This issue deals with how Leo should represent data internally. 

1.1. Unicode 

All strings are internally stored and managed as Unicode strings. The benefits are: 

a. Leo does not need to know or care about specific file/system encoding. I.e.
the code is checked and made reliable in a single encoding environment.
b. Compatibility with str functions, and easy data manipulation.
c. All major character sets are represented.
d. Data can be directly sent to Tk without conversion.

I think is option is the best mainly because of b, as a differentiator with respect to 1.2 below. 

1.2. UTF-8 

This is similar to the default mode in which Leo worked so far. The benefits are: 

a, c, d of Unicode above plus, 

e. We know existing code handles UTF-8 pretty well, which should minimized changes to the code. 
f. This is a good candidate for being the preferred .leo storage format (like the default today). 
g. Data is directly retrieved from Tk. 

While this option seems to have more advantages than 1.1, converting between
UTF-8 and Unicode is very simple, so f, g are less important. e is a selling
point.

1.3. Variable/Changing 

This is what Leo tried to do, i.e. adapt to some preferred encoding scheme. I
think that while friendly, it mainly made things complex and incompatible.
</t>
<t tx="T1602">2. Encoding conversion points. 

This issue discusses identified interaction points in which possible encoding conversion occurs. 

2.1. .leo's file encoding. 

The .leo file needs to have some encoding. One may debate whether this should
be a specific encoding like UTF-8, or depend on user preferences. Assuming
either 1.1 or 1.2 is selected above, there is no real benefit not to keep the
simplicity principle and decide on some encoding for the .leo, which is
compatible with the internal representation.

Deciding on UTF-8 has the following benefits: 

a. Compatible with existing default .leo files. 
b. Easy to use with either 1.1 or 1.2. 
c. Well known and used encoding scheme. 
d. Byte order indifferent, so it can easily move and be used on different platforms. 

This is my preferred choice. 

2.2. Text read from Tk. 

Tk's Text widget returns UTF-8. If 1.1 is selected, standard simple conversion
should take place, without having the problem of unmapped chars.

In 1.1 we should keep this in mind when we retrieve Tk content to compare with internal representation. 

2.3. Text sent to Tk. 

Tk accepts either Unicode strings or UTF-8 strings. This is compatible with both 1.1 and 1.2. 

My preference is to keep 1.1 and send the Unicode strings directly to Tk. 

2.4. File names within OS/filesystem, URLs interactions. 

At least for Windows OS compatibility, experience shows that file names should
be represented as Unicode strings. I believe we have not heard of any Unix
problems since this was added to Leo.

I think file names should be kept Unicode. We should further experiment with URLs. 

2.5. File content within read, import, untangle (implicit or explicit). 

The content of a file may have any encoding (character set representation).
Deciding what this encoding is has some options. Encoding may be specified as
part of the content, as in XML or HTML. Another option is for a directive in
the file's tree to define the encoding. Yet another is to have a preference,
and the last I could think of is letting the user select the encoding at the
time of import. Which of the options is most appropriate may depend on the
exact action, e.g. untangle vs. import.

At least for files known to Leo, i.e. read and untangle, I think Leo should use
an "encoding" directive in the internal tree, and otherwise use the preference,
which would default to UTF-8. This means that it will be compatible with
current behavior, as well as maintain compatibility with ASCII files. Import
should offer encoding selection, with the default being the preferred encoding.
Import may also generate an "encoding" directive documenting the encoding
choice.

To complicate things a bit more, we could check the encoding of XML/HTML files
(or any file how's suffix is included in the "XML Like" preference), which
include encoding specification, and take it as the encoding to use, even if it
contradicts some internal directive.

2.6. File content within write, export, tangle (implicit or explicit). 

I think write and tangle should use an internal encoding directive, and as a
fallback, the preference. Export should offer encoding selection, with the
default being based on encoding directive and as fallback on preference.
</t>
<t tx="T1603">3. Encoding process.

This issue discusses primitives and states in the encoding process.

3.1. Encoding directive.

If seems we need one. It may need some options to define error handling preference. 

3.2. Encoding errors. 

Encoding conversion errors occur when a character in the input encoding scheme
(character set) cannot be mapped to a corresponding character in the output
encoding scheme. I.e. the unmapped character does not exist in the output
encoding scheme. Typically in these situations, the unmapped character is
replaced with a standard replacement character (usually '?' or a square).

a. Conversion between Unicode and UTF-8 does not produce any errors, since
UTF-8 is a Unicode encoding scheme. Therefore, no errors are expected when
using 1.1 or 1.2 while interacting with Tk, the OS (in Unicode), and a UTF-8
encoded .leo file.

b. In 2.5 there should not be any errors as well, assuming that the CORRECT
encoding was chosen for the input file. However, in practice a user may make a
mistake, and there may be conversion errors. I.e. the input file may contain
characters that are not represented in the selected encoding scheme.

c. In 2.6 we should expect to see most encoding errors, since it may not be
possible to map all the Unicode characters managed by Leo to the selected
encoding scheme.

3.3. Error handling 

a. A message about encoding conversion error must be displayed in both 2.5 and
2.6, unless specifically directed otherwise by the user. The user may indicate
such a preference as an option of the encoding directive asking for silent
read, write, or both.

b. In case an error occurs, it may be desired to display a representative
sample of unmapped characters and their codes, but not all of them. E.g. Leo
may display the first 5-10 (user preference) unmapped characters. The reason
for this is that having a long list of unmapped characters in unmanageable
anyway, and takes a long time to display (thus delaying completion). A user may
choose to go through an iterative process, correcting a group of characters at
a time, or decide to ignore the errors.

c. A more advanced offering could be to mark nodes, or even the characters
themselves, which caused an encoding conversion error. I suspect this is a
complex programming task.

3.5 Error recovery

a. For Import/Export I believe Leo should just complete the operation, offering
the error handling decided upon in 3.4.

b. For Read/Untangle the question is whether Leo should replace existing tree
information if errors occur. Alternatives are: keep existing tree and text,
replace existing tree and text anyway, build a temporary parallel tree (so we
have existing and read trees), build temporary parallel nodes with existing
text next to offending nodes, and keep existing text in offending nodes as
comment.

The simple thing is to keep the existing tree and text (i.e. fail the
operation) and give the user a chance to redo the operation using a correct
encoding. This is my preference, because a file IS in some encoding scheme and
there need not be any errors when converting from the correct scheme to the
internal representation in 1.1 or 1.2. This will also be compatible with some
design ideas for version 4, in which existing text may be just "nothing" (thin
.leo).

c. For Write/Tangle the question is whether Leo should consider the data saved
if errors occur. If the data is not considered saved, than the .leo file should
still hold to its copy of the data, so a complete and accurate copy is still
somehow saved. This is especially true for the design ideas for version 4.


</t>
<t tx="T1604">4. Programmer's view 

4.1. Standard conversion functions 

I have sent Edward a version of my suggested Unicode conversion functions. They are basically: 

def convertString2Unicode(s, encoding): 
... 
return u,s 

and 

def convertUnicode2String(u, encoding): 
... 
return s,u 

The functions ALWAYS convert the input using some encoding to the corresponding
output, using the replacement character if required. Thus, the first returned
value is always the best representation of the input in the requested encoding.
If a replacement was used, than the second returned value is the original input
with the replacement character replacing the original unmapped characters. This
enables a comparison of the second value to the original to determine
problematic characters (which could then be displayed to the user). In case of
most unexpected error conditions (I cannot tell what they are because they are
unexpected :-)), that should not happen, the first value is "" and the second
is None (instead of "", when all is Ok).

I think these allow safe and easy conversion. 

4.2. Conversion stream reader/writers 

As for reading and writing files is a particular encoding, one approach is to
read a string and use the functions in 4.1. Another possible approach is to use
encoding reader and writer streams. I have no opinion at this point, as I have
not tried the second approach.</t>
<t tx="T1605"></t>
<t tx="T1606">@nocolor

I tried to write out text containing characters like:
        
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="T1607">@nocolor

I tried to write out text containing characters like:
        
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="T1608">@nocolor

I tried to write out text containing characters like:
        
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="T1609">@ignore

  </t>
<t tx="T1610">@encoding iso-8859-1</t>
<t tx="T1611"></t>
<t tx="T1612"></t>
<t tx="T1613">@encoding cp1252
@others</t>
<t tx="T1614">ab</t>
<t tx="T1615"></t>
<t tx="T1616">@nocolor

I've got a minor problem with locale settings and tkinter. My program 
has done a test to determine the current locale setting for the user:

loc = locale.getdefaultlocale()
if loc[1]:
   userEncoding = loc[1]
     try:
        ''.encode(userEncoding, 'replace')
     except:
        userEncoding = ''

if userEncoding == '':
   userEncoding='ascii'

Now, for the most part this works. However, one user of my program has 
just upgraded to Linux Mandrake 9.1 and (I think) he has set his 
language to "de". In any event, the getdefaultlocal() seems to return 
'de' which isn't a valid python encoding (??) and the above code then 
converts to his 'ascii'.

Reply from Martin v. Lwis

Using getdefaultlocale() is broken, and cannot be fixed. On Unix, use

locale.nl_langinfo(locale.CODESET)

instead; if supported, this will tell you the user's preferred encoding.

Be aware that
a) neither nl_langinfo nor CODESET may be supported by the system,
b) they may return a codeset for which a Python codec is not available,
c) you may have to invoke setlocale(locale.LC_CTYPE, "") before
    nl_langinfo returns a reasonable response (e.g. on Solaris)

Python 2.3 has a function locale.getpreferredencoding which does all
that. I recommend you copy its source code into your application, and
use that instead.

Regards,
Martin
</t>
<t tx="T1617"></t>
<t tx="T1618">@ignore</t>
<t tx="T1619">@nocolor

I think I have an idea what could have happened to my clones. If I clone a tree
and then clone nodes within one of those both trees, one tree does not do the
cloning but inserts the node as a regular one.

Example:

node 1 (clone)
   node 11
      node 111
   
node 1 (clone)
   node 11
      node 111

Now I clone node 111 one level up

node 1 (clone)
   node 11
      node 111 (clone)
   node 111 (clone)
   
node 1 (clone)
   node 11
      node 111 (clone)
   node 111 &lt;= This one has not been cloned, as I'd expected

Is this by design?

Kind regards
Franz GEIGER
</t>
<t tx="T1620"></t>
<t tx="T1621"></t>
<t tx="T1622"></t>
<t tx="T1623">def setWrap (self,v):
	
	c = self.commands
	dict = scanDirectives(c,v)
	if dict != None:
		# 8/30/03: Add scroll bars if we aren't wrapping.
		wrap = dict.get("wrap")
		if wrap:
			self.body.configure(wrap="word")
			self.bodyXBar.pack_forget()
		else:
			self.body.configure(wrap="none")
			self.bodyXBar.pack(side="bottom",fill="x")
</t>
<t tx="T1624"></t>
<t tx="T1625"># 5/20/03: Removed the ancient kludge for forcing the height &amp; width of f.
# The code in leoFileCommands.getGlobals now works!

def createLeoSplitter (self, parent, verticalFlag):
	
	"""Create a splitter window and panes into which the caller packs widgets.
	
	Returns (f, bar, pane1, pane2) """

	Tk = Tkinter
	
	# Create the frames.
	f = Tk.Frame(parent,bd=0,relief="flat")
	f.pack(expand=1,fill="both",pady=1)
	pane1 = Tk.Frame(f)
	pane2 = Tk.Frame(f)
	bar =   Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

	# Configure and place the frames.
	self.configureBar(bar,verticalFlag)
	self.bindBar(bar,verticalFlag)
	self.placeSplitter(bar,pane1,pane2,verticalFlag)

	return f, bar, pane1, pane2</t>
<t tx="T1626"></t>
<t tx="T1627">def createIconBar (self):
	
	"""Create an empty icon bar in the packer's present position"""

	if not self.iconFrame:
		self.iconFrame = Tk.Frame(self.outerFrame,height="5m",bd=2,relief="groove")
		self.iconFrame.pack(fill="x",pady=2)</t>
<t tx="T1628">def hideIconBar (self):
	
	"""Hide the icon bar by unpacking it.
	
	A later call to showIconBar will repack it in a new location."""
	
	if self.iconFrame:
		self.iconFrame.pack_forget()
</t>
<t tx="T1629">def clearIconBar(self):
	
	"""Destroy all the widgets in the icon bar"""
	
	f = self.iconFrame
	if not f: return
	
	for slave in f.pack_slaves():
		slave.destroy()

	f.configure(height="5m") # The default height.
	app.iconWidgetCount = 0
	app.iconImageRefs = []
</t>
<t tx="T1630">def showIconBar(self):
	
	"""Show the icon bar by repacking it"""

	self.iconFrame.pack(fill="x",pady=2)</t>
<t tx="T1631">def addIconButton(self,text=None,imagefile=None,image=None,command=None,bg=None):
	
	"""Add a button containing text or a picture to the icon bar.
	
	Pictures take precedence over text"""
	
	f = self.iconFrame
	if not imagefile and not image and not text: return

	# First define n.	
	try:
		app.iconWidgetCount += 1
		n = app.iconWidgetCount
	except:
		n = app.iconWidgetCount = 1

	if not command:
		def command(n=n):
			print "command for widget %s" % (n)

	if imagefile or image:
		&lt;&lt; create a picture &gt;&gt;
	elif text:
		w = min(6,len(text))
		b = Tk.Button(f,text=text,width=w,relief="groove",bd=2,command=command)
		b.pack(side="left", fill="y")
		return b
		
	return None</t>
<t tx="T1632">try:
	if imagefile:
		# Create the image.  Throws an exception if file not found
		imagefile = os.path.join(app.loadDir,imagefile)
		imagefile = os.path.normpath(imagefile)
		image = Tkinter.PhotoImage(master=app.root,file=imagefile)
		
		# Must keep a reference to the image!
		try:
			refs = app.iconImageRefs
		except:
			refs = app.iconImageRefs = []
	
		refs.append((imagefile,image),)
	
	if not bg:
		bg = f.cget("bg")

	b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
	b.pack(side="left",fill="y")
	return b
	
except:
	es_exception()
	return None</t>
<t tx="T1633">@tabwidth 4
</t>
<t tx="T1634">def createStatusLine (self):
	
	if self.statusFrame and self.statusLabel:
		return
	
	self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
	statusFrame.pack(fill="x",pady=1)
	
	text = "line 0, col 0"
	width = len(text) + 4
	self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
	self.statusLabel.pack(side="left",padx=1)
	
	bg = statusFrame.cget("background")
	self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
	self.statusText.pack(side="left",expand=1,fill="x")

	# Register an idle-time handler to update the row and column indicators.
	self.statusFrame.after_idle(self.updateStatusRowCol)</t>
<t tx="T1635">def clearStatusLine (self):
	
	t = self.statusText
	t.configure(state="normal")
	t.delete("1.0","end")
	t.configure(state="disabled")
</t>
<t tx="T1636">def putStatusLine (self,s,color=None):
	
	t = self.statusText ; tags = self.statusColorTags
	if not t: return

	t.configure(state="normal")
	
	if "black" not in self.logColorTags:
		tags.append("black")
		
	if color and color not in tags:
		tags.append(color)
		t.tag_config(color,foreground=color)

	if color:
		t.insert("end",s)
		t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
		t.tag_config("black",foreground="black")
		t.tag_add("black","end")
	else:
		t.insert("end",s)
	
	t.configure(state="disabled")</t>
<t tx="T1637">def updateStatusRowCol (self):
	
	body = self.body ; lab = self.statusLabel
	
	# New for Python 2.3: may be called during shutdown.
	if app.killed:
		return

	index = body.index("insert")
	row,col = getindex(body,index)
	if col &gt; 0:
		s = body.get("%d.0" % (row),index)
		s = toUnicode(s,app.tkEncoding) # 9/28/03
		col = computeWidth (s,self.tab_width)

	if row != self.lastStatusRow or col != self.lastStatusCol:
		s = "line %d, col %d " % (row,col)
		lab.configure(text=s)
		self.lastStatusRow = row
		self.lastStatusCol = col
		
	# Reschedule this routine 100 ms. later.
	# Don't use after_idle: it hangs Leo.
	self.statusFrame.after(100,self.updateStatusRowCol)</t>
<t tx="T1638"></t>
<t tx="T1639">@nocolor</t>
<t tx="T1640">- Cut uncloned node from test.leo.
- Pasted it in LeoPy.leo.
- A second copy of the node appeared later in the file!

This was probably due to not clearing the tnodesDict ivar when use_gnx was false. The effect would be to mis-join nodes that have nothing to do with each other!
</t>
<t tx="T1641">6/11/03:  called self.assignFileIndices in putLeoOutline when using old code.

</t>
<t tx="T1642">Pasted nodes with the same file indices _work_ like clones but aren't marked as clones.

The problem may be the new representation for join lists in 4.0.

t.joinList is the list of all vnodes joined to it.

It may be that the only thing to do is rewrite this code for 4.0.  It certainly is confusing.</t>
<t tx="T1643"></t>
<t tx="T1644"></t>
<t tx="T1645">def compactFileIndices (self):
	
	"""Assign a file index to all tnodes, compacting all file indices"""
	
	c = self.commands ; root = c.rootVnode()
	
	v = root
	self.maxTnodeIndex = 0
	while v: # Clear all indices.
		v.t.setFileIndex(0)
		v = v.threadNext()

	v = c.rootVnode()
	while v: # Set indices for all tnodes that will be written.
		t = v.t
		if t.hasBody() or len(v.t.joinList) &gt; 0: # Write shared tnodes even if they are empty.
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		v = v.threadNext()</t>
<t tx="T1646"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,frame,fileName,atFileNodesFlag=true):

	c=self.commands
	c.setChanged(false) # 10/1/03: May be set when reading @file nodes.
	&lt;&lt; warn on read-only files &gt;&gt;
	self.mFileName = c.mFileName
	self.tnodesDict = {}
	ok = true
	c.frame.setTreeIniting(true) # Disable changes in endEditLabel
	c.loading = true # disable c.changed
	try:
		&lt;&lt; scan all the xml elements &gt;&gt;
	except BadLeoFile, message:
		&lt;&lt; raise an alert &gt;&gt;
		ok = false
	self.setAllJoinLinks() # 9/23/03: Must do this before reading @file nodes.
	c.initAllCloneBits() # 9/23/03
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)
	if not c.frame.currentVnode():
		c.frame.setCurrentVnode(c.frame.rootVnode())
	c.selectVnode(c.frame.currentVnode()) # load body pane
	c.frame.setTreeIniting(false) # Enable changes in endEditLabel
	c.loading = false # reenable c.changed
	c.setChanged(c.changed) # Refresh the changed marker.
	self.tnodesDict = {}
	return ok, self.ratio</t>
<t tx="T1647">try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		es("read only: " + fileName,color="red")
		leoDialog.askOk("Read-only ouline",
			"Warning: the outline: " + fileName + " is read-only.").run(modal=true)
except:
	if 0: # testing only: access may not exist on all platforms.
		es("exception getting file access")
		es_exception()</t>
<t tx="T1648">self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("&lt;leo_file&gt;")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="T1649"># All other exceptions are Leo bugs.

# es_exception()
alert(self.mFileName + " is not a valid Leo file: " + `message`)</t>
<t tx="T1650"># This method finishes pasting the outline from the clipboard.
def finishPaste(self):

	c=self.commands
	current = c.currentVnode()
	after = current.nodeAfterTree()
	c.beginUpdate()
	if 1: # inside update...
		if 0: # Warning: this will only join pasted clones, and is very dangerous.
			&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
		&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
		self.compactFileIndices()
		c.selectVnode(current)
	c.endUpdate()
	return current</t>
<t tx="T1651">v = c.currentVnode()

while v and v != after:
	if v not in v.t.joinList:
		v.t.joinList.append(v)
	v = v.threadNext()
</t>
<t tx="T1652">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

v = c.currentVnode()
while v and v != after:
	v.initClonedBit(v.shouldBeClone())
	v.clearDirty()
	v = v.threadNext()</t>
<t tx="T1653"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s):

	self.usingClipboard = true
	self.fileBuffer = s ; self.fileIndex = 0
	self.tnodesDict = {}

	try:
		self.getXmlVersionTag() # leo.py 3.0
		self.getXmlStylesheetTag() # 10/25/02
		self.getTag("&lt;leo_file&gt;")
		self.getClipboardHeader()
		self.getVnodes()
		self.getTnodes()
		self.getTag("&lt;/leo_file&gt;")
		v = self.finishPaste()
	except BadLeoFile:
		v = None

	# Clean up.
	self.fileBuffer = None ; self.fileIndex = 0
	self.usingClipboard = false
	self.tnodesDict = {}
	return v</t>
<t tx="T1654">def getTnodes (self):

	# A slight change: we require a tnode element.  But Leo always writes this.
	if self.getOpenTag("&lt;tnodes&gt;"):
		return
		
	while self.matchTag("&lt;t"):
		self.getTnode()
	self.getTag("&lt;/tnodes&gt;")
</t>
<t tx="T1655">def getTnode (self):

	# we have already matched &lt;t.
	index = -1 ; attrDict = {}
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("tx=\"T"):
			index = self.getIndex() ; self.getDquote()
			# if self.usingClipboard: trace(index)
		elif self.matchTag("rtf=\"1\""): pass # ignored
		elif self.matchTag("rtf=\"0\""): pass # ignored
		elif self.matchTag("&gt;"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val

	t = self.tnodesDict.get(index)
	&lt;&lt; handle unknown attributes &gt;&gt;
	if t:
		if self.usingClipboard:
			&lt;&lt; handle read from clipboard &gt;&gt;
		else:
			&lt;&lt; handle read from file &gt;&gt;
	else:
		es("no tnode with index: " + `index` + ".  The text will be discarded")
	self.getTag("&lt;/t&gt;")</t>
<t tx="T1656">s = self.getEscapedString()
t.setTnodeText(s,encoding=self.leo_file_encoding)</t>
<t tx="T1657">if t:
	s = self.getEscapedString()
	t.setTnodeText(s,encoding=self.leo_file_encoding)
	# trace(`index`,`len(s)`)</t>
<t tx="T1658">keys = attrDict.keys()
if keys:
	t.unknownAttributes = attrDict
	if 0: # For debugging.
		s = "unknown attributes for tnode"
		print s ; es(s, color = "blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; es(s)</t>
<t tx="T1659">def getVnodes (self):

	c=self.commands
	if  self.usingClipboard:
		# Paste after the current vnode.
		back = c.currentVnode() ; parent = back.parent()
	else:
		back = None ; parent = None

	if self.getOpenTag("&lt;vnodes&gt;"):
		return

	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)

	self.getTag("&lt;/vnodes&gt;")</t>
<t tx="T1660">def getVnode (self,parent,back):

	# trace("parent:" + `parent` + ", back:" + `back`)
	c = self.commands
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {}
	# we have already matched &lt;v.
	while 1:
		if self.matchTag("a=\""):
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		elif self.matchTag("t=\"T"):
			tref = self.getIndex() ; self.getDquote()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList=\""):
			tnodeList = self.getTnodeList() # New for 4.0
		elif self.matchTag("&gt;"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("&lt;vh&gt;"):
		headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
	# Link v into the outline using parent and back.
	v = self.createVnode(parent,back,tref,headline,attrDict)
	if tnodeList:
		v.tnodeList = tnodeList # New for 4.0
		# trace("%4d" % len(tnodeList),v)
	&lt;&lt; Set the remembered status bits &gt;&gt;
	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)
	# End this vnode.
	self.getTag("&lt;/v&gt;")
	return v</t>
<t tx="T1661"># The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break
self.getDquote()</t>
<t tx="T1662">if setCurrent:
	c.frame.setCurrentVnode(v)

if setExpanded:
	v.initExpandedBit()

if setMarked:
	v.setMarked()

if setOrphan:
	v.setOrphan()

if setTop:
	c.mTopVnode = v  # Not used at present.

</t>
<t tx="T1663"></t>
<t tx="T1664">def assignFileIndices (self,root=None):
	
	"""Assign a file index to all tnodes"""
	
	c=self.commands
	
	if root == None:
		root = c.rootVnode()
	v = root
	while v:
		t = v.t

		# 8/28/99.  Write shared tnodes even if they are empty.
		if t.hasBody() or len(v.t.joinList) &gt; 0:
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		else:
			t.setFileIndex(0)
			
		# if self.usingClipboard: trace(t.fileIndex)
		v = v.threadNext()</t>
<t tx="T1665"># Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

	self.outputString = "" ; self.outputFile = None
	self.usingClipboard = true
	self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
	self.putProlog()
	self.putClipboardHeader()
	self.putVnodes()
	self.putTnodes()
	self.putPostlog()
	s = self.outputString
	self.outputString = None
	self.usingClipboard = false
	return s</t>
<t tx="T1666">def copyTreeWithNewTnodes (self):
	
	"""Return a copy of self with all new tnodes"""
	
	c = self.commands
	# trace(`self`)
	
	# Create the root node.
	old_v = self
	new_v = vnode(c,tnode())
	new_v.t.headString = old_v.t.headString
	new_v.t.bodyString = old_v.t.bodyString
	
	# Recursively create all descendents.
	old_child = old_v.firstChild() ; n = 0
	while old_child:
		new_child = old_child.copyTreeWithNewTnodes()
		new_child.linkAsNthChild (new_v, n)
		n += 1
		old_child = old_child.next()
		
	# Return the root of the new tree.
	return new_v</t>
<t tx="T1667">def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c=self.commands
	if self.usingClipboard: # write the current tree.
		v = c.currentVnode() ; after = v.nodeAfterTree()
	else: # write everything
		v = c.rootVnode() ; after = None

	self.put("&lt;tnodes&gt;") ; self.put_nl()
	&lt;&lt; write only those tnodes that were referenced &gt;&gt;
	self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="T1668"># Populate tnodes
tnodes = {}
while v and v != after:
	index = v.t.fileIndex
	if index &gt; 0 and not tnodes.has_key(index):
		tnodes[index] = v.t
	v = v.threadNext()

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	t = tnodes[index]
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isVisited(): self.putTnode(t)</t>
<t tx="T1669">def putTnode (self,t):
	
	# if self.usingClipboard: trace(t.fileIndex)

	self.put("&lt;t")
	self.put(" tx=") ; self.put_in_dquotes("T" + `t.fileIndex`)
	if hasattr(t,"unknownAttributes"):
		&lt;&lt; put unknown tnode attributes &gt;&gt;
	self.put("&gt;")

	if t.bodyString:
		self.putEscapedString(t.bodyString)

	self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="T1670">attrDict = t.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown tnode attribute"
		print s ;  es(s, color="red")
		print attr, es(attr)</t>
<t tx="T1671">@ This method puts all vnodes by starting the recursion.  putVnode will write all vnodes in the order in which they appear in the outline.
@c
def putVnodes (self):

	c=self.commands
	c.clearAllVisited()

	self.put("&lt;vnodes&gt;") ; self.put_nl()
	if self.usingClipboard:
		self.putVnode(
			c.currentVnode(), # Write only current tree.
			None) # Don't write top vnode status bit.
	else: 
		v = c.rootVnode()
		while v:
			self.putVnode(
				v, # Write the next top-level node.
				c.frame.topVnode()) # Write the top-vnode status bit.
			v = v.next()
	self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="T1672">from leoGlobals import *

checkClones2Links(verbose=true)</t>
<t tx="T1673">def headString (self):
	
	"""Return the headline string."""
	
	# This message should never be printed and we want to avoid crashing here!
	if not isUnicode(self.t.headString):
		s = "Leo internal error: not unicode:" + `self.t.headString`
		print s ; es(s,color="red")
		
	# Make _sure_ we return a unicode string.
	return toUnicode(self.t.headString,app.tkEncoding)

def cleanHeadString (self):
	
	s = self.headString()
	return toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'</t>
<t tx="T1674">def checkClones2Links (c=None,verbose=false):
	
	if not c: c = top()
	
	c.clearAllVisited()
	v = c.rootVnode()
	&lt;&lt; clear statistics &gt;&gt;
	while v:
		if v.isCloned() and not v.t.isVisited():
			v.t.setVisited()
			&lt;&lt; handle each item in v's join list &gt;&gt;
		v = v.threadNext()
				
	&lt;&lt; print statistics &gt;&gt;</t>
<t tx="T1675">targetsInDerivedFiles = []
multipleTargetsInDerivedFiles = []
clonesInNoDerivedFiles = []
clonedAtFileNodes = []
</t>
<t tx="T1676">for name, theList in (
	("targetsInDerivedFiles:", targetsInDerivedFiles),
	("multipleTargetsInDerivedFiles:", multipleTargetsInDerivedFiles),
	("clonesInNoDerivedFiles:", clonesInNoDerivedFiles),
	("clonedAtFileNodes:", clonedAtFileNodes)):

	print ; print name, len(theList)

	if verbose:
		headlines = []
		for v in theList:
			headlines.append(v.cleanHeadString())
		headlines.sort()
		for h in headlines:
			print h</t>
<t tx="T1677">if v.isAnyAtFileNode():
	clonedAtFileNodes.append(v)
else:
	anchors = 0 ; targets = 0
	for j in v.t.joinList:
		
		# See if j should be an anchor: i.e., whether it is in any @file node.
		p = j ; isAnchor = false
		while p:
			if p.isAnyAtFileNode():
				isAnchor = true
				break
			p = p.parent()
		if isAnchor: anchors += 1
		else: targets += 1

	if anchors == 1:
		targetsInDerivedFiles.append(v)
	elif anchors &gt; 1:
		multipleTargetsInDerivedFiles.append(v)
	else:
		clonesInNoDerivedFiles.append(v)</t>
<t tx="T1678">@nocolor

targetsInDerivedFiles: 418

clonesInNoDerivedFiles: 20

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="T1679">@ The key is the new clearAllIvars routine.  This is simple and foolproof.</t>
<t tx="T1680"></t>
<t tx="T1681"></t>
<t tx="T1682"># Objects must not be "destroyed" more than once; only this method calls destroy routines.

def destroyAllWindowObjects (self,frame):

	"""Clear all links to objects in a Leo window."""
	
	# print "app.destroyAllNodes", frame
	
	# Do this first.
	&lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;
	
	# Destroy all subcommanders &amp; the commander.
	clearAllIvars(frame.commands.atFileCommands)
	clearAllIvars(frame.commands.fileCommands)
	clearAllIvars(frame.commands.importCommands)
	clearAllIvars(frame.commands.tangleCommands)
	clearAllIvars(frame.commands.undoer)
	clearAllIvars(frame.commands)

	# Destroy the all ivars in the Leo frame and all helper classes.
	frame.clearAllIvars()
	
	# Finally, destroy the frame itself.
	frame.destroyAllPanels()
	clearAllIvars(frame)
	
	# Note: pointers to frame still exist in the caller!</t>
<t tx="T1683"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

v = frame.commands.rootVnode()
while v:
	vList.append(v)
	if v.t:
		key = id(v.t)
		if not tDict.has_key(key):
			tDict[key] = v.t
	v = v.threadNext()
	
for key in tDict.keys():
	clearAllIvars(tDict[key])

for v in vList:
	clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="T1684">def closeLeoWindow (self,frame):
	
	"""Attempt to close a Leo window.
	
	Return false if the user veto's the close."""
	
	app = self ; c = frame.commands

	if c.changed:
		veto = frame.promptForSave()
		# print "veto",veto
		if veto: return false

	app.setLog(None) # no log until we reactive a window.
	
	doHook("close-frame",c=c) # This may remove frame from the window list.
	
	if frame in app.windowList:
		app.destroyWindow(frame)
	
	if app.windowList:
		# Pick a window to activate so we can set the log.
		w = app.windowList[0]
		w.deiconify()
		w.top.lift()
		app.setLog(w)
	else:
		app.finishQuit()

	return true # The window has been closed.
</t>
<t tx="T1685">def finishQuit(self):
	
	self.killed = true # Disable after events.
	
	if self.afterHandler != None:
		# print "finishQuit: cancelling",self.afterHandler
		self.root.after_cancel(self.afterHandler)
		self.afterHandler = None

	# Wait until everything is quiet before really quitting.
	doHook("end1")

	self.destroyAllGlobalWindows()
	
	self.destroyAllOpenWithFiles()

	if 0: # Works in Python 2.1 and 2.2.  Leaves Python window open.
		self.root.destroy()
		
	else: # Works in Python 2.3.  Closes Python window.
		self.root.quit()</t>
<t tx="T1686">def onQuit (self):
	
	app = self
	
	app.quitting = true
	
	while app.windowList:
		w = app.windowList[0]
		if not app.closeLeoWindow(w):
			break

	app.quitting = false # If we get here the quit has been disabled.


</t>
<t tx="T1687">def destroyAllPanels (self):
	
	"""Destroy all panels attached to this frame."""
	
	panels = (self.comparePanel, self.colorPanel, self.fontPanel, self.prefsPanel)

	for panel in panels:
		if panel:
			panel.top.destroy()
			
	self.comparePanel = None
	self.colorPanel = None
	self.fontPanel = None
	self.prefsPanel = None</t>
<t tx="T1688">def promptForSave (self):
	
	"""Prompt the user to save changes.
	
	Return true if the user vetos the quit or save operation."""
	
	c = self.commands
	name = choose(c.mFileName,c.mFileName,self.title)
	type = choose(app.quitting, "quitting?", "closing?")
	
	answer = leoDialog.askYesNoCancel("Confirm",
		'Save changes to %s before %s' % (name,type)).run(modal=true)
		
	# print answer	
	if answer == "cancel":
		return true # Veto.
	elif answer == "no":
		return false # Don't save and don't veto.
	else:
		if not c.mFileName:
			&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
		if c.mFileName:
			# print "saving", c.mFileName
			c.fileCommands.save(c.mFileName)
			return false # Don't veto.
		else:
			return true # Veto.</t>
<t tx="T1689"># Make sure we never pass None to the ctor.
if not c.mFileName:
	c.mFileName = ""
	
c.mFileName = tkFileDialog.asksaveasfilename(
	initialfile = c.mFileName,
	title="Save",
	filetypes=[("Leo files", "*.leo")],
	defaultextension=".leo")
</t>
<t tx="T1690">lastObjectCount = 0
lastObjectsDict = {}
debugGC = false

# gc may not exist everywhere.
try: 
	import gc
	if 0:
		if debugGC:
			gc.set_debug(
				gc.DEBUG_STATS |# prints statistics.
				# gc.DEBUG_LEAK | # Same as all below.
				gc.DEBUG_COLLECTABLE |
				gc.DEBUG_UNCOLLECTABLE |
				gc.DEBUG_INSTANCES |
				gc.DEBUG_OBJECTS |
				gc.DEBUG_SAVEALL)
except:
	traceback.print_exc()

@others
</t>
<t tx="T1691">def clearAllIvars (o):
	
	"""Clear all ivars of o, a member of some class."""
	
	o.__dict__.clear()
</t>
<t tx="T1692">def collectGarbage(message=None):
	
	if not debugGC: return
	
	if not message:
		message = callerName(n=2)
	
	try: gc.collect()
	except: pass
	
	if 1:
		printGc(message)
	
	if 0: # This isn't needed unless we want to look at individual objects.
	
		&lt;&lt; make a list of the new objects &gt;&gt;
		print "%25s: %d new, %d total objects" % (message,len(newObjects),len(objects))
</t>
<t tx="T1693"># WARNING: the id trick is not proper because newly allocated objects can have the same address as old objets.

global lastObjectsDict
objects = gc.get_objects()

newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

lastObjectsDict = {}
for o in objects:
	lastObjectsDict[id(o)]=o</t>
<t tx="T1694">def printGc(message=None,onlyPrintChanges=false):
	
	if not debugGC: return None
	
	if not message:
		message = callerName(n=2)
	
	global lastObjectCount

	try:
		n = len(gc.garbage)
		n2 = len(gc.get_objects())
		delta = n2-lastObjectCount
		if not onlyPrintChanges or delta:
			if n:
				print "garbage: %d, objects: %+6d =%7d %s" % (n,delta,n2,message)
			else:
				print "objects: %+6d =%7d %s" % (n2-lastObjectCount,n2,message)

		lastObjectCount = n2
		return delta
	except:
		traceback.print_exc()
		return None</t>
<t tx="T1695">def printGcRefs (verbose=true):

	refs = gc.get_referrers(app.windowList[0])
	print '-' * 30

	if verbose:
		print "refs of", app.windowList[0]
		for ref in refs:
			print type(ref)
			if 0:
				import leoFrame
				if type(ref) == type({}):
					keys = ref.keys()
					keys.sort()
					for key in keys:
						val = ref[key]
						if isinstance(val,leoFrame.LeoFrame):
							print key,ref[key]
	else:
		print "%d referers" % len(refs)</t>
<t tx="T1696">@ignore</t>
<t tx="T1697"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
	"@","@c","@code","@color","@comment",
	"@delims","@doc","@encoding","@end_raw",
	"@first","@header","@ignore",
	"@language","@last","@lineending",
	"@nocolor","@noheader","@nowrap","@others",
	"@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
	"@silent","@tabwidth","@terse",
	"@unit","@verbose","@wrap" ]</t>
<t tx="T1698">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

	c = top() # c may be None during startup.
	
	if not app.config.use_plugins:
		return None
	elif app.hookError:
		return None
	elif c and c.hookFunction:
		try:
			return c.hookFunction(tag,keywords)
		except:
			es("exception in c.hookFunction for " + c.frame.top.title())
	elif app.hookFunction:
		try:
			return app.hookFunction(tag,keywords)
		except:
			es("exception in app.hookFunction")
	else:
		import leoPlugins
		try:
			app.hookFunction = leoPlugins.doPlugins
			return app.hookFunction(tag,keywords)
		except:
			app.hookFunction = None
			es("exception in plugin")

	# Handle all exceptions.
	es_exception()
	app.hookError = true # Supress this function.
	app.idleTimeHook = false # Supress idle-time hook
	return None # No return value</t>
<t tx="T1699">"""Support new @direcives"""

from leoPlugins import *
from leoGlobals import *

if 1:
	directives = "markup", # A tuple with one string.
else:
	directives = ("markup","markup2")
	
@others

if 1: # Register the handlers...

	registerHandler("start1",addPluginDirectives)
	registerHandler("scan-directives",scanPluginDirectives)
	
	__version__ = "1.1"
	plugin_signon(__name__)</t>
<t tx="T1700">def addPluginDirectives (tag,keywords):
	
	"""Add all new directives to globalDirectivesList"""
	
	global directives

	if 0:
		s = ""
		for d in directives:
			s += '@' + d + ' '
		es(s,color="blue")

	for d in directives:
		if d not in globalDirectiveList:
			globalDirectiveList.append(d)</t>
<t tx="T1701">def scanPluginDirectives (tag, keywords):
	
	"""Add a tuple (d,v,s,k) to list for every directive d found"""
	
	global directives

	keys = ("c","v","s","old_dict","dict","pluginsList")
	c,v,s,old_dict,dict,pluginsList = [keywords.get(key) for key in keys]

	for d in directives:
		if not old_dict.has_key(d) and dict.has_key(d):
			# Point k at whatever follows the directive.
			k = dict[d]
			k += 1 + len(d) # Skip @directive
			k = skip_ws(s,k) # Skip whitespace
			# trace(`d`,`k`)
			pluginsList.append((d,v,s,k),)
</t>
<t tx="T1702">@ignore
@markup wiki
</t>
<t tx="T1703"></t>
<t tx="T1704"># Add any newly-added user keywords.
for d in globalDirectiveList:
	name = '@' + d
	if name not in leoKeywords:
		leoKeywords.append(name)

# Copy the arguments.
self.v = v
self.body = body

# Get the body text, converted to unicode.
s = getAllText(body)
assert(isUnicode(s))
self.sel = sel = body.index("insert") # get the location of the insert point
start, end = string.split(sel,'.')
start = int(start)

# trace(`self.language`)
# trace(`self.count` + `self.v`)
# trace(`body.tag_names()`)

if not self.incremental:
	self.removeAllTags()
	self.removeAllImages()

self.redoColoring = false
self.redoingColoring = false

&lt;&lt; configure tags &gt;&gt;
&lt;&lt; configure language-specific settings &gt;&gt;

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')</t>
<t tx="T1705">config = app.config
assert(config)

for name in default_colors_dict.keys(): # Python 2.1 support.
	option_name,default_color = default_colors_dict[name]
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Must use foreground, not fg.
	try:
		body.tag_config(name, foreground=color)
	except: # Recover after a user error.
		body.tag_config(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
	body.tag_config("link",underline=1) # defined
	body.tag_config("name",underline=0) # undefined
else:
	body.tag_config("link",underline=0)
	if underline_undefined:
		body.tag_config("name",underline=1)
	else:
		body.tag_config("name",underline=0)
		
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
	for name,option_name,default_color in (
		("blank","show_invisibles_space_background_color","Gray90"),
		("tab",  "show_invisibles_tab_background_color",  "Gray80")):
		option_color = config.getColorsPref(option_name)
		color = choose(option_color,option_color,default_color)
		try:
			body.tag_config(name,background=color)
		except: # Recover after a user error.
			body.tag_config(name,background=default_color)
	
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
	body.tag_configure("latexModeBackground",foreground="black")
	body.tag_configure("latexModeKeyword",foreground="blue")
	body.tag_configure("latexBackground",foreground="black")
	body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
	body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
	body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
	body.tag_configure("latexBackground",foreground="black",background="white")
	body.tag_configure("latexKeyword",foreground="blue",background="white")
	
# Tags for wiki coloring.
if self.showInvisibles:
	body.tag_configure("elide",background="yellow")
else:
	body.tag_configure("elide",elide="1")
body.tag_configure("bold",font=self.bold_font)
body.tag_configure("italic",font=self.italic_font)
body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
	self.body.tag_configure(name,foreground=name)</t>
<t tx="T1706">def removeAllTags (self):
	
	# Warning: the following DOES NOT WORK: self.body.tag_delete(self.tags)
	for tag in self.tags:
		self.body.tag_delete(tag)

	for tag in self.color_tags_list:
		self.body.tag_delete(tag)
	
def removeTagsFromLine (self):
	
	# print "removeTagsFromLine",self.line_index
	for tag in self.tags:
		self.body.tag_remove(tag,self.index(0),self.index("end"))
		
	for tag in self.color_tags_list:
		self.body.tag_remove(tag,self.index(0),self.index("end"))</t>
<t tx="T1707">def disable (self):

	print "disabling all syntax coloring"
	self.enabled=false

def __init__(self, commands):

	self.commands = commands
	self.count = 0 # how many times this has been called.
	self.use_hyperlinks = false # true: use hyperlinks and underline "live" links.
	self.enabled = true # true: syntax coloring enabled
	self.showInvisibles = false # true: show "invisible" characters.
	self.comment_string = None # Set by scanColorDirectives on @comment
	# For incremental coloring.
	self.tags = (
		"blank","comment","cwebName","docPart","keyword","leoKeyword",
		"latexModeBackground","latexModeKeyword",
		"latexBackground","latexKeyword",
		"link","name","nameBrackets","pp","string","tab",
		"elide","bold","bolditalic","italic") # new for wiki styling.
	self.color_pass = 0
	self.incremental = false
	self.redoColoring = false
	self.redoingColoring = false
	self.sel = None
	self.lines = []
	self.states = []
	self.last_flag = "unknown"
	self.last_language = "unknown"
	self.last_comment = "unknown"
	# For use of external markup routines.
	self.last_markup = "unknown" 
	self.markup_string = "unknown"
	&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;
	&lt;&lt; define dispatch dicts &gt;&gt;
	&lt;&lt; define fonts and data for wiki tags &gt;&gt;</t>
<t tx="T1708"># Copies of arguments.
self.v = None
self.body = None
self.language = None
self.flag = None
self.line_index = 0

# Others.
self.single_comment_start = None
self.block_comment_start = None
self.block_comment_end = None
self.has_string = None
self.string_delims = ("'",'"')
self.has_pp_directives = None
self.keywords = None
self.lb = None
self.rb = None
self.rootMode = None # None, "code" or "doc"

config = app.config
self.latex_cweb_docs     = config.getBoolColorsPref("color_cweb_doc_parts_with_latex")
self.latex_cweb_comments = config.getBoolColorsPref("color_cweb_comments_with_latex")
# print "docs,comments",`self.latex_cweb_docs`,`self.latex_cweb_comments`</t>
<t tx="T1709">self.state_dict = {
	"blockComment" : self.continueBlockComment,
	"doubleString" : self.continueDoubleString, # 1/25/03
	"nocolor"      : self.continueNocolor,
	"normal"       : self.doNormalState,
	"singleString" : self.continueSingleString,  # 1/25/03
	"string3s"     : self.continueSinglePythonString,
	"string3d"     : self.continueDoublePythonString,
	"doc"          : self.continueDocPart }
	
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

	self.dict1 = { # 1-character patterns.
		'"' : self.doString,
		"'" : self.doString,
		'@' : self.doPossibleLeoKeyword,
		' ' : self.doBlank,
		'\t': self.doTab }

	self.dict2 = {} # 2-character patterns
	
	# Searching this list might be very slow!
	mutli_list = [] # Multiple character patterns.
	
	# Enter single-character patterns...
	if self.has_pp_directives:
		dict1 ["#"] = self.doPPDirective
				
	for ch in string.ascii_letters:
		dict1 [ch] = self.doPossibleKeyword
	dict1 ['_'] = self.doPossibleKeyword
	
	if self.language == "latex":
		dict1 ['\\'] = self.doPossibleKeyword
		
	if self.language == "php":
		dict1 ['&lt;'] = self.doSpecialPHPKeyword
		dict1 ['?'] = self.doSpecialPHPKeyword
	
	# Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
	if self.language == "cweb":
		dict2 ["@("] = self.doPossibleSectionRefOrDef
	else:
		dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef
		
	if self.single_comment_start:
		n = len(self.single_comment_start)
		if n == 1:
			dict1 [self.single_comment_start] = self.doSingleCommentLine
		elif n == 2:
			dict2 [self.single_comment_start] = self.doSingleCommentLine
		else:
			mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
	
	if self.block_comment_start:
		n = len(self.block_comment_start)
		if n == 1:
			dict1 [self.block_comment_start] = self.doBlockComment
		elif n == 2:
			ddict2 [self.block_comment_start] = self.doBlockComment
		else:
			mutli_list.append((self.block_comment_start,self.doBlockComment),)</t>
<t tx="T1710">self.bold_font = config.getFontFromParams(
	"body_text_font_family", "body_text_font_size",
	"body_text_font_slant",  "body_text_font_weight")

if self.bold_font:
	self.bold_font.configure(weight="bold")

self.italic_font = config.getFontFromParams(
	"body_text_font_family", "body_text_font_size",
	"body_text_font_slant",  "body_text_font_weight")
	
if self.italic_font:
	self.italic_font.configure(slant="italic")

self.bolditalic_font = config.getFontFromParams(
	"body_text_font_family", "body_text_font_size",
	"body_text_font_slant",  "body_text_font_weight")
	
if self.bolditalic_font:
	self.bolditalic_font.configure(weight="bold",slant="italic")

self.color_tags_list = []
self.image_references = []
</t>
<t tx="T1711">def index (self,i):
	
	return "%s.%s" % (self.line_index,i)
		
def tag (self,name,i,j):

	self.body.tag_add(name,self.index(i),self.index(j))</t>
<t tx="T1712">def skip_python_string(self,s,i):

	delim = s[i:i+3]
	if delim == "'''" or delim == '"""':
		k = s.find(delim,i+3)
		if k == -1:
			return len(s),choose(delim=="'''","string3s","string3d")
		else:
			return k+3, "normal"
	else:
		return self.skip_string(s,i)</t>
<t tx="T1713"></t>
<t tx="T1714">if self.language == "python":

	delim = s[i:i+3]
	j, state = self.skip_python_string(s,i)
	if delim == '"""':
		# Only handle wiki items in """ strings.
		if not doHook("color-optional-markup",
			colorer=self,v=self.v,s=s,i=i,j=j,colortag="string"):
			self.tag("string",i,j)
	else:
		self.tag("string",i,j)
	i = j

else:
	j, state = self.skip_string(s,i)
	self.tag("string",i,j)
	i = j
</t>
<t tx="T1715">def continueDoublePythonString (self,s,i):
	j = s.find('"""',i)
	return self.continuePythonString(s,i,j,"string3d")

def continueSinglePythonString (self,s,i):
	j = s.find("'''",i)
	return self.continuePythonString(s,i,j,"string3s")

def continuePythonString (self,s,i,j,continueState):

	if j == -1: # The entire line is part of the triple-quoted string.
		j = len(s)
		if continueState == "string3d":
			if not doHook("color-optional-markup",
				colorer=self,v=self.v,s=s,i=i,j=j,colortag="string"):
				self.tag("string",i,j)
		else:
			self.tag("string",i,j)
		return j,continueState # skip the rest of the line.

	else: # End the string
		if continueState == "string3d":
			if not doHook("color-optional-markup",
				colorer=self,v=self.v,s=s,i=i,j=j,colortag="string"):
				self.tag("string",i,j+3)
			else:
				self.tag("string",i,j+3)
		else:
			self.tag("string",i,j+3)
		return j+3,"normal"</t>
<t tx="T1716">def continueDocPart (self,s,i):
	
	state = "doc"
	if self.language == "cweb":
		&lt;&lt; handle cweb doc part &gt;&gt;
	else:
		&lt;&lt; handle noweb doc part &gt;&gt;
	return i,state</t>
<t tx="T1717">word = self.getCwebWord(s,i)
if word and len(word) &gt; 0:
	j = i + len(word)
	if word in ("@&lt;","@(","@c","@d","@f","@p"):
		state = "normal" # end the doc part and rescan
	else:
		# The control code does not end the doc part.
		self.tag("keyword",i,j)
		i = j
		if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
			j = s.find("@&gt;",i)
			if j &gt; -1:
				self.tag("cwebName",i,j)
				self.tag("nameBrackets",j,j+2)
				i = j + 2
elif match(s,i,self.lb):
	j = self.doNowebSecRef(s,i)
	if j == i + 2: # not a section ref.
		self.tag("docPart",i,j)
	i = j
elif self.latex_cweb_docs:
	# Everything up to the next "@" is latex colored.
	j = s.find("@",i+1)
	if j == -1: j = len(s)
	self.doLatexLine(s,i,j)
	i = j
else:
	# Everthing up to the next "@" is in the doc part.
	j = s.find("@",i+1)
	if j == -1: j = len(s)
	self.tag("docPart",i,j)
	i = j</t>
<t tx="T1718">if i == 0 and match(s,i,"&lt;&lt;"):
	# Possible section definition line.
	return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
	j = self.skip_id(s,i+1,chars='-')
	word = s[i:j]
	word = word.lower()
else:
	word = ""

if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
	# End of the doc part.
	self.body.tag_remove("docPart",self.index(i),self.index(j))
	self.tag("leoKeyword",i,j)
	i = j ; state = "normal"
else:
	# The entire line is in the doc part.
	j = len(s)
	if not doHook("color-optional-markup",
		colorer=self,v=self.v,s=s,i=i,j=j,colortag="docPart"):
		self.tag("docPart",i,j)
	i = j # skip the rest of the line.
</t>
<t tx="T1719"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
else:
	j = len(s)
	if not doHook("color-optional-markup",
		colorer=self,v=self.v,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j</t>
<t tx="T1720">def continueBlockComment (self,s,i):
	
	j = s.find(self.block_comment_end,i)

	if j == -1:
		j = len(s) # The entire line is part of the block comment.
		if self.language=="cweb":
			self.doLatexLine(s,i,j)
		else:
			if not doHook("color-optional-markup",
				colorer=self,v=self.v,s=s,i=i,j=j,colortag="comment"):
				self.tag("comment",i,j)
		return j,"blockComment" # skip the rest of the line.

	else:
		# End the block comment.
		k = len(self.block_comment_end)
		if self.language=="cweb" and self.latex_cweb_comments:
			self.doLatexLine(s,i,j)
			self.tag("comment",j,j+k)
		else:
			if not doHook("color-optional-markup",
				colorer=self,v=self.v,s=s,i=i,j=j+k,colortag="comment"):
				self.tag("comment",i,j+k)
		i = j + k
		return i,"normal"</t>
<t tx="T1721">k = len(self.block_comment_start)

if not doHook("color-optional-markup",
	colorer=self,v=self.v,s=s,i=i,j=i+k,colortag="comment"):
	self.tag("comment",i,i+k)

i += k ; state = "blockComment"</t>
<t tx="T1722"># Handles non-cweb keyword.

def doAtKeyword (self,s,i):

	j = self.skip_id(s,i+1,chars="-") # to handle @root-code, @root-doc
	word = s[i:j]
	word = word.lower()
	if i != 0 and word != "@others":
		word = "" # can't be a Leo keyword, even if it looks like it.
	
	# 7/8/02: don't color doc parts in plain text.
	if self.language != "plain" and (word == "@" or word == "@doc"):
		# at-space is a Leo keyword.
		self.tag("leoKeyword",i,j)
		k = len(s) # Everything on the line is in the doc part.
		if not doHook("color-optional-markup",
			colorer=self,v=self.v,s=s,i=j,j=k,colortag="docPart"):
			self.tag("docPart",j,k)
		return k,"doc"
	elif word == "@nocolor":
		# Nothing on the line is colored.
		self.tag("leoKeyword",i,j)
		return j,"nocolor"
	elif word in leoKeywords:
		self.tag("leoKeyword",i,j)
		return j,"normal"
	else:
		return j,"normal"</t>
<t tx="T1723">@language python

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""

""" {picture file=../Icons/Leoapp.GIF}this """ # There are probdlems \with correct indexing following a graphic.

and if

from leoGlobals import * ; print `app().loadDir`</t>
<t tx="T1724"></t>
<t tx="T1725">def setInitialWindowGeometry(self):
	
	"""Set the position and size of the frame to config params."""
	
	config = app.config

	h = config.getIntWindowPref("initial_window_height")
	w = config.getIntWindowPref("initial_window_width")
	x = config.getIntWindowPref("initial_window_left")
	y = config.getIntWindowPref("initial_window_top")
	# print h,w,x,y
	
	if h == None or h &lt; 5: h = 5
	if w == None or w &lt; 5: w = 10
	y = max(y,0) ; x = max(x,0)

	self.top.geometry("%dx%d%+d%+d" % (w,h,x,y))</t>
<t tx="T1726">@ To do:
	
For users:
	
- Make Back and Forward icons smaller.
</t>
<t tx="T1727">def fillbox(self,event=None):

	"""Update a Recent Sections listbox dialog and update vnodeList &amp; tnodeList ivars"""

	# Only fill the box if the dialog is visible.
	# This is an important protection against bad performance.

	if self.top.state() == "normal":
		&lt;&lt; reconstruct the contents of self.box &gt;&gt;
		self.synchButtons()</t>
<t tx="T1728">c = self.c

self.box.delete(0,"end")
self.vnodeList = []
self.tnodeList = []

# Make sure the node still exists.
# Insert only the last cloned node.
i = 0
for v in c.visitedList:
	if v.exists(self.c) and v.t not in self.tnodeList:
		self.box.insert(i,v.headString().strip())
		self.tnodeList.append(v.t)
		self.vnodeList.append(v)
		i += 1
</t>
<t tx="T1729"></t>
<t tx="T1730">@nocolor

I have no idea how the old code worked at all.  The only parameter to any callback will be an event, so event must be the first parameter to the callback.</t>
<t tx="T1731">@ The fix was in &lt;&lt; convert tab to blanks &gt;&gt; in idle_body_key

The old code only converted tabs when everything before the insertion point was whitespace!</t>
<t tx="T1732"></t>
<t tx="T1733">@nocolor

Replaced getJoinList() by joinList
Replaced setJoinList() by joinList =
Defined joinHead in tnode class, not vnode class.
Created joinList directly in leoFileCommands
	- Eliminated joinHead ivar.
Rewrote joinNodeTo.
Removed unjoinNode and simplified unjoinTree.
Looked at calls to swap_links()
Tested all commands affected by joinList: clone, moves, undo.
	*** Found an old bug in undoReplace.
Did diffs on all changed files: (checked all usages of 
	(done) leoCommands
	(done) leoFileCommands
	(done) leoNodes
	(done) leoTree
	(done) leoUndo</t>
<t tx="T1734"></t>
<t tx="T1735">def setJoinList (self, v):

	assert(not self.joinList)
	self.joinList = v</t>
<t tx="T1736">def getJoinList (self):

	return self.joinList</t>
<t tx="T1737">def setJoinHead (self, v):

	self.joinHead = v</t>
<t tx="T1738"># Returns true if the nodes v1 and v2 are on the same join list.

def isOnJoinListOf (self, v2):
	
	v1 = self
	return v1.t == v2.t and v2 in v1.t.joinList</t>
<t tx="T1739">def unjoinNode (self):
	
	"""Unlinks the receiver from its own join list"""
	
	v = self ; j = v.t.joinList
	if v in j:
		j.remove(v)</t>
<t tx="T1740">		if 0: # 9/26/02: No longer used: derived files contain no clone indices.
			root.clearAllVisitedInTree()
			&lt;&lt; Handle clone bits &gt;&gt;
			&lt;&lt; Join cloned trees &gt;&gt;</t>
<t tx="T1741">@ This function joins all nodes in the two trees which should have the same topology. This code makes no other assumptions about the two trees; some or all of the nodes may already have been joined.

There are several differences between this method and the similar vnode:joinTreeTo method.  First, we can not assert that the two trees have the same topology because the derived file could have been edited outside of Leo.  Second, this method also merges the tnodes of all joined nodes.
@c
def joinTrees(self,tree1,tree2):

	assert(tree1 and tree2)
	# Join the roots using the vnode class.
	tree1.joinNodeTo(tree2)
	# 5/2/03: Now that tnodes contain join lists, this must be done _after_ joining the nodes.
	# Use a common tnode for both nodes.
	if tree1.t != tree2.t:
		tree1.setT(tree2.t)
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1 and child2:
		self.joinTrees(child1, child2)
		child1 = child1.next()
		child2 = child2.next()
	if child1 or child2:
		self.readError("cloned nodes have different topologies")</t>
<t tx="T1742">h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			t = h[cloneIndex]
			# v is a clone: share the previous tnode.
			v.setT(t)
			t.setVisited() # We will mark these clones later.
		else: h[cloneIndex] = v.t
	v = v.threadNext()

# Set clone marks for all visited tnodes.
v = root
while v and v != next:
	if v.t.isVisited():
		if v == root:
			pass
		elif v.shouldBeClone():
			v.initClonedBit(true)
		else:
			# Not a serious error.
			es("clone links cleared for: " + v.headString())
			v.unjoinTree();
			t.setCloneIndex(0) # t is no longer cloned.
	v = v.threadNext()</t>
<t tx="T1743">@ In most cases, this code is not needed, because the outline already has been read and nodes joined.  However, there could be problems on read errors, so we also join nodes here.
@c

h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			clone = h[cloneIndex]
			if v.headString() == clone.headString():
				self.joinTrees(clone,v)
			else:
				# An extremely serious error.  Data may be lost.
				self.readError(
					"Outline corrupted: " +
					"different nodes have same clone index!\n\t" +
					v.headString() + "\n\t" + clone.headString())
		# Enter v so we can join the next clone to it.
		# The next call to lookup will find this v, not the previous.
		h[cloneIndex] = v
	v = v.threadNext()</t>
<t tx="T1744"></t>
<t tx="T1745">def joinNodeTo (self, v2):
	
	"""Add self or v2 to their common join list"""

	v1 = self
	assert(v1.t==v2.t)
	j = v1.t.joinList
	
	if v1 not in j:
		j.append(v1)
		
	if v2 not in j:
		j.append(v2)</t>
<t tx="T1746">def unjoinTree (self):

	"""Remove all v and all its descendents v from v.t.joinList."""

	v = self
	after = self.nodeAfterTree()
	while v and v != after:
		if v in v.t.joinList:
			v.t.joinList.remove(v)
		v = v.threadNext()</t>
<t tx="T1747"></t>
<t tx="T1748"></t>
<t tx="T1749">B</t>
<t tx="T1750"></t>
<t tx="T1751"></t>
<t tx="T1752">test</t>
<t tx="T1753">@nocolor

- (done) Created runMainLoop function in leo.py so the call to mainloop() is in a separate function.

- (done) Added flush method to redirect class in leoGlobals.py

@color</t>
<t tx="T1754"># To redirect stdout a class only needs to implement a write(self,s) method.
def __init__ (self):
	self.old = None
	
def isRedirected (self):
	return self.old != None
	
def flush(self, *args):
	return # 6/14/03:  For LeoN: just for compatibility.

def redirect (self,stdout=1):
	import sys
	if not self.old:
		if stdout:
			self.old,sys.stdout = sys.stdout,self
		else:
			self.old,sys.stderr = sys.stderr,self

def undirect (self,stdout=1):
	import sys
	if self.old:
		if stdout:
			sys.stdout,self.old = self.old,None
		else:
			sys.stderr,self.old = self.old,None

def write(self,s):
	if self.old:
		if app.log: app.log.put(s)
		else: self.old.write(s)
	else: print s # Typically will not happen.
</t>
<t tx="T1755">def runMainLoop(root):
	
	"""A function that runs root.mainloop()
	
	LeoN may replace this fuction entirely."""
	
	root.mainloop()
</t>
<t tx="T1756">from leoGlobals import *
import os,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = false
tnodes = vnodes = 0

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
	@others
	
try:
	f = None
	try:
		print path
		if 1:
			source = f = open(path)
		else: # not needed, and it works.
			source = InputSource(path)
			source.setEncoding(app().tkEncoding) # Not needed.
		parser = make_parser()
		h = trace_parse()
		parser.setContentHandler(h)
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: es_exception()
finally:
	if f: f.close()</t>
<t tx="T1757">def characters(self,content):

	content = content.replace('\r','')

	if verbose and content.strip():
		print clean(content)
</t>
<t tx="T1758">def endDocument(self):
	trace()


</t>
<t tx="T1759">def endElement(self,name):
	if verbose: print '&lt;/' + clean(name).strip() + '&gt;'
</t>
<t tx="T1760">def ignorableWhitespace(self):
	trace()

def processingInstruction (self,target,data):
	trace()

def skippedEntity(self,name):
	trace(name)

def startElementNS(self,name,qname,attrs):
	trace(name)

def endElementNS(self,name,qname):
	trace(name)
</t>
<t tx="T1761">def startDocument(self):

	if verbose:
		print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
	trace()
</t>
<t tx="T1762">def startElement(self,name,atts):
	global vnodes,tnodes
	if verbose: print '&lt;' + clean(name).strip() + '&gt;',
	if name == "v":
		vnodes += 1
		v = leoNodes.vnode(top(),leoNodes.tnode())
	elif name == "t":
		tnodes += 1
		t = leoNodes.tnode()</t>
<t tx="T1763"></t>
<t tx="T1764">def writeDirtyAtFileNodes (self): # fileCommands

	"""The Write Dirty @file Nodes command"""
	
	c = self.commands

	writtenFiles = c.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=true)
	
	assert(writtenFiles != None)
	if writtenFiles:
		es("auto-saving outline",color="blue")
		c.frame.OnSave() # Must be done to set or clear tnodeList.</t>
<t tx="T1765"></t>
<t tx="T1766">@nocolor

What I did:

- Added Apply button.
- Frame class now permanently sets setgrid=0 to disable the resizing of the body pane.

To do:
	
- Make the font panel a standard dialog.
- Use a Tk.Text widget instead of a ListBox widget so we can display fonts in differently.

@color</t>
<t tx="T1767"></t>
<t tx="T1768">@nocolor

Developers forum
https://sourceforge.net/forum/message.php?msg_id=2081895
By: rodrigo_b

Plugins must be able to extend the Popup menu (secondary click over a node).

Should split leoTree.tree.OnPopup into tree.createPopupMenu and tree.showPopupMenu:

@color

def OnHeadlineRightClick(self,event=None):
	try:
		v = self ; c = v.commands
		if not doHook("headrclick1",c=c,v=v,event=event):
			self.commands.tree.OnActivate(self)
			self.commands.tree.createPopupMenu(self,event)
			doHook("headrclick2",c=c,v=v,event=event)
			self.commands.tree.showPopupMenu(self,event)
	except:
		es_event_exception("headrclick")

@nocolor

By this edit, the headrclick2 hook will be able to add elements to the recently
Popup menu created.</t>
<t tx="T1769">def OnPopup (self,v,event):
	
	"""Handle right-clicks in the outline."""
	
	# Note: "headrclick" hooks handled by vnode callback routine.

	if event != None:
		c = self.commands
		if not doHook("create-popup-menu",c=c,v=v,event=event):
			self.createPopupMenu(event)
		if not doHook("enable-popup-menu-items",c=c,v=v,event=event):
			self.enablePopupMenuItems(v,event)
		if not doHook("show-popup-menu",c=c,v=v,event=event):
			self.showPopupMenu(event)

	return "break"</t>
<t tx="T1770">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

	self.popupMenu.unpost()
	
</t>
<t tx="T1771">def createPopupMenu (self,event):
	
	c = self.commands ; frame = c.frame
	
	# If we are going to recreate it, we had better destroy it.
	if self.popupMenu:
		self.popupMenu.destroy()
		self.popupMenu = None
	
	self.popupMenu = menu = Tkinter.Menu(app.root, tearoff=0)
	
	# Add the Open With entries if they exist.
	if app.openWithTable:
		frame.createMenuEntries(menu,app.openWithTable,openWith=1)
		table = (("-",None,None),)
		frame.createMenuEntries(menu,table)
		
	&lt;&lt; Create the menu table &gt;&gt;
	frame.createMenuEntries(menu,table)</t>
<t tx="T1772">table = (
	("&amp;Read @file Nodes",None,frame.OnReadAtFileNodes),
	("&amp;Write @file Nodes",None,frame.OnWriteAtFileNodes),
	("-",None,None),
	("&amp;Tangle","Shift+Ctrl+T",frame.OnTangle),
	("&amp;Untangle","Shift+Ctrl+U",frame.OnUntangle),
	("-",None,None),
	("Toggle Angle &amp;Brackets","Ctrl+B",frame.OnToggleAngleBrackets),
	("-",None,None),
	("Cut Node","Shift+Ctrl+X",frame.OnCutNode),
	("Copy Node","Shift+Ctrl+C",frame.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",frame.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",frame.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",frame.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",frame.OnCloneNode),
	("Sort C&amp;hildren",None,frame.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",frame.OnSortSiblings),
	("-",None,None),
	("Contract Parent","Alt+0",frame.OnContractParent))</t>
<t tx="T1773">def enablePopupMenuItems (self,v,event):
	
	"""Enable and disable items in the popup menu."""
	
	c = self.commands ; menu = self.popupMenu

	&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
	isAtFile = choose(isAtFile,1,0)
	isAtRoot = choose(isAtRoot,1,0)
	canContract = v.parent() != None
	canContract = choose(canContract,1,0)
	
	for name in ("Read @file Nodes", "Write @file Nodes"):
		enableMenu(menu,name,isAtFile)
	for name in ("Tangle", "Untangle"):
		enableMenu(menu,name,isAtRoot)
	
	enableMenu(menu,"Cut Node",c.canCutOutline())
	enableMenu(menu,"Delete Node",c.canDeleteHeadline())
	enableMenu(menu,"Paste Node",c.canPasteOutline())
	enableMenu(menu,"Sort Children",c.canSortChildren())
	enableMenu(menu,"Sort Siblings",c.canSortSiblings())
	enableMenu(menu,"Contract Parent",c.canContractParent())</t>
<t tx="T1774">isAtFile = false ; isAtRoot = false
v2 = v ; next = v.nodeAfterTree()

while (not isAtFile or not isAtRoot) and v2 != None and v2 != next:
	if (
		v2.isAtFileNode() or
		v.isAtRawFileNode() or
		v.isAtSilentFileNode() or
		v.isAtNoSentinelsFileNode()):
		isAtFile = true

	isRoot, junk = is_special(v2.bodyString(),0,"@root")
	if isRoot:
		isAtRoot = true
	v2 = v2.threadNext()</t>
<t tx="T1775">def showPopupMenu (self,event):
	
	"""Show a popup menu."""
	
	c = self.commands ; menu = self.popupMenu

	if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
		menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
	
	menu.post(event.x_root, event.y_root)

	# Make certain we have focus so we know when we lose it.
	# I think this is OK for all OSes.
	set_focus(c,menu)</t>
<t tx="T1776">def OnHeadlineClick(self,event=None):
	try:
		v = self ; c = v.commands
		if not doHook("headclick1",c=c,v=v,event=event):
			c.frame.OnActivateHeadline(v)
		doHook("headclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headclick")
	
def OnHeadlineRightClick(self,event=None):
	try:
		v = self ; c = v.commands
		if not doHook("headrclick1",c=c,v=v,event=event):
			c.frame.OnActivateHeadline(v)
			c.frame.OnPopup(self,event)
		doHook("headrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headrclick")</t>
<t tx="T1777">@nocolor
Developers
http://sourceforge.net/forum/message.php?msg_id=2085578
By: bwmulder

I looked some more at the code. The following remarks are based on eye inspection
only, not testing.

Here is what I found:

1.
def createOpenWithTempFile (self, v, ext):

There is no point in storing the closed file in the dict. As far as I can tell
this is never used anywhere. What good could it be?

2. You are inconsistent with calling os.path.getmtime. In 

&lt;&lt; create or recreate temp file as needed &gt;&gt; 

and frame.createOpenWithTempFile, 

you have a try: catch: block for this function. In the plugin open_with.py you
write:

time = os.path.getmtime(path)
if time and time != dict.get("time"):

According to the documentation, getmtime either succeeds, or raises an exception.
If you get an exception, then the file is presumably no good anyway, and the
whole update mechanism would not work. In this case I would just delete the
file, with a message to the user.

3. Your original question: 

I think the code is almost OK. If the headstring or the language of the node
changes, then the second 'openwith'  call to openWithTempFilePath will return
a different path.

&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt; will leave path
== None,

and in 
&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt; 

path = self.createOpenWithTempFile(v,ext), createOpenWithTempFile will correctly
delete the old entry from openWithFiles, but the old file will not be deleted.

Maybe you should use:

&lt;&lt; remove previous entry from a.openWithFiles if it exists &gt;&gt;:

for d in a.openWithFiles[:]: # 6/30/03
.v = d.get("v")
..if v.t == v2.t:
...if d.get(path) == path:
....print "removing previous entry in a.openWithFiles for",v
....a.openWithFiles.remove(d)
...else:
....a.destroyOpenWithFileWithDict(d)

4. I guess mayhem will come to those who update a file whose node has been
deleted?

</t>
<t tx="T1778">@ 

Solution:  The problem was in tree.OnDeactivate.  The calls to tree.endEditLabel() and tree. self.dimEditLabel() were interfering with the double-click logic.

What I did:

- Removed unused frame.active and frame.activeFrame ivars.

- Added the following routines to leoGlobals.py.
	- get_focus.
	- openWithFileName (allows startup code to create a frame without an existing frame.)

- Changed startup code so that
	- Only one window is ever created on startup.
	- Windows are not witdrawn when they are created.

- Changed set_focus so it only call widget.focus_set if there has been a real change in focus.
	- This has no effect.</t>
<t tx="T1779"></t>
<t tx="T1780"># Called from quit logic and when user closes the window.
# Returns true if the close happened.

def OnCloseLeoEvent(self):

	app.closeLeoWindow(self)</t>
<t tx="T1781">def OnControlKeyDown (self,event=None):
	
	self.controlKeyIsDown = true
	
def OnControlKeyUp (self,event=None):

	self.controlKeyIsDown = false
</t>
<t tx="T1782"># Handle the "visibility" event and attempt to attach the Leo icon.
# This code must be executed whenever the window is redrawn.

def OnVisibility (self,event):

	if self.icon and event.widget is self.top:

		# print "OnVisibility"
		self.icon.attach(self.top)</t>
<t tx="T1783">def OnActivateBody (self,event=None):

	try:
		c = self.commands
		app.setLog(self,"OnActivateBody")
		self.tree.OnDeactivate()
		set_focus(c,c.body)
	except:
		es_event_exception("activate body")


</t>
<t tx="T1784">def OnActivateLeoEvent(self,event=None):

	try:
		app.setLog(self,"OnActivateLeoEvent")
	except:
		es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):

	try:
		app.setLog(None,"OnDeactivateLeoEvent")
	except:
		es_event_exception("deactivate Leo")</t>
<t tx="T1785">def OnActivateLog (self,event=None):

	try:
		app.setLog(self,"OnActivateLog")
		self.tree.OnDeactivate()
	except:
		es_event_exception("activate log")</t>
<t tx="T1786">def OnActivateTree (self,event=None):

	try:
		c = self.commands
		app.setLog(self,"OnActivateTree")
		self.tree.undimEditLabel()
		set_focus(c,c.frame.body) # 7/12/03
	except:
		es_event_exception("activate tree")
</t>
<t tx="T1787">def OnBodyClick (self,event=None):

	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodyclick1",c=c,v=v,event=event):
			self.OnActivateBody(event=event)
		doHook("bodyclick2",c=c,v=v,event=event)
	except:
		es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
	
	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodyrclick1",c=c,v=v,event=event):
			pass # By default Leo does nothing.
		doHook("bodyrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")</t>
<t tx="T1788">def OnBodyDoubleClick (self,event=None):

	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodydclick1",c=c,v=v,event=event):
			if event: # 8/4/02: prevent wandering insertion point.
				index = "@%d,%d" % (event.x, event.y) # Find where we clicked
			body = self.body
			start = body.index(index + " wordstart")
			end = body.index(index + " wordend")
			setTextSelection(self.body,start,end)
		doHook("bodydclick1",c=c,v=v,event=event)
	except:
		es_event_exception("bodydclick")

	return "break" # Inhibit all further event processing.</t>
<t tx="T1789"># Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):
	
	trace()

	try:
		if event.delta &lt; 1:
			self.canvas.yview(Tkinter.SCROLL, 1, Tkinter.UNITS)
		else:
			self.canvas.yview(Tkinter.SCROLL, -1, Tkinter.UNITS)
	except:
		es_event_exception("scroll wheel")

	return "break"</t>
<t tx="T1790">def OnDeactivate (self,event=None):
	
	"""Deactivate the tree pane, dimming any headline being edited."""

	c = self.commands
	focus = get_focus(c.frame.top)

	# Bug fix: 7/13/03: Only do this as needed.
	# Doing this on every click would interfere with the double-clicking.
	if focus not in (c.frame.body, c.frame.log):
		try:
			# trace(focus)
			self.endEditLabel()
			self.dimEditLabel()
		except:
			es_event_exception("deactivate tree")</t>
<t tx="T1791"># These convenience routines just call the corresponding method of the app.gui class.

def get_focus(top):
	"""Return the widget that has focus, or the body widget if None."""
	return app.gui.get_focus(top)
	
def set_focus(commands,widget):
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	return app.gui.set_focus(commands,widget)
	
def force_focus(commands,widget):
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	return app.gui.force_focus(commands,widget)
</t>
<t tx="T1792"></t>
<t tx="T1793">def abortEditLabelCommand (self):
	
	v = self.currentVnode
	# trace(v)
	if self.revertHeadline and v.edit_text() and v == self.editVnode:
		
		# trace(`self.revertHeadline`)
		v.edit_text().delete("1.0","end")
		v.edit_text().insert("end",self.revertHeadline)
		self.idle_head_key(v) # Must be done immediately.
		self.revertHeadline = None
		self.select(v)
		if v and len(v.t.joinList) &gt; 0:
			# 3/26/03: changed redraw_now to force_redraw.
			self.force_redraw() # force a redraw of joined headlines.</t>
<t tx="T1794"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	v = self.currentVnode
	self.setDisabledLabelState(v)

def undimEditLabel (self):

	v = self.currentVnode
	self.setSelectedLabelState(v)</t>
<t tx="T1795"># Start editing v.edit_text()

def editLabel (self, v):

	# End any previous editing
	if self.editVnode and v != self.editVnode:
		self.endEditLabel()
		self.revertHeadline = None
		
	self.editVnode = v # 7/7/03.

	# Start editing
	if v and v.edit_text():
		# trace(`v`)
		self.setNormalLabelState(v)
		self.revertHeadline = v.headString()</t>
<t tx="T1796"># End editing for self.editText

def endEditLabel (self):

	c = self.commands ; v = self.editVnode
	# trace(v)
	if v and v.edit_text():
		self.setUnselectedLabelState(v)
		self.editVnode = None
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		# 3/26/03: changed redraw_now to force_redraw.
		self.force_redraw() # force a redraw of joined and ancestor headlines.
	set_focus(c,c.body) # 10/14/02
		
def endEditLabelCommand (self):

	c = self.commands ; v = self.editVnode
	# trace(v)
	if v and v.edit_text():
		self.select(v)
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		# 3/26/03: changed redraw_now to force_redraw.
		self.force_redraw() # force a redraw of joined headlines.
	set_focus(c,c.body) # 10/14/02</t>
<t tx="T1797">def expandAllAncestors (self,v):

	redraw_flag = false
	p = v.parent()
	while p:
		if not p.isExpanded():
			p.expand()
			redraw_flag = true
		p = p.parent()
	return redraw_flag</t>
<t tx="T1798">def setNormalLabelState (self,v): # selected, editing
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set editing headline colors &gt;&gt;
		v.edit_text().tag_remove("sel","1.0","end")
		v.edit_text().tag_add("sel","1.0","end")
		set_focus(self.commands,v.edit_text())

def setDisabledLabelState (self,v): # selected, disabled
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,v): # selected, not editing
	self.setDisabledLabelState(v)

def setUnselectedLabelState (self,v): # not selected.
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set unselected headline colors &gt;&gt;</t>
<t tx="T1799">config = app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
	fg,bg = "black","white"
	
try:
	if selfg and selbg:
		v.edit_text().configure(
			selectforeground=selfg,selectbackground=selbg,
			state="normal",highlightthickness=1,fg=fg,bg=bg)
	else:
		v.edit_text().configure(
			state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1800">config = app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
	fg,bg = "black","gray80"

try:
	v.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1801">config = app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	v.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1802">def openWithFileName(fileName,old_c=None):
	
	"""Create a Leo Frame for the indicated fileName if the file exists."""
	
	from leoFrame import LeoFrame
	assert(app.config)

	if not fileName or len(fileName) == 0:
		return false, None

	# Create a full normalized path name.
	# Display the file name with case intact.
	fileName = os.path.join(os.getcwd(), fileName)
	fileName = os.path.normpath(fileName)
	oldFileName = fileName 
	fileName = os.path.normcase(fileName)

	# If the file is already open just bring its window to the front.
	list = app.windowList
	for frame in list:
		fn = os.path.normcase(frame.commands.mFileName)
		fn = os.path.normpath(fn)
		if fileName == fn:
			frame.deiconify()
			app.setLog(frame,"OpenWithFileName")
			# es("This window already open")
			return true, frame
			
	fileName = oldFileName # Use the idiosyncratic file name.

	try:
		file = open(fileName,'r')
		if file:
			c,frame = app.gui.newLeoCommanderAndFrame(fileName)
			if not doHook("open1",
				old_c=old_c,new_c=c,fileName=fileName):
				app.setLog(frame,"OpenWithFileName") # 5/12/03
				app.lockLog() # 6/30/03
				frame.commands.fileCommands.open(file,fileName) # closes file.
				app.unlockLog() # 6/30/03
			frame.openDirectory=os.path.dirname(fileName)
			frame.updateRecentFiles(fileName)
			doHook("open2",
				old_c=old_c,new_c=frame.commands,fileName=fileName)
			return true, frame
		else:
			es("can not open: " + fileName,color="red")
			return false, None
	except IOError:
		es("can not open: " + fileName, color="blue")
		return false, None
	except:
		es("exceptions opening: " + fileName,color="red")
		es_exception()
		if 0: # Do not do this here!
			if frame: app.gui.destroyLeoFrame(frame)
		return false, None
</t>
<t tx="T1803">@nocolor
 cuttin' and pastin'   
2003-07-01 21:02
Developers

Select some text. Copy. Now select some other text. Paste. Note how the copied text gets pasted in AFTER the selected text. Is this the correct behavior? Most apps, when I do this operation it REPLACES the selected text with the copied text, places my curser just to the right of the inserted text and leaves nothing selected after the operation. 

This isn't new behavior, its how it worked in 3.11 (I just checked). Its just a bit strange. 

Sorry, more small stuff. Overall the beta is a big improvement. 

- ordinarius  

abc xyz</t>
<t tx="T1804">@nocolor
Open Discussion
 RE: UPPERCASE bug   
2003-07-05 19:24  
Still unable to import source code files with an upper case extension. Using 3.12 beta 1 on XP. 

Also, can't import .cxx files. Looks like line 129 in 
leoImport.py should be changed to: 

elif ext == ".c" or ext == ".cpp" or ext == ".cxx":

@color</t>
<t tx="T1805">def createOutline (self,fileName,parent):

	c = self.commands ; current = c.currentVnode()
	junk, self.fileName = os.path.split(fileName) # junk/fileName
	self.methodName, ext = os.path.splitext(self.fileName) # methodName.fileType
	self.fileType = ext
	self.setEncoding()
	# trace(`self.fileName`) ; trace(`self.fileType`)
	# All file types except the following just get copied to the parent node.
	# Note: we should _not_ import header files using this code.
	ext = ext.lower()
	appendFileFlag = ext not in (
		".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
	&lt;&lt; Read file into s &gt;&gt;
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	if self.treeType == "@file":
		v.initHeadString("@file " + self.fileName)
	else:
		v.initHeadString(self.fileName)
		
	self.rootLine = choose(self.treeType=="@file","","@root "+self.fileName+'\n')

	if appendFileFlag:
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	elif ext in (".c", ".cpp", ".cxx"):
		self.scanCText(s,v)
	elif ext == ".el":
		self.scanElispText(s,v)
	elif ext == ".java":
		self.scanJavaText(s,v,true) #outer level
	elif ext == ".pas":
		self.scanPascalText(s,v)
	elif ext in (".py", ".pyw"):
		self.scanPythonText(s,v)
	elif ext == ".php":
		self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
	else:
		es("createOutline: can't happen")
	return v</t>
<t tx="T1806">try:
	file = open(fileName)
	s = file.read()
	s = toUnicode(s,self.encoding)
	file.close()
except:
	es("can not read " + fileName)
	es_exception()
	return None</t>
<t tx="T1807"></t>
<t tx="T1808"></t>
<t tx="T1809">File "src\leoColor.py", line 1403, in colorizeAnyLanguage
    new_states.append(old_states[j])
	
IndexError: list index out of range

The fix might be the following in  &lt; &lt; incrementally color the text &gt; &gt;

# 6/30/03: make a copies of everything
old_lines = self.lines[:]
old_states = self.states[:]
new_lines = lines[:]
	
I suspect that the old_states was being changed improperly as the result of changes to new_states.  We shall see.
</t>
<t tx="T1810">@  Each line has a starting state.  The starting state for the first line is always "normal".

We need remember only self.lines and self.states between colorizing.  It is not necessary to know where the text comes from, only what the previous text was!  We must always colorize everything when changing nodes, even if all lines match, because the context may be different.

We compute the range of lines to be recolored by comparing leading lines and trailing lines of old and new text.  All other lines (the middle lines) must be colorized, as well as any trailing lines whose states may have changed as the result of changes to the middle lines.
@c

# trace("incremental")

# 6/30/03: make a copies of everything
old_lines = self.lines[:]
old_states = self.states[:]
new_lines = lines[:]
new_states = []

new_len = len(new_lines)
old_len = len(old_lines)

if new_len == 0:
	self.states = []
	self.lines = []
	return

# Bug fix: 11/21/02: must test against None.
if leading != None and trailing != None:
	# print "leading,trailing:",leading,trailing
	leading_lines = leading
	trailing_lines = trailing
else:
	&lt;&lt; compute leading, middle &amp; trailing lines &gt;&gt;
	
middle_lines = new_len - leading_lines - trailing_lines
# print "middle lines", middle_lines

&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;
&lt;&lt; initialize new states &gt;&gt;
&lt;&lt; colorize until the states match &gt;&gt;</t>
<t tx="T1811">@ The leading lines are the leading matching lines.  The trailing lines are the trailing matching lines.  The middle lines are all other new lines.  We will color at least all the middle lines.  There may be no middle lines if we delete lines.
@c

min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading_lines = i

if leading_lines == new_len:
	# All lines match, and we must color _everything_.
	# (several routine delete, then insert the text again,
	# deleting all tags in the process).
	# print "recolor all"
	leading_lines = trailing_lines = 0
else:
	i = 0
	while i &lt; min_len - leading_lines:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing_lines = i
</t>
<t tx="T1812">@ 11/19/02: Changing @color or @nocolor directives requires we recolor all leading states as well.
@c

if trailing_lines == 0:
	m1 = new_lines[leading_lines:]
	m2 = old_lines[leading_lines:]
else:
	m1 = new_lines[leading_lines:-trailing_lines]
	m2 = old_lines[leading_lines:-trailing_lines]
m1.extend(m2) # m1 now contains all old and new middle lines.
if m1:
	for s in m1:
		assert(isUnicode(s))
		i = skip_ws(s,0)
		if match_word(s,i,"@color") or match_word(s,i,"@nocolor"):
			leading_lines = 0
			break
</t>
<t tx="T1813"># Copy the leading states from the old to the new lines.
i = 0
while i &lt; leading_lines and i &lt; old_len: # 12/8/02
	new_states.append(old_states[i])
	i += 1
	
# We know the starting state of the first middle line!
if middle_lines &gt; 0 and i &lt; old_len:
	new_states.append(old_states[i])
	i += 1
	
# Set the state of all other middle lines to "unknown".
first_trailing_line = new_len - trailing_lines
while i &lt; first_trailing_line:
	new_states.append("unknown")
	i += 1

# Copy the trailing states from the old to the new lines.
j = old_len - trailing_lines
while j &lt; old_len and j &lt; len(old_states):
	new_states.append(old_states[j])
	j += 1
	i += 1 # for the assert below.

while j &lt; len(old_states):
	new_states.append("unknown")
	j += 1
	i += 1 # for the assert below.
	
# A crucial assertion.  If it fails we won't handle continued states properly.
assert(i == new_len)
	# Step 1 writes leading_lines lines
	# Step 2 writes (new_len - trailing_lines - leading_lines) lines.
	# Step 3 writes trailing_lines lines.

# print "i:", i
if 0:
	for i in xrange(len(new_lines)):
		print new_states[i],new_lines[i]</t>
<t tx="T1814"># Colorize until the states match.
# All middle lines have "unknown" state, so they will all be colored.

# Start in the state _after_ the last leading line, which may be unknown.
i = leading_lines
while i &gt; 0:
	if i &lt; old_len and i &lt; new_len:
		state = new_states[i]
		assert(state!="unknown")
		break
	else:
		i -= 1

if i == 0:
	# Color plain text unless we are under the control of @nocolor.
	# state = choose(self.flag,"normal","nocolor")
	state = self.setFirstLineState()
	new_states[0] = state

# The new_states[] will be "unknown" unless the lines match,
# so we do not need to compare lines here.
while i &lt; new_len:
	self.line_index = i + 1
	state = self.colorizeLine(new_lines[i],state)
	i += 1
	# Set the state of the _next_ line.
	if i &lt; new_len and state != new_states[i]:
		new_states[i] = state
	else: break
	
# Update the ivars
self.states = new_states
self.lines = new_lines</t>
<t tx="T1815">@nocolor

What I did:
	
- removed event param from OnOpenWith.
- Created an Open With Submenu in &lt;&lt; create the top-level file entries &gt;&gt;
	This has the effect of not allowing a shortcut for this menu.
- Use app().hasOpenWithMenu to enable or disable Open With menu.
- Removed Shift-Control-O setting in leoConfig.leo/.txt.

@color</t>
<t tx="T1816"></t>
<t tx="T1817"># The following was improperly indented in @nosentinel files.  The expansion of &lt;&lt; class shape declarations &gt;&gt; was indented twice.

class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls
	
What I did:
	
1. Added this code to &lt;&lt; put possible section reference &gt;&gt;:

	if not self.sentinels:
		while len(s2) and s2[-1] in (' ','\t'):
			s2 = s2[:-1]
			
2. Created self.putBuffered to change tabs to blanks if the tabwidth is negative.
			
3. Changed most calls to self.os to self.putBuffered.</t>
<t tx="T1818">@ 

Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:

- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="T1819">def setLog (self,log,tag=""):
	"""set the frame to which log messages will go"""
	
	# print "setLog:",tag,"locked:",self.logIsLocked,`log`
	if not self.logIsLocked:
		self.log = log
		
def lockLog(self):
	"""Disable changes to the log"""
	self.logIsLocked = true
	
def unlockLog(self):
	"""Enable changes to the log"""
	self.logIsLocked = false</t>
<t tx="T1820">@ Event handlers must not assume anything about when they are called.

What I did:

- idle_redraw does nothing when dragging.
- v.OnEndDrag now always calls tree.OnEndDrag.
- tree.OnEndDrag now checks to see if tree.drag_v is still valid.
- Converted id from tuple to int in tree.OnIconClick.
- Always clear redrawScheduled ivar in tree.idle_redraw.</t>
<t tx="T1821">@ Important note: most hooks are created in the vnode callback routines, _not_ here.
</t>
<t tx="T1822">def OnActivate (self,v,event=None):

	try:
		c = self.commands
		&lt;&lt; activate this window &gt;&gt;
	except:
		es_event_exception("activate tree")</t>
<t tx="T1823">c = self.commands

if v == self.currentVnode:
	if self.active:
		self.editLabel(v)
	else:
		self.undimEditLabel()
		set_focus(c,self.canvas) # Essential for proper editing.
else:
	self.select(v)
	if v.t.insertSpot != None: # 9/1/02
		c.body.mark_set("insert",v.t.insertSpot)
		c.body.see(v.t.insertSpot)
	else:
		c.body.mark_set("insert","1.0")
	set_focus(c,c.body)

self.active = true</t>
<t tx="T1824"># Called on click in box and double-click in headline.

def OnBoxClick (self,v):

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.commands

	if v.isExpanded():
		v.contract()
	else:
		v.expand()

	self.active = true
	self.select(v)
	set_focus(c,c.body) # 7/12/03
	self.redraw()</t>
<t tx="T1825">def findVnodeWithIconId (self,id):
	
	# Due to an old bug, id may be a tuple.
	try:
		return self.icon_id_dict.get(id[0])
	except:
		return self.icon_id_dict.get(id)
</t>
<t tx="T1826">def OnContinueDrag(self,v,event):

	try:
		&lt;&lt; continue dragging &gt;&gt;
	except:
		es_event_exception("continue drag")</t>
<t tx="T1827"># trace(`v`)
assert(v == self.drag_v)

canvas = self.canvas
frame = self.commands.frame

if event:
	x,y = event.x,event.y
else:
	x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
	if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

if 0: # no longer used.
	canvas_x = canvas.canvasx(x)
	canvas_y = canvas.canvasy(y)
	id = self.canvas.find_closest(canvas_x,canvas_y)

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
	&lt;&lt; scroll the canvas as needed &gt;&gt;</t>
<t tx="T1828"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
	lo, hi = frame.treeBar.get()
	n = self.savedNumberOfVisibleNodes
	line_frac = 1.0 / float(n)
	frac = choose(y &lt; 0, lo - line_frac, lo + line_frac)
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	# es("lo,hi,frac:" + `lo` + " " + `hi` + " " + `frac`)
	canvas.yview("moveto", frac)
	
	# Queue up another event to keep scrolling while the cursor is outside the canvas.
	lo, hi = frame.treeBar.get()
	if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
		canvas.after_idle(self.OnContinueDrag,v,None) # Don't propagate the event.</t>
<t tx="T1829"># This works around an apparent Tk bug.

def OnControlT (self,event=None):

	# If we don't inhibit further processing the Tx.Text widget switches characters!
	return "break"</t>
<t tx="T1830"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,v,event):

	# Note: "drag" hooks handled by vnode callback routine.
	# trace(event)
	
	c = self.commands
	assert(v == self.drag_v)

	if not event:
		return

	if not self.dragging:
		windowPref = app.config.getBoolWindowPref
		# Only do this once: greatly speeds drags.
		self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
		self.dragging = true
		if windowPref("allow_clone_drags"):
			self.controlDrag = c.frame.controlKeyIsDown
			if windowPref("look_for_control_drag_on_mouse_down"):
				if windowPref("enable_drag_messages"):
					if self.controlDrag:
						es("dragged node will be cloned")
					else:
						es("dragged node will be moved")
		else: self.controlDrag = false
		self.canvas['cursor'] = "hand2" # "center_ptr"

	self.OnContinueDrag(v,event)</t>
<t tx="T1831">def OnEndDrag(self,v,event):
	
	"""Tree end-of-drag handler called from vnode event handler."""
	
	# trace(v)
	
	# 7/10/03: Make sure we are still dragging.
	if not self.drag_v:
		return

	assert(v == self.drag_v)
	c = self.commands ; canvas = self.canvas ; config = app.config

	if event:
		&lt;&lt; set vdrag, childFlag &gt;&gt;
		if config.getBoolWindowPref("allow_clone_drags"):
			if not config.getBoolWindowPref("look_for_control_drag_on_mouse_down"):
				self.controlDrag = c.frame.controlKeyIsDown

		if vdrag and vdrag != v:
			if self.controlDrag: # Clone v and move the clone.
				if childFlag:
					c.dragCloneToNthChildOf(v,vdrag,0)
				else:
					c.dragCloneAfter(v,vdrag)
			else: # Just drag v.
				if childFlag:
					c.dragToNthChildOf(v,vdrag,0)
				else:
					c.dragAfter(v,vdrag)
		else:
			if v and self.dragging:
				pass # es("not dragged: " + v.headString())
			if 0: # Don't undo the scrolling we just did!
				self.idle_scrollTo(v)
	
	# 1216/02: Reset the old cursor by brute force.
	self.canvas['cursor'] = "arrow"

	if self.drag_id:
		canvas.tag_unbind(self.drag_id , "&lt;B1-Motion&gt;")
		canvas.tag_unbind(self.drag_id , "&lt;Any-ButtonRelease-1&gt;")
		self.drag_id = None
		
	self.dragging = false
	self.drag_v = None</t>
<t tx="T1832">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="T1833">def OnIconClick (self,v,event):

	tree = self ; canvas = tree.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			self.drag_v = v
			self.drag_id = id
			if 1: # Use vnode callbacks.
				id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", v.OnDrag)
				id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", v.OnEndDrag)
			else:
				&lt;&lt; define drag callbacks &gt;&gt;
				id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", onDragCallback)
				id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", onEndDragCallback)
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
			self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)
	tree.select(v)
	
def OnIconRightClick (self,v,event):

	self.select(v)</t>
<t tx="T1834">def onDragCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if tree.dragging:
			if not doHook("dragging1",c=c,v=v,event=event):
				tree.OnDrag(v,event)
			doHook("dragging2",c=c,v=v,event=event)
		else:
			if not doHook("drag1",c=c,v=v,event=event):
				tree.OnDrag(v,event)
			doHook("drag2",c=c,v=v,event=event)
	except:
		es_event_exception("drag")
		
def onEndDragCallback(event,tree=tree,v=v):
	try:
		c = v.commands
		if not doHook("enddrag1",c=c,v=v,event=event):
			tree.OnEndDrag(v,event)
		doHook("enddrag2",c=c,v=v,event=event)
	except:
		es_event_exception("enddrag")
		
		
</t>
<t tx="T1835">def OnIconDoubleClick (self,v,event=None):

	# Note: "icondclick" hooks handled by vnode callback routine.

	c = self.commands
	s = v.headString().strip()
	if match_word(s,0,"@url"):
		if not doHook("@url1",c=c,v=v):
			url = s[4:].strip()
			&lt;&lt; stop the url after any whitespace &gt;&gt;
			&lt;&lt; check the url; return if bad &gt;&gt;
			&lt;&lt; pass the url to the web browser &gt;&gt;
		doHook("@url2",c=c,v=v)</t>
<t tx="T1836"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
	if 0: # No need for a warning.  Assume everything else is a comment.
		es("ignoring characters after space in url:"+url[i:])
		es("use %20 instead of spaces")
	url = url[:i]
</t>
<t tx="T1837">if not url or len(url) == 0:
	es("no url following @url")
	return
	
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
	url = 'http://' + url
if not re.match(urlPattern,url):
	es("invalid url: "+url)
	return
</t>
<t tx="T1838">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file:///home/me/todolist.html
@c

try:
	import os
	import webbrowser
	os.chdir(app.loadDir)
	# print "url:",url
	webbrowser.open(url)
except:
	es("exception opening " + url)
	es_exception()</t>
<t tx="T1839">def OnDrag(self,event=None):
	
	# trace()
	
	try:
		v = self ; c = v.commands
		if c.frame.dragging():
			if not doHook("dragging1",c=c,v=v,event=event):
				c.frame.OnDrag(v,event)
			doHook("dragging2",c=c,v=v,event=event)
		else:
			if not doHook("drag1",c=c,v=v,event=event):
				c.frame.OnDrag(v,event)
			doHook("drag2",c=c,v=v,event=event)
	except:
		es_event_exception("drag")</t>
<t tx="T1840">def OnEndDrag(self,event=None):
	
	"""Vnode end-drag handler."""
	
	# trace()

	try:
		v = self ; c = v.commands
		# 7/10/03: Always call frame.OnEndDrag, regardless of state.
		if not doHook("enddrag1",c=c,v=v,event=event):
			c.frame.OnEndDrag(v,event)
		doHook("enddrag2",c=c,v=v,event=event)
	except:
		es_event_exception("enddrag")</t>
<t tx="T1841">@ These callbacks are vnode methods so we can pass the vnode back to the tree class.
</t>
<t tx="T1842"># Called when the box is clicked.

def OnBoxClick(self,event=None):

	try:
		v = self ; c = v.commands
		if not doHook("boxclick1",c=c,v=v,event=event):
			self.commands.frame.OnBoxClick(v)
		doHook("boxclick2",c=c,v=v,event=event)
	except:
		es_event_exception("boxclick")</t>
<t tx="T1843">def OnHeadlineKey (self,event=None):

	try:
		v = self ; c = v.commands
		if not doHook("headkey1",c=c,v=v,event=event):
			c.frame.OnHeadlineKey(v,event)
		doHook("headkey2",c=c,v=v,event=event)
	except:
		es_event_exception("headkey")</t>
<t tx="T1844">def OnHyperLinkControlClick (self,event):

	try:
		v = self ; c = v.commands
		if not doHook("hypercclick1",c=c,v=v,event=event):
			c.beginUpdate()
			c.selectVnode(v)
			c.endUpdate()
			c.body.mark_set("insert","1.0")
		doHook("hypercclick2",c=c,v=v,event=event)
	except:
		es_event_exception("hypercclick")</t>
<t tx="T1845">def OnHyperLinkEnter (self,event=None):

	try:
		v = self ; c = v.commands
		if not doHook("hyperenter1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.body.tag_config(v.tagName,background="green")
		doHook("hyperenter2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperenter")</t>
<t tx="T1846">def OnHyperLinkLeave (self,event=None):

	try:
		v = self ; c = v.commands
		if not doHook("hyperleave1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.body.tag_config(v.tagName,background="white")
		doHook("hyperleave2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperleave")</t>
<t tx="T1847">def OnIconClick(self,event=None):
	try:
		v = self ; c = v.commands
		if not doHook("iconclick1",c=c,v=v,event=event):
			c.frame.OnIconClick(v,event)
		doHook("iconclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconclick")
	
def OnIconRightClick(self,event=None):
	try:
		v = self ; c = v.commands
		if not doHook("iconrclick1",c=c,v=v,event=event):
			c.frame.OnIconRightClick(v,event)
		doHook("iconrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")
</t>
<t tx="T1848">def OnIconDoubleClick(self,event=None):

	try:
		v = self ; c = v.commands
		if not doHook("icondclick1",c=c,v=v,event=event):
			c.frame.OnIconDoubleClick(v,event)
		doHook("icondclick2",c=c,v=v,event=event)
	except:
		es_event_exception("icondclick")
</t>
<t tx="T1849"></t>
<t tx="T1850">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2083188
By: riotnrrrd

There are two problems with 3.12 beta 1 (on Linux):

The 'open with' plugin only works when Leo has been opened with no file.
When a file is opened, the 'open with' option in the 'file' menu only offers
'Shift+Control+O', but nothing happens when it's pressed. The log pane says:

exception in app().hookFunction
AttributeError: 'NoneType' object has no attribute 'configure'

and there is the following traceback:

 Traceback (most recent call last):
  File "/home/opt/leo/leo-3.12beta1/src/leoGlobals.py", line 2174, in doHook
    return a.hookFunction(tag,keywords)
  File "/home/opt/leo/leo-3.12beta1/src/leoPlugins.py", line 27, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "/home/opt/leo/leo-3.12beta1/src/leoPlugins.py", line 60, in
doHandlersForTag
    ret = handle_fn(tag,keywords)
  File "/home/opt/leo/leo-3.12beta1/plugins/nav_buttons.py", line 72, in
updateRecentSections
    info.updateNavButtons()
  File "/home/opt/leo/leo-3.12beta1/plugins/nav_buttons.py", line 243,
in updateNavButtons
    b.configure(image=image,state=state)
AttributeError: 'NoneType' object has no attribute 'configure'</t>
<t tx="T1851">def updateNavButtons (self):	

	d = self ; c = self.c
	
	# Make sure we have initialized properly.
	if not hasattr(d,"lt_nav_button") or not hasattr(d,"rt_nav_button"):
		return
		
	if not d.lt_nav_button or not d.rt_nav_button: # 6/30/03
		return
	
	b = d.lt_nav_button
	if c.beadPointer &gt; 0:
		image = self.lt_nav_enabled_image
		state = "normal"
	else:
		image = d.lt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
	
	b = d.rt_nav_button
	if c.beadPointer + 1 &lt; len(c.beadList):
		image =self.rt_nav_enabled_image
		state = "normal"
	else:
		image = self.rt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
</t>
<t tx="T1852"></t>
<t tx="T1853">@nocolor

When a new file is opened, the previous window doesn't close, cannot be closed, but closes when Leo is shut down. The following traceback is produced:

Exception in Tkinter callback
Traceback (most recent call last):
  File "/usr/lib/python2.2/lib-tk/Tkinter.py", line 1316, in __call__
    return apply(self.func, args)
  File "/home/opt/leo/leo-3.12beta1/src/leoFrame.py", line 1784, in &lt;lambda&gt;
    callback = lambda f=f,name=name:f.OnOpenRecentFile(name)
  File "/home/opt/leo/leo-3.12beta1/src/leoFrame.py", line 2397, in
OnOpenRecentFile
    self.destroy() # force the window to go away now.
AttributeError: LeoFrame instance has no attribute 'destroy'

Fix:  Created app().destroyWindow and call it from frame.OnOpenRecentFile, OnRevert, OnOpen.</t>
<t tx="T1854">def destroyWindow (self,frame):
	
	app = self ; top = frame.top # Remember this.
		
	app.destroyOpenWithFilesForFrame(frame)
	
	# 8/27/03: Recycle only if more than one window open
	if len(app.windowList) &gt; 1:
		app.destroyAllWindowObjects(frame)

	app.windowList.remove(frame)

	top.destroy() # force the window to go away now.</t>
<t tx="T1855"></t>
<t tx="T1856">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2089325
By: jasonic

[Leo 3.12 beta 1]

Wondering about @file refresh behavior...

I make edit changes to @files externally. Then select in Leo File Menu Read/Write..
"Read @file Nodes". But must click on some other Node first and then back again
before change is visible in bottom content pane. Same for right clicking on
a Node to call  "Read @file Nodes".

A more natural workflow would be if "Read @file Nodes" directly refreshed the
content pane without need for the extra Node clicking.

thanks
Jason
</t>
<t tx="T1857">def readAtFileNodes (self):

	c = self.commands ; current = c.currentVnode()
	c.atFileCommands.readAll(current,partialFlag=true)
	self.setAllJoinLinks(current) # 5/3/03
	c.initAllCloneBits() # 5/3/03
	c.redraw() # 4/4/03
	
	# 7/8/03: force an update of the body pane.
	current.setBodyStringOrPane(current.bodyString())
	c.frame.onBodyChanged(current,undoType=None)</t>
<t tx="T1858"></t>
<t tx="T1859">@nocolor

The sortSequence function breaks if two different tuples have the same key.  Fortunately, Python's sort function can do all the work of sortSequence provided that we sort on the first item of each tuple.</t>
<t tx="T1860">def sortTopLevel (self):
	
	# Create a list of vnode, headline tuples
	c = self ; v = root = c.rootVnode()
	if not v: return
	&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;
	pairs = []
	while v:
		pairs.append((v.headString().lower(), v))
		v = v.next()
	# Sort the list on the headlines.
	pairs.sort()
	sortedNodes = pairs
	# Move the nodes
	c.beginUpdate()
	h,v = sortedNodes[0]
	if v != root:
		v.moveToRoot(oldRoot=root)
	for h,next in sortedNodes[1:]:
		next.moveAfter(v)
		v = next
	c.endUpdate()</t>
<t tx="T1861"># Get the present list of children.
sibs = []
sib = c.rootVnode()
while sib:
	sibs.append(sib)
	sib = sib.next()
c.undoer.setUndoParams("Sort Top Level",v,sort=sibs)</t>
<t tx="T1862">@ignore

The &lt;&lt; remove previous entry from a.openWithFiles if it exists &gt;&gt; loop destroyed the previous value of dict.</t>
<t tx="T1863">@ What I did:
	
- added set_focus and force_focus utilities for better tracing.
- changed drawText so it calls setNormalLabelState when v == editVnode.
	idle_redraw no longer interferes with the headline being edited.
- setNormalLabelState now selects all text and calls set_focus.
- added callers keyword param to trace.
- simplified c.insertHeadline: it no longer has to avoid redraws.</t>
<t tx="T1864"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Outline"):

	c = self ; current = c.currentVnode()
	if not current: return

	c.beginUpdate()
	if 1: # inside update...
		if current.hasChildren() and current.isExpanded():
			v = current.insertAsNthChild(0)
		else:
			v = current.insertAfter()
		c.undoer.setUndoParams(op_name,v,select=current)
		v.createDependents() # To handle effects of clones.
		c.selectVnode(v)
		c.editVnode(v)
		v.setDirty() # Essential in Leo2.
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T1865"># Convert all args to strings.
# Print if tracing for the presently executing function has been enabled.

def trace (*args,**keys):
	
	callers = keys.get("callers",false)

	s = ""
	for arg in args:
		if type(arg) != type(""):
			arg = repr(arg)
		if len(s) &gt; 0:
			s = s + " " + arg
		else:
			s = arg
	message = s
	try: # get the function name from the call stack.
		f1 = sys._getframe(1) # The stack frame, one level up.
		code1 = f1.f_code # The code object
		name = code1.co_name # The code name
	except: name = ""
	if name == "?":
		name = "&lt;unknown&gt;"

	if callers:
		import traceback
		traceback.print_stack()
		
	if 1: # Print all traces.
		print name + ": " + message
	else: # Print only enabled traces.
		t = app.trace_list
		# tracepoint names starting with '-' must match exactly.
		minus = len(name) &gt; 0 and name[0] == '-'
		if minus: name = name[1:]
		if (not minus and '*' in t) or name.lower() in t:
			s = name + ": " + message
			if 1: print s
			else: es(s)
</t>
<t tx="T1866"></t>
<t tx="T1867">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2080849
Help forum

I get an error message when tangling: 

can't convert | to ISO-8859-1

the character is displayed as a box (which I am representing by |).  It is important
to fix this immediately, because when the automatic untangle happens to the
@file outline, that offending character will be (silently!) replaced by a question
mark, which is fairly untrackable in the text I am working on.

This is a tricky problem because some characters, such as the hyphen, can appear
exactly the same on the screen but have two different numeric representations.
So you type in one thing in one environment, paste from another, and it looks
identical but it isn't.

1) Is there any way to trap that error message and find out where the offending
character is?

Could one change how conversion errors are output? If in the output file the
error character were replaced by a marker (say: ?\xa0?, where a0 is its hex
number of the character), then it could be debugged fairly easily.
</t>
<t tx="T1868"></t>
<t tx="T1869">@nocolor

If there are nested nodes with the same name in a file, if you try and go to a
line in a later instance it will go to the last line in the earlier node.

The fix works, sort of.  Gnx's may make matters worse.  We shall see.
</t>
<t tx="T1870"></t>
<t tx="T1871">Leo took an exception reformatting the following.  The problem was that getBodyLines wasn't handling the new values returned by getTextSelection.

@color

@language plain
@pagewidth 72
@tabwidth 2

The intent of this tool is to provide 
an aid to memorization practice.  The 
tool is directed at memorization of 
prose or poetry, not music or 
mathematics.  It would probably not 
be useful for memorization of dialog.  The 
purpose of such memorization is 
to be able to recreate a chunk of 
text in your head or on paper, and perhaps verbally.

The steps might be as follows:</t>
<t tx="T1872">@ 7/11/03:  This constitutes a major changes to Leo's fundamental vnode code.  

v.copyTree now creates a free-standing tree that may be linked into an existing outline using any of the v.linkX routines.  This is a major simplification that was long overdue.

N.B.  Copied trees share tnodes with the original code.  It would be easy to make this optional, and at present all code expects tnodes to be shared.

N.B.  Nodes of the copied trees are _not_ joined to the original tree.  That is, the copied vnodes v do not appear in v.t.joinList.
</t>
<t tx="T1873">def clone (self):

	c = self ; v = c.currentVnode()
	if not v: return
	c.beginUpdate()
	clone = v.clone(v)
	c.initAllCloneBitsInTree(v) # 10/14/03
	clone.setDirty() # essential in Leo2
	c.setChanged(true)
	if c.validateOutline():
		c.selectVnode(clone)
		c.undoer.setUndoParams("Clone",clone)
	c.endUpdate() # updates all icons</t>
<t tx="T1874">def addTreeToJoinLists (self):
	
	"""Add each v of v's entire tree to v.t.joinList."""
	
	v = self ; after = v.nodeAfterTree()
	
	while v and v != after:
		if not v in v.t.joinList:
			v.t.joinList.append(v)
		v = v.threadNext()</t>
<t tx="T1875"># Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):
	
	clone = self.cloneTree(back)
	clone.createDependents()

	# Set the clone bit in all nodes joined to back.
	# This is not nearly enough.
	clone.setClonedBit()
	back.setClonedBit()
	for v in back.t.joinList:
		v.setClonedBit()

	return clone</t>
<t tx="T1876">def cloneTree (self, oldTree):
	
	"""Create a cloned tree after oldTree."""

	# Create a new tree following oldTree.
	newTree = oldTree.copyTree()
	newTree.linkAfter(oldTree)
	# Join the trees and copy clone bits.
	oldTree.joinTreeTo(newTree)
	oldTree.copyCloneBitsTo(newTree)
	return newTree</t>
<t tx="T1877"># Rewritten 7/11/03.

def copyTree (self):
	
	"""Returns a free-standing copy of a vnode and all its descendents.
	
	The new tree uses the same tnodes as the old,
	but the new vnodes are _not_ joined to the old nodes.
	That is, the new vnodes v do not appear on v.t.joinList."""
	
	c = self.commands ; old_v = self
	
	# trace(self)
	
	# Copy all fields of the root.
	new_v = vnode(c,old_v.t)
	new_v.t.headString = old_v.t.headString
	new_v.iconVal = old_v.iconVal
	assert(new_v not in new_v.t.joinList)

	# Recursively copy and link all children.
	old_child = old_v.firstChild()
	n = 0
	while old_child:
		new_child = old_child.copyTree()
		new_child.linkAsNthChild(new_v,n)
		assert(new_child not in new_child.t.joinList)
		n += 1
		old_child = old_child.next()
		
	return new_v
</t>
<t tx="T1878"># This method creates all nodes that depend on the receiver.
def createDependents (self):

	v = self ; parent = v.parent()
	if not parent: return

	# Copy v as the nth child of all nodes joined to parent.
	n = v.childIndex()
	
	# 7/11/03: work on copy of join list.
	joinList = parent.t.joinList[:]
	if parent in joinList:
		joinList.remove(parent)

	for p in joinList:
		# trace(n,p)
		copy = v.copyTree()
		copy.linkAsNthChild(p,n)
		v.joinTreeTo(copy)</t>
<t tx="T1879"># Destroys all dependent vnodes and tree nodes associated with the receiver.

def destroyDependents (self):
	
	"""Destroy the nth child of all nodes joined to the receiver's parent.."""

	parent = self.parent()
	if not parent:
		# trace("no parent",self)
		return

	n = self.childIndex()
	
	# 7/11/03: work on copy of join list.
	joinList = parent.t.joinList[:]
	if parent in joinList:
		joinList.remove(parent)
	#trace(parent,joinList)

	for join in joinList:
		# trace(n,join)
		child = join.nthChild(n)
		if child:
			child.unjoinTree()
			child.unlink()
			child.destroyTree()</t>
<t tx="T1880">@nocolor

What I did:

- Changed getTextSelection so that it returns a tuple (insert,insert) instead of (None,None) if the selection range is empty.  This does most of the work!

- Pass an oldSel param to most calls of onBodyChanged.

- Added a newSel param to onBodyChanged and idle_body_key.

- Forced the focus to the body pane after pressing undo/redo buttons in the Spell Checker.  This makes the selection visible.

@color</t>
<t tx="T1881">@
- Added "clear-mark" and "set-mark" hooks.
- Moved dialog classes used by nav_buttons plugin into that plugin.

</t>
<t tx="T1882">def setMarked (self):

	self.statusBits |= self.markedBit
	doHook("set-mark",c=self.commands,v=self)

def initMarkedBit (self):

	self.statusBits |= self.markedBit</t>
<t tx="T1883">def clearMarked (self):

	self.statusBits &amp;= ~ self.markedBit
	doHook("clear-mark",c=self.commands,v=self)</t>
<t tx="T1884"></t>
<t tx="T1885"></t>
<t tx="T1886">@ignore</t>
<t tx="T1887">@nocolor

By: jasonic ( Jason Cunliffe ) 
 RE: using @file paths to create structure   
2003-07-17 14:16  
ekr: &gt;Set create_nonexistent_directories = 1 in leoConfig.txt 

Flag is is set, but not working... 

errors writing: C:\Program Files\Leo\jasonic\testdir\aaaa.r 
path does not exist: C:\Program Files\Leo\jasonic\testdir 

any ideas? 

thanks 
JAson</t>
<t tx="T1888">This is a test</t>
<t tx="T1889"></t>
<t tx="T1890">@nocolor

An assert failed: v in joinList when undoing an Extract Section command.

Probably undoing a non-cloned node that was the descendent of a cloned node.  </t>
<t tx="T1891"></t>
<t tx="T1892">elif undoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section",
	"Read @file Nodes"):

	u.v = self.undoReplace(u.v,u.newTree,u.oldTree,u.oldText)
	c.selectVnode(u.v) # Does full recolor.
	if u.oldSel:
		start,end=u.oldSel
		setTextSelection(c.frame.body,start,end)
	redrawFlag = true</t>
<t tx="T1893">elif redoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section",
	"Read @file Nodes"):

	u.v = self.undoReplace(u.v,u.oldTree,u.newTree,u.newText)
	c.selectVnode(u.v) # Does full recolor.
	if u.newSel:
		start,end=u.newSel
		setTextSelection(c.frame.body,start,end)
	redrawFlag = redoType in ("Extract","Extract Names","Extract Section","Read @file Nodes")
</t>
<t tx="T1894">@ This routine implements undo for any kind of operation, no matter how complex.  Just do:

	v_copy = c.undoer.saveTree(v)
	...make arbitrary changes to v's tree.
	c.undoer.setUndoParams("Op Name",v,select=current,oldTree=v_copy)
@c

def undoReplace (self,v,new_data,old_data,text):

	"""Replace new_v with old_v during undo."""

	u = self
	if 0:
		trace(u.undoType)
		trace("u.bead",u.bead, type(u.peekBead(u.bead)))
		trace("new_data:",type(new_data))
		trace("old_data:",type(old_data))

	assert(type(new_data)==type((),) or type(old_data)==type((),))

	# new_data will be None the first time we undo this operation.
	# In that case, we must save the new tree for later undo operation.
	try:
		new_v, new_headlines, new_bodies, new_attributes = new_data
	except:
		new_data = u.saveTree(v)
		new_v, new_headlines, new_bodies, new_attributes = new_data
		# Put the new data in the bead.
		d = u.beads[u.bead]
		d["newTree"] = new_data
		u.beads[u.bead] = d
		# Another kludge to satisfy assert(new_v in joinList) below.
		new_v = v
		
	# The previous code should already have created this data.
	old_v, old_headlines, old_bodies, old_attributes = old_data
	assert(new_bodies != None)
	assert(old_bodies != None)

	u = self ; c = u.commands
	joinList = new_v.t.joinList[:]
	result = None
	for v in joinList:
		copy = old_v.copyTree()
		if not result: result = copy
		# Remember how to link the new node.
		parent = v.parent()
		prev = v.back()
		next = v.next()
		n = v.childIndex()
		# Unlink the old tree.
		v.unjoinTree()
		v.unlink()
		# Link in the new tree.
		if parent: copy.linkAsNthChild(parent,n)
		elif prev: copy.linkAfter(prev)
		else:      copy.linkAsRoot(oldRoot=next)
		copy.addTreeToJoinLists()
		assert(copy in copy.t.joinList)

	if not result:
		result = old_v

	# Restore all headlines and bodies from the saved lists.
	v = result; after = result.nodeAfterTree()
	encoding = app.tkEncoding
	i = 0
	while v and v != after:
		v.initHeadString(old_headlines[i],encoding)
		v.t.setTnodeText(old_bodies[i],encoding)
		u.restoreExtraAttributes(v,old_attributes[i])
		v = v.threadNext()
		i += 1

	result.setBodyStringOrPane(result.bodyString())
	c.initAllCloneBits()
	return result</t>
<t tx="T1895">@ 

- Made keywords dicts ivars of the colorizer class, which should have been done long ago anyway.</t>
<t tx="T1896"></t>
<t tx="T1897"></t>
<t tx="T1898"></t>
<t tx="T1899"></t>
<t tx="T1900">def init (self,c):

	# N.B.: separate c.ivars are much more convenient than a dict.
	for key in self.intKeys:
		val = getattr(c, key + "_flag")
		self.dict[key].set(val)
		# trace(key,val)

	&lt;&lt; set widgets &gt;&gt;
	
	# Set radio buttons from ivars.
	val = self.dict["pattern_match"].get()
	self.dict["radio-find-type"].set(
		choose(val,"pattern-search","plain-search"))

	val = self.dict["suboutline_only"].get()
	self.dict["radio-search-scope"].set(
		choose(val,"suboutline-only","entire-outine"))</t>
<t tx="T1901">self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)</t>
<t tx="T1902"></t>
<t tx="T1903"># Initializes prefs ivars and widgets from c's ivars.

def init(self,c):

	self.commands = c
	#trace(`c.tab_width`)

	for var in ivars:
		val = getattr(c,var)
		setattr(self,var,val)
		# trace(val,var)

	&lt;&lt; remember values for revert &gt;&gt;
	&lt;&lt; set widgets &gt;&gt;
	# print "init" ; print self.print_ivars()</t>
<t tx="T1904"># Global options
self.revert_tangle_batch_flag = c.tangle_batch_flag
self.revert_untangle_batch_flag = c.untangle_batch_flag
self.revert_page_width = c.page_width
self.revert_tab_width = c.tab_width
# Default Tangle Options
self.revert_tangle_directory = c.tangle_directory
self.revert_output_doc_flag = c.output_doc_flag
self.revert_use_header_flag = c.use_header_flag
# Default Target Language
if c.target_language == None: # 7/29/02
	c.target_language = "python"
self.revert_target_language = c.target_language</t>
<t tx="T1905"># Global options
self.replace_tabs_var.set(choose(c.tab_width&lt;0,1,0)) # 1/30/03
self.tangle_batch_var.set(c.tangle_batch_flag)
self.untangle_batch_var.set(c.untangle_batch_flag)
self.pageWidthText.delete("1.0","end")
self.pageWidthText.insert("end",`c.page_width`)
self.tabWidthText.delete("1.0","end")
self.tabWidthText.insert("end",`abs(c.tab_width)`) # 1/30/03
# Default Tangle Options
self.tangleDirectoryText.delete("1.0","end")
self.tangleDirectoryText.insert("end",c.tangle_directory)
self.output_doc_var.set(c.output_doc_flag)
self.use_header_var.set(c.use_header_flag)
# Default Target Language
if c.target_language == None:
	c.target_language = "python" # 7/29/02
self.lang_var.set(c.target_language)</t>
<t tx="T1906"># These event handlers get executed when the user types in the prefs panel.

def set_ivars (self,c):

	&lt;&lt; update ivars &gt;&gt;
	for var in ivars:
		val = getattr(self,var)
		setattr(c,var,val)
		
	c.frame.setTabWidth(c.tab_width)
	# self.print_ivars()

def idle_set_ivars (self, event=None):
	
	c = top() ; v = c.currentVnode()
	self.top.after_idle(self.set_ivars,c)
	c.frame.recolor(v)
	# print self.print_ivars()
	
def print_ivars (self):
	
	for var in ivars:
		trace(var, getattr(self,var))</t>
<t tx="T1907"># Global options
w = self.pageWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.page_width = abs(int(w))
except:
	self.page_width = default_page_width
	
w = self.tabWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.tab_width = abs(int(w))
	if self.replace_tabs_var.get(): # 1/30/03
		self.tab_width = - abs(self.tab_width)
	# print self.tab_width
except:
	self.tab_width = default_tab_width

self.tangle_batch_flag = self.tangle_batch_var.get()
self.untangle_batch_flag = self.untangle_batch_var.get()

# Default Tangle options
dir = self.tangleDirectoryText.get("1.0","end")
self.tangle_directory = string.strip(dir)

self.use_header_flag = self.use_header_var.get()
self.output_doc_flag = self.output_doc_var.get()

# Default Target Language
self.target_language = self.lang_var.get()
</t>
<t tx="T1908"></t>
<t tx="T1909">def clearIvars (self):
	
	self.v = None # The node being operated upon for undo and redo.
	for ivar in optionalIvars:
		setattr(self,ivar,None)</t>
<t tx="T1910">def getBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads):
		return None
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	self.clearIvars()
	u.v = d["v"]
	u.undoType = d["undoType"]

	for ivar in optionalIvars:
		val = d.get(ivar,None)
		setattr(u,ivar,val)

	if not u.new_undo: # Recreate an "oldText" entry if necessary.
		if u.undoType == "Typing" and u.oldText == None:
			assert(n &gt; 0)
			old_d = u.beads[n-1]
			# The user will lose data if these asserts fail.
			assert(old_d["undoType"] == "Typing")
			assert(old_d["v"] == u.v)
			u.oldText = old_d["newText"]
			# trace(`u.oldText`)
	return d
	
def peekBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads):
		return None
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	return d

def setBead (self,n,keywords=None):

	u = self ; d = {}
	d["undoType"]=u.undoType
	d["v"]=u.v
	# Only enter significant entries into the dictionary.
	# This is an important space optimization for typing.
	for ivar in optionalIvars:
		if getattr(u,ivar) != None:
			d[ivar] = getattr(u,ivar)
	# copy all significant keywords to d.
	if keywords:
		for key in keywords.keys():
			if keywords[key] != None:
				d[key] = keywords[key]
	# Clear the "oldText" entry if the previous entry was a "Typing" entry.
	# This optimization halves the space needed for Undo/Redo Typing.
	if not u.new_undo:
		if u.undoType == "Typing" and n &gt; 0:
			old_d = u.beads[n-1]
			if old_d["undoType"] == "Typing" and old_d["v"] == u.v:
				del d["oldText"] # We can recreate this entry from old_d["newText"]
				# trace(`u.oldText`)
	# trace(`d`)
	return d
</t>
<t tx="T1911"></t>
<t tx="T1912"></t>
<t tx="T1913"></t>
<t tx="T1914">@nocolor

Developers forum
By: edcdave ( David Harris ) 
 "No absolute directory specified anywhere"   
2003-07-20 01:16

I managed to come up with a reproducible scenario which generates the message "No absolute directory specified anywhere". 

Open a new leo window (from desktop or using File/New). Enter @file testprog.py as the headline of the first node. 

Execute Save or SaveAs, specify a path and file name using the dialog box and click Save. The message will appear in the upper right pane.

The fix was to change:
	
if len(dir) &gt; 0 and os.path.isabs(fileName) and os.path.exists(fileName):
	
to

if len(dir) &gt; 0 and os.path.isabs(dir) and os.path.exists(dir):

BTW, because we are getting the path from a dialog box, we don't have to deal with the create_nonexistent_directories option.</t>
<t tx="T1915">def save(self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
			if app.config.save_clears_undo_buffer:
				es("clearing undo")
				c.undoer.clearUndoState()
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)</t>
<t tx="T1916">@ There was no way to remove a default shortcut so that no shortcut was used.  Now entries in leoConfig.txt of the form:
	
commandName = None

will clear any previous shortcut.</t>
<t tx="T1917">def getShortcut (self,name):
	
	val = self.keysDict.get(name)
	
	# 7/19/03: Return "None" if the setting is "None"
	# This allows settings to disable a default shortcut.
	return val</t>
<t tx="T1918">@nocolor

The @wrap and @nowrap directives should override the default leoConfig setting.

@color</t>
<t tx="T1919">@nocolor

A new problem in Python 2.3: "after" event get called during shutdown.  At present, the workaround is to do the following:

1. Use root.quit rather than root.destroy.  This ensures that no Tk objects get garbage collected.

2. Use the app().killed var to disable "after" routines during shutdown.  This is defensive programming so we don't rely on Tk's apparently buggy shutdown logic.

@color</t>
<t tx="T1920"></t>
<t tx="T1921"></t>
<t tx="T1922">def findChild (self,headline):
	
	"""Return the next tnode in the at.tnodeList."""

	at = self

	if at.importing:
		v = at.createImportedNode(at.root,at.commands,headline)
		return v.t

	if not hasattr(at.root,"tnodeList"):
		at.readError("no tnodeList for " + `at.root`)
		es("Write the @file node or use the Import Derived File command")
		trace("no tnodeList for ",at.root)
		return None
		
	if at.tnodeListIndex &gt;= len(at.root.tnodeList):
		at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,`at.root`))
		trace("bad tnodeList index",at.tnodeListIndex,len(at.root.tnodeList),at.root)
		return None
		
	t = at.root.tnodeList[at.tnodeListIndex]
	assert(t)
	at.tnodeListIndex += 1

	# Get any vnode joined to t.
	# To do: cut/paste may cause problems here...
	try:
		v = t.joinList[0]
	except:
		at.readError("No joinList for tnode")
		trace(at.tnodeListIndex,len(at.root.tnodeList))
		return None

	# Check the headline.
	if headline.strip() == v.headString().strip():
		t.setVisited() # Supress warning about unvisited node.
		return t
	else:
		at.readError(
			"Mismatched headline.\nExpecting: %s\ngot: %s" %
			(headline,v.headString()))
		trace("Mismatched headline",headline,v.headString())
		trace(at.tnodeListIndex,len(at.root.tnodeList))
		return None
</t>
<t tx="T1923">@ To do:
	
- (done) Create a 16 x 16 leoApp16.ico
- (done) Upload leoApp16.ico to cvs.
- (done) Reinstall PIL and tkIcon for Python 2.2.
- (done) Test the code using Python 2.2
	
- Document that PIL and tkIcon are not needed in Python 2.3 and above.
	- In LeoDocs.leo
	- On Leo's web site.

</t>
<t tx="T1924">def setDefaultIcon(self):
	
	"""Set the icon to be used in all Leo windows.
	
	This code does nothing for Tk versions before 8.4.3."""
	
	gui = self

	try:
		version = gui.root.getvar("tk_patchLevel")
		if CheckVersion(version,"8.4.3"):
			# tk 8.4.3 or greater: load a 16 by 16 icon.
			path = os.path.join(app.loadDir,"..","Icons")
			if os.path.exists(path):
				file = os.path.join(path,"LeoApp16.ico")
				if os.path.exists(path):
					self.bitmap = Tkinter.BitmapImage(file)
				else:
					es("LeoApp16.ico not in Icons directory", color="red")
			else:
				es("Icons directory not found: "+path, color="red")
	except:
		print "exception setting bitmap"
		traceback.print_exc()</t>
<t tx="T1925">def attachLeoIcon (self,w):
	
	"""Try to attach a Leo icon to the Leo Window.
	
	Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
	Otherwise, try to use the Python Imaging Library and the tkIcon package."""

	if self.bitmap != None:
		# We don't need PIL or tkicon: this is tk 8.3.4 or greater.
		try:
			w.wm_iconbitmap(self.bitmap)
		except:
			self.bitmap = None
	
	if self.bitmap == None:
		try:
			&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
		except:
			# traceback.print_exc()
			self.leoIcon = None</t>
<t tx="T1926">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image,tkIcon,_tkicon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
	try: self.leoIcon.attach(w.winfo_id())
	except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
	# Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
	icon_file_name = os.path.join(app.loadDir,'..','Icons','LeoWin.gif')
	icon_file_name = os.path.normpath(icon_file_name)
	icon_image = Image.open(icon_file_name)
	if 1: # Doesn't resize.
		self.leoIcon = self.createLeoIcon(icon_image)
	else: # Assumes 64x64
		self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="T1927"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
	
	try:
		import Image,tkIcon,_tkicon
		
		i = icon ; m = None
		# create transparency mask
		if i.mode == "P":
			try:
				t = i.info["transparency"]
				m = i.point(lambda i, t=t: i==t, "1")
			except KeyError: pass
		elif i.mode == "RGBA":
			# get transparency layer
			m = i.split()[3].point(lambda i: i == 0, "1")
		if not m:
			m = Image.new("1", i.size, 0) # opaque
		# clear unused parts of the original image
		i = i.convert("RGB")
		i.paste((0, 0, 0), (0, 0), m)
		# create icon
		m = m.tostring("raw", ("1", 0, 1))
		c = i.tostring("raw", ("BGRX", 0, -1))
		return _tkicon.new(i.size, c, m)
	except:
		return None</t>
<t tx="T1928"></t>
<t tx="T1929">@nocolor

1. In 4.0 getLeoFile must call setAllJoinLinks _before_ reading @file nodes.

This is perfectly safe in 4.0 because reading _never_ creates vnodes or alters vnode links.

2. writeAll and writeMissing now return a count of the written files.

This allows the caller to do an auto-save only if something was really written.</t>
<t tx="T1930">def writeAtFileNodes (self):
	
	c = self.commands

	writtenFiles = c.atFileCommands.writeAll(writeAtFileNodesFlag=true)
	assert(writtenFiles != None)
	if writtenFiles:
		es("auto-saving outline",color="blue")
		c.frame.OnSave() # Must be done to set or clear tnodeList.</t>
<t tx="T1931">def writeMissingAtFileNodes (self):

	c = self.commands ; v = c.currentVnode()

	if v:
		at = c.atFileCommands
		writtenFiles = at.writeMissing(v)
		assert(writtenFiles != None)
		if writtenFiles:
			es("auto-saving outline",color="blue")
			c.frame.OnSave() # Must be done to set or clear tnodeList.</t>
<t tx="T1932">def writeMissing(self,v):

	at = self
	if at.trace: trace("old_df",v)

	write_new = not app.config.write_old_format_derived_files
	df = choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = false
	after = v.nodeAfterTree()
	while v and v != after:
		if v.isAtSilentFileNode() or (v.isAnyAtFileNode() and not v.isAtIgnoreNode()):
			missing = false ; valid = true
			df.targetFileName = v.anyAtFileNodeName()
			&lt;&lt; set missing if the file does not exist &gt;&gt;
			if valid and missing:
				&lt;&lt; create df.outputFile &gt;&gt;
				if at.outputFile:
					&lt;&lt; write the @file node &gt;&gt;
			v = v.nodeAfterTree()
		elif v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	
	if writtenFiles &gt; 0:
		es("finished")
	else:
		es("no missing @file node in the selected tree")
		
	return writtenFiles # 9/23/03: so caller knows whether to do an auto-save.</t>
<t tx="T1933"># This is similar, but not the same as, the logic in openWriteFile.

valid = df.targetFileName and len(df.targetFileName) &gt; 0

if valid:
	try:
		# Creates missing directives if option is enabled.
		df.scanAllDirectives(v)
		valid = df.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false

if valid:
	try:
		fn = df.targetFileName
		df.shortFileName = fn # name to use in status messages.
		df.targetFileName = os.path.join(df.default_directory,fn)
		df.targetFileName = os.path.normpath(df.targetFileName)
		path = df.targetFileName # Look for the full name, not just the directory.
		valid = path and len(path) &gt; 0
		if valid:
			missing = not os.path.exists(path)
	except:
		es("exception creating path:" + fn)
		es_exception()
		valid = false</t>
<t tx="T1934">try:
	df.outputFileName = df.targetFileName + ".leotmp"
	df.outputFile = open(df.outputFileName,'wb')
	if df.outputFile == None:
		es("can not open " + df.outputFileName)
except:
	es("exception opening:" + df.outputFileName)
	es_exception()
	df.outputFile = None
</t>
<t tx="T1935">if v.isAtSilentFileNode():
	at.silentWrite(v)
elif v.isAtRawFileNode():
	at.rawWrite(v)
elif v.isAtNoSentinelsFileNode():
	at.write(v,nosentinels=true)
elif v.isAtFileNode():
	at.write(v)
else: assert(0)

writtenFiles = true
</t>
<t tx="T1936">def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	at = self ; c = at.commands
	write_new = not app.config.write_old_format_derived_files
	df = choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = [] # Files that might be written again.

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		v = c.currentVnode()
		after = v.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		v = c.rootVnode()
		after = None

	&lt;&lt; Clear all orphan bits &gt;&gt;
	while v and v != after:
		if v.isAnyAtFileNode() or v.isAtIgnoreNode():
			&lt;&lt; handle v's tree &gt;&gt;
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()

	&lt;&lt; say the command is finished &gt;&gt;
	
	return len(writtenFiles) # 9/23/03: so caller knows whether to do an auto-save.</t>
<t tx="T1937">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

v2 = v
while v2 and v2 != after:
	v2.clearOrphan()
	v2 = v2.threadNext()</t>
<t tx="T1938"># This code is a little tricky: @ignore not recognised in @silentfile nodes.

if v.isDirty() or writeAtFileNodesFlag or v.t in writtenFiles:

	if v.isAtSilentFileNode():
		at.silentWrite(v)
	elif v.isAtIgnoreNode():
		pass
	elif v.isAtRawFileNode():
		at.rawWrite(v)
	elif v.isAtNoSentinelsFileNode():
		at.write(v,nosentinels=true)
	elif v.isAtFileNode():
		at.write(v)

	if not v.isAtIgnoreNode():
		writtenFiles.append(v.t)</t>
<t tx="T1939">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) &gt; 0:
		es("finished")
	elif writeAtFileNodesFlag:
		es("no @file nodes in the selected tree")
	else:
		es("no dirty @file nodes")</t>
<t tx="T1940"></t>
<t tx="T1941">def newLeoCommanderAndFrame(self,fileName):
	
	"""Create a commander and its view frame for the Leo main window."""
	
	if not fileName: fileName = ""
	&lt;&lt; compute the window title &gt;&gt;

	# Create an unfinished frame to pass to the commanders.
	if 1:
		frame = app.gui.newLeoFrame(title)
	else:
		frame = leoFrame.LeoFrame(title)
	
	# Create the commander and its subcommanders.
	c = leoCommands.Commands(frame,fileName)
	
	# Finish creating the frame (kludge: sets c.body so it can create the outline.)
	frame.finishCreate(c)
	c.log = c.frame.log # Kludge: should replace c.log by abstract log routines.
	
	# Finish initing the subcommanders.
	c.undoer.clearUndoState() # Menus must exist at this point.
	
	doHook("after-create-leo-frame",c=c)
	return c,frame</t>
<t tx="T1942"># Set the window title and fileName
if fileName:
	title = computeWindowTitle(fileName)
else:
	s = "untitled"
	n = app.numberOfWindows
	if n &gt; 0:
		s += `n`
	title = computeWindowTitle(s)
	app.numberOfWindows = n+1

</t>
<t tx="T1943">def computeWindowTitle (fileName):

	if fileName == None:
		return "untitled"
	else:
		path,fn = os.path.split(fileName)
		if path:
			title = fn + " in " + path
		else:
			title = fn
		return title</t>
<t tx="T1944">def __init__ (self,commands):
	
	u = self ; u.commands = commands
	
	# Ivars to transition to new undo scheme...
	
	u.debug = false # true: enable debugging code in new undo scheme.
	u.debug_print = false # true: enable print statements in debug code.
	u.new_undo = true # true: enable new debug code.

	# Statistics comparing old and new ways (only if u.debug is on).
	u.new_mem = 0
	u.old_mem = 0

	# State ivars...
	u.undoType = "Can't Undo"
	
	# These must be set here, _not_ in clearUndoState.
	u.redoMenuLabel = "Can't Redo"
	u.undoMenuLabel = "Can't Undo"
	u.realRedoMenuLabel = "Can't Redo"
	u.realUndoMenuLabel = "Can't Undo"
	u.undoing = false # True if executing an Undo command.
	u.redoing = false # True if executing a Redo command.</t>
<t tx="T1945"></t>
<t tx="T1946">def __init__(self,frame,fileName):
	
	# trace("Commands",fileName)

	self.frame = frame
	self.mFileName = fileName
	self.initIvars()

	# initialize the sub-commanders
	self.fileCommands = leoFileCommands.fileCommands(self)
	self.atFileCommands = leoAtFile.atFile(self)
	self.importCommands = leoImport.leoImportCommands(self)
	self.tangleCommands = leoTangle.tangleCommands(self)
	self.undoer = leoUndo.undoer(self)

def initIvars(self):

	&lt;&lt; initialize ivars &gt;&gt;
	self.setIvarsFromFind()</t>
<t tx="T1947"># per-document info...
self.hookFunction = None
self.openDirectory = None # 7/2/02

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = false # true if any data has been changed since the last save.
self.loading = false # true if we are loading a file: disables c.setChanged()

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = 4
self.tangle_batch_flag = false
self.untangle_batch_flag = false
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = false
self.output_doc_flag = false
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.</t>
<t tx="T1948">def __repr__ (self):
	
	try:
		return "Commander: " + self.mFileName
	except:
		return "Commander: bad mFileName"
		
__str__ = __repr__
</t>
<t tx="T1949"></t>
<t tx="T1950">def getBuildNumber(self):
	return self.ver[10:-1] # Strip off "$Reversion" and the trailing "$"

def getSignOnLine (self):
	return "Leo 4.0.2, build %s, October 22, 2003" % self.getBuildNumber()
	
def initVersion (self):
	self.ver = "$Revision$" # CVS will update this.
	
def signOnWithVersion (self):

	frame = self
	color = app.config.getWindowPref("log_error_color")
	signon = frame.getSignOnLine()
	n1,n2,n3,junk,junk=sys.version_info
	tkLevel = frame.top.getvar("tk_patchLevel")
	
	es("Leo Log Window...",color=color)
	es(signon)
	es("Python %d.%d.%d, Tk %s" % (n1,n2,n3,tkLevel))
	enl()</t>
<t tx="T1951">def finishCreate (self,c):
	
	frame = self ; frame.commands = c ; Tk = Tkinter
	
	# Create the toplevel.
	frame.top = top = Tk.Toplevel()
	attachLeoIcon(top)
	top.title(frame.title)
	top.minsize(30,10) # In grid units.

	# Create all the subframes.
	frame.createLeoFrame(top)
	c.body = frame.body ## To be deleted.
	frame.tree = leoTree.leoTree(c,frame,frame.canvas)
	frame.setTabWidth(c.tab_width)

	&lt;&lt; create the first tree node &gt;&gt;
	v = c.currentVnode()
	
	if not doHook("menu1",c=c,v=v):
		frame.createMenuBar(top)
	app.setLog(frame,"frame.__init__") # the LeoFrame containing the log
	app.windowList.append(frame)
	
	self.signOnWithVersion()
	
	frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
	frame.top.bind("&lt;Button-1&gt;", frame.OnActivateLeoEvent)
	
	frame.top.bind("&lt;Activate&gt;", frame.OnActivateLeoEvent) # Doesn't work on windows.
	frame.top.bind("&lt;Deactivate&gt;", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

	frame.top.bind("&lt;Control-KeyPress&gt;",frame.OnControlKeyDown)
	frame.top.bind("&lt;Control-KeyRelease&gt;",frame.OnControlKeyUp)
	
	frame.tree.canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)
	frame.log.bind("&lt;Button-1&gt;", frame.OnActivateLog)
	
	frame.body.bind("&lt;Button-1&gt;", frame.OnBodyClick)
	frame.body.bind("&lt;Button-3&gt;", frame.OnBodyRClick)
	frame.body.bind("&lt;Double-Button-1&gt;", frame.OnBodyDoubleClick)
	frame.body.bind("&lt;Key&gt;", frame.tree.OnBodyKey)

	frame.body.bind(virtual_event_name("Cut"), frame.OnCut)
	frame.body.bind(virtual_event_name("Copy"), frame.OnCopy)
	frame.body.bind(virtual_event_name("Paste"), frame.OnPaste)

	# Handle mouse wheel in the outline pane.
	if sys.platform == "linux2": # This crashes tcl83.dll
		frame.tree.canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
		
	# print_bindings("canvas",frame.tree.canvas)
</t>
<t tx="T1952">t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
v.initHeadString("NewHeadline")
v.moveToRoot()

c.beginUpdate()
c.frame.redraw()
c.frame.focus_get()
c.editVnode(v)
c.endUpdate(false)</t>
<t tx="T1953">def __repr__ (self):

	return "&lt;leoFrame: %s&gt;" % self.title
</t>
<t tx="T1954">def clearAllIvars(self):
	
	"""Clear all ivars in helper classes."""

	frame = self
	clearAllIvars(frame.tree.colorizer)
	clearAllIvars(frame.tree)</t>
<t tx="T1955"></t>
<t tx="T1956">class leoProxy:
	
	"""A proxy for the gApp object that can be created before gApp itself.
	
	After gApp is created, both app.x and app().x refer to gApp.x."""

	def __getattr__(self,attr):
		return getattr(gApp,attr)
		
	def __setattr__(self,attr,val):
		setattr(gApp,attr,val)

	def __call__(self):
		return gApp
		
# The code can use app.x and app().x to refer to ivars of the leoApp class.
app = leoProxy()</t>
<t tx="T1957">@nocolor

- Use the base leoGui class as an aid to refactoring.
- Hook up the LeoFrame class.</t>
<t tx="T1958">def createTkGui (self,fileName = None):
	
	"""A convenience routines for plugins to create the default Tk gui class."""
	
	app = self
	if 0:
		if fileName:
			s = "creating default tkinterGui from " + shortFileName(fileName)
		trace(s) ; es(s, color = "red")
	app.gui = leoGui.tkinterGui()
	app.root = app.gui.createRootWindow()
	app.gui.finishCreate()</t>
<t tx="T1959"></t>
<t tx="T1960">@nocolor

@+doc and @+at sentinels now contain whatever trailing whitespace followed the corresponding @doc or @ directives.</t>
<t tx="T1961"></t>
<t tx="T1962">def putBlankDocLine (self):
	
	at = self
	
	at.putPending(split=false)

	if not at.endSentinelComment:
		at.putIndent(at.indent)
		at.os(at.startSentinelComment) ; at.oblank()

	at.onl()</t>
<t tx="T1963">def putStartDocLine (self,s,i,kind):
	
	"""Write the start of a doc part."""
	
	at = self ; at.docKind = kind
	
	sentinel = choose(kind == docDirective,"@+doc","@+at")
	directive = choose(kind == docDirective,"@doc","@")
	
	# Skip past the directive.
	i += len(directive)
	
	# Get the trailing whitespace.
	j = skip_ws(s,i)
	ws = s[i:j]
	
	# Put the opening @+doc or @-doc sentinel, including trailing whitespace.
	at.putSentinel(sentinel + ws)

	# Put the opening comment.
	if at.endSentinelComment:
		at.putIndent(at.indent)
		at.os(at.startSentinelComment) ; at.onl()

	# Put an @nonl sentinel if there is significant text following @doc or @.
	if not is_nl(s,j):
		at.putSentinel("@nonl")
		at.putDocLine(s,j)

	if 0: # old code
		# put the opening @+doc or @-doc sentinel, including trailing whitespace.
		sentinel = choose(kind == docDirective,"@+doc","@+at")
		at.putSentinel(sentinel)
		
		# Put the opening comment.
		if at.endSentinelComment:
			at.putIndent(at.indent)
			at.os(at.startSentinelComment) ; at.onl()
	
		# Skip past the directive
		directive = choose(kind == docDirective,"@doc","@")
		i += len(directive)
		
		# 9/21/03: Looking ahead here helps preserve intended whitespace.
		if match(s,i,' ') or match(s,i,'\t'):
			i += 1
		j = skip_ws(s,i)
		
		# Put an @nonl sentinel if there is significant text following @doc or @.
		if not is_nl(s,j):
			at.putSentinel("@nonl")
			at.putDocLine(s,i)</t>
<t tx="T1964">def putDocLine (self,s,i):
	
	"""Handle one line of a doc part.
	
	Output complete lines and split long lines and queue pending lines.
	Inserted newlines are always preceded by whitespace."""
	
	at = self
	j = skip_line(s,i)
	s = s[i:j]

	if at.endSentinelComment:
		leading = at.indent
	else:
		leading = at.indent + len(at.startSentinelComment) + 1

	if not s or s[0] == '\n':
		# A blank line.
		at.putBlankDocLine()
	else:
		&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="T1965">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

	# Scan to the next word.
	word1 = i # Start of the current word.
	word2 = i = skip_ws(s,i)
	while i &lt; len(s) and s[i] not in (' ','\t'):
		i += 1
	word3 = i = skip_ws(s,i)
	# trace(s[word1:i])
	
	if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
		if at.pending:
			# trace("splitting long line.")
			# Ouput the pending line, and start a new line.
			at.putPending(split=true)
			at.pending = [s[word2:word3]]
		else:
			# Output a long word on a line by itself.
			# trace("long word:",s[word2:word3])
			at.pending = [s[word2:word3]]
			at.putPending(split=true)
	else:
		# Append the entire word to the pending line.
		# trace("appending",s[word1:word3])
		at.pending.append(s[word1:word3])
			
# Output the remaining line: no more is left.
at.putPending(split=false)</t>
<t tx="T1966">def putEndDocLine (self):
	
	"""Write the conclusion of a doc part."""
	
	at = self
	
	at.putPending(split=false)
	
	# Put the closing delimiter if we are using block comments.
	if at.endSentinelComment:
		at.putIndent(at.indent)
		at.os(at.endSentinelComment)
		at.onl() # Note: no trailing whitespace.

	sentinel = choose(at.docKind == docDirective,"@-doc","@-at")
	at.putSentinel(sentinel)</t>
<t tx="T1967">def putPending (self,split):
	
	"""Write the pending part of a doc part.
	
	We retain trailing whitespace iff the split flag is true."""
	
	at = self ; s = ''.join(at.pending) ; at.pending = []
	
	# trace("split",`s`)
	
	# Remove trailing newline temporarily.  We'll add it back later.
	if s and s[-1] == '\n':
		s = s[:-1]

	if not split:
		s = s.rstrip()
		if not s:
			return

	at.putIndent(at.indent)

	if not at.endSentinelComment:
		at.os(at.startSentinelComment) ; at.oblank()

	at.os(s) ; at.onl()</t>
<t tx="T1968">def readStartAt (self,s,i):
	
	"""Read an @+at sentinel."""
	
	at = self ; assert(match(s,i,"+at"))
	i += 3 ; j = skip_ws(s,i) ; ws = s[i:j]
	at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
	at.inCode = false
	at.endSentinelStack.append(endAt)
	
def readStartDoc (self,s,i):
	
	"""Read an @+doc sentinel."""

	at = self ; assert(match(s,i,"+doc"))
	i += 4 ; j = skip_ws(s,i) ; ws = s[i:j]
	at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
	at.inCode = false
	at.endSentinelStack.append(endDoc)</t>
<t tx="T1969">def readLastDocLine (self,tag):
	
	at = self
	end = at.endSentinelComment
	start = at.startSentinelComment
	s = ''.join(at.docOut)
	
	# Remove the @doc or @space.  We'll add it back at the end.
	if match(s,0,tag):
		s = s[len(tag):]
	else:
		at.readError("Missing start of doc part")
		return

	if end:
		# Remove opening block delim.
		if match(s,0,start):
			s = s[len(start):]
		else:
			at.readError("Missing open block comment")
			return
			
		# Remove trailing newline.
		if s[-1] == '\n':
			s = s[:-1]
	
		# Remove closing block delim.
		if s[-len(end):] == end:
			s = s[:-len(end)]
		else:
			at.readError("Missing close block comment")
			return

	at.out.append(tag + s)
	at.docOut = []</t>
<t tx="T1970"></t>
<t tx="T1971"></t>
<t tx="T1972">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2228302
By: nobody

Platform: Python 2.2.1, Tk 8.3.2, Windows NT
Happens in Leo 3.11.1, 4.0b2

Start with this outline (A is cloned):
A'
....B
....C
A'
....B
....C
D

Then make a clone of D under A.

If you ctrl-drag node D to A, it works correctly.

If you use ctrl-` or the Clone Node menu to clone D and then drag D under A,
one of the D nodes is *not* marked as a clone! (Though it sort of behaves as
a clone.)

--eric k
</t>
<t tx="T1973"></t>
<t tx="T1974"># Returns false if any node of tree is a clone of parent or any of parents ancestors.

def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

	clone_message = "Illegal move or drag: no clone may contain a clone of itself"
	drag_message  = "Illegal drag: Can't drag a node into its own tree"

	# 10/25/02: Create dictionaries for faster checking.
	parents = {} ; clones = {}
	while parent:
		parents [parent.t] = parent.t
		if parent.isCloned():
			clones [parent.t] = parent.t
		parent = parent.parent()
	
	# 10/25/02: Scan the tree only once.
	v = root ; next = root.nodeAfterTree()
	while v and v != next:
		ct = clones.get(v.t)
		if ct != None and ct == v.t:
			if warningFlag:
				alert(clone_message)
			return false
		v = v.threadNext()

	pt = parents.get(root.t)
	if pt == None:
		return true
	else:
		if warningFlag:
			alert(drag_message)
		return false
</t>
<t tx="T1975">def initAllCloneBits (self):
	
	"""Initialize all clone bits in the entire outline"""

	c=self
	c.clearAllVisited()
	v = self.frame.rootVnode()
	c.beginUpdate()
	while v:
		if not v.t.isVisited():
			v.t.setVisited() # Inhibit visits to all joined nodes.
			c.initJoinedCloneBits(v)
		v = v.threadNext()
	c.endUpdate()
	
def initAllCloneBitsInTree (self,v):
	
	"""Initialize all clone bits in the v's subtree"""

	c=self
	v.clearAllVisitedInTree()
	after = v.nodeAfterTree()
	c.beginUpdate()
	while v and v != after:
		if not v.t.isVisited():
			v.t.setVisited() # Inhibit visits to all joined nodes.
			c.initJoinedCloneBits(v)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1976"># Initializes all clone bits in the all nodes joined to v.

def initJoinedCloneBits (self,v):
	
	if 0:
		if not self.loading:
			trace(len(v.t.joinList),v)

	c = self
	c.beginUpdate()
	mark = v.shouldBeClone()
	if mark:
		# Set clone bit in v and all joined nodes.
		v.setClonedBit()
		for v2 in v.t.joinList:
			v2.setClonedBit()
	else:
		# Set clone bit in v and all joined nodes.
		v.clearClonedBit()
		for v2 in v.t.joinList:
			v2.clearClonedBit()
	c.endUpdate()
</t>
<t tx="T1977"># Makes sure all nodes are valid.

def validateOutline (self):

	c = self ; root = c.rootVnode()
	if root:
		return root.validateOutlineWithParent(None)
	else:
		return true</t>
<t tx="T1978"></t>
<t tx="T1979">def dragAfter(self,v,after):

	# es("dragAfter")
	c = self
	if not c.checkMoveWithParentWithWarning(v,after.parent(),true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(after)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 10/8/03
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T1980">def dragCloneToNthChildOf (self,v,parent,n):

	c = self
	c.beginUpdate()
	# trace("v,parent,n:"+v.headString()+","+parent.headString()+","+`n`)
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	if not c.checkMoveWithParentWithWarning(clone,parent,true):
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveToNthChildOf(parent,n)
	c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T1981">def dragToNthChildOf(self,v,parent,n):

	# es("dragToNthChildOf")
	c = self
	if not c.checkMoveWithParentWithWarning(v,parent,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveToNthChildOf(parent,n)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 10/8/03
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T1982">def demote(self):

	c = self ; v = c.currentVnode()
	if not v or not v.next(): return
	last = v.lastChild() # EKR: 3/19/03
	# Make sure all the moves will be valid.
	child = v.next()
	while child:
		if not c.checkMoveWithParentWithWarning(child,v,true):
			return
		child = child.next()
	c.beginUpdate()
	if 1: # update range...
		c.mInhibitOnTreeChanged = true
		c.endEditing()
		while v.next():
			child = v.next()
			child.moveToNthChildOf(v,v.numberOfChildren())
		v.expand()
		c.selectVnode(v)
		v.setDirty()
		c.setChanged(true)
		c.mInhibitOnTreeChanged = false
		c.initAllCloneBits() # 7/6/02
	c.endUpdate()
	c.undoer.setUndoParams("Demote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1983">@ Moving down is more tricky than moving up; we can't move v to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self
	v = c.currentVnode()
	if not v: return
	# Set next to the node after which v will be moved.
	next = v.visNext()
	while next and v.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v down &gt;&gt;
		v.setDirty() # This second call is essential.
		c.selectVnode(v)# 4/23/01
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 10/8/03
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1984"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if next.hasChildren() and next.isExpanded():
	# Attempt to move v to the first child of next.
	if c.checkMoveWithParentWithWarning(v,next,true):
		v.moveToNthChildOf(next,0)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
	# Attempt to move v after next.
	if c.checkMoveWithParentWithWarning(v,next.parent(),true):
		v.moveAfter(next)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T1985">def moveOutlineLeft(self):
	
	# clear_stats() ; # stat()
	c = self
	v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent: return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 10/8/03
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.
	# print_stats()</t>
<t tx="T1986">def moveOutlineRight(self):
	
	# clear_stats() ; # stat()
	c = self
	v = c.currentVnode()
	if not v: return
	back = v.back()
	if not back: return
	if not c.checkMoveWithParentWithWarning(v,back,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		n = back.numberOfChildren()
		v.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 7/6/02
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.
	# print_stats()</t>
<t tx="T1987">def moveOutlineUp(self):

	c = self
	v = c.currentVnode()
	if not v: return
	back = v.visBack()
	if not back: return
	back2 = back.visBack()
	c = self
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v up &gt;&gt;
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 10/8/03
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1988"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if not back2:
	# v will be the new root node
	v.moveToRoot(c.frame.rootVnode()) # 3/16/02, 5/17/02
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(v,back2,true):
		v.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(v,back2.parent(),true):
	# Insert after back2.
	v.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T1989">def promote(self):

	c = self
	v = c.currentVnode()
	if not v or not v.hasChildren(): return
	last = v.lastChild() # EKR: 3/19/03
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		after = v
		while v.hasChildren():
			child = v.firstChild()
			child.moveAfter(after)
			after = child
		v.setDirty()
		c.setChanged(true)
		c.selectVnode(v)
	c.endUpdate()
	c.undoer.setUndoParams("Promote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1990">def dragCloneAfter (self,v,after):

	c = self
	c.beginUpdate()
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	# trace("v,after:"+v.headString()+","+after.headString())
	if not c.checkMoveWithParentWithWarning(clone,after.parent(),true):
		trace("invalid clone move")
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveAfter(after)
	c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T1991">Two new settings:
	
allow_clone_drags = 1
# 1: Allows control-dragging to create clones.
# 0: All drags move nodes.
# See also: look_for_control_drag_on_mouse_down
# Setting this setting to 0 allows Leo to be used on Aqua.

enable_drag_messages = 1
# 1: Tell whether drags will move nodes or clone nodes.
# 0: Don't issue such messages.</t>
<t tx="T1992"></t>
<t tx="T1993">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2239827
By: sanori

At line 1854 (in createOpenWithTempFile method) of src/LeoFrame.py, the
v.bodyString() is *encoded* as given encoding and saved to temporary file. But,
at line 64 (in on_idle method) of plugin/open_with.py, the string in the file,
s, is copied back to leo pane, *without decoding*.

The code in plugin/open_with.py, v.setBodyStringOrPane(s) assumes that the saved
file is encoded as UTF-8. But, if a user specifies the encoding other than UTF-8
or ASCII, it messes up the leo pane.

Therefore, the code should be changed to v.setBodyStringOrPane(s, encoding)
, I think.

Am I right?

-Sanori</t>
<t tx="T1994"></t>
<t tx="T1995"></t>
<t tx="T1996">@nocolor

This was tricky to get right:
	
- There are several calls to after_idle(idle_body_key), so which gets scheduled is a matter of timing.  To handle that I added the tree.forceFullRedraw() routine.

- The undo/redo code also recolors the text.  Added a new param to undoRedoText so that it could force a full redraw after cut/paste.</t>
<t tx="T1997"># Coloring...
def getColorizer(self): return self.tree.colorizer
def recolor_now(self,v): return self.tree.recolor_now(v)
def recolor_range(self,v,leading,trailing): return self.tree.recolor_range(v,leading,trailing)
def recolor(self,v,incremental=false): return self.tree.recolor(v,incremental)
def updateSyntaxColorer(self,v): return self.tree.colorizer.updateSyntaxColorer(v)

# Drawing.
def beginUpdate(self): return self.tree.beginUpdate()
def endUpdate(self,flag=true): return self.tree.endUpdate(flag)
def drawIcon(self,v,x,y): return self.tree.drawIcon(v,x,y)
def redraw(self): return self.tree.redraw()
def redraw_now(self): return self.tree.redraw_now()

# Editing...
def editLabel(self,v): return self.tree.editLabel(v)
def editVnode(self): return self.tree.editVnode  
def endEditLabel(self): return self.tree.endEditLabel()
def setEditVnode(self,v): self.tree.editVnode = v
def setNormalLabelState(self,v): return self.tree.setNormalLabelState(v)

# Focus...
def focus_get(self): return self.tree.canvas.focus_get()

# Fonts...
def getFont(self): return self.tree.getFont()
def setFont(self,font): return self.tree.setFont(font)  

# Scrolling... 
def scrollTo(self,v): return self.tree.scrollTo(v)
def idle_scrollTo(self,v): return self.tree.idle_scrollTo(v)

# Selecting...
def select(self,v,updateBeadList=true): return self.tree.select(v,updateBeadList)

# Getters and setters...
def currentVnode(self): return self.tree.currentVnode
def dragging(self): return self.tree.dragging
def rootVnode(self): return self.tree.rootVnode
def topVnode(self): return self.tree.topVnode
def setCurrentVnode(self,v): self.tree.currentVnode = v
def setRootVnode(self,v): 	self.tree.rootVnode = v
def setTreeIniting(self,flag): self.tree.initing = flag

# vnode callbacks: to be removed.
if 1: # No longer needed if the tree class injects the vnode callbacks.
	def OnBoxClick(self,v): return self.tree.OnBoxClick(v)
	def OnIconClick(self,v,event): return self.tree.OnIconClick(v,event)
	def OnIconDoubleClick(self,v,event): return self.tree.OnIconDoubleClick(v,event)
	def OnIconRightClick(self,v,event): return self.tree.OnIconRightClick(v,event)
	def OnDrag(self,v,event): return self.tree.OnDrag(v,event)
	def OnEndDrag(self,v,event): return self.tree.OnEndDrag(v,event)
	def OnPopup(self,v,event): return self.tree.OnPopup(v,event)
# OnHeadlineClick
# OnHeadlineRightClick
def OnActivateHeadline(self,v): return self.tree.OnActivate(v)

# Notifications. Can these be folded into convenience routines??
def onBodyChanged(self,*args,**keys): return self.tree.onBodyChanged(*args,**keys)
def onHeadChanged(self,*args,**keys): return self.tree.onHeadChanged(*args,**keys)
def OnHeadlineKey(self,v,event): return self.tree.OnHeadlineKey(v,event)
def idle_head_key(self,v): return self.tree.idle_head_key(v)

# Others...
def expandAllAncestors(self,v): return self.tree.expandAllAncestors(v)
def getEditTextDict(self,v): return self.tree.edit_text_dict.get(v)</t>
<t tx="T1998">def recolor(self,v,incremental=0):

	body = self.commands.frame.body
	
	if 0: # Do immediately
		self.colorizer.colorize(v,body,incremental)
	else: # Do at idle time
		self.colorizer.schedule(v,body,incremental)

def recolor_now(self,v,incremental=0):

	body = self.commands.frame.body
	self.colorizer.colorize(v,body,incremental)
	
def recolor_range(self,v,leading,trailing):

	body = self.commands.frame.body
	self.colorizer.recolor_range(v,body,leading,trailing)</t>
<t tx="T1999">elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`redoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.v:
		c.selectVnode(u.v)
	elif redoType in ("Cut","Paste"):
		c.frame.tree.forceFullRecolor()

	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo",undoType=redoType)
	
	if u.newSel:
		start,end=u.newSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif redoType == "Change All":

	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# trace(`redoType`)
		if redoType == "Change All":
			c.selectVnode(u.v)
			break
		elif redoType == "Change":
			u.v.t.setTnodeText(u.newText)
			u.v.setDirty()
		elif redoType == "Change Headline":
			u.v.initHeadString(u.newText)
		else: assert(false)

elif redoType == "Change Headline":
	
	# trace(`u.newText`)
	u.v.setHeadStringOrHeadline(u.newText)
	# Update all joined headlines.
	for v2 in u.v.t.joinList:
		if v2 != u.v:
			v2.setHeadString(u.newText)
	c.selectVnode(u.v)</t>
<t tx="T2000">@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`undoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.v:
		c.selectVnode(u.v)
	elif undoType in ("Cut","Paste"):
		c.frame.tree.forceFullRecolor()

	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo",undoType=undoType)
	if u.oldSel:
		start,end=u.oldSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif undoType == "Change All":

	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# trace(`undoType`)
		if undoType == "Change All":
			c.selectVnode(u.v)
			break
		elif undoType == "Change":
			u.v.t.setTnodeText(u.oldText)
			u.v.setDirty()
		elif undoType == "Change Headline":
			u.v.initHeadString(u.oldText)
		else: assert(false)
		
elif undoType == "Change Headline":
	
	# trace(`u.oldText`)
	u.v.setHeadStringOrHeadline(u.oldText)
	# 9/24/02: update all joined headlines.
	for v2 in u.v.t.joinList:
		if v2 != u.v:
			v2.setHeadString(u.oldText)
	c.selectVnode(u.v)</t>
<t tx="T2001"></t>
<t tx="T2002"></t>
<t tx="T2003">@nocolor

This does not take into account the following line number issues:
	
- Source lines in doc parts may be broken into shorter lines.
  The trailing newline convention determines whether trailing newlines are real or not.
- There are problems with trailing newlines in body text.
- Lines may have been inserted or deleted from the derived file.

A better way to find a given line would be as follows:
	
- Scan backward from line "n", looking for a "suitable" line for comparisons.
  This line should have a minimum number of non-whitespace characters.
- Remember the offset of this line from line "n".
- Given a "candidate" offset into a vnode, scan forward and backward
  until a matching line in the outline is found.
  (A match is not guaranteed if the derived file has been changed).</t>
<t tx="T2004">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1928067
Open Discussion

I would like Go To Line Number to work with @file-nosent files also.

// Niklas

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1929033

One idea on how to do it is to tie in "Go To Line Number" to the write code
that produces the outline. This will ensure that line numbers are always perfectly
accurate. Here is a working proof-of-concept implementation for the atFile class
(I don't know enough about Leo's internals to write a "real" implementation.)

def gotoLine(self,root,n, nosentinels=false):
...c = self.commands
...self.sentinels = not nosentinels
...
...&lt;&lt; initialize &gt;&gt;
...
...# additional init
...self.startSentinelComment = ''
...
...old_os = self.os
...old_put_body = self.putBodyPart
...
...class gotoResult:
.......pass
.......
...result = gotoResult()
...result.total = 0
...result.found = false
...result.nodes = [None]
...result.node_lines = [0]

...def gotoOs(self, s):
.......result.total += s.count('\n')
.......result.node_lines[-1] += s.count('\n')
.......if result.total &gt;= n and not result.found:
...........result.found = true
...........result.lines = result.total
...........result.node = result.nodes[-1]
...........result.line = result.node_lines[-1] + result.total - n
.......
...def gotoPutBodyPart(self, v):
.......result.nodes.append(v)
.......result.node_lines.append(0)
.......old_put_body(v)
.......result.node_lines.pop()
.......result.nodes.pop()
.......
...try:
.......atFile.os = gotoOs
.......atFile.putBodyPart = gotoPutBodyPart
...
.......&lt;&lt; write then entire @file tree &gt;&gt;
.......
...finally:
.......atFile.os = old_os
.......atFile.putBodyPart = old_put_body
.......
...if result.found and result.node:
.......return (result.node, result.line)
...else:
.......return (root, 1)

the &lt;&lt;references&gt;&gt; are cloned from the write node.

// Niklas
</t>
<t tx="T2005">@language c
@ignore
@color</t>
<t tx="T2006">@first line 5
line6
line7
&lt;&lt; ref &gt;&gt;
line 17
line 18</t>
<t tx="T2007">ref line 12
ref line 13</t>
<t tx="T2008">@first line 1
line6
line7
&lt;&lt; ref &gt;&gt;
line 9
line 10</t>
<t tx="T2009">ref line 15
ref line 16
</t>
<t tx="T2010"></t>
<t tx="T2011">def scanElispText(self,s,v):
	
	c = self.commands
	v.appendStringToBody("@ignore\n@language elisp\n")
	i = 0 ; start = 0
	while i &lt; len(s):
		progress = i
		ch = s[i] ; # trace(get_line(s,i))
		if ch == ';':
			i = skip_line(s,i)
		elif ch == '(':
			j = self.skipElispParens(s,i)
			k = skip_ws(s,i+1)
			if match_word(s,k,"defun") or match_word(s,k,"defconst") or match_word(s,k,"defvar"):
				data = s[start:i]
				if data.strip():
					self.createElispDataNode(v,data)
				self.createElispFunction(v,s[i:j+1])
				start = j+1
			i = j
		else:
			i += 1
		assert(progress &lt; i)
	data = s[start:len(s)]
	if data.strip():
		self.createElispDataNode(v,data)</t>
<t tx="T2012">def skipElispParens (self,s,i):
	
	level = 0 ; n = len(s)
	assert(match(s,i,'('))
	
	while i &lt; n:
		c = s[i]
		if c == '(':
			level += 1 ; i += 1
		elif c == ')':
			level -= 1
			if level &lt;= 0:
				return i
			i += 1
		elif c == '"': i = skip_string(s,i) # Single-quotes are not strings.
		elif match(s,i,";"):  i = skip_line(s,i)
		else: i += 1
	return i
</t>
<t tx="T2013">def skipElispId (self,s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c in string.ascii_letters or c in string.digits or c == '-':
			i += 1
		else: break
	return i</t>
<t tx="T2014">def createElispFunction (self,v,s):
	
	body = s
	i = 1 # Skip the '('
	i = skip_ws(s,i)

	# Set the prefix in the headline.
	assert(match(s,i,"defun") or match_word(s,i,"defconst") or match_word(s,i,"defvar"))
	if match_word(s,i,"defconst"):
		prefix = "const "
	elif match_word(s,i,"defvar"):
		prefix = "var "
	else:
		prefix = ""

	# Skip the "defun" or "defconst" or "defvar"
	i = self.skipElispId(s,i)
	
	# Get the following id.
	i = skip_ws(s,i)
	j = self.skipElispId(s,i)
	id = prefix + s[i:j]

	self.createHeadline(v,body,id)
</t>
<t tx="T2015">def createElispDataNode (self,v,s):
	
	data = s
	# trace(len(data))
	
	# Skip blank lines and comment lines.
	i = 0
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if match(s,i,';'):
			i = skip_line(s,i)
		else: break

	# Find the next id, probably prefixed by an open paren.
	if match(s,i,"("):
		i = skip_ws(s,i+1)
	j = self.skipElispId(s,i)
	id = s[i:j]
	if not id:
		id = "unnamed data"

	self.createHeadline(v,data,id)</t>
<t tx="T2016">@nocolor

The old code gets this done with some pretty ugly code.

@color</t>
<t tx="T2017">def rawWrite(self,root):

	at = self
	if at.trace: trace("new_df",root)

	c = at.commands ; at.root = root
	at.errors = 0
	at.root.tnodeList = [] # 9/26/03: after beta 1 release.
	at.sentinels = true # 10/1/03
	c.endEditing() # Capture the current headline.
	try:
		at.targetFileName = root.atRawFileNodeName()
		ok = at.openWriteFile(root)
		if not ok: return
		&lt;&lt; write root's tree &gt;&gt;
		at.closeWriteFile()
		at.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		at.handleWriteException(root)</t>
<t tx="T2018">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

next = root.nodeAfterTree()
v = root
while v and v != next:
	&lt;&lt; Write v's node &gt;&gt;
	v = v.threadNext()

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T2019">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# Write @first line, whether empty or not
	line = s[j:i]
	at.putBuffered(line) ; at.onl()
	i = skip_nl(s,i)</t>
<t tx="T2020">s2 = app.config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)&gt; 0:
			at.putSentinel("@comment " + line)
</t>
<t tx="T2021">at.putOpenNodeSentinel(v)

s = v.bodyString()
if s and len(s) &gt; 0:
	s = toEncodedString(s,at.encoding,reportErrors=true) # 3/7/03
	at.outputStringWithLineEndings(s)
	
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
	at.onl() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(v)
</t>
<t tx="T2022">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	at.putBuffered(line[i:]) ; at.onl()</t>
<t tx="T2023">def putLeadInSentinel (self,s,i,j,delta):
	
	"""Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
	
	Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

	i points at the start of a line.
	j points at @others or a section reference.
	delta is the change in at.indent that is about to happen and hasn't happened yet."""

	at = self
	at.leadingWs = "" # Set the default.
	if i == j:
		return # The @others or ref starts a line.

	k = skip_ws(s,i)
	if j == k:
		# Only whitespace before the @others or ref.
		if 1: # new code
			at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
		else:
			# The @ws sentinel contributs the _delta_ of the whitespace that precedes it.
			at.putIndent(at.indent) ; at.os(s[i:j]) # Put the whitespace, preserving its spelling.
			oldIndent = at.indent ; at.indent = 0 # Put the @ws sentinel with no more leading whitespace.
			at.putSentinel("@ws")
			at.indent = oldIndent
	else:
		at.os(s[i:j]) ; at.onl() # 10/21/03: changed s[k:j] to s[i:j].
		at.indent += delta # Align the @nonl with the following line.
		at.putSentinel("@nonl")
		at.indent -= delta # Let the caller set at.indent permanently.</t>
<t tx="T2024"></t>
<t tx="T2025">def open(self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	c.beginUpdate()
	ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=true)
	&lt;&lt; Make the top node visible &gt;&gt;
	c.endUpdate()
	# delete the file buffer
	self.fileBuffer = ""
	return ok</t>
<t tx="T2026">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = os.path.dirname(fileName) 
if len(dir) &gt; 0:
	c.openDirectory = dir</t>
<t tx="T2027">if 0: # This can't be done directly.

	# This should be done after the pane size has been set.
	top = c.frame.topVnode()
	if top: c.frame.scrollTo(top)</t>
<t tx="T2028"># The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None):
	
	"""Common read logic for any derived file."""
	
	at = self ; c = at.commands
	at.errors = 0
	at.scanDefaultDirectory(root)
	if at.errors: return
	&lt;&lt; set fileName from root and importFileName &gt;&gt;
	&lt;&lt; open file or return false &gt;&gt;
	es("reading: " + root.headString())
	firstLines,read_new = at.scanHeader(file,fileName)
	df = choose(read_new,at.new_df,at.old_df)
	&lt;&lt; copy ivars to df &gt;&gt;
	root.clearVisitedInTree()
	try:
		df.readOpenFile(root,file,firstLines)
	except:
		at.error("Unexpected exception while reading derived file")
		es_exception()
	file.close()
	root.clearDirty() # May be set dirty below.
	after = root.nodeAfterTree()
	&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;
	if df.errors == 0:
		if not df.importing:
			&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;
	&lt;&lt; delete all tempBodyStrings &gt;&gt;
	return df.errors == 0</t>
<t tx="T2029">if importFileName:
	fileName = importFileName
elif root.isAtFileNode():
	fileName = root.atFileNodeName()
else:
	fileName = root.atRawFileNodeName()
	
if not fileName:
	at.error("Missing file name.  Restoring @file tree from .leo file.")
	return false</t>
<t tx="T2030">fn = os.path.join(at.default_directory,fileName)
fn = os.path.normpath(fn)
fn = toUnicode(fn,"ascii")

try:
	file = open(fn,'r')
	if file:
		&lt;&lt; warn on read-only file &gt;&gt;
	else: return false
except:
	at.error("Can not open: " + '"@file ' + fn + '"')
	root.setDirty()
	return false</t>
<t tx="T2031">try:
	read_only = not os.access(fn,os.W_OK)
	if read_only:
		es("read only: " + fn,color="red")
except:
	pass # os.access() may not exist on all platforms.</t>
<t tx="T2032">df.importing = importFileName != None
df.importRootSeen = false

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.targetFileName = fileName
df.indent = 0
df.raw = false
df.root = root
df.root_seen = false
</t>
<t tx="T2033">v = root
while v and v != after:
	try: s = v.t.tempBodyString
	except: s = ""
	if s and not v.t.isVisited():
		at.error("Not in derived file:" + v.headString())
		v.t.setVisited() # One message is enough.
	v = v.threadNext()</t>
<t tx="T2034">v = root
while v and v != after:
	try: s = v.t.tempBodyString
	except: s = ""
	if s != v.bodyString():
		es("changed: " + v.headString(),color="blue")
		if 0: # For debugging.
			print ; print "changed: " + v.headString()
			print ; print "new:",`s`
			print ; print "old:",`v.bodyString()`
		v.setBodyStringOrPane(s) # Sets v and v.commands dirty.
		v.setMarked()
	v = v.threadNext()</t>
<t tx="T2035">v = root
while v and v != after:
	if hasattr(v.t,"tempBodyString"):
		delattr(v.t,"tempBodyString")
	v = v.threadNext()</t>
<t tx="T2036">def setChanged (self,changedFlag):

	c = self
	if not c.frame: return
	# Clear all dirty bits _before_ setting the caption.
	# 9/15/01 Clear all dirty bits except orphaned @file nodes
	if not changedFlag:
		# trace("clearing all dirty bits")
		v = c.rootVnode()
		while v:
			if v.isDirty() and not (v.isAtFileNode() or v.isAtRawFileNode()):
				v.clearDirtyJoined()
			v = v.threadNext()
	# Update all derived changed markers.
	c.changed = changedFlag
	s = c.frame.getTitle() # s = c.frame.top.title()
	if len(s) &gt; 2 and not c.loading: # don't update while loading.
		if changedFlag:
			# import traceback ; traceback.print_stack()
			if s [0] != '*': c.frame.top.title("* " + s)
		else:
			if s[0:2]=="* ": c.frame.top.title(s[2:])


</t>
<t tx="T2037"></t>
<t tx="T2038"></t>
<t tx="T2039">@nocolor

I just installed the latest version of Leo and I haven't yet forced it  
to run without a terminal window so I was able to see why I can't  
change my language preference.  Here's why:

Exception in Tkinter callback
Traceback (most recent call last):
   File  
"/Library/Frameworks/Python.framework/Versions/2.3/lib/python2.3/lib- 
tk/Tkinter.py", line 1345, in __call__
     return self.func(*args)
   File "/usr/local/lib/leo/src/leoPrefs.py", line 313, in set_lang
     c = top() ; v = c.currentVnode()
AttributeError: 'NoneType' object has no attribute 'currentVnode'
</t>
<t tx="T2040"># This event handler gets executed when the user chooses a new default language.

def set_lang (self):
	
	c = self.commands
	v = c.currentVnode()
	language = self.lang_var.get()
	c.target_language = self.target_language = language
	c.frame.recolor(v)
	# trace(language)</t>
<t tx="T2041">@ frame.doCommand and frame.OnMenuClick now set app.log, so top() will be reliable after any command is executed.

Note 1: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
@c

def top():
	
	"""Return the commander of the topmost window"""
	
	# Warning: may be called during startup or shutdown when nothing exists.
	try:
		return app.log.commands
	except:
		return None</t>
<t tx="T2042"></t>
<t tx="T2043"></t>
<t tx="T2044">#class level-code after the method definitions is dropped.

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="T2045"></t>
<t tx="T2046">@ Creates a child node c of parent for the class, and children of c for each def in the class.
@c

def scanPythonClass (self,s,i,start,parent):

	# trace(get_line(s,i))
	classIndent = self.getLeadingIndent(s,i)
	&lt;&lt; set classname and headline, or return i &gt;&gt;
	i = skip_line(s,i) # Skip the class line.
	&lt;&lt; create class_vnode &gt;&gt;
	savedMethodName = self.methodName
	self.methodName = headline
	# Create a node for leading declarations of the class.
	i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=true)
	&lt;&lt; create nodes for all defs of the class &gt;&gt;
	&lt;&lt; append any other class material &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T2047"># Skip to the class name.
i = skip_ws(s,i)
i = skip_c_id(s,i) # skip "class"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	classname = s[j:i]
	headline = "class " + classname
else:
	return i</t>
<t tx="T2048"># Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
	self.methodsSeen = true

# i points just after the class line.
body = s[start:i]
body = self.undentBody(body)
class_vnode = self.createHeadline(parent,prefix + body,headline)
</t>
<t tx="T2049">indent =  self.getLeadingIndent(s,i)
start = i = skip_blank_lines(s,i)
parent_vnode = None # 7/6/02
while i &lt; len(s) and indent &gt; classIndent:
	progress = i
	if is_nl(s,i):
		j = skip_nl(s,i)
		indent = self.getLeadingIndent(s,j)
		if indent &gt; classIndent: i = j
		else: break
	elif match_c_word(s,i,"def"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonDef(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif match_c_word(s,i,"class"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonClass(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif s[i] == '#': i = skip_to_end_of_line(s,i)
	elif s[i] == '"' or s[i] == '\'': i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T2050"># This must be done after the declaration reference is generated.
if self.treeType == "@file":
	class_vnode.appendStringToBody("\t@others\n")
else:
	ref = angleBrackets(" class " + classname + " methods ")
	class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode</t>
<t tx="T2051">s2 = s[start:i]
if s2:
	class_vnode.appendStringToBody(s2)</t>
<t tx="T2052">@ Creates a node of parent for the def.
@c

def scanPythonDef (self,s,i,start,parent):

	# trace(get_line(s,i))
	&lt;&lt; set headline or return i &gt;&gt;
	&lt;&lt; skip the Python def &gt;&gt;
	# Create the def node.
	savedMethodName = self.methodName
	self.methodName = headline
	&lt;&lt; Create def node &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T2053">i = skip_ws(s,i)
i = skip_c_id(s,i) # Skip the "def"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	headline = s[j:i]
	# trace("headline:" + `headline`)
else: return i</t>
<t tx="T2054"># Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
while i &lt; len(s) and indent &gt; defIndent:
	progress = i
	ch = s[i]
	if is_nl(s,i):
		i = skip_nl(s,i)
		indent = self.getLeadingIndent(s,i)
		if indent &lt;= defIndent:
			break
	elif ch == '#':
		i = skip_to_end_of_line(s,i) # 7/29/02
	elif ch == '"' or ch == '\'':
		i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T2055"># Create the prefix line for @root trees.
if self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
	self.methodsSeen = true

# Create body.
start = skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="T2056">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=true):
	
	done = false ; start = i
	while not done and i &lt; len(s):
		progress = i
		# trace(get_line(s,i))
		ch = s[i]
		if ch == '\n':
			i = skip_nl(s,i)
			# 2/14/03: break on lesser indention.
			j = skip_ws(s,i)
			if not is_nl(s,j) and not match(s,j,"#"):
				lineIndent = self.getLeadingIndent(s,i)
				if lineIndent &lt;= indent:
					break
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'':
			i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; break on def or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	j = skip_blank_lines(s,start)
	if is_nl(s,j): j = skip_nl(s,j)
	if j &lt; i:
		&lt;&lt; Create a child node for declarations &gt;&gt;
	return i</t>
<t tx="T2057">if match_c_word(s,i,"def") or match_c_word(s,i,"class"):
	i = find_line_start(s,i)
	done = true
	break
else:
	i = skip_c_id(s,i)</t>
<t tx="T2058">headline = ref = angleBrackets(" " + self.methodName + " declarations ")
leading_tab = choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
	body = "@code\n\n" + body
self.createHeadline(parent,body,headline)</t>
<t tx="T2059">@ This code creates a child of parent for each Python function definition seen.  See the comments for scanCText for what the text looks like.
@c

def scanPythonText (self,s,parent):

	decls_seen = false ; start = i = 0
	self.methodsSeen = false
	while i &lt; len(s):
		progress = i
		# trace(get_line(s,i))
		ch = s[i]
		if ch == '\n' or ch == '\r': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; handle possible Python function or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	if not decls_seen: # 2/17/03
		parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
	&lt;&lt; Append a reference to the methods of this file &gt;&gt;
	&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="T2060">if match_c_word(s,i,"def") or match_word(s,i,"class"):
	isDef = match_c_word(s,i,"def")
	if not decls_seen:
		parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
		i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=false)
		decls_seen = true
		if self.treeType == "@file": # 7/29/02
			parent.appendStringToBody("@others\n") # 7/29/02
	if isDef:
		i = start = self.scanPythonDef(s,i,start,parent)
	else:
		i = start = self.scanPythonClass(s,i,start,parent)
else:
	i = skip_c_id(s,i)</t>
<t tx="T2061">if self.treeType == "@root" and self.methodsSeen:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n\n")</t>
<t tx="T2062"># Do nothing if only whitespace is left.
i = start ; i = skip_ws_and_nl(s,i)
if i &lt; len(s):
	parent.appendStringToBody(s[start:])</t>
<t tx="T2063"></t>
<t tx="T2064"></t>
<t tx="T2065">@nocolor

By: szemengtan ( Sze Meng Tan ) 
 Remove Sentinels command in version 4   
2003-10-15 07:41  

 I am running Leo version 4 beta 4 under Windows XP and am unable to get the Remove Sentinels command under the Export menu to work correctly. Although the program reports the creation of the output file with a .txt extension, the resulting output file is blank. This command appears to work correctly in version 3.12.

Best regards,

Sze Tan
 
</t>
<t tx="T2066">def removeSentinelsCommand (self,fileName):

	self.setEncoding()
	path, self.fileName = os.path.split(fileName) # path/fileName
	&lt;&lt; Read file into s &gt;&gt;
	valid = true
	line_delim = start_delim = end_delim = None
	&lt;&lt; set delims from the header line &gt;&gt;
	if valid == false:
		es("invalid @+leo sentinel in " + fileName)
		return

	# trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))

	s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
	ext = app.config.remove_sentinels_extension
	if ext == None or len(ext) == 0:
		ext = ".txt"
	if ext[0] == '.':
		newFileName = os.path.join(path,fileName+ext)
	else:
		head,ext2 = os.path.splitext(fileName) 
		newFileName = os.path.join(path,head+ext+ext2)
	&lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="T2067">try:
	file = open(fileName)
	s = file.read()
	s = toUnicode(s,self.encoding)
	file.close()
except:
	es("exception while reading " + fileName)
	es_exception()
	return</t>
<t tx="T2068"># This code is similar to atFile::scanHeader.

tag = "@+leo" ; tag2 = "-ver="
# Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not find_on_line(s,i,tag):
	i = skip_line(s,i)
# We should be at the @+leo line.
i = j = skip_ws(s,i)
# The opening comment delim is the initial non-whitespace.
while i &lt; len(s) and not match(s,i,tag) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i: line_delim = s[j:i]
else: valid = false
# Make sure we have @+leo
i = skip_ws(s,i)
if match(s,i,tag): i += len(tag)
else: valid = false
# Skip a version tag. Bug fix: 10/15/03
if valid and match(s,i,tag2):
	i += len(tag2) + 1 # Skip the tag and the actual version.
# The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	start_delim = line_delim
	end_delim = s[j:i]
	line_delim = None</t>
<t tx="T2069"></t>
<t tx="T2070"></t>
<t tx="T2071"></t>
<t tx="T2072"></t>
<t tx="T2073"></t>
<t tx="T2074"></t>
<t tx="T2075">@nocolor


@color</t>
<t tx="T2076">def importDerivedFiles (self,parent,fileName):
	
	c = self.commands ; at = c.atFileCommands
	current = c.currentVnode()
	
	c.beginUpdate()
	v = parent.insertAfter()
	v.initHeadString("Imported @file " + fileName)
	c.undoer.setUndoParams("Import",v,select=current)
	at.read(v,importFileName=fileName)
	c.selectVnode(v)
	v.expand()
	c.endUpdate()
</t>
<t tx="T2077">def createImportedNode (self,root,c,headline):
	
	at = self

	if at.importRootSeen:
		v = at.root.insertAsLastChild()
		v.initHeadString(headline)
	else:
		# Put the text into the already-existing root node.
		v = at.root
		at.importRootSeen = true
		
	v.t.setVisited() # Suppress warning about unvisited node.
	return v</t>
<t tx="T2078">@nocolor

What I did:

v.copyTree isn't enough to save undo info: it doesn't create new tnodes.  Alas, it can't create new tnodes because of clones.  Therefore, I replaced v.copyTree with c.undoer.copyTree(v).

The undoer must save and restore any tnodeList and unknownAttribute ivars.  Failure to restore tnodeList ivars will cause problems when @file nodes are written.

@color</t>
<t tx="T2079">C:\prog\leoCVS\leo&gt;c:\python23\python src\leo.py test\test.leo
Text encoding = cp1252
4 plugins loaded, 39 examined
C:\prog\leoCVS\leo&gt;t

C:\prog\leoCVS\leo&gt;cd c:\prog\LeoCVS\leo

Did Extract Section Names command, then undo:

C:\prog\leoCVS\leo&gt;c:\python23\python src\leo.py test\test.leo
Text encoding = cp1252
4 plugins loaded, 39 examined
exception executing command
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoFrame.py", line 1598, in doCommand
    command(event)
  File "C:\prog\leoCVS\leo\src\leoFrame.py", line 2428, in OnUndo
    self.commands.undoer.undo()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 801, in undo
    u.v = self.undoReplace(u.v,u.oldTree,u.oldText)
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 998, in undoReplace
    assert(new_v in joinList)
AssertionError
</t>
<t tx="T2080"></t>
<t tx="T2081">def saveTree (self,v):
	
	tree = v.copyTree()
	headlines = []
	bodies = []
	extraAttributes = []
	after = v.nodeAfterTree()
	while v and v != after:
		headlines.append(v.headString())
		bodies.append(v.bodyString())
		data = v.extraAttributes(), v.t.extraAttributes()
		extraAttributes.append(data)
		v = v.threadNext()
	return tree, headlines, bodies, extraAttributes

def restoreExtraAttributes (self,v,extraAttributes):

	v_extraAttributes, t_extraAttributes = extraAttributes
	v.setExtraAttributes(v_extraAttributes)
	v.t.setExtraAttributes(t_extraAttributes)</t>
<t tx="T2082">def extraAttributes (self):

	try:    return self.unknownAttributes
	except: return None
	
def setExtraAttributes (self,attributes):
	
	if attributes != None:
		self.unknownAttributes = attributes</t>
<t tx="T2083">def extraAttributes (self):

	try:    tnodeList = self.tnodeList
	except: tnodeList = None
	
	try:    unknownAttributes = self.unknownAttributes
	except: unknownAttributes = None

	return tnodeList, unknownAttributes
	
def setExtraAttributes (self,data):
	
	tnodeList, unknownAttributes = data

	if tnodeList != None:
		self.tnodeList = tnodeList

	if unknownAttributes != None:
		self.unknownAttributes = unknownAttributes</t>
<t tx="T2084">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2231060
By: riotnrrrd



</t>
<t tx="T2085">import sys,string
print sys.version
print u'\xa6' in string.ascii_letters
print u'\xa6' in string.letters # fails _sometimes_</t>
<t tx="T2086">With Python 2.2 (on Linux) it works, still no luck with 2.3: starting with no
.leo file specified, the window opens, but typing any letter in the body pane
produces the log:

---
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)
---

and the traceback:

---
Traceback (most recent call last):
  File "/home/opt/leo/leo-4.0-b3/src/leoColor.py", line 1464,
in colorizeAnyLanguage
    state = self.colorizeLine(new_lines[i],state)
  File "/home/opt/leo/leo-4.0-b3/src/leoColor.py", line 1580, in colorizeLine
    i,state = func(s,i)
  File "/home/opt/leo/leo-4.0-b3/src/leoColor.py", line 1829, in doNormalState
    if ch in string.ascii_letters or ch == '_' or (
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)
---</t>
<t tx="T2087"></t>
<t tx="T2088">Starting with leoConfig.leo the window opens for a second, then dies, and the
following traceback is produced:

Traceback (most recent call last):
  File "/home/opt/leo/leo-4.0-b3/src/leoGlobals.py", line 743, in
openWithFileName
    frame.commands.fileCommands.open(file,fileName) # closes file.
  File "/home/opt/leo/leo-4.0-b3/src/leoFileCommands.py", line 999, in open
    ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=true)
  File "/home/opt/leo/leo-4.0-b3/src/leoFileCommands.py", line 493, in
getLeoFile
    c.selectVnode(c.frame.currentVnode()) # load body pane
  File "/home/opt/leo/leo-4.0-b3/src/leoCommands.py", line 2124, in selectVnode
    c.frame.select(v,updateBeadList)
  File "/home/opt/leo/leo-4.0-b3/src/leoFrame.py", line 636, in select
    def select(self,v,updateBeadList=true): return self.tree.select(v,updateBeadList)
  File "/home/opt/leo/leo-4.0-b3/src/leoTree.py", line 2220, in select
    frame.setWrap(v)
  File "/home/opt/leo/leo-4.0-b3/src/leoFrame.py", line 559, in setWrap
    dict = scanDirectives(c,v)
  File "/home/opt/leo/leo-4.0-b3/src/leoGlobals.py", line 590, in scanDirectives
dict = get_directives_dict(s)
  File "/home/opt/leo/leo-4.0-b3/src/leoGlobals.py", line 409, in
get_directives_dict
    j = skip_c_id(s,i+1)
  File "/home/opt/leo/leo-4.0-b3/src/leoGlobals.py", line 2736, in skip_c_id
    if c in string.letters or c in string.digits or c == '_':
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)


Traceback (most recent call last):
  File "./leo.py", line 177, in ?
    run(fileName)
  File "./leo.py", line 62, in run
    c,frame = createFrame(fileName)
  File "./leo.py", line 131, in createFrame
    c,frame = app.gui.newLeoCommanderAndFrame(fileName=None)
  File "/home/opt/leo/leo-4.0-b3/src/leoGui.py", line 90, in
newLeoCommanderAndFrame
    frame.finishCreate(c)
  File "/home/opt/leo/leo-4.0-b3/src/leoFrame.py", line 146, in finishCreate
    self.signOnWithVersion()
  File "/home/opt/leo/leo-4.0-b3/src/leoFrame.py", line 101,
in signOnWithVersion
    es("Leo Log Window...",color=color)
  File "/home/opt/leo/leo-4.0-b3/src/leoGlobals.py", line 2049, in es
    log.put(s,color=color)
  File "/home/opt/leo/leo-4.0-b3/src/leoFrame.py", line 963, in put
    self.log.insert("end",s)
  File "/usr/lib/python2.3/lib-tk/Tkinter.py", line 2894, in insert
    self.tk.call((self._w, 'insert', index, chars) + args)
_tkinter.TclError: invalid command name
".1076707404.1076707500.1076707692.1076707532.1076707756.1076707564.log"</t>
<t tx="T2089"></t>
<t tx="T2090">@nocolor

** scanDirectives just uses v.t.bodyString.
	This looks wrong.  It should call v.bodyString(), and v.bodyString should assert(isUnicode(result))

- Move Text selection code from leoGlobals to leoGui.

- Make sure getpreferredencoding in leoGlobals isn't a problem.

** The code is full of Tk idioms.  Somehow these have to be abstracted away.
	- getSelectedCharacter
	- getSelectedLine
	etc.

Search for t.get, text.get, etc.

Search for t.bodyString (or just bodyString??)</t>
<t tx="T2091">@nocolor

1. Called getAllText in the following routines:

colorizeAnyLanguage
convertAllBlanks,convertAllTabs,extract,extractSection,extractSectionNames
OnExecuteScript

2. Called getSelectedText in the following routines:

OnExecuteScript

3. Called x = toUnicode(s,app.tkEncoding) in the following routines after a call to t.get(...)

bound_paragraph,getBodyLines,reformatParagraph
OnReturnKey
OnFindMatchingBracket,findMatchingBracket
updateStatusRowCol
changeAll,findAll
&lt;&lt; test for whole word match &gt;&gt;</t>
<t tx="T2092">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2212611
By: riotnrrrd

@nocolor

Sorry about the delay, I switched back to 2.2 for Leo and pretty much forgot
all about this.

Anyway, here goes:

System is Linux and using Leo 4.0b1 (though things seemed similar with 3.12).
Using Python 2.2 works fine, but with 2.3 I get the following (fresh install
of Leo, no changes to leoConfig.leo):

Opening without a .leo file:

Everything seems normal first but when I type a non-ascii character, the following
shows up in the log window:

-----
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)
-----

and the following traceback:








______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226</t>
<t tx="T2093">Traceback (most recent call last):
  File "/home/opt/leo/leo-4.0-b1/src/leoColor.py", line 1460,
in colorizeAnyLanguage
    state = self.colorizeLine(new_lines[i],state)
  File "/home/opt/leo/leo-4.0-b1/src/leoColor.py", line 1576, in colorizeLine
    i,state = func(s,i)
  File "/home/opt/leo/leo-4.0-b1/src/leoColor.py", line 1825, in doNormalState
    if ch in string.letters or ch == '_' or (

UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)
</t>
<t tx="T2094">When I open leo with leoConfig.leo, I get 

Leo Log Window...
Leo 4.0 beta 1, Python 2.3.0, Tk 8.4.4

reading: /home/opt/leo/leo-4.0-b1/config/leoConfig.leo
exceptions opening/home/opt/leo/leo-4.0-b1/config/leoConfig.leo

UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)

Leo Log Window...
Leo 4.0 beta 1, Python 2.3.0, Tk 8.4.4

File not found: /home/opt/leo/leo-4.0-b1/config/leoConfig.leo

in the log window and the traceback:

Traceback (most recent call last):
  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 972, in openWithFileName
    frame.commands.fileCommands.open(file,fileName) # closes file.

  File "/home/opt/leo/leo-4.0-b1/src/leoFileCommands.py", line 953, in open
    ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=true)

  File "/home/opt/leo/leo-4.0-b1/src/leoFileCommands.py", line 462, in getLeoFile
    c.selectVnode(c.tree.currentVnode) # load body pane

  File "/home/opt/leo/leo-4.0-b1/src/leoCommands.py", line 2120, in selectVnode
    c.tree.select(v,updateBeadList)

  File "/home/opt/leo/leo-4.0-b1/src/leoTree.py", line 1909, in select
    frame.setWrap(v)

  File "/home/opt/leo/leo-4.0-b1/src/leoFrame.py", line 559, in setWrap
    dict = scanDirectives(c,v)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 752, in scanDirectives
dict = get_directives_dict(s)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 569, in
get_directives_dict
    j = skip_c_id(s,i+1)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 2901, in skip_c_id
    if c in string.letters or c in string.digits or c == '_':

UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)</t>
<t tx="T2095">and a new Leo window opens. When I click another node, I don't get moved there,
but get the following:

exception handling , activate tree,  event
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)

in log, and the traceback:

Traceback (most recent call last):
  File "/home/opt/leo/leo-4.0-b1/src/leoTree.py", line 748, in OnActivate
    self.select(v)

  File "/home/opt/leo/leo-4.0-b1/src/leoTree.py", line 1909, in select
    frame.setWrap(v)

  File "/home/opt/leo/leo-4.0-b1/src/leoFrame.py", line 559, in setWrap
    dict = scanDirectives(c,v)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 752, in scanDirectives
dict = get_directives_dict(s)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 569, in
get_directives_dict
    j = skip_c_id(s,i+1)

  File "/home/opt/leo/leo-4.0-b1/src/leoGlobals.py", line 2901, in skip_c_id
    if c in string.letters or c in string.digits or c == '_':

UnicodeDecodeError: 'ascii' codec can't decode byte 0xa6 in position 52: ordinal
not in range(128)
</t>
<t tx="T2096">## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

	ch = s[i] ; state = "normal"
	assert(type(ch)==type(u""))

	if ch in string.ascii_letters or ch == '_' or (
		(ch == '\\' and self.language=="latex") or
		(ch in '/&amp;&lt;&gt;' and self.language=="html")):
		&lt;&lt; handle possible keyword &gt;&gt;
	elif match(s,i,self.lb):
		i = self.doNowebSecRef(s,i)
	elif ch == '@':
		&lt;&lt; handle at keyword &gt;&gt;
	elif match(s,i,self.single_comment_start):
		&lt;&lt; handle single-line comment &gt;&gt;
	elif match(s,i,self.block_comment_start):
		&lt;&lt; start block comment &gt;&gt;
	elif ch == '%' and self.language=="cweb":
		&lt;&lt; handle latex line &gt;&gt;
	elif self.language=="latex":
		&lt;&lt; handle latex normal character &gt;&gt;
	# ---- From here on self.language != "latex" -----
	elif ch in self.string_delims:
		&lt;&lt; handle string &gt;&gt;
	elif ch == '#' and self.has_pp_directives:
		&lt;&lt; handle C preprocessor line &gt;&gt;
	elif self.language == "php" and (match(s,i,"&lt;") or match(s,i,"?")):
		&lt;&lt; handle special php keywords &gt;&gt;
	elif ch == ' ':
		&lt;&lt; handle blank &gt;&gt;
	elif ch == '\t':
		&lt;&lt; handle tab &gt;&gt;
	else:
		&lt;&lt; handle normal character &gt;&gt;

	assert(self.progress &lt; i)
	return i,state
</t>
<t tx="T2097"></t>
<t tx="T2098">if self.language == "latex":
	&lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
	&lt;&lt; handle possible html keyword &gt;&gt;
else:
	&lt;&lt; handle general keyword &gt;&gt;
i = j</t>
<t tx="T2099">if match(s,i,"\\"):
	j = self.skip_id(s,i+1)
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.</t>
<t tx="T2100">if match(s,i,"&lt;!---") or match(s,i,"&lt;!--"):
	if match(s,i,"&lt;!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif match(s,i,"&lt;"):
	if match(s,i,"&lt;/"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif match(s,i,"&amp;"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif match(s,i,"/&gt;"):
	j = i + 2
	self.tag("keyword",i,j)
elif match(s,i,"&gt;"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
</t>
<t tx="T2101">if self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language == "elisp":
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)
word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
</t>
<t tx="T2102">if self.language == "cweb":
	if match(s,i,"@(") or match(s,i,"@&lt;"):
		&lt;&lt; handle cweb ref or def &gt;&gt;
	else:
		word = self.getCwebWord(s,i)
		if word:
			&lt;&lt; Handle cweb control word &gt;&gt;
		else:
			i,state = self.doAtKeyword(s,i)
else:
	i,state = self.doAtKeyword(s,i)</t>
<t tx="T2103"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
	j = s.find("@&gt;",i)
	if j &gt; -1:
		self.tag("cwebName",i,j)
		self.tag("nameBrackets",j,j+2)
		i = j + 2</t>
<t tx="T2104">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = choose(j==-1,2,3)
if j == -1:
	j = s.find("@&gt;",i+2)

if j == -1:
	i += 2
else:
	self.tag("cwebName",i+2,j)
	self.tag("nameBrackets",j,j+k)
	i = j + k
</t>
<t tx="T2105">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)</t>
<t tx="T2106"></t>
<t tx="T2107">if self.language=="cweb":
	self.tag("latexModeBackground",i,i+1)
else:
	self.tag("latexBackground",i,i+1)
i += 1</t>
<t tx="T2108"></t>
<t tx="T2109"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
	if match(s,i,self.single_comment_start) or match(s,i,self.block_comment_start):
		break
	else: i += 1

self.tag("pp",j,i)</t>
<t tx="T2110">if match(s,i,"&lt;?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif match(s,i,"?&gt;"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1
</t>
<t tx="T2111">if self.showInvisibles:
	self.tag("blank",i,i+1)
i += 1</t>
<t tx="T2112">if self.showInvisibles:
	self.tag("tab",i,i+1)
#print "tab",i,self.body.cget("tabs"),self.body.tag_config("tab")
i += 1</t>
<t tx="T2113"># self.tag("normal",i,i+1)
i += 1</t>
<t tx="T2114">def createVnode(self,parent,back,tref,headline,attrDict):
	
	# trace(`headline` + ", parent:" + `parent` + ", back:" + `back`)
	v = None ; c = self.commands
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		t = self.tnodesDict.get(tref)
		if not t:
			t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()
		c.frame.setRootVnode(v)
	v.initHeadString(headline,encoding=self.leo_file_encoding)
	&lt;&lt; handle unknown vnode attributes &gt;&gt;
	return v</t>
<t tx="T2115">keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict
	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; es(s, color = "blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; es(s)</t>
<t tx="T2116">class baseColorizer:
	"""The base class for Leo's syntax colorer."""
	&lt;&lt; define colorizer keywords &gt;&gt;
	@others
	
class colorizer (baseColorizer):
	"""Leo's syntax colorer class"""
	pass</t>
<t tx="T2117"></t>
<t tx="T2118">def OnHyperLinkControlClick (self,v):

	pass</t>
<t tx="T2119">def OnHyperLinkEnter (self,v):

	pass # trace(`v` + ", " + `v.tagName`)</t>
<t tx="T2120">def OnHyperLinkLeave (self,v):

	pass # trace(`v`)</t>
<t tx="T2121"># The main colorizer entry point.

def colorize(self,v,body,incremental=false):

	if self.enabled:
		# print "colorize:incremental",incremental
		self.incremental=incremental
		self.updateSyntaxColorer(v)
		self.colorizeAnyLanguage(v,body)
		
# Called from incremental undo code.
# Colorizes the lines between the leading and trailing lines.
		
def recolor_range(self,v,body,leading,trailing):
	
	if self.enabled:
		# print "recolor_range:leading,trailing",leading,trailing
		self.incremental=true
		self.updateSyntaxColorer(v)
		self.colorizeAnyLanguage(v,body,leading=leading,trailing=trailing)
</t>
<t tx="T2122">def colorizeAnyLanguage (self,v,body,leading=None,trailing=None):
	
	"""Color the body pane either incrementally or non-incrementally"""
	
	#trace(`v`)
	try:
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		doHook("init-color-markup",colorer=self,v=self.v)
		self.color_pass = 0
		if self.incremental and (
			&lt;&lt; all state ivars match &gt;&gt; ):
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			&lt;&lt; non-incrementally color the text &gt;&gt;
		if self.redoColoring:
			&lt;&lt; completely recolor in two passes &gt;&gt;
		&lt;&lt; update state ivars &gt;&gt;
		return "ok" # for testing.
	except:
		&lt;&lt; set state ivars to "unknown" &gt;&gt;
		if self.commands:
			es_exception()
		else:
			import traceback
			traceback.print_exc()
		return "error" # for testing.</t>
<t tx="T2123">self.flag == self.last_flag and
self.last_language == self.language and
self.comment_string == self.last_comment and
self.markup_string == self.last_markup</t>
<t tx="T2124"># trace("non-incremental")

self.line_index = 1 # The Tk line number for indices, as in n.i
for s in lines:
	state = self.colorizeLine(s,state)
	self.line_index += 1
</t>
<t tx="T2125">self.last_flag = self.flag
self.last_language = self.language
self.last_comment = self.comment_string
self.last_markup = self.markup_string</t>
<t tx="T2126">self.last_flag = "unknown"
self.last_language = "unknown"
self.last_comment = "unknown"</t>
<t tx="T2127"># This code is executed only if graphics characters will be inserted by user markup code.

# Pass 1:  Insert all graphics characters.

self.removeAllImages()
s = self.body.get("1.0","end")
lines = s.split('\n')

self.color_pass = 1
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
	state = self.colorizeLine(s,state)
	self.line_index += 1

# Pass 2: Insert one blank for each previously inserted graphic.

self.color_pass = 2
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
	&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;
	state = self.colorizeLine(s,state)
	self.line_index += 1
</t>
<t tx="T2128">@ A spectacular kludge.

Images take up a real index, yet the get routine does not return any character for them!
In order to keep the colorer in synch, we must insert dummy blanks in s at the positions corresponding to each image.
@c

inserted = 0

for photo,image,line_index,i in self.image_references:
	if self.line_index == line_index:
		n = i+inserted ; 	inserted += 1
		s = s[:n] + ' ' + s[n:]
</t>
<t tx="T2129">def colorizeLine (self,s,state):

	# print "line,inc,state,s:",self.line_index,self.incremental,state,s
	assert(isUnicode(s))

	if self.incremental:
		self.removeTagsFromLine()

	i = 0
	while i &lt; len(s):
		self.progress = i
		func = self.state_dict[state]
		i,state = func(s,i)

	return state</t>
<t tx="T2130">def continueDoubleString (self,s,i):
	return self.continueString(s,i,'"',"doubleString")
	
def continueSingleString (self,s,i):
	return self.continueString(s,i,"'","singleString")

# Similar to skip_string.
def continueString (self,s,i,delim,continueState):
	# trace(delim + s[i:])
	continueFlag = choose(self.language in ("elisp","html"),true,false)
	j = i
	while i &lt; len(s) and s[i] != delim:
		if s[i:] == "\\":
			i = len(s) ; continueFlag = true ; break
		elif s[i] == "\\":
			i += 2
		else:
			i += 1
	if i &gt;= len(s):
		i = len(s)
	elif s[i] == delim:
		i += 1 ; continueFlag = false
	self.tag("string",j,i)
	state = choose(continueFlag,continueState,"normal")
	return i,state</t>
<t tx="T2131">def continueNocolor (self,s,i):

	if i == 0 and s[i] == '@':
		j = self.skip_id(s,i+1)
		word = s[i:j]
		word = word.lower()
	else:
		word = ""
	
	if word == "@color" and self.language != "plain":
		# End of the nocolor part.
		self.tag("leoKeyword",0,j)
		return i,"normal"
	else:
		# The entire line is in the nocolor part.
		# Add tags for blanks and tabs to make "Show Invisibles" work.
		for ch in s[i:]:
			if ch == ' ':
				self.tag("blank",i,i+1)
			elif ch == '\t':
				self.tag("tab",i,i+1)
			i += 1
		return i,"nocolor"</t>
<t tx="T2132"># Colorize the line from i to j.

def doLatexLine (self,s,i,j):

	while i &lt; j:
		if match(s,i,"\\"):
			k = self.skip_id(s,i+1)
			word = s[i:k]
			if word in self.latex_keywords:
				self.tag("latexModeKeyword",i,k)
			i = k
		else:
			self.tag("latexModeBackground",i,i+1)
			i += 1</t>
<t tx="T2133">def doNowebSecRef (self,s,i):

	self.tag("nameBrackets",i,i+2)
	
	# See if the line contains the right name bracket.
	j = s.find(self.rb+"=",i+2)
	k = choose(j==-1,2,3)
	if j == -1:
		j = s.find(self.rb,i+2)
	if j == -1:
		return i + 2
	else:
		searchName = self.body.get(self.index(i),self.index(j+k)) # includes brackets
		ref = findReference(searchName,self.v)
		if ref:
			self.tag("link",i+2,j)
			if self.use_hyperlinks:
				&lt;&lt; set the hyperlink &gt;&gt;
		elif k == 3: # a section definition
			self.tag("link",i+2,j)
		else:
			self.tag("name",i+2,j)
		self.tag("nameBrackets",j,j+k)
		return j + k</t>
<t tx="T2134"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + `self.hyperCount`
self.hyperCount += 1
self.body.tag_delete(tagName)
self.tag(tagName,i+2,j)
ref.tagName = tagName
self.body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)</t>
<t tx="T2135">def schedule(self,v,body,incremental=0):

	if self.enabled:
		self.incremental=incremental
		body.after_idle(self.idle_colorize,v,body)
		
def idle_colorize(self,v,body):

	# trace(`v` + ", " + `body`)
	if v and body and self.enabled:
		self.colorize(v,body,self.incremental)</t>
<t tx="T2136">def getCwebWord (self,s,i):
	
	# trace(get_line(s,i))
	if not match(s,i,"@"):
		return None
	
	ch1 = ch2 = word = None
	if i + 1 &lt; len(s): ch1 = s[i+1]
	if i + 2 &lt; len(s): ch2 = s[i+2]

	if match(s,i,"@**"):
		word = "@**"
	elif not ch1:
		word = "@"
	elif not ch2:
		word = s[i:i+2]
	elif (
		(ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
		ch1 not in string.ascii_letters # non-letter control code
	):
		word = s[i:i+2]
		
	# if word: trace(`word`)
		
	return word</t>
<t tx="T2137">def removeAllImages (self):
	
	for photo,image,line_index,i in self.image_references:
		try:
			index = self.body.index(image)
			# print "removing image at: ", `index`
			self.body.delete(index)
		except:
			pass # The image may have been deleted earlier.
	
	self.image_references = []</t>
<t tx="T2138"># self.flag is true unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,v):
	
	self.flag = self.useSyntaxColoring(v)
	self.scanColorDirectives(v)
</t>
<t tx="T2139"># Return true if v unless v is unambiguously under the control of @nocolor.

def useSyntaxColoring (self,v):

	first = v ; val = true
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		no_color = dict.has_key("nocolor")
		color = dict.has_key("color")
		# trace(`dict` + ", " + `v`)
		# A color anywhere in the target enables coloring.
		if color and v == first:
			val = true ; break
		# Otherwise, the @nocolor specification must be unambiguous.
		elif no_color and not color:
			val = false ; break
		elif color and not no_color:
			val = true ; break
		else:
			v = v.parent()
	# trace("useSyntaxColoring",`val`)
	return val</t>
<t tx="T2140">@ These methods are like the corresponding functions in leoGlobals.py except they issue no error messages.
</t>
<t tx="T2141">def setFirstLineState (self):
	
	if self.flag:
		if self.rootMode:
			state = choose(self.rootMode=="code","normal","doc")
		else:
			state = "normal"
	else:
		state = "nocolor"

	return state</t>
<t tx="T2142">def skip_id(self,s,i,chars=None):

	n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch in string.ascii_letters or ch in string.digits or ch == '_':
			i += 1
		elif chars and ch in chars:
			i += 1
		else: break
	return i
</t>
<t tx="T2143">def skip_string(self,s,i):

	delim = s[i] ; i += 1
	assert(delim == '"' or delim == "'")
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i:] == "\\":
			return n,choose(delim=="'","singleString","doubleString")
		elif s[i] == '\\' :
			i += 2
		else: i += 1

	if i &gt;= n:
		if self.language in ("elisp","html"):
			return n,"doubleString"
		else:
			return n, "normal"
	elif s[i] == delim:
		i += 1
	return i,"normal"
</t>
<t tx="T2144"></t>
<t tx="T2145"></t>
<t tx="T2146">def OnReturnKey (self,event):
	
	# Remove the newly inserted newline from the search &amp; change strings.
	for text in (self.find_text,self.change_text):
		ch = text.get("insert - 1c")
		ch= toUnicode(ch,app.tkEncoding) # 9/28/03
		if ch in ('\r','\n'):
			text.delete("insert - 1c")

	# Do the default command.
	self.findNextCommand(top())
	return "break"</t>
<t tx="T2147"></t>
<t tx="T2148">@ This routine performs a single batch change operation, updating the head or body string of v and leaving the result in s_text.  We update the c.body if we are changing the body text of c.currentVnode().

s_text contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.v is visible.
@c

def batchChange (self,pos1,pos2,count):

	c = self.commands ; v = self.v ; st = self.s_text
	# Replace the selection with c.change_text
	if st.compare(pos1, "&gt;", pos2):
		pos1,pos2=pos2,pos1
	st.delete(pos1,pos2)
	st.insert(pos1,c.change_text)
	s = getAllText(st)
	# Update the selection.
	insert=choose(c.reverse_flag,pos1,pos1+'+'+`len(c.change_text)`+'c')
	st.tag_remove("sel","1.0","end")
	st.mark_set("insert",insert)
	# trace("result:" + `insert` + ", " + `s`)
	# Update the node
	if self.in_headline:
		&lt;&lt; set the undo head params &gt;&gt;
		v.initHeadString(s)
	else:
		&lt;&lt; set the undo body typing params &gt;&gt;
		v.setBodyStringOrPane(s)
	# Set mark, changed and dirty bits.
	if c.mark_changes_flag:
		v.setMarked()
	if not c.isChanged():
		c.setChanged(true)
	v.setDirty()</t>
<t tx="T2149">sel = None
if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]
if s != v.headString():
	if count == 1:
		c.undoer.setUndoParams("Change All",v) # Tag the start of the Change all.
	c.undoer.setUndoTypingParams(v,"Change Headline",v.bodyString(),s,sel,sel)</t>
<t tx="T2150">sel = c.body.index("insert")
if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]
if s != v.bodyString():
	if count == 1:
		c.undoer.setUndoParams("Change All",v) # Tag the start of the Change all.
	c.undoer.setUndoTypingParams(v,"Change",v.bodyString(),s,sel,sel)</t>
<t tx="T2151">def changeAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos1, pos2 = self.findNextMatch()
		if pos1:
			count += 1
			self.batchChange(pos1,pos2,count)
			line = st.get(pos1 + " linestart", pos1 + " lineend")
			line = toUnicode(line,app.tkEncoding) # 9/28/03
			self.printLine(line,allFlag=true)
		else: break
	c.endUpdate() # self.restore
	# Make sure the headline and body text are updated.
	v = c.currentVnode()
	c.frame.onHeadChanged(v)
	c.frame.onBodyChanged(v,"Can't Undo")
	if count &gt; 0:
		# A change was made.  Tag the end of the Change All command.
		c.undoer.setUndoParams("Change All",v)
	es("changed: " + `count`)
	self.restore(data)</t>
<t tx="T2152">def findAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos, newpos = self.findNextMatch()
		if pos:
			count += 1
			line = st.get(pos + " linestart", pos + " lineend")
			line = toUnicode(line,app.tkEncoding) # 9/28/03
			self.printLine(line,allFlag=true)
		else: break
	c.endUpdate()
	es("found: " + `count`)
	self.restore(data)</t>
<t tx="T2153"># Set pos to None if word characters preceed or follow the selection.

before = t.get(pos + "-1c", pos)
first  = t.get(pos)
last   = t.get(newpos)
after  = t.get(newpos, newpos + "+1c")

before = toUnicode(before,app.tkEncoding) # 9/28/03
first  = toUnicode(first, app.tkEncoding) # 9/28/03
last   = toUnicode(last,  app.tkEncoding) # 9/28/03
after  = toUnicode(after, app.tkEncoding) # 9/28/03

# print before, first, last, after

if before and is_c_id(before) and first and is_c_id(first):
	pos = None
if after  and is_c_id(after)  and last  and is_c_id(last):
	pos = None</t>
<t tx="T2154">@ 

Setting t.bodyString without converting to unicode is definitely a bug.

And it is very bad style to be using a "raw" ivar like this.</t>
<t tx="T2155">assert(match(s,i,"+body"))

child_out = [] ; child = v # Do not change out or v!
oldIndent = self.indent ; self.indent = lineIndent
self.scanText(file,child,child_out,endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = toUnicode(body,app.tkEncoding) # 9/28/03

if self.importing:
	child.t.bodyString = body
else:
	child.t.tempBodyString = body

self.indent = oldIndent</t>
<t tx="T2156">def readEndNode (self,s,i):
	
	"""Handle end-of-node processing for @-others and @-ref sentinels."""

	at = self
	
	# End raw mode.
	at.raw = false
	
	# Set the temporary body text.
	s = ''.join(at.out)
	s = toUnicode(s,app.tkEncoding) # 9/28/03

	if at.importing:
		at.t.bodyString = s
	else:
		at.t.tempBodyString = s
			
	# Indicate that the tnode has been set in the derived file.
	at.t.setVisited()

	# End the previous node sentinel.
	at.indent = at.indentStack.pop()
	at.out = at.outStack.pop()
	at.t = at.tStack.pop()

	at.popSentinelStack(endNode)</t>
<t tx="T2157"></t>
<t tx="T2158"># All params have defaults, so t = tnode() is valid.

def __init__ (self,index=0,bodyString=None,headString=None):

	self.statusBits = 0 # status bits
	self.selectionStart = 0 # The start of the selected body text.
	self.selectionLength = 0 # The length of the selected body text.
	self.insertSpot = None # Location of previous insert point.
	self.scrollBarSpot = None # Previous value of scrollbar position.
	# For Pre-3.12 files.  These must always exist.
	self.fileIndex = index # The immutable file index for self tnode.
	self.cloneIndex = 0 # Zero for @file nodes
	# New in 3.12
	self.joinList = [] # vnodes on the same joinlist are updated together.
	
	self.headString = toUnicode(headString,app.tkEncoding) # 9/28/03
	self.bodyString = toUnicode(bodyString,app.tkEncoding) # 9/28/03</t>
<t tx="T2159"></t>
<t tx="T2160"># Compatibility routine for scripts

def bodyString (self):

	# This message should never be printed and we want to avoid crashing here!
	if not isUnicode(self.t.bodyString):
		s = "Leo internal error: not unicode:" + `self.t.bodyString`
		print s ; es(s,color="red")

	# Make _sure_ we return a unicode string.
	return toUnicode(self.t.bodyString,app.tkEncoding)</t>
<t tx="T2161"></t>
<t tx="T2162"></t>
<t tx="T2163">@nocolor

- Remove all references to c from frame ctor
	- At present the Commands.__init__ requires a frame param to work properly.

- Convert all c.body.x to c.frame.body_x
	** Abstract the calls...

- Need new frame methods:

	(done) f.setTitle, f.getTitle

- Use PyChecker positively to help eliminate commander ivars</t>
<t tx="T2164">def newColorFrame(self,commander):
	"""Create a colorFrame."""
	pass # To do

def newColorNameFrame(self,commander):
	"""Create a colorNameFrame."""
	pass # To do

def newCompareFrame(self,commander):
	"""Create a compareFrame."""
	pass # To do

def newFindFrame(self,commander):
	"""Create a findFrame."""
	pass # To do

def newFontFrame(self,commander):
	"""Create a fontFrame."""
	pass # To do

def newLeoFrame(self,title):
	"""Create a view frame for the Leo main window."""
	return leoFrame.LeoFrame(title)

def newPrefsFrame(self,commander):
	"""Create a prefsFrame."""
	pass # To do</t>
<t tx="T2165"></t>
<t tx="T2166">def getTitle (self):
	return self.top.title()
	
def setTopGeometry(self,geom):
	self.top.geometry(geom)
	
def deiconify (self):
	self.top.deiconify()
	
def lift (self):
	self.top.lift()
	
def update (self):
	self.top.update()</t>
<t tx="T2167"></t>
<t tx="T2168">@nocolor

This can be done with callback functions defined for each tree node.  However, that creates _lots_ of functions.

A cool alternative is for the _tree_ class to create the vnode callbacks using funcToMethod.  "vnode" methods created in this way are entitled to know about the intimate details of the tree class, so there is no need to define access methods in the frame class.

@color</t>
<t tx="T2169">@nocolor

This is an elegant way of keeping the vnode class pure.

@color</t>
<t tx="T2170"></t>
<t tx="T2171">@language python
@pagewidth 80

@ This section contains all the source code of leo.py.

We use the following conventions throughout the code:

a: the application object.
c: a commander
ch: a character
d: a dialog or a dict.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
s: a string
t: a tnode or a Tk.Text widget.
u: an undoer
v: a vnode

See the child of this node called "Overview of Code" for more documentation.
</t>
<t tx="T2172">@nocolor
@ignore

This documentation describes leo.py. Other versions of Leo are similar in design; the differences between versions are generally not interesting enough to describe here.

All versions of Leo are organized as a collection of classes.  The general organization of Leo has remained remarkably stable throughout all versions of Leo, although the names of classes are different in different versions. Smalltalk's Model/View/Controller terminology is a good way to organize Leo's classes conceptually.

Model classes represent the fundamental data. The vnode and tnode classes are Leo's primary model classes.

View classes draw the screen. The main view classes are leoFrame.py and leoTree.py.  The colorizer class in leoColor.py handles syntax coloring in the body pane. In leo.py, the view classes know about data stored in the vnode class. Most events (keystrokes and mouse actions) in the outline and body pane are handled in the leoTree class. The leoFrame class also creates the Leo window, including menus, and dispatches the appropriate members of the controller classes in response to menu commands.

Controller classes (aka commanders) control the application. In Leo, controllers mostly handle menu commands. In leo.py, the Commands class creates subcommanders to handle complex commands. The atFile class reads and writes files derived from @file trees. The leoFind class handles the Find and Change commands. The leoImportCommands class handles the Import and Export commands, the tangleCommands class handles the Tangle and Untangle commands and the undoer class handles the Undo command. Other classes could be considered controller classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not subclasses of their commander. Instead, subcommanders know the commander that created them, and call that commander as needed. Commanders and subcommanders call the model and view classes as needed. For example, the Commands class handles outline commands. To move a headline, the commander for the window calls a vnode move routine to alter the data, then calls the view class to redraw the screen based on the new data.

A singleton instance of the LeoApp class represents the application itself. All code uses the app() global function to gain access to this singleton member. The ivars of the LeoApp object are the equivalent of Leo's global variables. leo.py uses no global Python variables, except the gApp variable returned by app(). leoGlobals.py defines all application constants.  Naturally, most constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the LeoPrefs class represents user preferences (model), the Preference Panel (view) and the Preferences menu command (controller). Similarly, the leoFind class represents find settings, the Find/Change dialog, and the Find/Change commands.

The children of this node are clones of code-level documentation found throughout this code.</t>
<t tx="T2173">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
	+ a' (1)
	+ a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
	+ a'
		+ b
	+ a'
		+ b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
	+ a'
		+ b' (1)
		+ b' (2)
	+ a'
		+ b' (1)
		+ b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then converts each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="T2174">@ Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.  These topics are interrelated.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is true.  This allows code to suppress redrawing entirely when needed.  For example, study the idle_body_key event handler to see how Leo conditionally redraws the outline pane.

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.

Handling events. Besides redrawing the screen, Leo must handle events or commands that change the text in the outline or body panes.  It is surprisingly difficult to ensure that headline and body text corresponds to the vnode and tnode corresponding to presently selected outline, and vice versa. For example, when the user selects a new headline in the outline pane, we must ensure that 1) the vnode and tnode of the previously selected node have up-to-date information and 2) the body pane is loaded from the correct data in the corresponding tnode.  Early versions of Leo attempted to satisfy these conditions when the user switched outline nodes.  Such attempts never worked well; there were too many special cases.  Later versions of Leo, including leo.py, use a much more direct approach.  The event handlers make sure that the vnode and tnode corresponding to the presently selected node are always kept up-to-date.  In particular, every keystroke in the body pane causes the presently selected tnode to be updated immediately.  There is no longer any need for the c.synchVnode method, though that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline panes.  The actual work is done in the idle_head_key and idle_body_key methods.  These routines are surprisingly complex; they must handle all the tasks mentioned above, as well as others. The idle_head_key and idle_body_key methods should not be called outside the leoTree class.  However, it often happens that code that handles user commands must simulate an event.  That is, the code needs to indicate that headline or body text has changed so that the screen may be redrawn properly.   The leoTree class defines the following simplified event handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders and subcommanders call these event handlers to indicate that a command has changed, or will change, the headline or body text.  Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that the outline pane is redrawn only when needed.
</t>
<t tx="T2175">@ The Tangle command translates the selected @root tree into one or more well-formatted C source files. The outline should contain directives, sections references and section definitions, as described in Chapter 4. The Untangle command is essentially the reverse of the Tangle command. The Tangle command creates a derived file from an @root tree; the Untangle command incorporates changes made to derived files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete definitions of all sections and places these definitions in a symbol table. The first pass also makes a list of root sections. Definitions can appear in any order, so we must scan the entire input file to know whether any particular definition has been completed.

Tangle's second pass creates one file for each @root node. Tangle rescans each section in the list of roots, copying the root text to the output and replacing each section reference by the section's definition. This is a recursive process because any definition may contain other references. We can not allow a section to be defined in terms of itself, either directly or indirectly. We check for such illegally recursive definitions in pass 2 using the section stack class.  Tangle indicates where sections begin and end using comment lines called sentinel lines.  The this part of the appendix discusses the format of the sentinels output by the Tangle command.

The key design principle of the Tangle command is this: Tangle must output newlines in a context-free manner. That is, Tangle must never output conditional newlines, either directly or indirectly. Without this rule Untangle could not determine whether to skip or copy newlines.

The Tangle command increases the indentation level of a section expansion the minimum necessary to align the section expansion with the surrounding code. In essence, this scheme aligns all section expansions with the line of code in which the reference to the section occurs. In some cases, several nested sections expansions will have the same indentation level. This can occur, for example, when a section reference in an outline occurs at the left margin of the outline.

This scheme is probably better than more obvious schemes that indent more "consistently." Such schemes would produce too much indentation for deeply nested outlines. The present scheme is clear enough and avoids indentation wherever possible, yet indents sections adequately. End sentinel lines make this scheme work by making clear where the expansion of one section ends and the expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line. Untangle is aware of this hack and adjusts accordingly. This extra indentation handles several common code idioms, which otherwise would create under-indented code. In short, Tangle produces highly readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex.  It must do a perfect job of updating the outline, especially whitespace, from expansions of section definitions created by the Tangle command.  Such expansions need not be identical because they may have been generated at different levels of indentation.  The Untangle command can not assume that all expansions of a section will be identical in the derived file; within the derived file, the programmer may have made incompatible changes to two different expansions of the same section. Untangle must check to see that all expansions of a section are "equivalent".  As an added complication, derived files do not contain all the information found in @root trees.  @root trees may contain headlines that generate no code at all.  Also, an outline may define a section in several ways: with an @c or @code directive or with a section definition line.  To be useful, Untangle must handle all these complications flawlessly. The appendix discusses the various conventions used in the sentinels output by the Tangle command.  These conventions allow the Untangle command to recreate whitespace correctly.

Untangle operates in two passes. The first pass finds definitions in the derived file and enters them into the Untangle Symbol Table, or UST.   Definitions often include references to other sections, so definitions often include nested definitions of referenced sections. The first pass of Untangle uses a definition stack to keep track of nested definitions. The top of the stack represents the definition following the latest reference, except for the very first entry pushed on the stack, which represents the code in the outline that contains the @root directive. The stack never becomes empty because of the entry for the @root section. All definitions of a section should match--otherwise there is an inconsistent definition. This pass uses a forgiving compare routine that ignores differences that do not affect the meaning of a program.

Untangle's second pass enters definitions from the outline into the Tangle Symbol Table, or TST. The second pass simultaneously updates all sections in the outline whose definition in the TST does not match the definition in the UST.  The central coding insight of the Untangle command is that the second pass of Untangle is almost identical to the first pass of Tangle! That is, Tangle and Untangle share key parts of code, namely the skip_body() method and its allies.  Just when skip_body() enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.
</t>
<t tx="T2176">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="T2177">@ Only leo.py supports unlimited undo.  Unlimited undo is straightforward; it merely requires that all commands that affect the outline or body text must be undoable. In other words, everything that affects the outline or body text must be remembered.

We may think of all the actions that may be Undone or Redone as a string of beads (undo nodes). Undoing an operation moves backwards to the next bead; redoing an operation moves forwards to the next bead. A bead pointer points to the present bead. The bead pointer points in front of the first bead when Undo is disabled.  The bead pointer points at the last bead when Redo is disabled. An undo node is a Python dictionary containing all information needed to undo or redo the operation.

The Undo command uses the present bead to undo the action, then moves the bead pointer backwards. The Redo command uses the bead after the present bead to redo the action, then moves the bead pointer forwards. All undoable operations call setUndoParams() to create a new bead. The list of beads does not branch; all undoable operations (except the Undo and Redo commands themselves) delete any beads following the newly created bead.

I did not invent this model of unlimited undo.  I first came across it in the documentation for Apple's Yellow Box classes.
</t>
<t tx="T2178">@ The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the leoFind class:

1.	Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state information from one invocation to the next. This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command. Failure to follow this principle caused all kinds of problems in the Borland and Macintosh codes. There is one exception to this rule: we must remember where interactive wrapped searches start. This principle simplifies the code because most ivars do not persist. However, each command must ensure that the Leo window is left in a state suitable for restarting the incremental (interactive) Find and Change commands. Details of initialization are discussed below.

2. The Find and Change commands must not change the state of the outline or body pane during execution. That would cause severe flashing and slow down the commands a great deal. In particular, c.selectVnode and c.editVnode methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo window in the proper state to execute another incremental command. We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.

Initialization involves setting the self.c, self.v, self.in_headline, self.wrapping and self.s_text ivars. Setting self.in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that self.s_text is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextVnode() method handles the many details involved by setting self.s_text and its insert and sel attributes.
</t>
<t tx="T2179">@nocolor</t>
<t tx="T2180">@color

@ NSIS Script for LEO - Literate Programming Editor with Outlines
http://sourceforge.net/projects/leo

How to create an installer for Leo using this script:
	1. Install NSIS (from http://www.nullsoft.com)
	2. Put the leo.nsi file in the directory containing the Leo program files.
	3. Right-click on the leo.nsi file and choose "Compile"
	
Version 1.0 of this script by Joe Orr, donated to public domain.
</t>
<t tx="T2181">@comment ;
@silent
@root ../dist/leo.nsi

; NOTE: this .NSI script is designed for NSIS v1.8+

&lt;&lt; installer settings &gt;&gt;
&lt;&lt; required files section &gt;&gt;
&lt;&lt; optional files section &gt;&gt;
&lt;&lt; file association &gt;&gt;
&lt;&lt; post install section &gt;&gt;
&lt;&lt; uninstall section &gt;&gt;

; eof</t>
<t tx="T2182">@code

# [Installer Attributes]
Name "Leo"
OutFile "leosetup.exe"
Caption "Leo Installer"

&lt;&lt; Additional Installer Settings &gt;&gt;
&lt;&lt; icons used by the installer &gt;&gt;
&lt;&lt; the user license &gt;&gt;
&lt;&lt; the installation dir &gt;&gt;

ComponentText "This will install Leo on your computer. Select which optional components you would also like to install."</t>
<t tx="T2183">@code
Icon c:\prog\leoCVS\leo\Icons\leo_inst.ico
EnabledBitmap c:\prog\leoCVS\leo\Icons\leo_on.bmp
DisabledBitmap c:\prog\leoCVS\leo\Icons\leo_off.bmp</t>
<t tx="T2184">@code

InstallDir "$PROGRAMFILES\Leo"
InstallDirRegKey HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo" ""
DirShow show # (make this hide to not let the user change it)
DirText "Select the directory to install Leo in:"</t>
<t tx="T2185">@code
LicenseText "You must agree to this license before installing."
LicenseData c:\prog\leoCVS\leo\doc\LICENSE.TXT</t>
<t tx="T2186">@ You may not need to change these for your own app...
@c
ShowInstDetails show
AutoCloseWindow false
SilentInstall normal
CRCCheck on
SetCompress auto
SetDatablockOptimize on
SetOverwrite ifnewer
WindowIcon off</t>
<t tx="T2187">@code

Section "Leo" ; (default, required section)

  &lt;&lt; check to see whether Python is installed &gt;&gt;

ok:
  # List all files to included in installer	
  
  SetOutPath $INSTDIR
  File c:\prog\leoCVS\leo\__init__.py
  CreateShortCut "$INSTDIR\Shortcut to leo.py.lnk" "$INSTDIR\src\leo.py" "" "$INSTDIR\src\leo.py" 0

  SetOutPath $INSTDIR\config
  File c:\prog\leoCVS\leo\config\leoConfig.leo
  File c:\prog\leoCVS\leo\config\leoConfig.txt
 
  SetOutPath $INSTDIR\doc
  File c:\prog\leoCVS\leo\doc\LeoDocs.leo
  File c:\prog\leoCVS\leo\doc\README.TXT
  File c:\prog\leoCVS\leo\doc\INSTALL.TXT
  File c:\prog\leoCVS\leo\doc\PKG-INFO.TXT
  File c:\prog\leoCVS\leo\doc\LICENSE.TXT
  # File c:\prog\leoCVS\leo\doc\manifest.in
  
  SetOutPath $INSTDIR\Icons
  File c:\prog\leoCVS\leo\Icons\*.*
  
  SetOutPath $INSTDIR\examples
  
  SetOutPath $INSTDIR\plugins
  File c:\prog\leoCVS\leo\plugins\leoPlugins.leo
  File c:\prog\leoCVS\leo\plugins\*.py
  File c:\prog\leoCVS\leo\plugins\*.ini
  File c:\prog\leoCVS\leo\plugins\*.txt
  
  SetOutPath $INSTDIR\scripts
  File c:\prog\leoCVS\leo\scripts\*.py
  
  SetOutPath $INSTDIR\scripts\install
  File c:\prog\leoCVS\leo\scripts\install\*
  
  SetOutPath $INSTDIR\scripts\other
  File c:\prog\leoCVS\leo\scripts\other\*.py
  
  SetOutPath $INSTDIR\scripts\tangle
  File c:\prog\leoCVS\leo\scripts\tangle\*.py
  
  SetOutPath $INSTDIR\src
  File c:\prog\leoCVS\leo\src\LeoPy.leo
  File c:\prog\leoCVS\leo\src\leo*.py
  
  SetOutPath $INSTDIR\test
  
  SetOutPath $INSTDIR\tools

SectionEnd ; end of default section
</t>
<t tx="T2188">@code
# I sure hope there is a better way to do this, but other techniques don't seem to work.

# Supposedly the Python installer creates the following registry entry
# HKEY_LOCAL_MACHINE\Software\Python\PythonCore\CurrentVersion
# and then we can read find the Python folder location via
# HKEY_LOCAL_MACHINE\Software\Python\PythonCore\{versionno}. 
# Unfortunately, at the time of this writing, the Python installer is NOT writing the first entry. There is no way to know what the current versionno is.
# Hence, the following hack.

# Get pythonw.exe path from registry... except it isn't there, nor is it an environment variable... thanks guys!
# We'll have to get it in a roundabout way
ReadRegStr $9 HKEY_LOCAL_MACHINE "SOFTWARE\Classes\Python.NoConFile\shell\open\command" ""

# cut 8 characters from back of the open command
StrCpy $8 $9 -8

IfFileExists $8 ok tryagain

tryagain:
# ok, that  didn't work, but since the Python installer doesn't seem to be consistent, we'll try again
# cut 3 characters from back of the open command
StrCpy $8 $9 -3

IfFileExists $8 ok ng

ng:
  MessageBox MB_OK "Python is not installed on this system. $\nPlease install Python first. $\n$\nClick OK to cancel installation and remove installation Files."
  
  Delete "$INSTDIR\config\*.*" ; config dir
  RMDir "$INSTDIR\config"
  Delete "$INSTDIR\doc\*.*" ; doc dir
  RMDir "$INSTDIR\doc"
  Delete "$INSTDIR\examples\*.*" ; src dir
  RMDir "$INSTDIR\examples"
  Delete "$INSTDIR\Icons\*.*" ; Icons dir
  RMDir "$INSTDIR\Icons"
  Delete "$INSTDIR\plugins\*.*" ; plugins dir
  RMDir "$INSTDIR\plugins"
  Delete "$INSTDIR\scripts\*.*" ; scripts dir
  RMDir "$INSTDIR\scripts"
  Delete "$INSTDIR\src\*.*" ; src dir
  RMDir "$INSTDIR\src"
  Delete "$INSTDIR\test\*.*" ; test dir
  RMDir "$INSTDIR\test"
  Delete "$INSTDIR\tools\*.*" ; tools dir
  RMDir "$INSTDIR\tools"
  Delete "$INSTDIR\*.*" ; Leo directory
  RMDir "$INSTDIR"

  Quit


</t>
<t tx="T2189">@code

# optional sections

Section "Start Menu Shortcuts"
  CreateDirectory "$SMPROGRAMS\Leo"
  CreateShortCut "$SMPROGRAMS\Leo\Uninstall.lnk" "$INSTDIR\uninst.exe" "" "$INSTDIR\uninst.exe" 0
  CreateShortCut "$SMPROGRAMS\Leo\Leo.lnk" "$8" '"$INSTDIR\src\leo.py"' "$INSTDIR\Icons\LeoApp.ico" 0  
SectionEnd

Section "Desktop Shortcut"
  CreateShortCut "$DESKTOP\Leo.lnk" "$8" '"$INSTDIR\src\leo.py"' "$INSTDIR\Icons\LeoApp.ico" 0
SectionEnd</t>
<t tx="T2190">@code

Section ".leo File Association"
  SectionIn 1
  SectionIn 2
  SectionIn 3

  # back up old value of .leo in case some other program was using it
  ReadRegStr $1 HKCR ".leo" ""
  StrCmp $1 "" Label1
  StrCmp $1 "LeoFile" Label1
  WriteRegStr HKCR ".leo" "backup_val" $1
 
Label1:
  WriteRegStr HKCR ".leo" "" "LeoFile"
  WriteRegStr HKCR "LeoFile" "" "Leo File"
  WriteRegStr HKCR "LeoFile\shell" "" "open"
  WriteRegStr HKCR "LeoFile\DefaultIcon" "" $INSTDIR\Icons\LeoDoc.ico,0 
  WriteRegStr HKCR "LeoFile\shell\open\command" "" '$8 "$INSTDIR\src\leo.py" %1'  

SectionEnd</t>
<t tx="T2191">@code

Section "-post" # (post install section, happens last after any optional sections)

  # add any commands that need to happen after any optional sections here
  WriteRegStr HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo" "" "$INSTDIR"
  WriteRegStr HKEY_LOCAL_MACHINE "Software\Microsoft\Windows\CurrentVersion\Uninstall\leo" "DisplayName" "Leo (remove only)"
  WriteRegStr HKEY_LOCAL_MACHINE "Software\Microsoft\Windows\CurrentVersion\Uninstall\leo" "UninstallString" '"$INSTDIR\uninst.exe"'

  # write out uninstaller
  WriteUninstaller "$INSTDIR\uninst.exe"

SectionEnd ; end of -post section

</t>
<t tx="T2192">@code

# [ begin uninstall settings/section ]
UninstallText "This will uninstall Leo from your system"
UninstallCaption "Uninstall Leo"
UninstallIcon c:\prog\leoCVS\leo\Icons\uninst.ico

Section Uninstall

DeleteRegKey HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo"
DeleteRegKey HKEY_LOCAL_MACHINE "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\leo"

&lt;&lt; remove file association &gt;&gt;
&lt;&lt; remove program folder &gt;&gt;
&lt;&lt; remove shortcuts &gt;&gt;

; remove directories used.
RMDir "$SMPROGRAMS\Leo"

SectionEnd ; end of uninstall section</t>
<t tx="T2193">@code

  ReadRegStr $1 HKCR ".leo" ""
  StrCmp $1 "LeoFile" 0 NoOwn ; only do this if we own it
	ReadRegStr $1 HKCR ".leo" "backup_val"
	StrCmp $1 "" 0 RestoreBackup ; if backup == "" then delete the whole key
	  DeleteRegKey HKCR ".leo"
	Goto NoOwn
	RestoreBackup:
	  WriteRegStr HKCR ".leo" "" $1
	  DeleteRegValue HKCR ".leo" "backup_val"
  NoOwn:
</t>
<t tx="T2194">@code
MessageBox MB_YESNO|MB_ICONQUESTION \
			 "Delete all files in Leo Program folder?" \
			 IDNO NoDelete  

  Delete "$INSTDIR\config\*.*" ; config dir
  RMDir "$INSTDIR\config"
  Delete "$INSTDIR\doc\*.*" ; doc dir
  RMDir "$INSTDIR\doc"
  Delete "$INSTDIR\examples\*.*" ; src dir
  RMDir "$INSTDIR\examples"
  Delete "$INSTDIR\Icons\*.*" ; Icons dir
  RMDir "$INSTDIR\Icons"
  Delete "$INSTDIR\plugins\*.*" ; plugins dir
  RMDir "$INSTDIR\plugins"
  Delete "$INSTDIR\scripts\install\*.*" ; scripts\install dir
  RMDir "$INSTDIR\scripts\install"
  Delete "$INSTDIR\scripts\other\*.*" ; scripts\other dir
  RMDir "$INSTDIR\scripts\other"
  Delete "$INSTDIR\scripts\tangle\*.*" ; scripts\tangle dir
  RMDir "$INSTDIR\scripts\tangle"
  Delete "$INSTDIR\scripts\*.*" ; scripts dir
  RMDir "$INSTDIR\scripts"
  Delete "$INSTDIR\src\*.*" ; src dir
  RMDir "$INSTDIR\src"
  Delete "$INSTDIR\test\*.*" ; test dir
  RMDir "$INSTDIR\test"
  Delete "$INSTDIR\tools\*.*" ; tools dir
  RMDir "$INSTDIR\tools"
  Delete "$INSTDIR\*.*" ; Leo directory
  RMDir "$INSTDIR"

NoDelete:
</t>
<t tx="T2195">@code
Delete "$SMPROGRAMS\Leo\*.*"
Delete "$DESKTOP\Leo.lnk"</t>
<t tx="T2196">Leo is Open Software and is distributed under the terms of the Python License. The gist of the license is that Leo is absolutely free, even for commercial use (including resale). There is no GNU-like "copyleft" restriction. The Open Source Initiative board has voted to certify the Python license as Open Source. This license is compatible with the GPL.

Copyright (c) 1997-2003 by Edward K. Ream. All Rights Reserved.

Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of Leo or Edward K. Ream not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.</t>
<t tx="T2197"></t>
<t tx="T2198">System requirements for leo.py
------------------------------

leo.py requires Python 2.1 and tcl/tk 8.3 or above.

	Download Python from http://python.org/ 
	Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Warning: When building Tcl on Linux, do not specify "--enable-threads" .
Only use Tcl with the default "threads not enabled" case.
</t>
<t tx="T2199">
Installing the leo.py on Linux
------------------------------

You can install Leo using the install script provided.  Remember to 'chmod +x' before running this script.

Leo is distributed as a single compressed (.zip) folder.  Simply uncompress this folder, put the folder in a convenient place and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.leoOpen(fileName) # runs leo.py, reloads all modules, and opens fileName.

You may specify options using the configuration file called leoConfig.txt.  You should generate this file using leoConfig.leo.</t>
<t tx="T2200">
Installing the leo.py on Windows
--------------------------------

Important: You can install leo.py on Windows using the single-click installer called leosetup.exe.

Leo is distributed as a single compressed (.zip) folder.  Uncompress this folder, put the folder in a convenient place and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.leoOpen(fileName) # runs leo.py, reloads all modules, and opens fileName.

You may specify options using the configuration file called leoConfig.txt.  You should generate this file using leoConfig.leo.
</t>
<t tx="T2201">
Installing leo.py on MacOs
--------------------------

Bruce M. Bolden, bruceb@cs.uidaho.edu, is using Leo on MaxOS X.  Here is his description of how to get Leo working there:

I installed: 
- Latest OS X Developer tools
- latest (as of about two weeks ago) tk/tcl
		 MacOSXTk8.4a4-2.tar.gz
- the machopython distribution
http://prdownloads.sourceforge.net/wxpython/MachoPython-2.2.1.dmg

For OS X 10.1, I followed the directions at:
	http://tony.lownds.com/macosx/tkinter.html

That worked fine for 10.1, but didn't work for 10.2.  It
took awhile to find a Python distribution that worked
correctly with tk/tcl.

I was just getting into Leo about a week before 10.2 was released and thought about---what if it breaks....10.2 broke it, but I was able to find a solution as described above.

More re MacOS from Bruce Bolden
-------------------------------

I just finished building tk successfully!  The magic step was the execution of the command

cp ../generic/prolog.ps to ../library/prolog.ps

AFTER 

cd ../../tk/macosx

in the instructions on "Steps to build Tcl/Tk 8.4.0 on MacOS X":

http://mini.net/tcl/4052

I found this solution while looking at the tcl-mac mailing list archive.  The earlier (current?) tar ball on SourceForge did not have the file prolog.ps in the library directory:

http://sourceforge.net/mailarchive/forum.php?thread_id=1060496&amp;forum_id=3853

Copy and Paste seem to work just fine now in Leo!  This was my original question for you.

I also noticed that someone else built everything on OS X 10.2 (Jaguar), but they did it under X.  Since, the new version of Tk appears to support the OS X interface quite well, I'm not going to bother installing X (for now).

So, Leo works two different ways on OS X 10.2.
</t>
<t tx="T2202">
Using shell scripts and batch files to make using Leo easier
------------------------------------------------------------

On Linux, the following shell script will allow you to open foo.leo files by typing leo foo

#!/bin/sh 
python &lt;leopath&gt;/leo.py $1

where &lt;leopath&gt; is replaced with the path to the leo directory. 

On Windows, the equivalent batch file would be:

c:\python22\python &lt;leopath&gt;leo.py %1

</t>
<t tx="T2203">Metadata-Version: 1.0
Name: leo
Version: 4.0.2
Summary: Leo: Literate Editor with Outlines
Home-page: http://webpages.charter.net/edreamleo/front.html
Author: Edward K. Ream
Author-email: edreamleo@charter.net
License: Python
Description: Leo is an outline-oriented editor written in 100% pure Python.
		Leo works on any platform that supports Python 2.1 or 2.2 and the Tk toolkit.
		This version of Leo was developed with Python 2.2.1 and Tk 8.3.2.
		You may download Python from http://python.org/ and
		tcl/Tk from http://tcl.activestate.com/software/tcltk/
		Leo features a multi-window outlining editor, Python colorizing,
		powerful outline commands and many other things, including 
		Unlimited Undo/Redo and an integrated Python shell(IDLE) window.
		Leo will place its own icon in Leo windows provided that you have
		installed Fredrik Lundh's PIL and tkIcon packages:
		Download PIL from http://www.pythonware.com/downloads/index.htm#pil
		Download tkIcon from http://www.effbot.org/downloads/#tkIcon
Platform: Windows, Linux, Macintosh
</t>
<t tx="T2204">Important note: See INSTALL.TXT for installation instructions.

Leo is available at:  http://sourceforge.net/projects/leo/
Leo requires Python 2.1 or above and tcl/tk 8.3 or above.
Leo will work on Linux, Windows and MacOs X Jaguar.

Leo 4.0.2                         October 24, 2003

Yet another bug-fix release:

- Fixes a crasher in reportBadChars when a .leo file contains a character that
  can not be represented in the encoding specified in the first line of the
  .leo file.
- Leo now sends full tracebacks to the log window when Leo takes an unexpected
 exception.
- Leo now issues a more informative message when the @comment directive
  inhibits the Untangle command.

Note: This version does _not_ support Unicode file names or directory names.

Leo 4.0.1                         October 22, 2003

This is a bug fix release:
	
- Fixes several crashers.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.


Leo 4.0 final                     October 17, 2003

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------

** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File and Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

See the notes for the various beta releases for full details.</t>
<t tx="T2205"># The manifest template: specifies all files to be included in the distribution.

# Note: these are glob patterns!  Be careful:  .. may not work.

include __init__.py

include config/leoConfig.leo
include config/leoConfig.txt

include doc/LeoDocs.leo
include doc/README.TXT
include doc/INSTALL.TXT
include doc/PKG-INFO.TXT
include doc/LICENSE.TXT

include Icons/*.*

include plugins/*.*
exclude plugins/*.pyc

include src/LeoPy.leo
include src/leo*.py

include scripts/*
include scripts/install/*.py
include scripts/other/*.py
include scripts/tangle/*.py

include install
include uninstall
include manifest.in
include MANIFEST

# Setup is more confusing than helpful.
exclude setup.py</t>
<t tx="T2206">@ignore
@color

import prepareSetup
prepareSetup.setup()

import os
# This _must_ be run from the main leo directory
os.system("python setup.py sdist --formats=zip")
</t>
<t tx="T2207">@first #! /usr/bin/env python
@language python
@color

# Prepare to execute setup.py
# This script has access to app.  setup.py does not.

from leoGlobals import *

@others

def setup(path = ""):
	saveAllLeoFiles()
	tangleLeoConfigDotLeo(path)
	print "preSetup complete"
</t>
<t tx="T2208">def saveAllLeoFiles():
	
	for frame in app.windowList:
		c = frame.commands
		name = c.mFileName
		if name == "": name = "untitled"
		if c.changed:
			print "saving ",name
			frame.OnSave()
</t>
<t tx="T2209">def tangleLeoConfigDotLeo(path):

	c = None ; name = os.path.join(path,"config","leoConfig.leo") # 6/28/03, 10/22/03
	oldtop = top()
	for frame in app.windowList:
		if frame.commands.mFileName == name :
			c = frame.commands
			break
	
	if c == None:
		c = top()
		flag,frame = c.frame.OpenWithFileName(name)
		if not flag:
			print "can not open ",name
			return
		c = frame.commands
			
	print "Tangling ", name
	app.setLog(oldtop.frame) # Keep sending messages to the original frame.
	c.tangleCommands.tangleAll()
	c.frame.OnClose()
	app.setLog(oldtop.frame)</t>
<t tx="T2210">@first #! /usr/bin/env python
@language python

@ Script for creating distributions of leo.py using Python's distutils package.
Invoke this script as follows:

import os
os.system(r"cd C:\prog\leoCVS\leo")
os.system("python setup.py sdist --formats=zip")
@c

true = 1 ; false = 0
from distutils.core import setup
import distutils,os,sys,traceback

@others

if 1: # Use this only for final distributions.
	if sys.argv[1] == "sdist":
		setDefaultParams()

# modules = generateModules()
modules = []

setup (
	&lt;&lt; setup info for setup.py &gt;&gt;
)

if sys.argv[1] == "sdist":
	print "setup complete"</t>
<t tx="T2211">name="leo",
version="4.0.2",
author="Edward K. Ream",
author_email="edream@tds.net",
url="http://personalpages.tds.net/~edream/front.html",
py_modules=modules, # leo*.py also included in manifest
description = "Leo: Literate Editor with Outlines",
licence="Python", # [sic], not license
platforms=["Windows, Linux, Macintosh"],
long_description =
"""Leo is an outline-oriented editor written in 100% pure Python.
Leo works on any platform that supports Python 2.1 or 2.2 and the Tk toolkit.
This version of Leo was developed with Python 2.2.1 and Tk 8.3.2.

Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Leo features a multi-window outlining editor with powerful outline commands,
support for literate programming features, syntax colorizing for many common
languages, unlimited Undo/Redo, an integrated Python shell(IDLE) window,
and many user options including user-definable colors and fonts and user-
definable shortcuts for all menu commands.

Leo a unique program editor, outline editor, literate programming tool,
data manager and project manager. Cloned outlines are a key enabling feature
that make possible multiple views of a project within a single Leo outline.
"""</t>
<t tx="T2212">def printReminders ():

	print
	print "- Update version numbers"
	print "- Clear Default Tangle Directory"
	print "- Distribute both leox-y.zip and leosetup.exe"
	print</t>
<t tx="T2213"># Generate the list of modules in the distribution.

def generateModules():

	dir = os.getcwd()
	dir = os.path.join(dir,"src")
	files = os.listdir(dir)
	modules = []
	for f in files:
		head,tail = os.path.split(f)
		root,ext = os.path.splitext(tail)
		if tail[0:3]=="leo" and ext==".py":
			modules.append(root)
			
	modules.sort()
	# print "modules:", modules
	return modules
</t>
<t tx="T2214">def replacePatterns (file,pats):

	try:
		path = os.getcwd()
		name  = os.path.join(path,file)
		f = open(name)
	except:
		print "*****", file, "not found"
		return
	try:
		data = f.read()
		f.close()
		changed = false
		for pat1,pat2 in pats:
			newdata = data.replace(pat1,pat2)
			if data != newdata:
				changed = true
				data = newdata
				print file,"replaced",pat1,"by",pat2
		if changed:
			f = open(name,"w")
			f.write(data)
			f.close()
	except:
		traceback.print_exc()
		sys.exit()
</t>
<t tx="T2215">def setDefaultParams():

	print "setDefaultParams"

	pats = (
		("create_nonexistent_directories = 1","create_nonexistent_directories = 0"),
		("read_only = 1","read_only = 0"),
		("use_plugins = 1","use_plugins = 0"))

	import os
	
	if 0:
		cwd = os.getcwd()
		print "cwd:",cwd
		os.chdir(os.path.join(cwd,".."))
		print "cwd:",cwd

	replacePatterns(os.path.join("config","leoConfig.leo"),pats)
	replacePatterns(os.path.join("config","leoConfig.txt"),pats)</t>
<t tx="T2216">@first #! /usr/bin/env python
@language python
@color

# Postprocess after executing setup.py
# This script has access to app.  setup.py does not.

from leoGlobals import *

@others

def setup():
	if 1: # Use this only for final distributions.
		unsetDefaultParams()
	print "postSetup complete"
</t>
<t tx="T2217">def unsetDefaultParams():

	print "unsetDefaultParams"
	
	pats = (("use_plugins = 0","use_plugins = 1"),)

	replacePatterns(os.path.join("config","leoConfig.leo"),pats)
	replacePatterns(os.path.join("config","leoConfig.txt"),pats)</t>
<t tx="T2218">@color
@lineending nl
@language shell</t>
<t tx="T2219">#!/bin/sh

############################################
# This is a small install script to install
# leo on GNU/Linux. 
# Leo is Open Software and is distributed under the terms 
# of the Python License.  Please see:
# docs/LICENSE.TXT for details.
#
# This install script created by Frank Merenda 
# (fmerenda@yahoo.com)
#
# verison 1.0 - 06/30/2003
# - initial creation 
#
# 
# - minor changes to try and use a "prefix" directory
# - step 5 copies the src and config directories as 
# directories rather that file (this seems to prevent
# the need to remove ".." from the python scripts on RH9
# anyway.)
# - IMPORTANT NOTE: I did not understand step 6 so its
# commented out. Someone who knows leo better than I do
# should look at this.
# - Note: I'm a leo newbie so I don't know if this fixes plugin
# problems since I don't think I use them.
# David Holden (dh@iucr.org)
#   
#
############################################


################################
# Variables for usage in this script.
################################
LEO_PREFIX="/usr/local"
LEO_RUN_SCRIPT_SOURCE='./scripts/install/leo-script.txt'
LEO_RUN_SCRIPT_OUTPUT="${LEO_PREFIX}/bin/leo"
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"


echo ""
echo "Prefix directory set to \"$LEO_PREFIX\""

################################
# Step 1
# Verify the current user is root
################################
CURRENT_USER=$(whoami)

if [ "$CURRENT_USER" = "root" ] ; then
	echo ""
    echo Verified user is root
else
	echo ""
    echo You must be root to run this program
    exit 0;
fi    
   
################################
# Step 2
# Make the directory structure
################################
echo ""
echo Making directory structure $LEO_LIB_DIR

RESULTS=`mkdir -p $LEO_LIB_DIR 2&gt;&amp;1`
if [ $? -ne 0 ]; then
    echo Failure making directory $LEO_LIB_DIR!
    exit 0;
fi
   
################################
# Step 3
# Copy the files
################################
echo ""
echo Copying files.....

RESULTS=`cp -rp * $LEO_LIB_DIR/ 2&gt;&amp;1`
if [ $? -ne 0 ]; then
    echo Failure copying files to $LEO_LIB_DIR
    exit 0;
fi

###############################
# Step 4
# Clean up the duplicate files so it's not
# confusing to the user. These files
# Are copied directly to the main 
# directory. Assume you have permissions
# since you checked above.
###############################
rm -rf $LEO_LIB_DIR/src
rm -rf $LEO_LIB_DIR/config
   
###############################
# Step 5
# Don't make a liar out of me in step 4.
# Copy the files. that you just deleted....   
###############################
cp -rp src $LEO_LIB_DIR/.
cp -rp config $LEO_LIB_DIR/.

###############################
# Step 6
# Add in symbolic links to point to 
# leoConfig and LeoDocs.   
###############################
#mkdir -p /usr/lib/config 
#chmod 777 /usr/lib/config
#ln -sf /$LEO_LIB_DIR/leoConfig.leo /usr/lib/config/leoConfig.leo
#chmod 666 /$LEO_LIB_DIR/leoConfig.leo  
#
#ln -sf /$LEO_LIB_DIR/leoConfig.txt /usr/lib/config/leoConfig.txt
#chmod 666 /$LEO_LIB_DIR/leoConfig.txt  
#
#mkdir -p /usr/lib/doc
#ln -sf $LEO_LIB_DIR/doc/LeoDocs.leo /usr/lib/doc/LeoDocs.leo
#chmod 666 $LEO_LIB_DIR/doc/LeoDocs.leo 
   
################################
# Step 7
# Create the startup script
################################
echo ""
echo Creating startup script located at: $LEO_RUN_SCRIPT_OUTPUT

echo "python ${LEO_PREFIX}/lib/leo/src/leo.py \$1" &gt; $LEO_RUN_SCRIPT_OUTPUT

RESULTS=`chmod 755 $LEO_RUN_SCRIPT_OUTPUT`   
   
echo ""
echo "***** Leo installed successfully - "
echo "      make sure ${LEO_PREFIX}/bin is in your path then"
echo "      type 'leo filename.leo' to use it."   
echo "                                                 *****"
echo ""
exit 0;</t>
<t tx="T2220">#!/bin/sh

############################################
# This is a small install script to install
# leo on GNU/Linux. 
# Leo is Open Software and is distributed under the terms 
# of the Python License.  Please see:
# docs/LICENSE.TXT for details.
#
# This install script created by Frank Merenda 
# (fmerenda@yahoo.com)
#
# verison 1.0 - 06/30/2003
# - initial creation 
#
# 
# - minor changes to try and use a "prefix" directory
# - step 5 copies the src and config directories as 
# directories rather that file (this seems to prevent
# the need to remove ".." from the python scripts on RH9
# anyway.)
# - IMPORTANT NOTE: I did not understand step 6 so its
# commented out. Someone who knows leo better than I do
# should look at this.
# - Note: I'm a leo newbie so I don't know if this fixes plugin
# problems since I don't think I use them.
# David Holden (dh@iucr.org)
#   
#
############################################


################################
# Variables for usage in this script.
################################
LEO_PREFIX="/usr/local"
LEO_RUN_SCRIPT_SOURCE='./scripts/install/leo-script.txt'
LEO_RUN_SCRIPT_OUTPUT="${LEO_PREFIX}/bin/leo"
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"

echo ""
echo "Prefix directory set to \"$LEO_PREFIX\""

################################
# Step 1
# show commands to remove leo
################################
echo ""
echo "To uninstall leo check the following \"rm\" commands
if they look ok execute them as root."

echo "
rm -fr $LEO_LIB_DIR
rm -f  $LEO_RUN_SCRIPT_OUTPUT

"</t>
<t tx="T2221">@language python
@ignore

@ This section contains scripts and other files for creating, testing and distributing leo.py.  leo.py itself does not use any of the code in these scripts, nor do these scripts use any code in leo.py.
@c

# To convert from C to Python, do the following from Leo's Python window:
import c2py
c2py.convertCurrentTree()

# To convert from Leo1 to Leo2, do the following from Leo's Python window:
import c2py
c2py.leo1to2()

@  To create a source distribution using Python's distutils:

On windows: do the following from inside a console window:
	cd c:\prog\LeoPy
	sdist

On Linux do the following:
	cd LeoPy
	python setup.py sdist --force-manifest --formats=gztar,zip</t>
<t tx="T2222">@first #!/usr/bin/python

"""
A simple script to install Leo on Linux.

Contributed by David McNab &lt;david@rebirthing.co.nz&gt;
"""

import commands,os,sys # commands module is for Unix only.

# We must be root to use this script.
if os.getuid() != 0:
	print "You need to run this install script as root"
	sys.exit(1)

# Create /usr/lib/leo and copy all files there.
print "***** Installing Leo to /usr/lib/leo..."
commands.getoutput("mkdir -p /usr/lib/leo")
commands.getoutput("cp -rp * /usr/lib/leo")

# Create user's 'leo' command script into /usr/bin/leo
print "***** Creating Leo startup script -&gt; /usr/bin/leo"
fd = open("/usr/bin/leo", "w")
fd.write("""#!/usr/bin/python
import commands,sys
files = " ".join(sys.argv[1:])
print commands.getoutput("python /usr/lib/leo/leo.py %s" % files)
""")
fd.close()
commands.getoutput("chmod 755 /usr/bin/leo")
print "***** Leo installed successfully - type 'leo filename.leo' to use it."
</t>
<t tx="T2223">import fnmatch, os

def findDosFile(pattern, dirname):
	
	"""Check for crlf in files"""

	files = os.listdir(dirname)
	names = fnmatch.filter(files, pattern)
	for name in names:
		path = os.path.join(dirname, name)
		if os.path.isfile(path):
			bytes = open(path, 'rb').read()
			count = bytes.count('\r\n')
			if '\0' not in bytes and count:
				print "%4d %s" % (count,path)

dir = "c:\prog\leoCvs\leo"
print ; findDosFile("*",dir)

# The following files were reported:  MANIFEST, PKG-INFO.
# Both were created by @silentfile.</t>
<t tx="T2224">@first #! /usr/bin/env python
@language python

@ When using c2py as a script to translate entire files, use convertCFileToPython().  When using c2py within Leo, use convertCurrentTree().

Please set user data in the &lt;&lt; specifying user types &gt;&gt; section.
@c

&lt;&lt; what c2py does &gt;&gt;
&lt;&lt; theory of operation &gt;&gt;
import string
&lt;&lt; specifying user types &gt;&gt;
true = 1 ; false = None
tabWidth = 4 # how many blanks in a tab.
printFlag = false
doLeoTranslations = true ; dontDoLeoTranslations = false
&lt;&lt; define testData &gt;&gt;
@others

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

def test():
	global printFlag ; printFlag = true
	for s in testData:
		convertCStringToPython(s, doLeoTranslations)
		
def go():
	test()

if __name__ == "__main__":
	speedTest(2)</t>
<t tx="T2225"></t>
<t tx="T2226">@ c2py converts C or C++ text into python text.  The conversion is not complete.  Nevertheless, c2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations before removing all curly braces.

Suppose we are translating:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
	{
		body
	}

1. Translates the function prototype, i.e., translates:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
	def aMethod(v1,...vn):

As a special case, c2py translates:

	aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
	aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

	a) Removes all casts of the form (t) or (t*) or (t**), etc.
	b) Converts t x, t *x, t **x, etc. to x.
	c) Converts x = new t(...) to x = t(...)
	d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
	e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to true
Changes all FALSE to false
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="T2227">@ Strategy and Performance

c2py is straightforward.  The speed of c2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down c2py significantly.

No scans are done within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
	i = 0
	while i &lt; body(len):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif &lt;&lt; found what we are looking for ? &gt;&gt; :
			&lt;&lt; convert what we are looking for, setting i &gt;&gt;
		else: i += 1

That's about all there is to it.  The code was remarkably easy to write and seems clear to me.
</t>
<t tx="T2228">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type definitions correctly; it converts
	new aType(...)
to
	aType(...)
@c

classList = [
	"vnode", "tnode", "Commands",
	"wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
	
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictionary used to translate ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
	
ivarsDict = {
	"atFile": [ "mCommands", "mErrors", "mStructureErrors",
		"mTargetFileName", "mOutputFileName", "mOutputStream",
		"mStartSentinelComment", "mEndSentinelComment", "mRoot"],

	"vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

	"tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
		"mSelectionStart", "mSelectionLength", "mCloneIndex"],
		
	"LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

	"Commands": [
		# public
		"mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
		"mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
		#private
		"mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
		"mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
		"mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
		"mMaxVnodeTag",
		"mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
		"mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="T2229">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
	// test ; {} /* */.\n\
	#if 0 //comment\n\
		if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
		else\n\
			this -&gt; mNextFrame = gLeoFrameList ;\n\
	#else\n\
		\n\
		vnode *v = new vnode(a,b);\n\
		Commands *commander = (Commands) NULL ; // after cast\n\
		this -&gt; mPrevFrame = NULL ;\n\
	#endif\n\
	if (a==b)\n\
		a = 2;\n\
	else if (a ==c)\n\
		a = 3;\n\
	else return; \n\
	/* Block comment test:\n\
		if(2):while(1): end.*/\n\
	for(int i = 1; i &lt; limit; ++i){\n\
		mVisible = FALSE ;\n\
		mOnTop = TRUE ;\n\
	}\n\
	// trailing ws.	 \n\
	mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
	gActiveFrame = this ;\n\
}\n\
	", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="T2230">def speedTest(passes):

	import time
	file = r"c:\prog\LeoPy\LeoPy.leo"
	f=open(file)
	if not f:
		print "not found: ", file
		return
	s=f.read()
	f.close()
	print "file:", file, " size:", len(s), " passes:", passes
	print "speedTest start"
	time1 = time.clock()
	p = passes
	while p &gt; 0:
		n = len(s) ; i = 0 ; lines = 0
		while -1 &lt; i &lt; n:
			if s[i] == '\n':
				lines += 1 ; i += 1
			else:
				i = s.find('\n',i) # _much_ faster than list-based-find.
			continue
			# match is about 9 times slower than simple test.
			if s[i]=='\n': # match(s,i,'\n'): # 
				i += 1
			else:
				i += 1
		p -= 1
	time2 = time.clock()
	print "lines:", lines
	print "speedTest done:"
	print "elapsed time:", time2-time1
	print "time/pass:", (time2-time1)/passes</t>
<t tx="T2231"></t>
<t tx="T2232">def leo1to2():

	import leo
	import leoGlobals
	c=leoGlobals.top()
	v=c.currentVnode()
	convertLeo1to2(v,c)
</t>
<t tx="T2233">def convertLeo1to2(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertStringLeo1to2(s)
		v.setBodyStringOrPane(s)
		v=v.threadNext()

	c.Repaint() # for backward compatibility
	print "end of leo1to2"</t>
<t tx="T2234">def convertStringLeo1to2 (s):

	# print "convertStringLeo1to2:start\n", s
	codeList = stringToList(s) ; outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList1to2(code)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc) # same as in c2py
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T2235">@ We do _not_ replace @root by @file or insert @others as needed.  Inserting @others can be done easily enough by hand, and may take more global knowledge than we can reasonably expect to have.
@c

def convertCodeList1to2(list):

	if 0: # There isn't much reason to do this.
		removeAtRoot(list)
	safeReplace(list, "@code", "@c")
	replaceSectionDefs(list)
	removeLeadingAtCode(list)
</t>
<t tx="T2236">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="T2237">def convertCurrentTree():

	import c2py
	import leo
	import leoGlobals
	c=leoGlobals.top()
	v = c.currentVnode()
	c2py.convertLeoTree(v,c)</t>
<t tx="T2238">def convertLeoTree(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertCStringToPython(s, doLeoTranslations )
		v.setBodyStringOrPane(s)
		v=v.threadNext()
	c.Repaint() # for backward compatibility.
	print "end of c2py"</t>
<t tx="T2239">def convertCFileToPython(file):

	f=open(file, 'r')
	if not f: return
	s = f.read()
	f.close();
	f=open(file + ".py", 'w')
	if not f: return
	s = convertCStringToPython(s, dontDoLeoTranslations )
	f.write(s)
	f.close()</t>
<t tx="T2240"></t>
<t tx="T2241">def convertCStringToPython(s, leoFlag):

	# print "convertCStringToPython:start\n", s
	firstPart = true
	codeList = stringToList(s)
	
	if not leoFlag:
		convertCodeList(codeList, firstPart, dontDoLeoTranslations)
		return listToString(codeList)

	outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList(code, firstPart, doLeoTranslations)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		firstPart = false # don't remove @c from here on.
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc)
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T2242">def convertCodeList(list, firstPart, leoFlag):
	#first
	replace(list, "\r", None)
	convertLeadingBlanks(list)
	if leoFlag:
		replaceSectionDefs(list)
	mungeAllFunctions(list)
	#next
	safeReplace(list, " -&gt; ", '.')
	safeReplace(list, "-&gt;", '.')
	safeReplace(list, " . ", '.')
	safeReplace(list, "this.self", "self")
	safeReplace(list, "{", None)
	safeReplace(list, "}", None)
	safeReplace(list, "#if", "if")
	safeReplace(list, "#else", "else")
	safeReplace(list, "#endif", None)
	safeReplace(list, "else if", "elif")
	safeReplace(list, "else", "else:")
	safeReplace(list, "&amp;&amp;", "and")
	safeReplace(list, "||", "or")
	safeReplace(list, "TRUE", "true")
	safeReplace(list, "FALSE", "false")
	safeReplace(list, "NULL", "None")
	safeReplace(list, "this", "self")
	safeReplace(list, "try", "try:")
	safeReplace(list, "catch", "except:")
	if leoFlag:
		safeReplace(list, "@code", "@c")
	#next
	handleAllKeywords(list)
	# after processing for keywords
	removeSemicolonsAtEndOfLines(list)
	#last
	if firstPart and leoFlag: removeLeadingAtCode(list)
	removeBlankLines(list)
	removeExcessWs(list)
	# your taste may vary: in Python I don't like extra whitespace
	safeReplace(list, " :", ":") 
	safeReplace(list, ", ", ",")
	safeReplace(list, " ,", ",")
	safeReplace(list, " (", "(")
	safeReplace(list, "( ", "(")
	safeReplace(list, " )", ")")
	safeReplace(list, ") ", ")")
	replaceComments(list) # should follow all calls to safeReplace
	removeTrailingWs(list)
	safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="T2243">def convertDocList(docList):

	# print "convertDocList:", docList
	if matchWord(docList, 0, "@doc"):
		i = skipWs(docList, 4)
		if match(docList, i, "\n"):
			i += 1
		docList[0:i] = list("@ ")</t>
<t tx="T2244">def skipDocPart(list, i):
	
	# print "skipDocPart", i
	while i &lt; len(list):
		if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
			break
		elif isSectionDef(list,i):
			break
		else: i = skipPastLine(list, i)
	return i</t>
<t tx="T2245">def skipCodePart(codeList, i):
	
	# print "skipCodePart", i
	if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
		return i
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			i = skipCBlockComment(codeList,i)
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		elif match(codeList, i, "\n"):
			i += 1
			if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
				break
		else: i += 1
	return i</t>
<t tx="T2246"></t>
<t tx="T2247"></t>
<t tx="T2248">def convertLeadingBlanks(list):

	global tabWidth
	if tabWidth &lt; 2: return
	i = 0
	while i &lt; len(list):
		n = 0
		while i &lt; len(list) and list[i] == ' ':
			n += 1 ; i += 1
			if n == tabWidth:
				list[i-tabWidth:i] = ['\t']
				i = i - tabWidth + 1
				n = 0
		i = skipPastLine(list, i)</t>
<t tx="T2249">def findInList(list, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(list):
		if match(list, i, findList): return i
		else: i += 1
	return -1</t>
<t tx="T2250">def findInCode(codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList, i, findList):
			return i
		else: i += 1
	return -1</t>
<t tx="T2251"># We scan for a '{' at the top level that is preceeded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

	prevSemi = 0 # Previous semicolon: header contains all previous text
	i = 0
	firstOpen = None
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
			prevSemi = i
		elif match(codeList, i, '('):
			if not firstOpen:
				firstOpen = i
			i += 1
		elif match(codeList, i, '#'):
			i = skipPastLine(codeList, i)
			prevSemi = i
		elif match(codeList, i, ';'):
			i += 1
			prevSemi = i
		elif matchWord(codeList, i, "@code"):
			i += 5
			prevSemi = i # restart the scan
		elif matchWord(codeList, i, "@c"):
			i += 2 ; prevSemi = i # restart the scan
		elif match(codeList, i, "{"):
			i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
			prevSemi = i ; firstOpen = None # restart the scan
		else: i += 1</t>
<t tx="T2252"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

	assert(match(codeList,i,"{"))
	prevSemi = skipWsAndNl(codeList, prevSemi)
	close = prevNonWsOrNlChar(codeList, i)
	if close &lt; 0 or codeList[close] != ')':
		return 1 + skipToMatchingBracket(codeList, i)
	if not firstOpen:
		return 1 + skipToMatchingBracket(codeList, i)
	close2 = skipToMatchingBracket(codeList, firstOpen)
	if close2 != close:
		return 1 + skipToMatchingBracket(codeList, i)
	open = firstOpen
	assert(codeList[open]=='(')
	head = codeList[prevSemi:open]
	# do nothing if the head starts with "if", "for" or "while"
	k = skipWs(head,0)
	if k &gt;= len(head) or not head[k] in string.letters:
		return 1 + skipToMatchingBracket(codeList, i)
	kk = skipPastWord(head,k)
	if kk &gt; k:
		headString = listToString(head[k:kk])
		# C keywords that might be followed by '{'
		# print "headString:", headString
		if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
			return 1 + skipToMatchingBracket(codeList, i)
	args = codeList[open:close+1]
	k = 1 + skipToMatchingBracket(codeList,i)
	body = codeList[i:k]
	#print "head:", listToString(head)
	#print "args:", listToString(args)
	#print "body:", listToString(body)
	#print "tot: ", listToString(codeList[prevSemi:k])
	head = massageFunctionHead(head)
	args = massageFunctionArgs(args)
	body = massageFunctionBody(body)
	#print "head2:", listToString(head)
	#print "args2:", listToString(args)
	#print "body2:", listToString(body)
	#print "tot2: ", listToString(codeList[prevSemi:k])
	result = []
	for item in head:
		result.append(item)
	for item in args:
		result.append(item)
	for item in body:
		result.append(item)
	codeList[prevSemi:k] = result
	return k</t>
<t tx="T2253">def massageFunctionArgs(args):
	global gClassName
	assert(args[0]=='(')
	assert(args[-1]==')')

	result = ['('] ; lastWord = []
	if gClassName:
		for item in list("self,"): result.append(item) #can put extra comma

	i = 1
	while i &lt; len(args):
		i = skipWsAndNl(args, i)
		c = args[i]
		if c in string.letters:
			j = skipPastWord(args,i)
			lastWord = args[i:j]
			i = j
		elif c == ',' or c == ')':
			for item in lastWord:
				result.append(item)
			if lastWord != [] and c == ',':
				result.append(',')
			lastWord = []
			i += 1
		else: i += 1
	if result[-1] == ',':
		del result[-1]
	result.append(')')
	result.append(':')
	# print "new args:", listToString(result)
	return result</t>
<t tx="T2254">def massageFunctionHead(head):

	# print "head:", listToString(head)
	result = []
	prevWord = []
	global gClassName ; gClassName = []
	i = 0
	while i &lt; len(head):
		i = skipWsAndNl(head, i)
		if i &lt; len(head) and head[i] in string.letters:
			result = []
			j = skipPastWord(head,i)
			prevWord = head[i:j]
			i = j
			# look for ::word2
			i = skipWs(head,i)
			if match(head,i,"::"):
				# Set the global to the class name.
				gClassName = listToString(prevWord)
				# print "class name:", gClassName
				i = skipWs(head, i+2)
				if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
					j = skipPastWord(head,i)
					if head[i:j] == prevWord:
						for item in list("__init__"): result.append(item)
					elif head[i]=='~' and head[i+1:j] == prevWord:
						for item in list("__del__"): result.append(item)
					else:
						# for item in "::": result.append(item)
						for item in head[i:j]: result.append(item)
					i = j
			else:
				for item in prevWord:result.append(item)
		else: i += 1
		
	finalResult = list("def ")
	for item in result: finalResult.append(item)
	# print "new head:", listToString(finalResult)
	return finalResult</t>
<t tx="T2255">def massageFunctionBody(body):

	body = massageIvars(body)
	body = removeCasts(body)
	body = removeTypeNames(body)
	return body</t>
<t tx="T2256">def massageIvars(body):

	if gClassName and ivarsDict.has_key(gClassName):
		ivars = ivarsDict [ gClassName ]
	else:
		ivars = []
	# print "key:ivars=", gClassName, ':', `ivars`

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			# print "looking up:", word
			if word in ivars:
				# replace word by self.word
				# print "replacing", word, " by self.", word
				word = "self." + word
				word = list(word)
				body[i:j] = word
				delta = len(word)-(j-i)
				i = j + delta
			else: i = j
		else: i += 1
	return body</t>
<t tx="T2257">def removeCasts(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif match(body, i, '('):
			start = i
			i = skipWs(body, i+1)
			if body[i] in string.letters:
				j = skipPastWord(body,i)
				word = listToString(body[i:j])
				i = j
				if word in classList or word in typeList:
					i = skipWs(body, i)
					while match(body,i,'*'):
						i += 1
					i = skipWs(body, i)
					if match(body,i,')'):
						i += 1
						# print "removing cast:", listToString(body[start:i])
						del body[start:i]
						i = start
		else: i += 1
	return body</t>
<t tx="T2258"># Do _not_ remove type names when preceeded by new.

def removeTypeNames(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif matchWord(body, i, "new"):
			i = skipPastWord(body,i)
			i = skipWs(body,i)
			# don't remove what follows new.
			if body[i] in string.letters:
				i = skipPastWord(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			if word in classList or word in typeList:
				k = skipWs(body, j)
				while match(body,k,'*'):
					k += 1 ; j = k
				# print "Deleting type name:", listToString(body[i:j])
				del body[i:j]
			else:
				i = j
		else: i += 1
	return body</t>
<t tx="T2259"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

	# print "handAllKeywords:", listToString(codeList)
	i = 0
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif ( matchWord(codeList,i,"if") or
			matchWord(codeList,i,"while") or
			matchWord(codeList,i,"for") or
			matchWord(codeList,i,"elif") ):
			i = handleKeyword(codeList,i)
		else:
			i += 1
	# print "handAllKeywords2:", listToString(codeList)</t>
<t tx="T2260">def handleKeyword(codeList,i):

	isFor = false
	if (matchWord(codeList,i,"if")):
		i += 2
	elif (matchWord(codeList,i,"elif")):
		i += 4
	elif (matchWord(codeList,i,"while")):
		i += 5
	elif (matchWord(codeList,i,"for")):
		i += 3
		isFor = true
	else: assert(0)
	# Make sure one space follows the keyword
	k = i
	i = skipWs(codeList,i)
	if k == i:
		c = codeList[i]
		codeList[i:i+1] = [ ' ', c ]
		i += 1
	# Remove '(' and matching ')' and add a ':'
	if codeList[i] == "(":
		j = removeMatchingBrackets(codeList,i)
		if j &gt; i and j &lt; len(codeList):
			c = codeList[j]
			codeList[j:j+1] = [":", " ", c]
			j = j + 2
		return j
	return i</t>
<t tx="T2261">def isWs(c):
	return c == ' ' or c == '\t'
	
def isWsOrNl(c):
	return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="T2262"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

	i = skipWs(list,i)
	if not match(list,i,"&lt;&lt;"): return false
	while i &lt; len(list) and list[i] != '\n':
		if match(list,i,"&gt;&gt;="): return i+3
		else: i += 1
	return false</t>
<t tx="T2263">def isStringOrComment(list, i):

	return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="T2264"># returns true if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	n = len(findList)
	j = 0
	while i+j &lt; len(codeList) and j &lt; len(findList):
		if codeList[i+j] != findList[j]:
			return false
		else:
			j += 1
			if j == n:
				return i+j
	return false</t>
<t tx="T2265">def matchWord (codeList, i, findStringOrList):

	j = match(codeList,i,findStringOrList)
	if not j:
		return false
	elif j &gt;= len(codeList):
		return true
	else:
		c = codeList[j]
		return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="T2266">def prevNonWsChar(list, i):

	i -= 1
	while i &gt;= 0 and isWs(list[i]):
		i -= 1
	return i

def prevNonWsOrNlChar(list, i):

	i -= 1
	while i &gt;= 0 and isWsOrNl(list[i]):
		i -= 1
	return i</t>
<t tx="T2267">def removeAllCComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"//"):
			j = skipPastLine(list,i)
			print "deleting single line comment:", listToString(list[i:j])
			del list[i:j]
		elif match(list,i,"/*"):
			j = skipCBlockComment(list,i)
			print "deleting block comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T2268">def removeAllCSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"/*"):
			# block comment starts a line
			i = skipCBlockComment(list,i)
			i = skipPastLine(line,i)
		elif match(list,i,"//@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T2269">def removeAllPythonComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"#"):
			j = skipPastLine(list,i)
			print "deleting comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T2270">def removeAllPythonSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"#@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T2271">def removeAtRoot (codeList):

	i = skipWs(codeList, 0)
	if matchWord(codeList,i,"@root"):
		j = skipPastLine(codeList,i)
		del codeList[i:j]

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i = skipWs(codeList, i+1)
			if matchWord (codeList,i,"@root"):
				j = skipPastLine(codeList,i)
				del codeList[i:j]
		else: i += 1
</t>
<t tx="T2272">def removeBlankLines(codeList):

	i = 0
	while i &lt; len(codeList):
		j = i
		while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
			j += 1
		if j== len(codeList) or codeList[j] == '\n':
			del codeList[i:j+1]
		else:
			oldi = i
			i = skipPastLine(codeList,i)</t>
<t tx="T2273">def removeExcessWs(codeList):

	i = 0
	i = removeExcessWsFromLine(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,'\n'):
			i += 1
			i = removeExcessWsFromLine(codeList,i)
		else: i += 1</t>
<t tx="T2274">def removeExcessWsFromLine(codeList,i):

	assert(i==0 or codeList[i-1] == '\n')
	i = skipWs(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i): break # safe
		elif match(codeList, i, '\n'): break
		elif match(codeList, i, ' ') or match(codeList, i, '\t'):
			# Replace all whitespace by one blank.
			k = i
			i = skipWs(codeList,i)
			codeList[k:i] = [' ']
			i = k + 1 # make sure we don't go past a newline!
		else: i += 1
	return i</t>
<t tx="T2275">def removeLeadingAtCode(codeList):

	i = skipWsAndNl(codeList,0)
	if matchWord(codeList,i,"@code"):
		i = skipWsAndNl(codeList,5)
		del codeList[0:i]
	elif matchWord(codeList,i,"@c"):
		i = skipWsAndNl(codeList,2)
		del codeList[0:i]</t>
<t tx="T2276">def removeMatchingBrackets(codeList, i):

	j = skipToMatchingBracket(codeList, i)
	if j &gt; i and j &lt; len(codeList):
		# print "del brackets:", listToString(codeList[i:j+1])
		c = codeList[j]
		if c == ')' or c == ']' or c == '}':
			del codeList[j:j+1]
			del codeList[i:i+1]
			# print "returning:", listToString(codeList[i:j])
			return j - 1
		else: return j + 1
	else: return j</t>
<t tx="T2277">def removeSemicolonsAtEndOfLines(list):

	i = 0
	while i &lt; len(list):
		if isStringOrComment(list,i):
			i = skipStringOrComment(list,i)
		elif list[i] == ';':
			j = skipWs(list,i+1)
			if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
				del list[i]
			else: i += 1
		else: i += 1</t>
<t tx="T2278">def removeTrailingWs(list):

	i = 0
	while i &lt; len(list):
		if isWs(list[i]):
			j = i
			i = skipWs(list,i)
			assert(j &lt; i)
			if i &gt;= len(list) or list[i] == '\n':
				# print "removing trailing ws:", `i-j`
				del list[j:i]
				i = j
		else: i += 1</t>
<t tx="T2279"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)

	i = 0
	while i &lt; len(codeList):
		if match(codeList, i, findList):
			codeList[i:i+len(findList)] = changeList
			i += len(changeList)
		else: i += 1</t>
<t tx="T2280"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

	i = 0
	if match(codeList, i, "//"):
		codeList[0:2] = ['#']
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			codeList[i:i+2] = ['#']
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			j = skipCBlockComment(codeList,i)
			del codeList[j-2:j]
			codeList[i:i+2] = ['#']
			j -= 2 ; k = i ; delta = -1
			while k &lt; j + delta :
				if codeList[k]=='\n':
					codeList[k:k+1] = ['\n', '#', ' ']
					delta += 2 ; k += 3 # progress!
				else: k += 1
			i = j + delta
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		else: i += 1</t>
<t tx="T2281"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

	i = 0
	j = isSectionDef(codeList,i)
	if j &gt; 0: codeList[i:j] = list("@c ")

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i += 1
			j = isSectionDef(codeList,i)
			if j &gt; i: codeList[i:j] = list("@c ")
		else: i += 1</t>
<t tx="T2282"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)
	i = 0
	if findList[0] in string.letters: #use matchWord
		while i &lt; len(codeList):
			if isStringOrComment(codeList,i):
				i = skipStringOrComment(codeList,i)
			elif matchWord(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1
	else: #use match
		while i &lt; len(codeList):
			if match(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1</t>
<t tx="T2283">def skipCBlockComment(codeList, i):

	assert(match(codeList, i, "/*"))
	i += 2

	while i &lt; len(codeList):
		if match(codeList, i, "*/"): return i + 2
		else: i += 1
	return i</t>
<t tx="T2284">def skipPastLine(codeList, i):

	while i &lt; len(codeList) and codeList[i] != '\n':
		i += 1
	if i &lt; len(codeList) and codeList[i] == '\n':
		i += 1
	return i</t>
<t tx="T2285">def skipPastWord(list, i):

	assert(list[i] in string.letters or list[i]=='~')
	
	# Kludge: this helps recognize dtors.
	if list[i]=='~':
		i += 1
	
	while i &lt; len(list) and (
		list[i] in string.letters or
		list[i] in string.digits or
		list[i]=='_'):
		i += 1
	return i</t>
<t tx="T2286">def skipString(codeList, i):

	delim = codeList[i] # handle either single or double-quoted strings
	assert(delim == '"' or delim == "'")
	i += 1

	while i &lt; len(codeList):
		if codeList[i] == delim: return i + 1
		elif codeList[i] == '\\': i += 2
		else: i += 1
	return i</t>
<t tx="T2287">def skipStringOrComment(list,i):

	if match(list,i,"'") or match(list,i,'"'):
		return skipString(list,i)
	if match(list, i, "//"):
		return skipPastLine(list,i)
	elif match(list, i, "/*"):
		return skipCBlockComment(list,i)
	else: assert(0)</t>
<t tx="T2288">def skipToMatchingBracket(codeList, i):

	c = codeList[i]
	if   c == '(': delim = ')'
	elif c == '{': delim = '}'
	elif c == '[': delim = ']'
	else: assert(0)

	i += 1
	while i &lt; len(codeList):
		c = codeList[i]
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif c == delim:
			return i
		elif c == '(' or c == '[' or c == '{':
			i = skipToMatchingBracket(codeList,i)
			i += 1 # skip the closing bracket.
		else: i += 1
	return i</t>
<t tx="T2289">def skipWs(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t':
			i += 1
		else: break
	return i
	
def skipWsAndNl(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t' or c == '\n':
			i += 1
		else: break
	return i</t>
<t tx="T2290"># converts a string to a list containing one item per character of the list.
# converts None to the empty string and leaves other types alone.

# list(string) does not work on none.
def stringToList(string):

	if string:
		return list(string)
	else:
		return []</t>
<t tx="T2291">def listToString(list):

	return string.join(list,"")</t>
<t tx="T2292"># routines to gather static statistics about opcodes based on dis module.

import compiler,dis,os,string,sys,types

@others</t>
<t tx="T2293">def go():
	
	dir = "c:/prog/leoCVS/leo/"
	modules = getModules(dir)
	stats = [0] * 256
	try:
		# Importing these might start leo itself and hang idle.
		modules.remove("leo")
		modules.remove("openLeo")
		modules.remove("openEkr")
		modules.remove("setup")
	except: pass
	# print modules
	
	for m in modules:
		try:
			print "module:", m
			exec("import " + m)
			a = eval(m)
			any(a,stats)
		except:
			import traceback
			traceback.print_exc()
			print "----- no matching class in", `m`
			
	print_stats(stats)</t>
<t tx="T2294">def getFiles (dir):

	# Generate the list of modules.
	allFiles = os.listdir(dir)
	files = []
	for f in allFiles:
		head,tail = os.path.split(f)
		root,ext = os.path.splitext(tail)
		if ext==".py":
			files.append(os.path.join(dir,f))
			
	return files</t>
<t tx="T2295">def getModules (dir):
	
	"""Return the list of Python files in dir."""
	
	files = []
	
	try:
		allFiles = os.listdir(dir)
		for f in allFiles:
			head,tail = os.path.split(f)
			fn,ext = os.path.splitext(tail)
			if ext==".py":
				files.append(fn)
	except: pass
			
	return files</t>
<t tx="T2296">def any(x,stats,printName = 0):
	# based on dis.dis()
	"""Gathers statistics for classes, methods, functions, or code."""
	if not x:
		return
	if type(x) is types.InstanceType:
		x = x.__class__
	if hasattr(x, 'im_func'):
		x = x.im_func
	if hasattr(x, 'func_code'):
		x = x.func_code
	if hasattr(x, '__dict__'):
		items = x.__dict__.items()
		items.sort()
		for name, x1 in items:
			if type(x1) in (types.MethodType,
							types.FunctionType,
							types.CodeType):
				if printName: print name
				try:
					any(x1,stats)
				except TypeError, msg:
					print "Sorry:", msg
	elif hasattr(x, 'co_code'):
		code(x,stats)
	else:
		raise TypeError, \
			  "don't know how to disassemble %s objects" % \
			  type(x).__name__</t>
<t tx="T2297">def code (co, stats):
	"""Gather static count statistics for a code object."""

	codeList = co.co_code
	# Count the number of occurances of each opcode.
	i = 0 ;  n = len(codeList)
	while i &lt; n:
		c = codeList[i]
		op = ord(c)
		stats[op] += 1
		i = i+1
		if op &gt;= dis.HAVE_ARGUMENT:
			i = i+2</t>
<t tx="T2298">def print_stats (stats):

	stats2 = [] ; total = 0
	for i in xrange(0,256):
		if stats[i] &gt; 0:
			stats2.append((stats[i],i))
		total += stats[i]

	stats2.sort()
	stats2.reverse()
	for stat,i in stats2:
		print string.rjust(`stat`,6), dis.opname[i]
	print "total", total</t>
<t tx="T2299">@language python

@ This file contains functions for non-interactive searching.  You might find these useful while running other scripts.
@c

import leo, string, re

@others</t>
<t tx="T2300">def changeAll ( commander, findPat, changePat, bodyFlag = 1 ):
	"""
	changeAll	make changes in an entire Leo outline.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = changeNext(v, pos, findPat, changePat, bodyFlag)
		pos = pos + n</t>
<t tx="T2301">def changeNext ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changeNext:	use string.find() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changeNext,
	changeNext(v,pos+len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findNext(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
		print "setting head string: ", result
	return v, pos</t>
<t tx="T2302">def changePrev ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changePrev:	use string.rfind() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changePrev,
	changePrev(v,pos-len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findPrev(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		#s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, pos</t>
<t tx="T2303">def findAll(c,pattern,bodyFlag=1):
	"""
	findAll		search an entire Leo outline for a pattern.
	
	c        commander for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text. false: search headline text.
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	v = c.rootVnode()
	n = len(pattern)
	result = [] ; pos = 0
	while v != None:
		v, pos = findNext(v,pos,pattern,bodyFlag)
		if v:
			result.append ((v, pos),)
		pos = pos + n
	return result</t>
<t tx="T2304">def findNext ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findNext:	use string.find() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findNext,
	findNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = s.find(pattern,pos )
		if pos != -1:
			return v, pos
		v = v.threadNext()
		pos = 0
	return None, 0</t>
<t tx="T2305">def findPrev ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findPrev:	use string.rfind() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findPrev,
	findPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = s.rfind(pattern,0,pos)
		if pos != -1:
			return v, pos
		v  = v.threadBack()
		pos = -1
	return None, 0</t>
<t tx="T2306">def reChangeAll ( commander, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeAll: make changes in an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reChangeNext(
			v, pos, findPat, changePat, bodyFlag, reFlags)
		pos = pos + n</t>
<t tx="T2307">def reChangeNext ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeNext: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangeNext,
	reChangeNext(v,pos+len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		print s, findPat, changePat
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T2308">def reChangePrev ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangePrev: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangePrev,
	reChangePrev(v,pos-len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindPrev(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T2309">def reFindAll(c,findPat,bodyFlag,reFlags=None):
	"""
	reFindAll	search an entire Leo outline using re module.
	
	c	     commander for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		flags argument to re.search().

	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	v = c.rootVnode()
	n = len(findPat)
	result = [] ; pos = 0
	while v != None:
		v, mo, pos = reFindNext(v,pos,findPat,bodyFlag,reFlags)
		if v != None:
			result.append ( (v,mo,pos) )
		pos = pos + n
	return result</t>
<t tx="T2310">def reFindNext ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindNext:	use re.search() to find pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.
	mo is a "match object"

	Note: if (v,pos) is a tuple returned previously from reFindNext,
	reFindNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos + mo.start()
		v = v.threadNext()
		pos = 0
	return None, None, 0</t>
<t tx="T2311">def reFindPrev ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindPrev:	use re.search() to find pattern in a Leo outline.

	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.
	
	Note 1: Searches vnodes in reverse (v.threadBack) direction.
	Searches text of vnodes in _forward_ direction.
	
	Note 2: if (v,pos) is a tuple returned previously from reFindPrev,
	reFindPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		# Forward search through text...
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos+mo.start()
		# Reverse search through vnode.
		v = v.threadBack()
		pos = 0
	return None, None, 0</t>
<t tx="T2312">def lineAtPos ( s, pos ):
	"""
	lineAtPos: return the line of a string containing the given index.
	s		a string
	pos		an index into s
	"""
	# find the start of the line containing the match
	if len(s) &lt; 1:
		return ""
	if pos &gt; len(s):
		pos = len(s)-1
		
	while pos &gt; 0:
		if s[pos] == '\n':
			pos = pos + 1
			break
		else:
			pos = pos - 1
	# return the line containing the match
	s = s[pos:]
	list = s.split("\n")
	return list[0]</t>
<t tx="T2313">def printFindList( findList, bodyFlag = 1 ):
	"""
	printFindList:	Print matching lines from the list.
	
	findList:		a list of (v,pos) tuples returned from findAll().
	Only the line containing the match is printed.
	Lines are printed once for each match found on the line.
	"""
	for v,pos in findList:
		if v != None:
			if bodyFlag:
				s = v.bodyString()
			else:
				s = v.headString()
			print lineAtPos(s, pos)</t>
<t tx="T2314">@first #! /usr/bin/env python
@language python

@ This tiny script is intended to be called from go.bat to open LeoPy.leo.  You could change the file name to be any file you work on a lot...
@c

import leo
leo.run("c:\prog\leoCVS\leo\LeoPy.leo")</t>
<t tx="T2315">@first #! /usr/bin/env python
@language python

# Example tangle_done.py file.
# Leo catches all exceptions thrown here; there is no need for try:except blocks.

@others</t>
<t tx="T2316"># Leo calls this routine if "Run tangle-done.py after Tangle" is checked in the Prefs panel.

def run (root_list):

	print "tangle_done roots:"
	for root in root_list:
		print root
	
	if 0: # Run code contributed by Paul Paterson.
		convertRSTfilesToHTML(root_list)</t>
<t tx="T2317">@ This routine creates .html files from all .rst files in root_list, the list of files that have just been tangled.

Adapted from code by Paul Paterson.
@c

def convertRSTfilesToHTML(root_list):
	
	import os
	
	for root in root_list: 
		base,fullname = os.path.split(root)
		name,ext = os.path.splitext(fullname)
		if ext == ".rst":
			file = os.path.join(base,name+".html")
			&lt;&lt; Convert root to corresponding .html file &gt;&gt;
</t>
<t tx="T2318"># Leo will report the execption if docutils is not installed.
from docutils.core import Publisher 
from docutils.io import FileInput,StringOutput,StringInput 

# Read .rst file into s.
f = open(root,"r")
s = f.read()
f.close()

# Restucture s into output.
pub = Publisher() 
pub.source = StringInput(pub.settings,source=s) 
pub.destination = StringOutput(pub.settings,encoding="utf-8") 
pub.set_reader('standalone',None,'restructuredtext') 
pub.set_writer('html') 
output = pub.publish()

# EKR: 3/7/03: convert output using the present encoding.
dict = scanDirectives(self.commands,v=root)
encoding = dict.get("encoding",None)
if encoding == None:
	encoding = app.config.default_derived_file_encoding
output = toEncodedString(output,encoding,reportErrors=true) 

# Write the corresponding html file.
f = open(file,"w")
f.write(output)
f.close()</t>
<t tx="T2319">@first #! /usr/bin/env python
@language python

# Example untangle_done script

def run(root_list):

	print "untangle_done roots:", root_list</t>
<t tx="T2320"># An example of running this script:
#
# import leoImport
# leoImport.importFiles("c:/prog/test", ".py")

def importFiles (dir, type = None, kind = "@file"):
	
	import os

	# Check the params.
	if kind != "@file" and kind != "@root":
		es("kind must be @file or @root: " + `kind`)
		return
	if not os.path.exists(dir):
		es("directory does not exist: " + `dir`)
		return
	
	c = top() # Get the commander.
	
	try:
		files = os.listdir(dir)
		files2 = []
		for f in files:
			path = os.path.join(dir,f)
			if os.path.isfile(path):
				name, ext = os.path.splitext(f)
				if type == None or ext == type:
					files2.append(path)
		if len(files2) &gt; 0:
			c.importCommands.importFilesCommand(files2,kind)
	except:
		es("exception in importFiles script")
		es_exception()</t>
<t tx="T2321">@ignore</t>
<t tx="T2322">@nocolor</t>
<t tx="T2323"></t>
<t tx="T2324">Leo 3.12.1 beta 1                     July 25, 2003

This version exists to test the new Linux install scripts and the related distribution stuff.

Leo 3.12                              July 17, 2003

Window sizes are now in pixels rather than grid units, so you must resize existing outlines (.leo files) when opening them for the first time using this version of Leo.  Don't panic!

Highlights of this version:

* Plugged a huge memory leak.
* Fixed a major bug involving undo.
* Added Icon &amp; Status areas to Leo window for use by plugins.
* Important new plugins:
  - The file leoPlugins.leo now contains all plugins.
  - add_directives.py allows plugins to define new directives.
  - color_markup.py supports wiki-styled markup.
  - mod_spelling.py checks spelling (requires aspell to be installed).
  - nav_buttons.py creates browser-style navigation plugins in the icon area.
  - plugins_menu.py creates a Plugins menu items for all loaded plugins.
  - scripts_menu.py creates a Scripts menu for all scripts in scripts folder.
  - spell
  - trace_gc traces all changes to memory at idle time.
* Other enhancements:
  - Redesigned the Find panel.   Non-functional options are dimmed.
  - Added @wrap and @nowrap directives.
  - Added Write Dirty @file Nodes command.
  - Added several new "stub hooks".
  - Hyperlinks are now enabled by default.
  - Leo now loads plugins in alphabetical order.
  - Leo now remembers the size and location of Leo windows.
  - Undo now restores the insert point or the selection range after most commands.
  - Added apply button to Font panel.
  - Improved the reporting of characters that do not exist in the present encoding.
* The usual assortment of bug fixes and minor improvements.
  - There are no known bugs in this version of Leo.</t>
<t tx="T2325">Leo 3.11.1                       May 1, 2003

This version fixes two bugs:
	
- Leo threw an exception at startup on some Linux systems.
- Creating clones by control dragging did not always work.

This code contains permanently disabled 4.0 code.

Leo 3.11                         April 27, 2003

This version of Leo contains many important improvements since 3.10,
especially support for unicode and a new plugin architecture.

The Highlights of 3.11:

** Leo supports unicode properly.
  - New @encoding directives specifies encoding for derived files.
  - New settings specify default encodings for .leo and derived files.
  - Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo.
- New commands:
  - Toggle Angle Brackets.
  - Insert Time/Date (in headline or body text).
  - Go To First/Last Node, Parent, Next/Previous Sibling.
  - Write Missing @file Nodes.
  - Expand/Contract Node.
- Improved commands:
  - Fixed a huge performance bug that slowed moving nodes left.
  - Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
  - Sort Siblings command can now sort top-level nodes.
  - Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
  - New @lineending directive specifies line endings.
  - Improved syntax coloring for html and xml.
  - Leo scrolls partially visible headlines into full view.
  - Added "Replace tabs with spaces" checkbox in Prefs panel.
- New settings in leoConfig.leo/.txt.
  - Added "tk_encoding" setting and related logic.
  - Colors for Show Invisibibles command and body_insertion_cursor
  - Settings affecting when control-drags start.
  - Defaults for unicode (see above).
- Many other bug fixes and improvements.</t>
<t tx="T2326">Leo 3.10                             December 14, 2002

This version of Leo corrects bugs, improves Leo's documentation and adds many new features:

- Rewrote Scripting Chapter in Leo's Users Guide.
- Improved the Customization Chapter of the Users Guide.
- Adds several customizations contributed by Leo's users.
  Among these: @read-only nodes. Reading empty .leo files.
  Redirecting stderr and stdout to Leo's log pane.
- New Mark Clones and Go To Next Clone commands.
- New Export Headlines command.
- Control-dragging a node now clones it.
- New "Node Only checkbox in the Find/Change panel.
- @root-code trees start in code mode by default.
  This allows @root trees to work like @file trees.
- @root-doc  trees start in doc  mode by default.
- Converted leoConfig.py to use @root-code
- New at_root_bodies_start_in_doc_mode option in leoConfig.py.
  Specifies whether @root trees work like @root-code or @root-doc.
- New synonyms: @file-asis = @silentfile
  @file-nosent = @nosentinelsfile ; @file-noref = @rawfile.
- Leo now supports navigation of menus using underlined menus.
- Added an easy way to replace any Leo method by a function.
  Hooks can now override part of Leo's code!
- Added routines to redirect stderr and stdout to Leo's log pane.
  These routines can be called from hooks.
- Added "event1" and "event2" hooks for customize event handling.
- Improved Leo's window icon, and improved how that icon is loaded.
- Added contributed code to support @read-only nodes.
  This code show how easy it is to customize Leo.
- The usual assortment of bug fixes and minor improvements.
  Actually, this release fixes more than the usual number of bugs.</t>
<t tx="T2327">Leo 3.9                               Nov 23, 2002

This is one of the most interesting versions of Leo ever released:

* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
	These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth to other editors.
  - The Go To Line Number command converts lines numbers in derived files
	to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
	This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
	By default, @space, @* and @** sections are colored as latex text.
	Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
	@file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
	installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.
</t>
<t tx="T2328">Leo 3.8                                 October 29, 2002

Many major improvements have been made to Leo, all made as the result of user requests:

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option specifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.</t>
<t tx="T2329">Leo 3.7                                 October 9, 2002

Many improvements have been made to Leo.  The highlights:

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands.
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode Latin-1 (iso-8859-1) encoding. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.
</t>
<t tx="T2330">Leo 3.6                                   September 11, 2002

Highlights:

- Fixed a large number of bugs, especially bugs that appear only on Linux.
- Leo now remembers the previous insertion point and location of the scrollbar when switching between nodes.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.
</t>
<t tx="T2331">Leo 3.5                                    August 14, 2002

The many bugs were reported in 3.4 show that  Leo is being heavily used.  This version corrects all known bugs and adds some new features:

- Added new entries in the help menu,
  (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added configuration options for horizontal scrollbars.
- Added an importFiles script for mass imports.
- Added better warnings for read-only files.
- Removed all '\r' characters when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.</t>
<t tx="T2332">Leo 3.4                                     August 11, 2002

This version contains many small improvements and bug fixes:

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.</t>
<t tx="T2333">Leo 3.3                                     August 3, 2002

This version of Leo:

- Adds support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.</t>
<t tx="T2334">Leo 3.2                                     July 30, 2002

This version generalizes the @others directive, improves the Import command and fixes several bugs.  See the children of this node for full details.

The highlights:

- Nested @others directives are now valid, an important improvement.
  This simplifies files that define more than one class.
- Improved the Import command and squashed several bugs lurking there.
- Made the various Go commands in the Outline-Move/Select menu functional
  by reassigning keyboard shorts
- Fixed a crasher in the Prefs Panel.
- Fixed numerous bugs in the Set Colors command.
- Fixed syntax coloring of C strings that span multiple lines.
- The usual minor improvements and bug fixes.
</t>
<t tx="T2335">Leo 3.1                                     July 20, 2002

This version fixes a blunder that affects only  Leo 3.0.
I recommend that all users of 3.0 upgrade to 3.1.

With this release Leo's to-do list is now empty!
I shall fix bugs as they are reported.
I'll add new features only if convinced that they contribute significantly to Leo.

The highlights:

- Fixed a blunder: Leo 3.0 did nothing when it was opened directly from  Leo.
  (Opening leo using openLeo.py did work.)
- Created a compare panel to control scripts in leoCompare.py.
- Added many new settings in leoConfig.txt to initialize the compare panel.
- The FAQ tells how to add support for new languages.
- The usual minor improvements and bug fixes.</t>
<t tx="T2336">Leo 3.0                                     July 16, 2002

This version is called 3.0 because it can optionally produce files that
can _not_ be read by the  Leo 2.x or the Borland version of Leo.
By default,  Leo 3.0 _does_ produce files that all previous versions of Leo can read.

As always, see LeoDocs.leo for full details.  The highlights:

- Many new user options in leoConfig.txt, including, among others,
  fonts in all panes, colors for syntax coloring and default window size and position.
- Support for .leo files with XML types like "ISO-8859-1", controlled by a user option.
  Note: by default, Leo writes files compatible with previous versions of Leo.
- Powerful new Color and Font pickers, fully connected to user options.
- Added Toggle Split Direction command, under control of user options.
- Added autoscrolling in the outline pane.
- Windows open at the position in which they were saved.
- The size and position of new windows can be controlled with user options.
- Eliminated drawing problems while opening files.
- Improved syntax coloring for @comment plain.
- The Convert All Blanks and Convert All Tabs commands are now undoable.
- Leo warns and aborts if Python 2.2 or above is not running.
- The usual bug fixes.
</t>
<t tx="T2337"></t>
<t tx="T2338">Leo version 2.5.1                           July 7, 2002

This version corrects crashers that affect undo/redo move commands.
Version 2.5 has been withdrawn.

ANYONE USING 2.5 SHOULD IMMEDIATELY SWITCH TO 2.5.1.

Leo version 2.5                             July 7, 2002

See LeoDocs.leo for full details.  The highlights:

- Leo supports tab widths properly, and negative tab widths cause
  Leo to convert tabs to blanks as you type.
- Three new commands appear in the Edit Body menu:
  Convert Tabs, Convert All Tabs and Convert All Blanks.
  Convert All Tabs and Convert All Spaces convert the entire selected tree.
- Leo now allows you to override selected preferences using a
  configuration file called leoConfig.txt.
  Leo acts as before if this file does not exist.
- The Preferences panel is now contains Ok, Cancel and Revert buttons.
- Cut and paste work properly in all situations.
  You can cut and paste between Leo and other applications,
  or between two different copies of Leo.
- Added the Recent Files submenu to the File menu.
- Fixed several crashers.
- Fixed several bugs in the Import commands.
- Leo will no longer abort reading if it detects an invalid directory name
  in the Default Tangle Directory in the Preferences panel.</t>
<t tx="T2339">Leo version 2.4                             June 20, 2002

This version fixes some annoying bugs and adds some nice features:

- Leo now properly highlights the headline of a newly created node.
- The Edit Headline command now works properly.
  Double and triple clicking in a headline now works as expected.
- You can now reorganize drag headlines around.
  You must drag from a node's icon and release on another node's icon.
- You can now open .leo files in  Leo by double clicking on .leo files,
  provided that you associate  Leo with .leo files.
- Improved error recovery when there are errors writing .leo files.
- All parts of LeoDocs.leo now match the documentation on Leo's web site.</t>
<t tx="T2340">Leo version 2.3                             June 12, 2002

This version fixes a minor problem with Leo.

- The code that reads and writes @file nodes now uses the directory containing the
 .leo file as a default when the Default Tangle Directory setting is empty in the Preferences panel.
- The Tangle and Untangle commands have used this convention for a long time.
- This default allows us to distribute LeoPy.leo without specifying
  a directory in the Preferences Panel.</t>
<t tx="T2341">Leo version 2.2                             June 2, 2002

The version fixes two bugs that happen rarely and can cause loss of data when they do happen.

- In certain circumstances  Leo v2.1 would delete most of an outline when
  a node was moved in front of the previous root node!
- All previous versions of Leo will crash when saving body text containing unicode characters.
  This could occur as the result of cutting and pasting text from another application into the body pane.
- Leo now writes body text containing unicode characters using Python's u-prefixed notation.
  That is, the body text is written as: u'escaped_text', where escaped text replaces unicode characters
  not in the ascii character set by escape sequences of the form \uxxxx.
- The result contains nothing but ascii characters, so Leo will have no problem reading it.
  Naturally, compilers and other tools may not understand Python's notation,
  so you may have to convert escaped text to something that your tools can understand.

Edward K. Ream</t>
<t tx="T2342">@first #! /usr/bin/env python

"""Entry point for Leo in Python."""

@language python
&lt;&lt; Import pychecker &gt;&gt;

from leoGlobals import *
import leoApp,leoConfig,leoDialog,leoFrame
import os,string,sys,traceback

@others

if __name__ == "__main__":
	if len(sys.argv) &gt; 1:
		if sys.platform=="win32": # Windows
			fileName = string.join(sys.argv[1:],' ')
		else:
			fileName = sys.argv[1]
		run(fileName)
	else:
		run()



</t>
<t tx="T2343">@ pychecker is extremely useful, and it sometimes reports problems erroneously.  In particular, the following warnings are invalid:

in leoFrame.py and leoNodes.py: warnings about the event param not being used. pychecker doesn't understand that these routines are Tkinter callbacks.

in leoApp.py and leoGlobals.py: pychecker doesn't seem to handle globals very well.  There are spurious warnings about globals.

several files: pychecker complains about several routines being "too big", i.e., pychecker doesn't understand about literate programming.

@c

if 0: # Set to 1 for lint-like testing.  This can also be done in idle.
	try:
		import pychecker.checker
	except: pass</t>
<t tx="T2344">@ To gather statistics, do the following in a Python window, not idle:

	import leo
	leo.profile()  (this runs leo)
	load leoDocs.leo (it is very slow)
	quit Leo.
@c

def profile ():
	
	"""Gather and print statistics about Leo"""

	import profile, pstats
	
	name = "c:/prog/test/leoProfile.txt"
	profile.run('leo.run()',name)

	p = pstats.Stats(name)
	p.strip_dirs()
	p.sort_stats('cum','file','name')
	p.print_stats()</t>
<t tx="T2345">@first # -*- coding: utf-8 -*-
@language python

from leoGlobals import *
import leoConfig,leoDialog,leoFind,leoGui,leoNodes
import locale,os,sys

class LeoApp:

	"""A class representing the Leo application itself.
	
	Ivars of this class are Leo's global variables."""
	
	@others
</t>
<t tx="T2346">def destroyAllGlobalWindows (self):
	
	for w in self.globalWindows:
		w.top.destroy()
		
	self.globalWindows = []
	
	self.findFrame = None
	self.pythonFrame = None
		
	doHook("destroy-all-global-windows")
</t>
<t tx="T2347">@ Try to remove temp files created with the Open With command.  This may fail if the files are still open.

We can't use es here because the log stream no longer exists.
@c 

def destroyAllOpenWithFiles (self):
	
	app = self

	for dict in self.openWithFiles[:]: # 7/10/03.
		app.destroyOpenWithFileWithDict(dict)
		
	# Delete the list so the gc can recycle Leo windows!
	app.openWithFiles = []</t>
<t tx="T2348">def destroyOpenWithFilesForFrame (self,frame):
	
	"""Close all "Open With" files associated with frame"""
	
	app = self
	
	# Make a copy of the list: it may change in the loop.
	openWithFiles = app.openWithFiles

	for dict in openWithFiles[:]: # 6/30/03
		c = dict.get("c")
		if c.frame == frame:
			app.destroyOpenWithFileWithDict(dict)
</t>
<t tx="T2349">def destroyOpenWithFileWithDict (self,dict):
	
	app = self
	
	path = dict.get("path")
	if path and os.path.exists(path):
		try:
			os.remove(path)
			print "deleting temp file:", shortFileName(path)
		except:
			print "can not delete temp file:", path
			
	# Remove dict from the list so the gc can recycle the Leo window!
	app.openWithFiles.remove(dict)</t>
<t tx="T2350">def forceShutdown (self):
	
	"""Forces an immediate shutdown of Leo at any time.
	
	In particular, may be called from plugins during startup."""
	
	for w in self.windowList[:]:
		self.destroyWindow(w)

	self.finishQuit()</t>
<t tx="T2351"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):
	
	cmn = canonicalizeTranslatedMenuName(menuName)
	return self.realMenuNameDict.get(cmn,menuName)
	
def setRealMenuName (self,untrans,trans):
	
	cmn = canonicalizeTranslatedMenuName(untrans)
	self.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

	for untrans,trans in table:
		self.setRealMenuName(untrans,trans)
</t>
<t tx="T2352">def writeWaitingLog (self):

	if self.log:
		for s,color in self.logWaiting:
			es(s,color=color,newline=0) # The caller must write the newlines.
		self.logWaiting = []
</t>
<t tx="T2353">"""Classes to read and write @file nodes."""

@language python

from leoGlobals import *
import leoColor,leoNodes
import filecmp,os,os.path,time

&lt;&lt; global atFile constants &gt;&gt;

class baseAtFile:
	"""The base class for the top-level atFile subcommander."""
	&lt;&lt; class baseAtFile methods &gt;&gt;
	
class atFile (baseAtFile):
	pass # May be overridden in plugins.
	
class baseOldDerivedFile:
	"""The base class to read and write 3.x derived files."""
	&lt;&lt; class baseOldDerivedFile methods &gt;&gt;
	
class oldDerivedFile(baseOldDerivedFile):
	pass # May be overridden in plugins.
	
class baseNewDerivedFile(oldDerivedFile):
	"""The base class to read and write 4.x derived files."""
	&lt;&lt; class baseNewDerivedFile methods &gt;&gt;
	
class newDerivedFile(baseNewDerivedFile):
	pass # May be overridden in plugins.</t>
<t tx="T2354"># These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
# not used      =  2
docDirective	   =  3 # @doc.
atDirective		   =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	  =  5 # @code
cDirective		    =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
# not used   = 21
endAt			 = 22 # @-at
endBody			 = 23 # @-body
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @&lt; &lt; ... &gt; &gt;
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.0...
startAfterRef  = 70 # @afterref (4.0)
startNl        = 71 # @nl (4.0)
startNonl      = 72 # @nonl (4.0)
	
sentinelDict = {
	# Unpaired sentinels: 3.x and 4.x.
	"@comment" : startComment,
	"@delims" :  startDelims,
	"@verbatim": startVerbatim,
	# Unpaired sentinels: 3.x only.
	"@verbatimAfterRef": startVerbatimAfterRef,
	# Unpaired sentinels: 4.x only.
	"@afterref" : startAfterRef,
	"@nl"       : startNl,
	"@nonl"     : startNonl,
	# Paired sentinels: 3.x only.
	"@+body":   startBody,   "@-body":   endBody,
	# Paired sentinels: 3.x and 4.x.
	"@+at":     startAt,     "@-at":     endAt,
	"@+doc":    startDoc,    "@-doc":    endDoc,
	"@+leo":    startLeo,    "@-leo":    endLeo,
	"@+node":   startNode,   "@-node":   endNode,
	"@+others": startOthers, "@-others": endOthers }</t>
<t tx="T2355">@others</t>
<t tx="T2356">def __init__(self,theCommander):
	
	self.commands = theCommander
	self.fileCommands = self.commands.fileCommands
	
	# Create subcommanders to handler old and new format derived files.
	self.old_df = oldDerivedFile(theCommander)
	self.new_df = newDerivedFile(theCommander)
	
	self.initIvars()
	
def initIvars(self):
	
	# Set by scanDefaultDirectory.
	self.default_directory = None
	self.errors = 0

	# Set by scanHeader when reading. Set by scanAllDirectives...
	self.encoding = app.config.default_derived_file_encoding
	self.endSentinelComment = None
	self.startSentinelComment = None</t>
<t tx="T2357">def error(self,message):

	es(message,color="red")
	print message
	self.errors += 1</t>
<t tx="T2358"></t>
<t tx="T2359">def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.commands
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	v = root
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	while v and v != after:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode() or v.isAtRawFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(v)
			else:
				# if v is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = v.isOrphan()
				ok = at.read(v)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					v.setDirty()
					c.setChanged(true)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	# Clear all orphan bits.
	v = root
	while v:
		v.clearOrphan()
		v = v.threadNext()
		
	if partialFlag and not anyRead:
		es("no @file nodes in the selected tree")</t>
<t tx="T2360">def scanDefaultDirectory(self,v):
	
	"""Set default_directory ivar by looking for @path directives."""

	at = self ; c = at.commands
	at.default_directory = None
	&lt;&lt; Set path from @file node &gt;&gt;
	if at.default_directory:
		return

	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		if dict.has_key("path"):
			&lt;&lt; handle @path &gt;&gt;
			return
		v = v.parent()

	&lt;&lt; Set current directory &gt;&gt;
	if not at.default_directory:
		# This should never happen: c.openDirectory should be a good last resort.
		at.error("No absolute directory specified anywhere.")
		at.default_directory = ""</t>
<t tx="T2361"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and os.path.isabs(dir):
	if os.path.exists(dir):
		at.default_directory = dir
	else:
		at.default_directory = makeAllNonExistentDirectories(dir)
		if not at.default_directory:
			at.error("Directory \"" + dir + "\" does not exist")</t>
<t tx="T2362"># We set the current director to a path so future writes will go to that directory.

k = dict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path and len(path) &gt; 0:
	base = getBaseDirectory() # returns "" on error.
	path = os.path.join(base,path)
	if os.path.isabs(path):
		&lt;&lt; handle absolute path &gt;&gt;
	else:
		at.error("ignoring bad @path: " + path)
else:
	at.error("ignoring empty @path")</t>
<t tx="T2363">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = path.strip()</t>
<t tx="T2364"># path is an absolute path.

if os.path.exists(path):
	at.default_directory = path
else:
	at.default_directory = makeAllNonExistentDirectories(path)
	if not at.default_directory:
		at.error("invalid @path: " + path)</t>
<t tx="T2365"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					at.default_directory = dir ; break
				else:
					at.default_directory = makeAllNonExistentDirectories(dir)</t>
<t tx="T2366">def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	&lt;&lt; skip any non @+leo lines &gt;&gt;
	&lt;&lt; make sure we have @+leo &gt;&gt;
	&lt;&lt; read optional version param &gt;&gt;
	&lt;&lt; read optional encoding param &gt;&gt;
	&lt;&lt; set the closing comment delim &gt;&gt;
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	return firstLines, new_df</t>
<t tx="T2367">@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) &gt; 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n &gt; 0
# s contains the tag
i = j = skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i &lt; n and not match(s,i,tag) and not is_nl(s,i):
	i += 1
if j &lt; i:
	at.startSentinelComment = s[j:i]
else: valid = false</t>
<t tx="T2368">@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = skip_ws(s,i)

if match(s,i,tag):
	i += len(tag)
else: valid = false</t>
<t tx="T2369">new_df = match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] != '-':
		i += 1

	if j &lt; i:
		pass # version = s[j:i]
	else:
		valid = false
</t>
<t tx="T2370"># Set the default encoding
at.encoding = app.config.default_derived_file_encoding

if match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next comma
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] not in (',','.'):
		i += 1
	if match(s,i,',') or match(s,i,'.'):
		encoding = s[j:i]
		i += 1
		# print "@+leo-encoding=",encoding
		if isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			es("bad encoding in derived file:",encoding)
	else:
		valid = false
</t>
<t tx="T2371"># The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]</t>
<t tx="T2372">def readLine (self,file):

	"""Reads one line from file using the present encoding"""
	
	s = readlineForceUnixNewline(file)
	u = toUnicode(s,self.encoding)
	return u</t>
<t tx="T2373"></t>
<t tx="T2374">def rawWrite (self,v):
	
	at = self
	write_new = not app.config.write_old_format_derived_files
	df = choose(write_new,at.new_df,at.old_df)
	try: df.rawWrite(v)
	except: at.writeException(v)
	
def silentWrite (self,v):

	at = self # 9/26/03
	try: at.old_df.silentWrite(v) # No new_df.silentWrite method.
	except: at.writeException(v)
	
def write (self,v,nosentinels=false):
	
	at = self
	write_new = not app.config.write_old_format_derived_files
	df = choose(write_new,at.new_df,at.old_df)
	try: df.write(v,nosentinels)
	except: at.writeException(v)
		
def writeException(self,v):
	self.error("Unexpected exception while writing " + v.headString())
	es_exception()</t>
<t tx="T2375">def writeOldDerivedFiles (self):
	
	self.writeDerivedFiles(write_old=true)

def writeNewDerivedFiles (self):

	self.writeDerivedFiles(write_old=false)
	
def writeDerivedFiles (self,write_old):
	
	config = app.config
	old = config.write_old_format_derived_files
	config.write_old_format_derived_files = write_old
	self.writeAll(writeAtFileNodesFlag=true)
	config.write_old_format_derived_files = old</t>
<t tx="T2376">@others</t>
<t tx="T2377">def __init__(self,theCommander):

	self.commands = theCommander # The commander for the current window.
	self.fileCommands = self.commands.fileCommands

	self.initIvars()

def initIvars(self):

	&lt;&lt; init atFile ivars &gt;&gt;
</t>
<t tx="T2378"># errors is the number of errors seen while reading and writing.
self.errors = 0

# Initialized by atFile.scanAllDirectives.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = None
self.endSentinelComment = None
self.language = None

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c
self.shortFileName = "" # short version of file name used for messages.
self.targetFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFile = None # The temporary output file.

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing the at-node directive and restore the old value when the
expansion is complete.
@c
self.indent = 0  # The unit of indentation is spaces, not tabs.

# The root of tree being written.
self.root = None

# Ivars used to suppress newlines between sentinels.
self.suppress_newlines = true # true: enable suppression of newlines.
self.newline_pending = false # true: newline is pending on read or write.

# Support of output_newline option
self.output_newline = getOutputNewline()

# Support of @raw
self.raw = false # true: in @raw mode
self.sentinels = true # true: output sentinels while expanding refs.

# Enables tracing (debugging only).
self.trace = false

# The encoding used to convert from unicode to a byte stream.
self.encoding = app.config.default_derived_file_encoding

# For interface between 3.x and 4.x read code.
self.file = None
self.importing = false
self.importRootSeen = false</t>
<t tx="T2379"></t>
<t tx="T2380">def readOpenFile(self,root,file,firstLines):
	
	"""Read an open 3.x derived file."""
	
	at = self
	if at.trace: trace("old_df",root)

	# Scan the file buffer
	at.scanAllDirectives(root)
	lastLines = at.scanText(file,root,[],endLeo)
	root.t.setVisited() # Disable warning about set nodes.

	# Handle first and last lines.
	try: body = root.t.tempBodyString
	except: body = ""
	lines = body.split('\n')
	at.completeFirstDirectives(lines,firstLines)
	at.completeLastDirectives(lines,lastLines)
	s = '\n'.join(lines).replace('\r', '')
	root.t.tempBodyString = s</t>
<t tx="T2381"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

	tag = "@first"
	foundAtFirstYet = 0
	outRange = range(len(out))
	j = 0
	for k in outRange:
		# skip leading whitespace lines
		if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @first directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtFirstYet = 1
		# quit if no leading lines to apply
		if j &gt;= len(firstLines): break
		# make the new @first directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
		leadingLine = " " + firstLines[j]
		out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="T2382"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

	tag = "@last"
	foundAtLastYet = 0
	outRange = range(-1,-len(out),-1)
	j = -1
	for k in outRange:
		# skip trailing whitespace lines
		if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @last directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtLastYet = 1
		# quit if no trailing lines to apply
		if j &lt; -len(lastLines): break
		# make the new @last directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
		trailingLine = " " + lastLines[j]
		out[k] = tag + trailingLine.rstrip() ; j -= 1
</t>
<t tx="T2383">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild(self,n,parent,headline):

	at = self
	assert(n &gt; 0)
	
	if at.importing:
		return at.createImportedNode(at.root,at.commands,headline)

	# Create any needed dummy children.
	dummies = n - parent.numberOfChildren() - 1
	if dummies &gt; 0:
		if 0: # CVS produces to many errors for this to be useful.
			es("dummy created")
		self.errors += 1
	while dummies &gt; 0:
		dummies -= 1
		dummy = parent.insertAsLastChild(leoNodes.tnode())
		# The user should never see this headline.
		dummy.initHeadString("Dummy")

	if n &lt;= parent.numberOfChildren():
		&lt;&lt; check the headlines &gt;&gt;
	else:
		# This is using a dummy; we should already have bumped errors.
		result = parent.insertAsLastChild(leoNodes.tnode())
	result.initHeadString(headline)
	
	result.setVisited() # Suppress all other errors for this node.
	result.t.setVisited() # Suppress warnings about unvisited nodes.
	return result</t>
<t tx="T2384"># 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
	start = self.startSentinelComment
	end = self.endSentinelComment
	if end and len(end) &gt; 0:
		# 1/25/03: The kludgy fix.
		# Compare the headlines without the delims.
		h1 =   headline.replace(start,"").replace(end,"")
		h2 = resulthead.replace(start,"").replace(end,"")
		if h1.strip() == h2.strip():
			# 1/25/03: Another kludge: use the headline from the outline, not the derived file.
			headline = resulthead
		else:
			self.errors += 1
	else:
		self.errors += 1
</t>
<t tx="T2385">def handleLinesFollowingSentinel (self,lines,sentinel,comments = true):
	
	"""convert lines following a sentinel to a single line"""
	
	m = " following" + sentinel + " sentinel"
	start = self.startSentinelComment
	end   = self.endSentinelComment
	
	if len(lines) == 1: # The expected case.
		s = lines[0]
	elif len(lines) == 5:
		self.readError("potential cvs conflict" + m)
		s = lines[1]
		es("using " + s)
	else:
		self.readError("unexpected lines" + m)
		es(len(lines), " lines" + m)
		s = "bad " + sentinel
		if comments: s = start + ' ' + s

	if comments:
		&lt;&lt; remove the comment delims from s &gt;&gt;
		
	# Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
	if start[-1:] == '@':
		s = s.replace('@@','@')

	return s</t>
<t tx="T2386"># Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if match(s,0,comment):
	s = s[len(comment):]
else:
	self.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
	s = string.strip(s[:-1])
else:
	k = s.rfind(end)
	s = string.strip(s[:k]) # works even if k == -1</t>
<t tx="T2387">def readLine (self,file):
	"""Reads one line from file using the present encoding"""
	
	s = readlineForceUnixNewline(file)
	u = toUnicode(s,self.encoding)
	return u

</t>
<t tx="T2388"># We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,file):
	
	"""	read lines following multiline sentinels"""
	
	lines = []
	start = self.startSentinelComment + '@ '
	nextLine = self.readLine(file)
	while nextLine and len(nextLine) &gt; 0:
		if len(lines) == 0:
			lines.append(nextLine)
			nextLine = self.readLine(file)
		else:
			# 5/1/03: looser test then calling sentinelKind.
			s = nextLine ; i = skip_ws(s,0)
			if match(s,i,start):
				lines.append(nextLine)
				nextLine = self.readLine(file)
			else: break

	return nextLine,lines</t>
<t tx="T2389"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc(self,file,s,i,out,kind):

	endKind = choose(kind ==startDoc,endDoc,endAt)
	single = len(self.endSentinelComment) == 0
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	nextLine = None ; kind = noSentinel
	while len(s) &gt; 0:
		&lt;&lt; set kind, nextLine &gt;&gt;
		if kind == endKind: break
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to out &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = self.readLine(file)
	if kind != endKind:
		self.readError("Missing " + self.sentinelName(endKind) + " sentinel")
	&lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="T2390">assert(match(s,i,choose(kind == startDoc, "+doc", "+at")))

out.append(choose(kind == startDoc, "@doc", "@"))
s = self.readLine(file)
</t>
<t tx="T2391">if not single:
	j = skip_ws(s,0)
	if match(s,j,self.startSentinelComment):
		s = self.readLine(file)</t>
<t tx="T2392">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == noSentinel:
	j = skip_ws(s,0)
	blankLine = s[j] == '\n'
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
	if blankLine and nextKind == endKind:
		kind = endKind # stop the scan now
</t>
<t tx="T2393"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment):
		i += len(self.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = self.skipIndent(s,0, self.indent)
</t>
<t tx="T2394"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
	# no trailing whitespace: the newline is real.
	out.append(line + '\n')
else:
	# trailing whitespace: the newline is not real.
	out.append(line)
</t>
<t tx="T2395"># This code will typically only be executed for HTML files.

if not single:

	delim = self.endSentinelComment
	n = len(delim)
	
	# Remove delim and possible a leading newline.
	s = string.join(out,"")
	s = s.rstrip()
	if s[-n:] == delim:
		s = s[:-n]
	if s[-1] == '\n':
		s = s[:-1]
		
	# Rewrite out in place.
	del out[:]
	out.append(s)
</t>
<t tx="T2396">def scanText (self,file,v,out,endSentinelKind,nextLine=None):
	
	"""Scan a 3.x derived file recursively."""

	lastLines = [] # The lines after @-leo
	lineIndent = 0 ; linep = 0 # Changed only for sentinels.
	while 1:
		&lt;&lt; put the next line into s &gt;&gt;
		&lt;&lt; set kind, nextKind &gt;&gt;
		if kind != noSentinel:
			&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
			i = self.skipSentinelStart(s,0)
		&lt;&lt; handle the line in s &gt;&gt;
	&lt;&lt; handle unexpected end of text &gt;&gt;
	assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
	return lastLines # We get here only if there are problems.</t>
<t tx="T2397">if nextLine:
	s = nextLine ; nextLine = None
else:
	s = self.readLine(file)
	if len(s) == 0: break</t>
<t tx="T2398">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == noSentinel:
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
else:
	nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText returns.</t>
<t tx="T2399">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if self.raw: # 10/15/02
	linep =0
else:
	linep = self.skipIndent(s,0,self.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': lineIndent += (abs(self.tab_width) - (lineIndent % abs(self.tab_width)))
	elif s[i] == ' ': lineIndent += 1
	else: break
	i += 1
# trace("lineIndent:" +`lineIndent` + ", " + `s`)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="T2400"># Issue the error.
name = self.sentinelName(endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T2401">if kind == noSentinel:
	&lt;&lt; append non-sentinel line &gt;&gt;
&lt;&lt; handle common sentinels &gt;&gt;
&lt;&lt; handle rare sentinels &gt;&gt;
else:
	&lt;&lt; warn about unknown sentinel &gt;&gt;</t>
<t tx="T2402"># We don't output the trailing newline if the next line is a sentinel.
if self.raw: # 10/15/02
	i = 0
else:
	i = self.skipIndent(s,0,self.indent)

assert(nextLine != None)

if nextKind == noSentinel:
	line = s[i:]
	out.append(line)
else:
	line = s[i:-1] # don't output the newline
	out.append(line)
</t>
<t tx="T2403">elif kind in (endAt, endBody,endDoc,endLeo,endNode,endOthers):
		&lt;&lt; handle an ending sentinel &gt;&gt;
elif kind == startBody:
	&lt;&lt; scan @+body &gt;&gt;
elif kind == startNode:
	&lt;&lt; scan @+node &gt;&gt;
elif kind == startRef:
	&lt;&lt; scan old ref &gt;&gt;
elif kind == startAt:
	&lt;&lt; scan @+at &gt;&gt;
elif kind == startDoc:
	&lt;&lt; scan @+doc &gt;&gt;
elif kind == startOthers:
	&lt;&lt; scan @+others &gt;&gt;</t>
<t tx="T2404"># trace("end sentinel:", self.sentinelName(kind))

if kind == endSentinelKind:
	if kind == endLeo:
		# Ignore everything after @-leo.
		# Such lines were presumably written by @last.
		while 1:
			s = self.readLine(file)
			if len(s) == 0: break
			lastLines.append(s) # Capture all trailing lines, even if empty.
	elif kind == endBody:
		self.raw = false
	# nextLine != None only if we have a non-sentinel line.
	# Therefore, nextLine == None whenever scanText returns.
	assert(nextLine==None)
	return lastLines # End the call to scanText.
else:
	# Tell of the structure error.
	name = self.sentinelName(kind)
	expect = self.sentinelName(endSentinelKind)
	self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="T2405">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(s,i,"&lt;&lt;"))

if len(self.endSentinelComment) == 0:
	line = s[i:-1] # No trailing newline
else:
	k = s.find(self.endSentinelComment,i)
	line = s[i:k] # No trailing newline, whatever k is.
		
# 10/30/02: undo cweb hack here
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	line = line.replace('@@','@')

out.append(line)</t>
<t tx="T2406">assert(match(s,i,"+at"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T2407">assert(match(s,i,"+doc"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T2408">assert(match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = ""
&lt;&lt; Set headline and ref &gt;&gt;

# print childIndex,headline

if childIndex == 0: # The root node.
	&lt;&lt; Check the filename in the sentinel &gt;&gt;
	# Put the text of the root node in the current node.
	self.scanText(file,v,out,endNode)
	v.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
else:
	# NB: this call to createNthChild is the bottleneck!
	child = self.createNthChild(childIndex,v,headline)
	child.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
	self.scanText(file,child,out,endNode)

&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</t>
<t tx="T2409">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i:
	self.readError("Implicit child index in @+node")
	childIndex = 0
else:
	childIndex = int(s[j:i])

if match(s,i,':'):
	i += 1 # Skip the ":".
else:
	self.readError("Bad child index in @+node")</t>
<t tx="T2410">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T2411"># Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(self.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	# 10/24/02: search from the right, not the left.
	k = s.rfind(self.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1
	
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if self.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')

# Set reference if it exists.
i = skip_ws(s,i)

if 0: # no longer used
	if match(s,i,"&lt;&lt;"):
		k = s.find("&gt;&gt;",i)
		if k != -1: ref = s[i:k+2]</t>
<t tx="T2412">h = headline.strip()

if h[:5] == "@file":
	i,junk,junk = scanAtFileOptions(h)
	fileName = string.strip(h[i:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
	fileName = string.strip(h[8:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")
</t>
<t tx="T2413">s = self.readLine(file)
kind = self.sentinelKind(s)

if len(s) &gt; 1 and kind == startVerbatimAfterRef:
	s = self.readLine(file)
	# trace("verbatim:"+`s`)
	out.append(s)
elif len(s) &gt; 1 and self.sentinelKind(s) == noSentinel:
	out.append(s)
else:
	nextLine = s # Handle the sentinel or blank line later.
</t>
<t tx="T2414">assert(match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

self.scanText(file,v,out,endOthers)</t>
<t tx="T2415">elif kind == startComment:
	&lt;&lt; scan @comment &gt;&gt;
elif kind == startDelims:
	&lt;&lt; scan @delims &gt;&gt;
elif kind == startDirective:
	&lt;&lt; scan @@ &gt;&gt;
elif kind == startLeo:
	&lt;&lt; scan @+leo &gt;&gt;
elif kind == startVerbatim:
	&lt;&lt; scan @verbatim &gt;&gt;</t>
<t tx="T2416">assert(match(s,i,"+leo"))
self.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T2417"># The first '@' has already been eaten.
assert(match(s,i,"@"))

if match_word(s,i,"@raw"):
	self.raw = true
elif match_word(s,i,"@end_raw"):
	self.raw = false

e = self.endSentinelComment
s2 = s[i:]
if len(e) &gt; 0:
	k = s.rfind(e,i)
	if k != -1:
		s2 = s[i:k] + '\n'
	
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	s2 = s2.replace('@@','@')
out.append(s2)
# trace(`s2`)</t>
<t tx="T2418">assert(match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
</t>
<t tx="T2419">assert(match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = skip_ws(s,i-1+7)
	
# Get the first delim.
j = i
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1

if j &lt; i:
	self.startSentinelComment = s[j:i]
	# print "delim1:", self.startSentinelComment

	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	end = choose(j&lt;i,s[j:i],"")
	i2 = skip_ws(s,i)
	if end == self.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
		self.endSentinelComment = "" # Not really two params.
		line = s[i0:j]
		line = line.rstrip()
		out.append(line+'\n')
	else:
		self.endSentinelComment = end
		# print "delim2:",end
		line = s[i0:i]
		line = line.rstrip()
		out.append(line+'\n')
else:
	self.readError("Bad @delims")
	# Append the bad @delims line to the body text.
	out.append("@delims")</t>
<t tx="T2420">assert(match(s,i,"verbatim"))

# Skip the sentinel.
s = self.readLine(file) 

# Append the next line to the text.
i = self.skipIndent(s,0,self.indent)
out.append(s[i:])
</t>
<t tx="T2421">j = i
i = skip_line(s,i)
line = s[j:i]
self.readError("Unknown sentinel: " + line)</t>
<t tx="T2422"></t>
<t tx="T2423"># 4/5/03: config.write_clone_indices no longer used.

def nodeSentinelText(self,v):
	
	if v == self.root or not v.parent():
		index = 0
	else:
		index = v.childIndex() + 1

	h = v.headString()
	&lt;&lt; remove comment delims from h if necessary &gt;&gt;

	return str(index) + '::' + h</t>
<t tx="T2424">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = self.startSentinelComment
end = self.endSentinelComment

if end and len(end) &gt; 0:
	h = h.replace(start,"")
	h = h.replace(end,"")</t>
<t tx="T2425">def putCloseNodeSentinel(self,v):

	s = self.nodeSentinelText(v)
	self.putSentinel("@-node:" + s)</t>
<t tx="T2426">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c
def putCloseSentinels(self,root,v):

	self.putCloseNodeSentinel(v)
	while 1:
		v = v.parent()
		assert(v) # root must be an ancestor of v.
		if  v == root: break
		self.putCloseNodeSentinel(v)</t>
<t tx="T2427">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c
def putOpenLeoSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.os(self.startSentinelComment)
	self.os(s)
	encoding = self.encoding.lower()
	if encoding != "utf-8":
		self.os("-encoding=")
		self.os(encoding)
		self.os(".")
	self.os(self.endSentinelComment)
	if self.suppress_newlines: # 9/27/02
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.
</t>
<t tx="T2428">@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):

	if v.isAtFileNode() and v != self.root:
		self.writeError("@file not valid in: " + v.headString())
		return
	
	s = self.nodeSentinelText(v)
	self.putSentinel("@+node:" + s)</t>
<t tx="T2429">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c
def putOpenSentinels(self,root,v):

	last = root
	while last != v:
		# Set node to v or the ancestor of v that is a child of last.
		node = v
		while node and node.parent() != last:
			node = node.parent()
		assert(node)
		self.putOpenNodeSentinel(node)
		last = node</t>
<t tx="T2430">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c
def putSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.newline_pending = false # discard any pending newline.
	self.onl() ; self.putIndent(self.indent) # Start of sentinel.
	self.os(self.startSentinelComment)

	# 11/1/02: The cweb hack: if the opening comment delim ends in '@',
	# double all '@' signs except the first, which is "doubled" by the
	# trailing '@' in the opening comment delimiter.
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		assert(s and len(s)&gt;0 and s[0]=='@')
		s = s.replace('@','@@')[1:]

	self.os(s)
	self.os(self.endSentinelComment)
	if self.suppress_newlines:
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.</t>
<t tx="T2431">@ This method tells what kind of sentinel appears in line s.  Typically s will be an empty line before the actual sentinel, but it is also valid for s to be an actual sentinel line.

Returns (kind, s, emptyFlag), where emptyFlag is true if kind == noSentinel and s was an empty line on entry.
@c

def sentinelKind(self,s):

	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment): 
		i += len(self.startSentinelComment)
	else:
		return noSentinel

	# 10/30/02: locally undo cweb hack here
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s = s[:i] + string.replace(s[i:],'@@','@')

	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return startRef
	if match(s,i,"@@"):   return startDirective
	if not match(s,i,'@'): return noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	key = s[j:i]
	if len(key) &gt; 0 and sentinelDict.has_key(key):
		# trace("found:",key)
		return sentinelDict[key]
	else:
		# trace("not found:",key)
		return noSentinel</t>
<t tx="T2432"># Returns the name of the sentinel for warnings.

def sentinelName(self, kind):

	sentinelNameDict = {
		noSentinel:  "&lt;no sentinel&gt;",
		startAt:     "@+at",     endAt:     "@-at",
		startBody:   "@+body",   endBody:   "@-body", # 3.x only.
		startDoc:    "@+doc",    endDoc:    "@-doc",
		startLeo:    "@+leo",    endLeo:    "@-leo",
		startNode:   "@+node",   endNode:   "@-node",
		startOthers: "@+others", endOthers: "@-others",
		startAfterRef:  "@afterref", # 4.x
		startComment:   "@comment",
		startDelims:    "@delims",
		startDirective: "@@",
		startNl:        "@nl",   # 4.x
		startNonl:      "@nonl", # 4.x
		startRef:       "@&lt;&lt;",
		startVerbatim:  "@verbatim",
		startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

	return sentinelNameDict.get(kind,"&lt;unknown sentinel!&gt;")</t>
<t tx="T2433">def skipSentinelStart(self,s,i):

	start = self.startSentinelComment
	assert(start and len(start)&gt;0)

	if is_nl(s,i): i = skip_nl(s,i)
	i = skip_ws(s,i)
	assert(match(s,i,start))
	i += len(start)
	# 7/8/02: Support for REM hack
	i = skip_ws(s,i)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1
</t>
<t tx="T2434"></t>
<t tx="T2435"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	n = len(s)
	if i &gt;= n or s[i] != '@':
		return noDirective

	table = (
		("@c",cDirective),
		("@code",codeDirective),
		("@doc",docDirective),
		("@end_raw",endRawDirective),
		("@others",othersDirective),
		("@raw",rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return choose(self.language=="cweb",
			noDirective,atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if self.language=="cweb" and (
		match_word(s,i,"@c") or
		i+1&gt;= n or s[i+1] not in string.ascii_letters):
		return noDirective

	for name,directive in table:
		if match_word(s,i,name):
			return directive
	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if match_word(s,i,name):
			return miscDirective

	return noDirective</t>
<t tx="T2436">def error(self,message):

	es_error(message)
	self.errors += 1
</t>
<t tx="T2437">def readError(self,message):

	# This is useful now that we don't print the actual messages.
	if self.errors == 0:
		es_error("----- error reading @file " + self.targetFileName)
		self.error(message) # 9/10/02: we must increment self.errors!
		
	print message

	if 0: # CVS conflicts create too many messages.
		self.error(message)
	
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T2438">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	&lt;&lt; Set ivars &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="T2439">self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app.config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="T2440"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) &gt; 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
</t>
<t tx="T2441"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T2442">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e</t>
<t tx="T2443"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")</t>
<t tx="T2444">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
</t>
<t tx="T2445"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			&lt;&lt; handle absolute path &gt;&gt;
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="T2446">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(app.loadDir,path)</t>
<t tx="T2447"># path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
</t>
<t tx="T2448">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w &gt; 0:
		self.page_width = w</t>
<t tx="T2449">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

</t>
<t tx="T2450"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""</t>
<t tx="T2451"># Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""</t>
<t tx="T2452"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

	ws = 0 ; n = len(s)
	while i &lt; n and ws &lt; width:
		if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
		elif s[i] == ' ':  ws += 1
		else: break
		i += 1
	return i</t>
<t tx="T2453">def writeError(self,message):

	if self.errors == 0:
		es_error("errors writing: " + self.targetFileName)

	self.error(message)
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T2454"></t>
<t tx="T2455"></t>
<t tx="T2456">def rawWrite(self,root):

	if self.trace: trace("old_df",root)
	
	c = self.commands ; self.root = root
	self.errors = 0
	self.sentinels = true # 10/1/03
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atRawFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		&lt;&lt; write root's tree &gt;&gt;
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)
</t>
<t tx="T2457">&lt;&lt; put all @first lines in root &gt;&gt;
self.putOpenLeoSentinel("@+leo")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

v = root
while v and v != next:
	&lt;&lt; Write v's node &gt;&gt;
	v = v.threadNext()

self.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T2458">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.putBuffered(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T2459">s2 = app.config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)&gt; 0:
			self.putSentinel("@comment " + line)
</t>
<t tx="T2460">self.putOpenNodeSentinel(v)
	
s = v.bodyString()
if s and len(s) &gt; 0:
	self.putSentinel("@+body")
	if self.newline_pending:
		self.newline_pending = false
		self.onl()
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)
	self.putSentinel("@-body")
	
self.putCloseNodeSentinel(v)
</t>
<t tx="T2461">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="T2462">def silentWrite(self,root):

	if self.trace: trace("old_df",root)

	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atSilentFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		v = root
		while v and v != next:
			&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;
			&lt;&lt; Write v's body &gt;&gt;
			v = v.threadNext()
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T2463">s = v.headString()
if match(s,0,"@@"):
	s = s[2:]
	if s and len(s) &gt; 0:
		s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
		self.outputFile.write(s)
</t>
<t tx="T2464">s = v.bodyString()
if s and len(s) &gt; 0:
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)</t>
<t tx="T2465"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false):
	
	if self.trace: trace("old_df",root)
	
	# Remove any old tnodeList.
	if hasattr(root,"tnodeList"):
		if self.trace: trace("removing tnodeList for " + `root`)
		delattr(root,"tnodeList")

	c = self.commands
	self.sentinels = not nosentinels
	&lt;&lt; initialize &gt;&gt;
	try:
		&lt;&lt; open the file; return on error &gt;&gt;
		root.clearVisitedInTree()
		&lt;&lt; write then entire @file tree &gt;&gt;
		self.closeWriteFile()
		&lt;&lt; warn about @ignored and orphans &gt;&gt;
		&lt;&lt; finish writing &gt;&gt;
	except:
		self.handleWriteException()
</t>
<t tx="T2466">self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
self.raw = false
c.endEditing() # Capture the current headline.</t>
<t tx="T2467">if nosentinels:
	self.targetFileName = root.atNoSentinelsFileNodeName()
else:
	self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root)
if not ok: return</t>
<t tx="T2468">next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="T2469">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="T2470"># 10/26/02: Always warn, even when language=="cweb"

next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		self.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		self.writeError("@ignore node: " + v.headString())
	v = v.threadNext()
</t>
<t tx="T2471">@ We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(self.outputFileName) # Delete the temp file.
	es("Not written: " + self.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	self.replaceTargetFileIfDifferent()</t>
<t tx="T2472"></t>
<t tx="T2473">def closeWriteFile (self):
	
	if self.outputFile:
		if self.suppress_newlines and self.newline_pending:
			self.newline_pending = false
			self.onl() # Make sure file ends with a newline.
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
</t>
<t tx="T2474">def handleWriteException (self,root=None):
	
	es("exception writing:" + self.targetFileName,color="red")
	es_exception()
	
	if self.outputFile:
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
	
	if self.outputFileName != None:
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName,color="red")
			es_exception()

	if root:
		# Make sure we try to rewrite this file.
		root.setOrphan()
		root.setDirty()</t>
<t tx="T2475"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root):

	try:
		self.scanAllDirectives(root)
		valid = self.errors == 0
	except:
		self.writeError("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false

	if valid:
		try:
			fn = self.targetFileName
			self.shortFileName = fn # name to use in status messages.
			self.targetFileName = os.path.join(self.default_directory,fn)
			self.targetFileName = os.path.normpath(self.targetFileName)
			path = os.path.dirname(self.targetFileName)
			if not path or not os.path.exists(path):
				self.writeError("path does not exist: " + path)
				valid = false
		except:
			self.writeError("exception creating path:" + fn)
			es_exception()
			valid = false

	if valid and os.path.exists(self.targetFileName):
		try:
			if not os.access(self.targetFileName,os.W_OK):
				self.writeError("read only: " + self.targetFileName)
				valid = false
		except:
			pass # os.access() may not exist on all platforms.
		
	if valid:
		try:
			self.outputFileName = self.targetFileName + ".tmp"
			self.outputFile = open(self.outputFileName,'wb')
			if self.outputFile is None:
				self.writeError("can not open " + self.outputFileName)
				valid = false
		except:
			es("exception opening:" + self.outputFileName)
			es_exception()
			valid = false
	
	if not valid:
		root.setOrphan()
		root.setDirty()
	
	return valid</t>
<t tx="T2476">def putInitialComment (self):
	
	s2 = app.config.output_initial_comment
	if s2:
		lines = string.split(s2,"\\n")
		for line in lines:
			line = line.replace("@date",time.asctime())
			if len(line)&gt; 0:
				self.putSentinel("@comment " + line)</t>
<t tx="T2477">def replaceTargetFileIfDifferent (self):
	
	assert(self.outputFile == None)
	
	if os.path.exists(self.targetFileName):
		if filecmp.cmp(self.outputFileName,self.targetFileName):
			&lt;&lt; delete the output file &gt;&gt;
		else:
			&lt;&lt; replace the target file with the output file &gt;&gt;
	else:
		&lt;&lt; rename the output file to be the target file &gt;&gt;
</t>
<t tx="T2478">try: # Just delete the temp file.
	os.remove(self.outputFileName)
except:
	es("exception deleting:" + self.outputFileName)
	es_exception()

es("unchanged: " + self.shortFileName)</t>
<t tx="T2479">try:
	# 10/6/02: retain the access mode of the previous file,
	# removing any setuid, setgid, and sticky bits.
	mode = (os.stat(self.targetFileName))[0] &amp; 0777
except:
	mode = None

try: # Replace target file with temp file.
	os.remove(self.targetFileName)
	try:
		utils_rename(self.outputFileName,self.targetFileName)
		if mode != None: # 10/3/02: retain the access mode of the previous file.
			try:
				os.chmod(self.targetFileName,mode)
			except:
				es("exception in os.chmod(%s)" % (self.targetFileName))
		es("writing: " + self.shortFileName)
	except:
		# 6/28/03
		self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
		es_exception()
except:
	self.writeError("exception removing:" + self.targetFileName)
	es_exception()
	try: # Delete the temp file when the deleting the target file fails.
		os.remove(self.outputFileName)
	except:
		es("exception deleting:" + self.outputFileName)
		es_exception()</t>
<t tx="T2480">try:
	utils_rename(self.outputFileName,self.targetFileName)
	es("creating: " + self.targetFileName)
except:
	self.writeError("exception renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	es_exception()</t>
<t tx="T2481"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

	# Calling self.onl() runs afoul of queued newlines.
	self.os(s.replace('\n',self.output_newline))</t>
<t tx="T2482">def putBodyPart(self,v):
	
	""" Generate the body enclosed in sentinel lines."""

	s = v.t.bodyString
	i = skip_ws_and_nl(s, 0)
	if i &gt;= len(s): return

	s = removeTrailingWs(s) # don't use string.rstrip!
	self.putSentinel("@+body")
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	self.putSentinel("@-body")</t>
<t tx="T2483">i = 0 ; n = len(s)
firstLastHack = 1

if firstLastHack:
	&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
while i &lt; n:
	kind = self.directiveKind(s,i)
	if firstLastHack:
		&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
	j = i
	if kind == docDirective or kind == atDirective:
		i = self.putDoc(s,i,kind)
	elif ( # 10/16/02
		kind == miscDirective or
		kind == rawDirective or
		kind == endRawDirective ):
		if firstLastHack:
			&lt;&lt; handle misc directives &gt;&gt;
		else:
			i = self.putDirective(s,i)
	elif kind == noDirective or kind == othersDirective:
		i = self.putCodePart(s,i,v)
	elif kind == cDirective or kind == codeDirective:
		i = self.putDirective(s,i)
		i = self.putCodePart(s,i,v)
	else: assert(false) # We must handle everything that directiveKind returns
	assert(n == len(s))
	assert(j &lt; i) # We must make progress.

if firstLastHack:
	&lt;&lt; put out the last directives, if any &gt;&gt;</t>
<t tx="T2484"># 14-SEP-2002 DTHEIN: If this is the root node, then handle all @first directives here
lookingForLast = 0
lookingForFirst = 0
initialLastDirective = -1
lastDirectiveCount = 0
if (v == self.root):
	lookingForLast = 1
	lookingForFirst = 1</t>
<t tx="T2485"># 14-SEP-2002 DTHEIN: If first directive isn't @first, then stop looking for @first
if lookingForFirst:
	if kind != miscDirective:
		lookingForFirst = 0
	elif not match_word(s,i,"@first"):
		lookingForFirst = 0

if lookingForLast:
	if initialLastDirective == -1:
		if (kind == miscDirective) and match_word(s,i,"@last"):
			# mark the point where the last directive was found
			initialLastDirective = i
	else:
		if (kind != miscDirective) or (not match_word(s,i,"@last")):
			# found something after @last, so process the @last directives
			# in 'ignore them' mode
			i, initialLastDirective = initialLastDirective, -1
			lastDirectiveCount = 0
			kind = self.directiveKind(s,i)</t>
<t tx="T2486">if lookingForFirst: # DTHEIN: can only be true if it is @first directive
	i = self.putEmptyDirective(s,i)
elif (initialLastDirective != -1) and match_word(s,i,"@last"):
	# DTHEIN: can only be here if lookingForLast is true
	# skip the last directive ... we'll output it at the end if it
	# is truly 'last'
	lastDirectiveCount += 1
	i = skip_line(s,i)
else:
	i = self.putDirective(s,i)</t>
<t tx="T2487"># 14-SEP-2002 DTHEIN
if initialLastDirective != -1:
	d = initialLastDirective
	for k in range(lastDirectiveCount):
		d = self.putEmptyDirective(s,d)</t>
<t tx="T2488">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c
def putDoc(self,s,i,kind):

	if kind == atDirective:
		i += 1 ; tag = "at"
	elif kind == docDirective:
		i += 4 ; tag = "doc"
	else: assert(false)
	# Set j to the end of the doc part.
	n = len(s) ; j = i
	while j &lt; n:
		j = skip_line(s, j)
		kind = self.directiveKind(s, j)
		if kind == codeDirective or kind == cDirective:
			break
	self.putSentinel("@+" + tag)
	self.putDocPart(s[i:j])
	self.putSentinel("@-" + tag)
	return j</t>
<t tx="T2489"># Puts a comment part in comments.
# Note: this routine is _never_ called in cweb mode,
# so noweb section references are _valid_ in cweb doc parts!

def putDocPart(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	single = len(self.endSentinelComment) == 0
	if not single:
		self.putIndent(self.indent)
		self.os(self.startSentinelComment) ; self.onl()
	# Put all lines.
	i = 0 ; n = len(s)
	while i &lt; n:
		self.putIndent(self.indent)
		leading = self.indent
		if single:
			self.os(self.startSentinelComment) ; self.oblank()
			leading += len(self.startSentinelComment) + 1
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	if not single:
		# This comment is like a sentinel.
		self.onl() ; self.putIndent(self.indent)
		self.os(self.endSentinelComment)
		self.onl() # Note: no trailing whitespace.</t>
<t tx="T2490">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

line = i # Start of the current line.
while i &lt; n:
	word = i # Start of the current word.
	# Skip the next word and trailing whitespace.
	i = skip_ws(s, i)
	while i &lt; n and not is_nl(s,i) and not is_ws(s[i]):
		i += 1
	i = skip_ws(s,i)
	# Output the line if no more is left.
	if i &lt; n and is_nl(s,i):
		break
	# Split the line before the current word if needed.
	lineLen = i - line
	if line == word or leading + lineLen &lt; self.page_width:
		word = i # Advance to the next word.
	else:
		# Write the line before the current word and insert a newline.
		theLine = s[line:word]
		self.os(theLine)
		self.onl() # This line must contain trailing whitespace.
		line = i = word  # Put word on the next line.
		break
# Remove trailing whitespace and output the remainder of the line.
theLine = string.rstrip(s[line:i]) # from right.
self.os(theLine)
if i &lt; n and is_nl(s,i):
	i = skip_nl(s,i)
	self.onl() # No inserted newline and no trailing whitespace.</t>
<t tx="T2491">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c
def putCodePart(self,s,i,v):

	atOthersSeen = false # true: at-others has been expanded.
	while i &lt; len(s):
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;

	# Raw code parts can only end at the end of body text.
	self.raw = false
	return i</t>
<t tx="T2492">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

leading_nl = (s[i] == body_newline) # 9/27/02: look ahead before outputting newline.
if leading_nl:
	i = skip_nl(s,i)
	self.onl() # 10/15/02: simpler to do it here.

#leading_ws1 = i # 1/27/03
j,delta = skip_leading_ws_with_indent(s,i,self.tab_width)
#leading_ws2 = j # 1/27/03
kind1 = self.directiveKind(s,i)
kind2 = self.directiveKind(s,j)
if self.raw:
	if kind1 == endRawDirective:
		&lt;&lt; handle @end_raw &gt;&gt;
else:
	if kind1 == othersDirective or kind2 == othersDirective:
		&lt;&lt; handle @others &gt;&gt;
	elif kind1 == rawDirective:
		&lt;&lt; handle @raw &gt;&gt;
	elif kind1 == noDirective:
		&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
	else:
		break # all other directives terminate the code part.</t>
<t tx="T2493"># This skips all indent and delta whitespace, so putAtOthers must generate it all.

if 0: # 9/27/02: eliminates the newline preceeding the @+others sentinel.
	# This does not seem to be a good idea.
	i = skip_line(s,i) 
else:
	i = skip_to_end_of_line(s,i)

if atOthersSeen:
	self.writeError("@others already expanded in: " + v.headString())
else:
	atOthersSeen = true
	self.putAtOthers(v, delta)
	
	# 12/8/02: Skip the newline _after_ the @others.
	if not self.sentinels and is_nl(s,i):
		i = skip_nl(s,i)
</t>
<t tx="T2494">self.raw = true
self.putSentinel("@@raw")
i = skip_line(s,i)</t>
<t tx="T2495">self.raw = false
self.putSentinel("@@end_raw")
i = skip_line(s,i)</t>
<t tx="T2496">if match (s,i,self.startSentinelComment + '@'):
	self.putSentinel("@verbatim") # Bug fix (!!): 9/20/03</t>
<t tx="T2497">if not self.raw:
	# 12/8/02: Don't write trailing indentation if not writing sentinels.
	if self.sentinels or j &lt; len(s):
		self.putIndent(self.indent)

newlineSeen = false
# 12/8/02: we buffer characters here for two reasons:
# 1) to make traces easier to read and 2) to increase speed.
buf = i # Indicate the start of buffered characters.
while i &lt; len(s) and not newlineSeen:
	ch = s[i]
	if ch == body_newline:
		break
	elif ch == body_ignored_newline:
		i += 1
	elif ch == '&lt;' and not self.raw:
		&lt;&lt; put possible section reference &gt;&gt;
	else:
		i += 1
# Output any buffered characters.
self.putBuffered(s[buf:i])</t>
<t tx="T2498">isSection, j = self.isSectionName(s, i)

if isSection:
	# Output the buffered characters and clear the buffer.
	s2 = s[buf:i] ; buf = i
	# 7/9/03: don't output trailing indentation if we aren't generating sentinels.
	if not self.sentinels:
		while len(s2) and s2[-1] in (' ','\t'):
			s2 = s2[:-1]
	self.putBuffered(s2)
	# Output the expansion.
	name = s[i:j]
	j,newlineSeen = self.putRef(name,v,s,j,delta)
	assert(j &gt; i) # isSectionName must have made progress
	i = j ; buf = i
else:
	# This is _not_ an error.
	i += 1</t>
<t tx="T2499">@ Returns true if v should be included in the expansion of the at-others directive in the body text of v's parent.

7/30/02: v will not be included if it is a definition node or if its body text contains an @ignore directive. Previously, a "nested" @others directive would also inhibit the inclusion of v.
@c
def inAtOthers(self,v):

	# Return false if this has been expanded previously.
	if  v.isVisited(): return false
	# Return false if this is a definition node.
	h = v.headString()
	i = skip_ws(h,0)
	isSection, j = self.isSectionName(h,i)
	if isSection: return false
	# Return false if v's body contains an @ignore or at-others directive.
	if 1: # 7/29/02: New code.  Amazingly, this appears to work!
		return not v.isAtIgnoreNode()
	else: # old &amp; reliable code
		return not v.isAtIgnoreNode() and not v.isAtOthersNode()</t>
<t tx="T2500"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

	if not match(s,i,"&lt;&lt;"):
		return false, -1
	i = find_on_line(s,i,"&gt;&gt;")
	if i:
		return true, i + 2
	else:
		return false, -1</t>
<t tx="T2501">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c
def putAtOthers(self,v,delta):

	self.indent += delta
	self.putSentinel("@+others")

	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putSentinel("@-others")
	self.indent -= delta</t>
<t tx="T2502">def putAtOthersChild(self,v):
	
	# trace("%d %s" % (self.indent,`v`))
	self.putOpenNodeSentinel(v)
	
	# Insert the expansion of v.
	v.setVisited() # Make sure it is never expanded again.
	self.putBodyPart(v)

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putCloseNodeSentinel(v)
</t>
<t tx="T2503">def putRef (self,name,v,s,i,delta):

	newlineSeen = false
	ref = findReference(name, v)
	if not ref:
		self.writeError("undefined section: " + name +
			"\n\treferenced from: " + v.headString())
		return i,newlineSeen

	# trace(self.indent,delta,s[i:])
	&lt;&lt; Generate the expansion of the reference &gt;&gt;

	# The newlineSeen allows the caller to break out of the loop.
	return i,newlineSeen</t>
<t tx="T2504"># Adjust indent here so sentinel looks better.
self.indent += delta

self.putSentinel("@" + name)
self.putOpenSentinels(v,ref)
self.putBodyPart(ref)
self.putCloseSentinels(v,ref)
&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;

self.indent -= delta
ref.setVisited()</t>
<t tx="T2505">j = skip_ws(s,i)
if j &lt; len(s) and match(s,j,self.startSentinelComment + '@'):
	self.putSentinel("@verbatimAfterRef")
	# 9/27/02: Put the line immediately, before the @-node sentinel.
	k = skip_to_end_of_line(s,i)
	self.putBuffered(s[i:k])
	i = k ; newlineSeen = false</t>
<t tx="T2506"></t>
<t tx="T2507">def putBuffered (self,s):
	
	"""Put s, converting all tabs to blanks as necessary."""
	
	if s:
		w = self.tab_width
		if w &lt; 0:
			lines = s.split('\n')
			for i in xrange(len(lines)):
				line = lines[i]
				line2 = ""
				for j in xrange(len(line)):
					ch = line[j]
					if ch == '\t':
						w2 = computeWidth(s[:j],w)
						w3 = (abs(w) - (w2 % abs(w)))
						line2 += ' ' * w3
					else:
						line2 += ch
				lines[i] = line2
			s = string.join(lines,'\n')
		self.os(s)</t>
<t tx="T2508">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * abs(n))

def onl(self):
	self.os(self.output_newline)

def os(self,s):
	if s is None or len(s) == 0: return
	if self.suppress_newlines and self.newline_pending:
		self.newline_pending = false
		s = self.output_newline + s
	if self.outputFile:
		try:
			s = toEncodedString(s,self.encoding,reportErrors=true)
			self.outputFile.write(s)
		except:
			es("exception writing:" + `s`)
			es_exception()

def otabs(self,n):
	self.os('\t' * abs(n))</t>
<t tx="T2509"># This method outputs s, a directive or reference, in a sentinel.

def putDirective(self,s,i):

	tag = "@delims"
	assert(i &lt; len(s) and s[i] == '@')
	k = i
	j = skip_to_end_of_line(s,i)
	directive = s[i:j]

	if match_word(s,k,tag):
		&lt;&lt; handle @delims &gt;&gt;
	else:
		self.putSentinel("@" + directive)

	i = skip_line(s,k)
	return i</t>
<t tx="T2510"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = choose(j&lt;i, s[j:i], "")
else:
	self.writeError("Bad @delims directive")</t>
<t tx="T2511"># 14-SEP-2002 DTHEIN
# added for use by putBodyPart()

# This method outputs the directive without the parameter text
def putEmptyDirective(self,s,i):

	assert(i &lt; len(s) and s[i] == '@')
	
	endOfLine = s.find('\n',i)
	# 21-SEP-2002 DTHEIN: if no '\n' then just use line length
	if endOfLine == -1:
		endOfLine = len(s)
	token = s[i:endOfLine].split()
	directive = token[0]
	self.putSentinel("@" + directive)

	i = skip_line(s,i)
	return i</t>
<t tx="T2512">def putIndent(self,n):
	
	"""Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

	if n != 0:
		w = self.tab_width
		if w &gt; 1:
			q,r = divmod(n,w) 
			self.otabs(q) 
			self.oblanks(r)
		else:
			self.oblanks(n)</t>
<t tx="T2513">@others</t>
<t tx="T2514">def __init__(self,theCommander):
	
	"""Ctor for 4.x atFile class."""
	
	at = self

	# Initialize the base class.
	oldDerivedFile.__init__(self,theCommander) 

	# For 4.x reading &amp; writing...
	at.inCode = true
	## at.nodeIndices = app.nodeIndices

	# For 4.x writing...
	at.docKind = None
	at.pending = [] # Doc part that remains to be written.

	# For 4.x reading...
	at.docOut = [] # The doc part being accumulated.
	at.done = false # true when @-leo seen.
	at.endSentinelStack = []
	at.importing = false
	at.indent = 0 ; at.indentStack = []
	at.lastLines = [] # The lines after @-leo
	at.leadingWs = ""
	at.out = None ; at.outStack = []
	at.root_seen = false # true: root vnode has been handled in this file.
	at.tnodeList = [] ; at.tnodeListIndex = 0
	at.t = None ; at.tStack = []

	# The dispatch dictionary used by scanText4.
	at.dispatch_dict = {
		# Plain line.
		noSentinel: at.readNormalLine,
		# Starting sentinels...
		startAt:     at.readStartAt,
		startDoc:    at.readStartDoc,
		startLeo:    at.readStartLeo,
		startNode:   at.readStartNode,
		startOthers: at.readStartOthers,
		# Ending sentinels...
		endAt:     at.readEndAt,
		endDoc:    at.readEndDoc,
		endLeo:    at.readEndLeo,
		endNode:   at.readEndNode,
		endOthers: at.readEndOthers,
		# Non-paired sentinels.
		startAfterRef:  at.readAfterRef,
		startComment:   at.readComment,
		startDelims:    at.readDelims,
		startDirective: at.readDirective,
		startNl:        at.readNl,
		startNonl:      at.readNonl,
		startRef:       at.readRef,
		startVerbatim:  at.readVerbatim,
		# Ignored 3.x sentinels
		endBody:               at.ignoreOldSentinel,
		startBody:             at.ignoreOldSentinel,
		startVerbatimAfterRef: at.ignoreOldSentinel }</t>
<t tx="T2515"></t>
<t tx="T2516">def readOpenFile(self,root,file,firstLines):
	
	"""Read an open 4.x derived file."""
	
	at = self
	if at.trace: trace("new_df",root)

	# Scan the 4.x file.
	at.scanAllDirectives(root)
	at.tnodeListIndex = 0
	lastLines = at.scanText4(file,root)
	root.t.setVisited() # Disable warning about set nodes.
	
	# Handle first and last lines.
	try: body = root.t.tempBodyString
	except: body = ""
	lines = body.split('\n')
	at.completeFirstDirectives(lines,firstLines)
	at.completeLastDirectives(lines,lastLines)
	s = '\n'.join(lines).replace('\r', '')
	root.t.tempBodyString = s</t>
<t tx="T2517">def scanText4 (self,file,v):
	
	"""Scan a 4.x derived file non-recursively."""

	at = self
	&lt;&lt; init ivars for scanText4 &gt;&gt;
	while at.errors == 0 and not at.done:
		s = at.readLine(file)
		if len(s) == 0: break
		kind = at.sentinelKind(s)
		# trace(at.sentinelName(kind),`s`)
		if kind == noSentinel:
			i = 0
		else:
			i = at.skipSentinelStart(s,0)
		func = at.dispatch_dict[kind]
		func(s,i)

	if at.errors == 0 and not at.done:
		&lt;&lt; report unexpected end of text &gt;&gt;

	return at.lastLines</t>
<t tx="T2518"># Unstacked ivars...
at.done = false
at.inCode = true
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.indent = 0 # Changed only for sentinels.
at.rootSeen = false

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = v.t ; at.tStack = []

if 0: # Useful for debugging.
	if hasattr(v,"tnodeList"):
		trace("len(v.tnodeList)",len(v.tnodeList),v)
	else:
		trace("no tnodeList",v)</t>
<t tx="T2519">assert(at.endSentinelStack)

at.readError(
	"Unexpected end of file. Expecting %s sentinel" %
	at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="T2520">def readNormalLine (self,s,i):

	at = self
	
	if at.inCode:
		if not at.raw:
			s = removeLeadingWhitespace(s,at.indent,at.tab_width)
		at.out.append(s)
	else:
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="T2521">if len(at.endSentinelComment) == 0:
	# Skip the single comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,at.startSentinelComment):
		i += len(at.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = at.skipIndent(s,0,at.indent)

</t>
<t tx="T2522">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
	# no trailing whitespace: the newline is real.
	at.docOut.append(line + '\n')
else:
	# trailing whitespace: the newline is fake.
	at.docOut.append(line)</t>
<t tx="T2523"></t>
<t tx="T2524">def readStartLeo (self,s,i):
	
	"""Read an unexpected @+leo sentinel."""

	at = self
	assert(match(s,i,"+leo"))
	at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T2525">def readStartNode (self,s,i):
	
	"""Read an @node sentinel."""
	
	at = self ; assert(match(s,i,"+node:"))
	i += 6
	
	&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
	if not at.root_seen:
		at.root_seen = true
		&lt;&lt; Check the filename in the sentinel &gt;&gt;

	i,newIndent = skip_leading_ws_with_indent(s,0,at.tab_width)
	at.indentStack.append(at.indent) ; at.indent = newIndent
	
	at.outStack.append(at.out) ; at.out = []
	at.tStack.append(at.t) ; at.t = at.findChild(headline)
	
	at.endSentinelStack.append(endNode)</t>
<t tx="T2526"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	k = s.rfind(at.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')</t>
<t tx="T2527">h = headline.strip()

if h[:5] == "@file":
	i,junk,junk = scanAtFileOptions(h)
	fileName = string.strip(h[i:])
	if fileName != at.targetFileName:
		at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
	fileName = string.strip(h[8:])
	if fileName != at.targetFileName:
		at.readError("File name in @node sentinel does not match file's name")
else:
	at.readError("Missing @file in root @node sentinel")</t>
<t tx="T2528">def readStartOthers (self,s,i):
	
	"""Read an @+others sentinel."""

	at = self
	j = skip_ws(s,i)
	leadingWs = s[i:j]
	if leadingWs:
		assert(match(s,j,"@+others"))
	else:
		assert(match(s,j,"+others"))

	# Make sure that the generated at-others is properly indented.
	at.out.append(leadingWs + "@others\n")
	
	at.endSentinelStack.append(endOthers)</t>
<t tx="T2529"></t>
<t tx="T2530">def readEndAt (self,s,i):
	
	"""Read an @-at sentinel."""

	at = self
	at.readLastDocLine("@")
	at.popSentinelStack(endAt)
	at.inCode = true
		
def readEndDoc (self,s,i):
	
	"""Read an @-doc sentinel."""

	at = self
	at.readLastDocLine("@doc")
	at.popSentinelStack(endDoc)
	at.inCode = true</t>
<t tx="T2531">def readEndLeo (self,s,i):
	
	"""Read an @-leo sentinel."""
	
	at = self

	# Ignore everything after @-leo.
	# Such lines were presumably written by @last.
	while 1:
		s = at.readLine(at.file)
		if len(s) == 0: break
		at.lastLines.append(s) # Capture all trailing lines, even if empty.

	at.done = true</t>
<t tx="T2532">def readEndOthers (self,s,i):
	
	"""Read an @-others sentinel."""
	
	at = self
	at.popSentinelStack(endOthers)</t>
<t tx="T2533"></t>
<t tx="T2534">def  ignoreOldSentinel (self,s,i):
	
	"""Ignore an 3.x sentinel."""
	
	es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="T2535">def  readAfterRef (self,s,i):
	
	"""Read an @afterref sentinel."""
	
	at = self
	assert(match(s,i,"afterref"))
	
	# Append the next line to the text.
	s = at.readLine(at.file)
	at.out.append(s)</t>
<t tx="T2536">def readComment (self,s,i):
	
	"""Read an @comment sentinel."""

	assert(match(s,i,"comment"))

	# Just ignore the comment line!
</t>
<t tx="T2537">def readDelims (self,s,i):
	
	"""Read an @delims sentinel."""
	
	at = self
	assert(match(s,i-1,"@delims"));

	# Skip the keyword and whitespace.
	i0 = i-1
	i = skip_ws(s,i-1+7)
		
	# Get the first delim.
	j = i
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	
	if j &lt; i:
		at.startSentinelComment = s[j:i]
		# print "delim1:", at.startSentinelComment
	
		# Get the optional second delim.
		j = i = skip_ws(s,i)
		while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
			i += 1
		end = choose(j&lt;i,s[j:i],"")
		i2 = skip_ws(s,i)
		if end == at.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
			at.endSentinelComment = "" # Not really two params.
			line = s[i0:j]
			line = line.rstrip()
			at.out.append(line+'\n')
		else:
			at.endSentinelComment = end
			# print "delim2:",end
			line = s[i0:i]
			line = line.rstrip()
			at.out.append(line+'\n')
	else:
		at.readError("Bad @delims")
		# Append the bad @delims line to the body text.
		at.out.append("@delims")</t>
<t tx="T2538">def readDirective (self,s,i):
	
	"""Read an @@sentinel."""
	
	at = self
	assert(match(s,i,"@")) # The first '@' has already been eaten.
	
	if match_word(s,i,"@raw"):
		at.raw = true
	elif match_word(s,i,"@end_raw"):
		at.raw = false
	
	e = at.endSentinelComment
	s2 = s[i:]
	if len(e) &gt; 0:
		k = s.rfind(e,i)
		if k != -1:
			s2 = s[i:k] + '\n'
		
	start = at.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s2 = s2.replace('@@','@')

	at.out.append(s2)</t>
<t tx="T2539">def readNl (self,s,i):
	
	"""Handle an @nonl sentinel."""
	
	at = self
	assert(match(s,i,"nl"))
	
	if at.inCode:
		at.out.append('\n')
	else:
		at.docOut.append('\n')</t>
<t tx="T2540">def readNonl (self,s,i):
	
	"""Handle an @nonl sentinel."""
	
	at = self
	assert(match(s,i,"nonl"))
	
	if at.inCode:
		s = ''.join(at.out)
		if s and s[-1] == '\n':
			at.out = [s[:-1]]
		else:
			trace("out:",`s`)
			at.readError("unexpected @nonl directive in code part")	
	else:
		s = ''.join(at.pending)
		if s:
			if s and s[-1] == '\n':
				at.pending = [s[:-1]]
			else:
				trace("docOut:",`s`)
				at.readError("unexpected @nonl directive in pending doc part")
		else:
			s = ''.join(at.docOut)
			if s and s[-1] == '\n':
				at.docOut = [s[:-1]]
			else:
				trace("docOut:",`s`)
				at.readError("unexpected @nonl directive in doc part")</t>
<t tx="T2541">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
	
	"""Handle an @&lt;&lt; sentinel."""
	
	at = self
	j = skip_ws(s,i)
	assert(match(s,j,"&lt;&lt;"))
	
	if len(at.endSentinelComment) == 0:
		line = s[i:-1] # No trailing newline
	else:
		k = s.find(at.endSentinelComment,i)
		line = s[i:k] # No trailing newline, whatever k is.
			
	# Undo the cweb hack.
	start = at.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		line = line.replace('@@','@')

	at.out.append(line)</t>
<t tx="T2542">def readVerbatim (self,s,i):
	
	"""Read an @verbatim sentinel."""
	
	at = self
	assert(match(s,i,"verbatim"))
	
	# Append the next line to the text.
	s = at.readLine(at.file) 
	i = at.skipIndent(s,0,at.indent)
	at.out.append(s[i:])</t>
<t tx="T2543">def badEndSentinel (self,expectedKind):
	
	"""Handle a mismatched ending sentinel."""

	at = self
	assert(at.endSentinelStack)
	at.readError("Ignoring %s sentinel.  Expecting %s" %
		(at.sentinelName(at.endSentinelStack[-1]),
		 at.sentinelName(expectedKind)))
		 
def popSentinelStack (self,expectedKind):
	
	"""Pop an entry from endSentinelStack and check it."""
	
	at = self
	if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
		at.endSentinelStack.pop()
	else:
		at.badEndSentinel(expectedKind)</t>
<t tx="T2544"></t>
<t tx="T2545">def nodeSentinelText(self,v):
	
	"""Return the text of a @+node or @-node sentinel for v."""
	
	at = self ; h = v.headString()
	&lt;&lt; remove comment delims from h if necessary &gt;&gt;
	return h</t>
<t tx="T2546">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) &gt; 0:
	h = h.replace(start,"")
	h = h.replace(end,"")</t>
<t tx="T2547">def putOpenLeoSentinel(self,s):
	
	"""Write @+leo sentinel."""

	at = self
	
	if not at.sentinels:
		return # Handle @nosentinelsfile.

	encoding = at.encoding.lower()
	if encoding != "utf-8":
		s = s + "-encoding=%s." % (encoding)
	
	at.putSentinel(s)</t>
<t tx="T2548">def putOpenNodeSentinel(self,v):
	
	"""Write @+node sentinel for v."""
	
	at = self

	if v.isAtFileNode() and v != at.root:
		at.writeError("@file not valid in: " + v.headString())
		return
	
	s = at.nodeSentinelText(v)
	at.putSentinel("@+node:" + s)

	# Append the n'th tnode to the root's tnode list.

	# trace("%3d %3d" % (len(at.root.tnodeList),v.t.fileIndex),v)
	at.root.tnodeList.append(v.t)</t>
<t tx="T2549"># This method outputs all sentinels.

def putSentinel(self,s):

	"Write a sentinel whose text is s, applying the CWEB hack if needed."
	
	at = self

	if not at.sentinels:
		return # Handle @file-nosent

	at.putIndent(at.indent)
	at.os(at.startSentinelComment)
	&lt;&lt; apply the cweb hack to s &gt;&gt;
	at.os(s)
	if at.endSentinelComment:
		at.os(at.endSentinelComment)
	at.onl()</t>
<t tx="T2550">@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
	assert(s and s[0]=='@')
	s = s.replace('@','@@')[1:]</t>
<t tx="T2551">def skipSentinelStart(self,s,i):
	
	"""Skip the start of a sentinel."""

	start = self.startSentinelComment
	assert(start and len(start)&gt;0)

	i = skip_ws(s,i)
	assert(match(s,i,start))
	i += len(start)

	# 7/8/02: Support for REM hack
	i = skip_ws(s,i)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1
</t>
<t tx="T2552">def sentinelKind(self,s):
	
	"""Return the kind of sentinel at s."""
	
	at = self

	i = skip_ws(s,0)
	if match(s,i,at.startSentinelComment): 
		i += len(at.startSentinelComment)
	else:
		return noSentinel

	# Locally undo cweb hack here
	start = at.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s = s[:i] + string.replace(s[i:],'@@','@')
		
	# 4.0: Look ahead for @[ws]@others and @[ws]&lt;&lt;
	if match(s,i,"@"):
		j = skip_ws(s,i+1)
		if j &gt; i+1:
			# trace(`ws`,`s`)
			if match(s,j,"@+others"):
				return startOthers
			elif match(s,j,"&lt;&lt;"):
				return startRef
			else:
				# No other sentinels allow whitespace following the '@'
				return noSentinel

	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return startRef
	if match(s,i,"@@"):   return startDirective
	if not match(s,i,'@'): return noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	key = s[j:i]
	if len(key) &gt; 0 and sentinelDict.has_key(key):
		return sentinelDict[key]
	else:
		return noSentinel</t>
<t tx="T2553"></t>
<t tx="T2554"></t>
<t tx="T2555"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
	
	at = self
	if at.outputFile:
		at.outputFile.flush()
		at.outputFile.close()
		at.outputFile = None</t>
<t tx="T2556"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false):
	
	"""Write a 4.x derived file."""
	
	at = self ; c = at.commands
	if at.trace: trace("new_df",root)

	at.sentinels = not nosentinels
	&lt;&lt; initialize &gt;&gt;
	try:
		&lt;&lt; open the file; return on error &gt;&gt;
		root.clearVisitedInTree()
		&lt;&lt; write then entire @file tree &gt;&gt;
		at.closeWriteFile()
		&lt;&lt; warn about @ignored and orphans &gt;&gt;
		&lt;&lt; finish writing &gt;&gt;
	except:
		at.handleWriteException()</t>
<t tx="T2557">at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.tnodeList = []
at.raw = false
c.endEditing() # Capture the current headline.</t>
<t tx="T2558">if nosentinels:
	at.targetFileName = root.atNoSentinelsFileNodeName()
else:
	at.targetFileName = root.atFileNodeName()

ok = at.openWriteFile(root)
if not ok: return</t>
<t tx="T2559"># unvisited nodes will be orphans, except in cweb trees.
root.clearVisitedInTree()

&lt;&lt; put all @first lines in root &gt;&gt;

# Put the main part of the file.
at.putOpenLeoSentinel("@+leo-ver=4")
at.putInitialComment()
at.putBody(root)
at.putSentinel("@-leo")
root.setVisited()

&lt;&lt; put all @last lines in root &gt;&gt;


</t>
<t tx="T2560">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# Write @first line, whether empty or not
	line = s[j:i]
	self.os(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T2561">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.os(line[i:]) ; self.onl()</t>
<t tx="T2562"># 10/26/02: Always warn, even when language=="cweb"

next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		at.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		at.writeError("@ignore node: " + v.headString())
	v = v.threadNext()
</t>
<t tx="T2563">@ We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c

if at.errors &gt; 0 or at.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(at.outputFileName) # Delete the temp file.
	es("Not written: " + at.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	at.replaceTargetFileIfDifferent()</t>
<t tx="T2564">def putBody(self,v):
	
	""" Generate the body enclosed in sentinel lines."""

	at = self ; s = v.bodyString()

	v.setVisited() # Mark the node for the orphans check.
	if not s: return

	inCode = true
	
	# Make _sure_ all lines end in a newline.
	# If we add a trailing newline, we'll generate an @nonl sentinel below.
	trailingNewlineFlag = s and s[-1] == '\n'
	if not trailingNewlineFlag:
		s = s + '\n'
	
	at.putOpenNodeSentinel(v)
	i = 0
	while i &lt; len(s):
		next_i = skip_line(s,i)
		assert(next_i &gt; i)
		kind = at.directiveKind(s,i)
		&lt;&lt; handle line at s[i] &gt;&gt;
		i = next_i
	if not inCode:
		at.putEndDocLine()
	if not trailingNewlineFlag:
		at.putSentinel("@nonl")
	at.putCloseNodeSentinel(v)</t>
<t tx="T2565">if kind == noDirective:
	if inCode:
		hasRef,n1,n2 = at.findSectionName(s,i)
		if hasRef and not at.raw:
			at.putRefLine(s,i,n1,n2,v)
		else:
			at.putCodeLine(s,i)
	else:
		at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
	assert(not at.pending)
	at.putStartDocLine(s,i,kind)
	inCode = false
elif kind in (cDirective,codeDirective):
	# Only @c and @code end a doc part.
	if not inCode:
		at.putEndDocLine() 
	at.putDirective(s,i)
	inCode = true
elif kind == othersDirective:
	inCode = true
	at.putAtOthersLine(s,i,v)
elif kind == rawDirective:
	at.raw = true
	at.putSentinel("@@raw")
elif kind == endRawDirective:
	at.raw = false
	at.putSentinel("@@end_raw")
	i = skip_line(s,i)
elif kind == miscDirective:
	at.putDirective(s,i)
else:
	assert(not "unknown directive")</t>
<t tx="T2566"></t>
<t tx="T2567">def inAtOthers(self,v):
	
	"""Returns true if v should be included in the expansion of the at-others directive
	
	in the body text of v's parent."""

	# Return false if this has been expanded previously.
	if  v.isVisited():
		# trace("previously visited",v)
		return false
	
	# Return false if this is a definition node.
	h = v.headString() ; i = skip_ws(h,0)
	isSection,junk = self.isSectionName(h,i)
	if isSection:
		# trace("is section",v)
		return false

	# Return false if v's body contains an @ignore directive.
	if v.isAtIgnoreNode():
		# trace("is @ignore",v)
		return false
	else:
		# trace("ok",v)
		return true</t>
<t tx="T2568">def putAtOthersChild(self,v):

	v.setVisited() # Make sure v is never expanded again.
	self.putBody(v) # Insert the expansion of v.

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()
</t>
<t tx="T2569">def putAtOthersLine (self,s,i,v):
	
	"""Put the expansion of @others."""
	
	at = self
	j,delta = skip_leading_ws_with_indent(s,i,at.tab_width)
	at.putLeadInSentinel(s,i,j,delta)

	at.indent += delta
	if at.leadingWs:
		at.putSentinel("@" + at.leadingWs + "@+others")
	else:
		at.putSentinel("@+others")
	
	child = v.firstChild()
	while child:
		if at.inAtOthers(child):
			at.putAtOthersChild(child)
		child = child.next()

	at.putSentinel("@-others")
	at.indent -= delta</t>
<t tx="T2570">def putCodeLine (self,s,i):
	
	"""Put a normal code line."""
	
	at = self
	
	# Put @verbatim sentinel if required.
	k = skip_ws(s,i)
	if match(s,k,self.startSentinelComment + '@'):
		self.putSentinel("@verbatim")

	j = skip_line(s,i)
	if not at.raw:
		at.putIndent(at.indent)
	line = s[i:j]
	# trace(`line`)
	at.os(line)</t>
<t tx="T2571">def putRefLine(self,s,i,n1,n2,v):
	
	"""Put a reference at s[n1:n2+2] from v."""
	
	at = self ; name = s[n1:n2+2]

	ref = findReference(name,v)
	if not ref:
		at.writeError(
			"undefined section: %s\n\treferenced from: %s" %
			( name,v.headString()))
		return
	
	# Expand the ref.
	j,delta = skip_leading_ws_with_indent(s,i,at.tab_width)
	at.putLeadInSentinel(s,i,n1,delta)
	at.indent += delta
	if at.leadingWs:
		at.putSentinel("@" + at.leadingWs + name)
	else:
		at.putSentinel("@" + name)
	at.putBody(ref)
	at.indent -= delta
	
	# Handle whatever follows the ref.
	j = skip_ws(s,n2+2)
	if j &lt; len(s) and s[j] != '\n':
		i = skip_to_end_of_line(s,i)
		after = s[n2+2:i]
		at.putSentinel("@afterref")
		at.os(after) ; at.onl()
	else:
		# Temporarily readjust delta to make @nl look better.
		at.indent += delta
		at.putSentinel("@nl")
		at.indent -= delta</t>
<t tx="T2572"></t>
<t tx="T2573">def findSectionName(self,s,i):
	
	end = s.find('\n',i)
	if end == -1:
		n1 = s.find("&lt;&lt;",i)
		n2 = s.find("&gt;&gt;",i)
	else:
		n1 = s.find("&lt;&lt;",i,end)
		n2 = s.find("&gt;&gt;",i,end)

	return -1 &lt; n1 &lt; n2, n1, n2</t>
<t tx="T2574">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * abs(n))

def onl(self):
	self.os(self.output_newline)
	
def os (self,s):
	if s and self.outputFile:
		try:
			s = toEncodedString(s,self.encoding,reportErrors=true)
			self.outputFile.write(s)
		except:
			es("exception writing:" + `s`)
			es_exception()

def otabs(self,n):
	self.os('\t' * abs(n))</t>
<t tx="T2575"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	at = self
	n = len(s)
	if i &gt;= n or s[i] != '@':
		j = skip_ws(s,i)
		if match_word(s,j,"@others"):
			return othersDirective
		else:
			return noDirective

	table = (
		("@c",cDirective),
		("@code",codeDirective),
		("@doc",docDirective),
		("@end_raw",endRawDirective),
		("@others",othersDirective),
		("@raw",rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return choose(at.language=="cweb",
			noDirective,atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if at.language=="cweb" and (
		match_word(s,i,"@c") or
		i+1&gt;= n or s[i+1] not in string.ascii_letters):
		return noDirective

	for name,directive in table:
		if match_word(s,i,name):
			return directive

	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if match_word(s,i,name):
			return miscDirective

	return noDirective</t>
<t tx="T2576">@language python

# Syntax coloring routines for Leo.py

from leoGlobals import *
import string,Tkinter,tkColorChooser

&lt;&lt; define leo keywords &gt;&gt;
&lt;&lt; define colorizer constants &gt;&gt;
&lt;&lt; define color panel data &gt;&gt;

@others</t>
<t tx="T2577"># These defaults are sure to exist.
default_colors_dict = {
	# tag name      :(     option name,           default color),
	"comment"       :("comment_color",               "red"),
	"cwebName"      :("cweb_section_name_color",     "red"),
	"pp"             :("directive_color",             "blue"),
	"docPart"        :("doc_part_color",              "red"),
	"keyword"        :("keyword_color",               "blue"),
	"leoKeyword"     :("leo_keyword_color",           "blue"),
	"link"           :("section_name_color",          "red"),
	"nameBrackets"   :("section_name_brackets_color", "blue"),
	"string"         :("string_color",                "#00aa00"), # Used by IDLE.
	"name"           :("undefined_section_name_color","red"),
	"latexBackground":("latex_background_color","white") }</t>
<t tx="T2578">colorPanelData = (
	#Dialog name,                option name,         default color),
	("Brackets",          "section_name_brackets_color", "blue"),
	("Comments",          "comment_color",               "red"),
	("CWEB section names","cweb_section_name_color",     "red"),
	("Directives",        "directive_color",             "blue"),
	("Doc parts",         "doc_part_color",              "red"),
	("Keywords" ,         "keyword_color",               "blue"),
	("Leo Keywords",      "leo_keyword_color",           "blue"),
	("Section Names",     "section_name_color",          "red"),
	("Strings",           "string_color",   "#00aa00"), # Used by IDLE.
	("Undefined Names",   "undefined_section_name_color","red") )

colorNamesList = (
	"gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
	"snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
	"seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
	"AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
	"PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
	"NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
	"LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
	"cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
	"honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
	"LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
	"MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
	"SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
	"RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
	"DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
	"SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
	"DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
	"SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
	"LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
	"LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
	"LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
	"LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
	"PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
	"CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
	"turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
	"DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
	"DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
	"aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
	"DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
	"PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
	"SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
	"green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
	"chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
	"DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
	"DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
	"LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
	"LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
	"LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
	"gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
	"DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
	"RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
	"IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
	"sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
	"wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
	"chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
	"firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
	"salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
	"LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
	"DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
	"coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
	"OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
	"red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
	"HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
	"LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
	"PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
	"maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
	"VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
	"orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
	"MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
	"DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
	"purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
	"MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
	"thistle4" )
</t>
<t tx="T2579">class baseLeoColorPanel:
	"""The base class for Leo's color panel."""
	@others
	
class leoColorPanel (baseLeoColorPanel):
	"""A class that creates Leo's color picker panel."""
	pass

</t>
<t tx="T2580">def __init__ (self,c):
	
	self.commands = c
	self.frame = c.frame
	# Set by run.
	self.top = None
	# Options provisionally set by callback.
	self.changed_options = []
	# For communication with callback.
	self.buttons = {}
	self.nameButtons = {}
	self.option_names = {}
	# Save colors for revert.  onOk alters this.
	self.revertColors = {}
	config = app.config
	for name,option_name,default_color in colorPanelData:
		self.revertColors[option_name] = config.getColorsPref(option_name)</t>
<t tx="T2581">def showColorPicker (self,name):
	
	option_name = self.option_names[name]
	color = app.config.getColorsPref(option_name)
	rgb,val = tkColorChooser.askcolor(color=color)
	if val != None:
		self.update(name,val)</t>
<t tx="T2582">def showColorName (self,name,color):
	
	np = leoColorNamePanel(self,name,color)
	np.run(name,color)</t>
<t tx="T2583">def onOk (self):
	# Update the revert colors
	config = app.config
	for name in self.changed_options:
		option_name = self.option_names[name]
		self.revertColors[option_name] = config.getColorsPref(option_name)
	self.changed_options = []
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.colorPanel = None
		self.top.destroy()
	
def onCancel (self):
	self.onRevert()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.colorPanel = None
		self.top.destroy()
	
def onRevert (self):
	config = app.config
	for name in self.changed_options:
		option_name = self.option_names[name]
		old_val = self.revertColors[option_name]
		# Update the current settings.
		config.setColorsPref(option_name,old_val)
		# Update the buttons.
		b = self.buttons[name]
		b.configure(bg=old_val)
		b = self.nameButtons[name]
		b.configure(text=`old_val`)
	self.changed_options = []
	self.commands.recolor()</t>
<t tx="T2584">def update (self,name,val):
	
	config = app.config
	# es(str(name) + " = " + str(val))
	
	# Put the new color in the button.
	b = self.buttons[name]
	b.configure(bg=val)
	option_name = self.option_names[name]
	
	# Put the new color name or value in the name button.
	b = self.nameButtons[name]
	b.configure(text=str(val))
	
	# Save the changed option names for revert and cancel.
	if name not in self.changed_options:
		self.changed_options.append(name)

	# Set the new value and recolor.
	config.setColorsPref(option_name,val)
	self.commands.recolor()</t>
<t tx="T2585">class baseLeoColorNamePanel:
	"""The base class for Leo's color name picker panel."""
	@others
	
class leoColorNamePanel(baseLeoColorNamePanel):
	"""A class that creates Leo's color name picker panel."""
	pass</t>
<t tx="T2586">def __init__ (self, colorPanel, name, color):
	
	self.colorPanel = colorPanel
	self.name = name
	self.color = color
	self.revertColor = color</t>
<t tx="T2587">def getSelection (self):

	box = self.box ; color = None
	
	# Get the family name if possible, or font otherwise.
	items = box.curselection()

	if len(items)&gt; 0:
		try: # This shouldn't fail now.
			items = map(int, items)
			color = box.get(items[0])
		except:
			es("unexpected exception")
			es_exception()

	if not color:
		color = self.color
	return color</t>
<t tx="T2588">def onApply (self,event=None):
	self.color = color = self.getSelection()
	self.colorPanel.update(self.name,color)

def onOk (self):
	color = self.getSelection()
	self.colorPanel.update(self.name,color)
	self.top.destroy()
	
def onCancel (self):
	self.onRevert()
	self.top.destroy()
	
def onRevert (self):
	self.color = color = self.revertColor
	self.select(self.color)
	self.colorPanel.update(self.name,color)</t>
<t tx="T2589">def select (self,color):

	# trace(color)

	# The name should be on the list!
	box = self.box
	for i in xrange(0,box.size()):
		item = box.get(i)
		if color == item:
			box.select_clear(0,"end")
			box.select_set(i)
			box.see(i)
			return

	# trace("not found:" + `color`)</t>
<t tx="T2590">@language python

from leoGlobals import *
import leoAtFile,leoFileCommands,leoImport,leoNodes,leoTangle,leoUndo

class baseCommands:
	"""The base class for Leo's main commander."""
	@others

class Commands (baseCommands):
	"""A class that implements most of Leo's commands."""
	pass</t>
<t tx="T2591"># This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):

	c = self ; find = app.findFrame
	if find:
		find.set_ivars(c)
</t>
<t tx="T2592">@ This should be called whenever we need to use preference:
i.e., before reading, writing, tangling, untangling.

7/2/02: We no longer need this now that the Prefs dialog is modal.
@c

def setIvarsFromPrefs (self):

	pass</t>
<t tx="T2593"></t>
<t tx="T2594">def beginUpdate(self):

	self.frame.beginUpdate()
	
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="T2595">def bringToFront(self):

	self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="T2596">def endUpdate(self, flag=true):
	
	self.frame.endUpdate(flag)
	
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="T2597">def recolor(self):

	self.frame.recolor(self.frame.currentVnode())</t>
<t tx="T2598">def redraw(self):

	self.frame.redraw()
	
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="T2599"></t>
<t tx="T2600">def canContractAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2601">def canContractAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2602">def canContractParent (self):

	c = self ; v = c.currentVnode()
	return v.parent() != None</t>
<t tx="T2603">def canContractSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T2604">def canDeleteHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	if v.parent(): # v is below the top level.
		return true
	else: # v is at the top level.  We can not delete the last node.
		return v.threadBack() or v.next()

canCutOutline = canDeleteHeadline</t>
<t tx="T2605">def canDemote (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	return v.next() != None</t>
<t tx="T2606">def canExpandAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2607">def canExpandAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2608">def canExpandSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if not v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T2609">def canExtract (self):

	c = self
	if c.body:
		i, j = getTextSelection(c.body)
		return i and j and c.body.compare(i, "!=", j)
	else:
		return false

canExtractSection = canExtract
canExtractSectionNames = canExtract</t>
<t tx="T2610">def canFindMatchingBracket (self):
	
	c = self ; body = c.body
	brackets = "()[]{}"
	c1 = body.get("insert -1c")
	c2 = body.get("insert")
	# Bug fix: 2/11/03
	return (c1 and c1 in brackets) or (c2 and c2 in brackets)</t>
<t tx="T2611">def canGoToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isDirty()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2612">def canGoToNextMarkedHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isMarked()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2613">def canMarkChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2614">def canMarkChangedRoots (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2615">def canMoveOutlineDown (self):

	c = self
	if 1: # The permissive way
		current = c.currentVnode()
		if not current: return false
		v = current.visNext()
		while v and current.isAncestorOf(v):
			v = v.visNext()
		return v != None
	else: # The MORE way.
		return c.currentVnode().next() != None</t>
<t tx="T2616">def canMoveOutlineLeft (self):

	c = self ; v = c.currentVnode()
	if 0: # Old code: assumes multiple leftmost nodes.
		return v and v.parent()
	else: # Can't move a child of the root left.
		return v and v.parent() and v.parent().parent()</t>
<t tx="T2617">def canMoveOutlineRight (self):

	c = self ; v = c.currentVnode()
	return v and v.back()</t>
<t tx="T2618">def canMoveOutlineUp (self):

	c = self ; v = c.currentVnode()
	if 1: # The permissive way.
		return v and v.visBack()
	else: # The MORE way.
		return v and v.back()</t>
<t tx="T2619">def canPromote (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()</t>
<t tx="T2620">def canRevert (self):

	# c.mFileName will be "untitled" for unsaved files.
	c = self
	return (c.frame and c.mFileName and c.isChanged())</t>
<t tx="T2621"># 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
	v = self.currentVnode()
	return v and v.threadBack()
	
def canSelectThreadNext (self):
	v = self.currentVnode()
	return v and v.threadNext()

def canSelectVisBack (self):
	v = self.currentVnode()
	return v and v.visBack()
	
def canSelectVisNext (self):
	v = self.currentVnode()
	return v and v.visNext()</t>
<t tx="T2622">def canShiftBodyLeft (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false
		
def canShiftBodyRight (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false</t>
<t tx="T2623">def canSortChildren (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()
	
def canSortSiblings (self):

	c = self ; v = c.currentVnode()
	return v.next() or v.back()</t>
<t tx="T2624">def canUndo (self):

	c = self
	return c.undoer.canUndo()
	
def canRedo (self):

	c = self
	return c.undoer.canRedo()</t>
<t tx="T2625"># Returns true if any node is marked.

def canUnmarkAll (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isMarked():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T2626"></t>
<t tx="T2627"></t>
<t tx="T2628">def contractAllHeadlines (self):

	c = self ; current = c.currentVnode()
	v = c.rootVnode()
	c.beginUpdate()

	while v:
		c.contractSubtree(v)
		v = v.next()

	if not current.isVisible():
		# 1/31/03: Select the topmost ancestor of the presently selected node.
		v = current
		while v and v.parent():
			v = v.parent()
		c.selectVnode(v)

	c.endUpdate()
	c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="T2629">def contractNode (self):
	
	c = self ; v = c.currentVnode()
	
	c.beginUpdate()
	v.contract()
	c.endUpdate()
</t>
<t tx="T2630">def contractParent (self):
	
	c = self ; v = c.currentVnode()
	parent = v.parent()
	if not parent: return
	
	c.beginUpdate()
	c.selectVnode(parent)
	parent.contract()
	c.endUpdate()</t>
<t tx="T2631">def expandAllHeadlines(self):

	c = self ; v = root = c.rootVnode()
	c.beginUpdate()
	while v:
		c.expandSubtree(v)
		v = v.next()
	c.selectVnode(root)
	c.endUpdate()
	c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="T2632">def expandAllSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	c.expandSubtree(v)
	while child:
		c.expandSubtree(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T2633">def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
</t>
<t tx="T2634">def expandNextLevel (self):

	c = self ; v = c.currentVnode()
	
	# 1/31/02: Expansion levels are now local to a particular tree.
	if c.expansionNode != v:
		c.expansionLevel = 1
		c.expansionNode = v
		
	self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="T2635">def expandNode (self):
	
	c = self ; v = c.currentVnode()
	
	c.beginUpdate()
	v.expand()
	c.endUpdate()

</t>
<t tx="T2636">def expandPrevLevel (self):

	c = self ; v = c.currentVnode()
	
	# 1/31/02: Expansion levels are now local to a particular tree.
	if c.expansionNode != v:
		c.expansionLevel = 1
		c.expansionNode = v
		
	self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="T2637"></t>
<t tx="T2638">def contractSubtree (self,v):

	last = v.lastNode()
	while v and v != last:
		v.contract()
		v = v.threadNext()</t>
<t tx="T2639">def expandSubtree (self,v):

	c = self
	last = v.lastNode()
	while v and v != last:
		v.expand()
		v = v.threadNext()
	c.frame.redraw()</t>
<t tx="T2640">def expandToLevel (self,level):

	c = self
	c.beginUpdate()
	if 1: # 1/31/03: The expansion is local to the present node.
		v = c.currentVnode() ; n = v.level()
		after = v.nodeAfterTree()
		while v and v != after:
			if v.level() - n + 1 &lt; level:
				v.expand()
			else:
				v.contract()
			v = v.threadNext()
	else: # The expansion is global
		# Start the recursion.
		# First contract everything.
		c.contractAllHeadlines()
		v = c.rootVnode()
		while v:
			c.expandTreeToLevelFromLevel(v,level,1)
			v = v.next()
	c.expansionLevel = level
	c.expansionNode = c.currentVnode()
	c.endUpdate()</t>
<t tx="T2641"></t>
<t tx="T2642"># Compatibility with scripts

def currentVnode (self):

	return self.frame.currentVnode()
</t>
<t tx="T2643">def clearAllMarked (self):

	c = self ; v = c.rootVnode()
	while v:
		v.clearMarked()
		v = v.threadNext()</t>
<t tx="T2644">def clearAllVisited (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		# tick("clearAllVisited loop")
		v.clearVisited()
		if v.t:
			v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate(false) # never redraw the tree.</t>
<t tx="T2645"># Compatibility with scripts

def fileName (self):

	return self.mFileName
</t>
<t tx="T2646">def isChanged (self):

	return self.changed</t>
<t tx="T2647"># Compatibility with scripts

def rootVnode (self):

	return self.frame.rootVnode()
</t>
<t tx="T2648"></t>
<t tx="T2649">def goToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isDirty():
		v = v.threadNext()
	if not v:
		v = c.rootVnode()
		while v and not v.isDirty():
			v = v.threadNext()
	if v:
		c.selectVnode(v)</t>
<t tx="T2650">def goToNextMarkedHeadline(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isMarked():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2651">def goToNextClone(self):

	c = self ; current = c.currentVnode()
	if not current: return
	if not current.isCloned(): return

	v = current.threadNext()
	while v and v.t != current.t:
		v = v.threadNext()
		
	if not v:
		# Wrap around.
		v = c.rootVnode()
		while v and v != current and v.t != current.t:
			v = v.threadNext()

	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2652">def markChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			v.setMarked()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2653">def markChangedRoots (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			s = v.bodyString()
			flag, i = is_special(s,0,"@root")
			if flag:
				v.setMarked()
				c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2654">def markAllAtFileNodesDirty (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isAtFileNode()and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2655">def markAtFileNodesDirty (self):

	c = self
	v = c.currentVnode()
	if not v: return
	after = v.nodeAfterTree()
	c.beginUpdate()
	while v and v != after:
		if v.isAtFileNode() and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2656">def markClones (self):

	c = self ; current = v = c.currentVnode()
	if not v: return
	if not v.isCloned(): return
	
	v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.t == current.t:
			v.setMarked()
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2657">def markHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return

	c.beginUpdate()
	if v.isMarked():
		v.clearMarked()
	else:
		v.setMarked()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T2658">def markSubheads(self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	while child:
		if not child.isMarked():
			child.setMarked()
			child.setDirty()
			c.setChanged(true)
		child = child.next()
	c.endUpdate()</t>
<t tx="T2659">def unmarkAll(self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isMarked():
			v.clearMarked()
			v.setDirty()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2660"></t>
<t tx="T2661"># Selects v: sets the focus to v and edits v.

def editVnode(self,v):

	c = self
	# trace(v)
	if v:
		c.selectVnode(v)
		c.frame.editLabel(v)</t>
<t tx="T2662"># Ends the editing in the outline.

def endEditing(self):

	self.frame.endEditLabel()
</t>
<t tx="T2663">def selectThreadBack(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.threadBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T2664">def selectThreadNext(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2665"># This has an up arrow for a control key.

def selectVisBack(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.visBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2666">def selectVisNext(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.visNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T2667"># This is called inside commands to select a new vnode.

def selectVnode(self,v,updateBeadList=true):

	# All updating and "synching" of nodes are now done in the event handlers!
	c = self
	c.frame.endEditLabel()
	c.frame.select(v,updateBeadList)
	# trace(v)
	set_focus(c,c.body)
	self.editing = false</t>
<t tx="T2668"># Selects the given node and enables editing of the headline if editFlag is true.

def selectVnodeWithEditing(self,v,editFlag):

	c = self
	if editFlag:
		c.editVnode(v)
	else:
		c.selectVnode(v)
</t>
<t tx="T2669">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="T2670">def updateSyntaxColorer(self,v):

	self.frame.updateSyntaxColorer(v)
</t>
<t tx="T2671">@language python

# The code for Leo's Compare Panel and the compare class.

from leoGlobals import *
import difflib,filecmp,os,string
import Tkinter,tkFileDialog

@others

if __name__ == "__main__":
	pass</t>
<t tx="T2672">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b
</t>
<t tx="T2673">def go ():

	cmp = leoCompare(
		commands = None,
		
		appendOutput = true,

		ignoreBlankLines = true,
		ignoreFirstLine1 = false,
		ignoreFirstLine2 = false,
		ignoreInteriorWhitespace = false,
		ignoreLeadingWhitespace = true,
		ignoreSentinelLines = false,
		
		limitCount = 9, # Zero means don't stop.
		limitToExtension = ".py",  # For directory compares.
		makeWhitespaceVisible = true,
		
		printBothMatches = false,
		printMatches = false,
		printMismatches = true,
		printTrailingMismatches = false,

		outputFileName = None)

	if 1: # Compare all files in Tangle test directories

		path1 = "c:\\prog\\test\\tangleTest\\"
		path2 = "c:\\prog\\test\\tangleTestCB\\"
		cmp.compare_directories(path1,path2)

	else: # Compare two files.

		name1 = "c:\\prog\\test\\compare1.txt"
		name2 = "c:\\prog\\test\\compare2.txt"
		cmp.compare_files(name1,name2)</t>
<t tx="T2674">class baseLeoCompare:
	"""The base class for Leo's compare code."""
	@others
	
class leoCompare (baseLeoCompare):
	"""A class containing Leo's compare code."""
	pass</t>
<t tx="T2675"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

	# Keyword arguments are much convenient and more clear for scripts.
	commands = None,
	
	appendOutput = false,

	ignoreBlankLines = true,
	ignoreFirstLine1 = false,
	ignoreFirstLine2 = false,
	ignoreInteriorWhitespace = false,
	ignoreLeadingWhitespace = true,
	ignoreSentinelLines = false,

	limitCount = 0, # Zero means don't stop.
	limitToExtension = ".py",  # For directory compares.
	makeWhitespaceVisible = true,

	printBothMatches = false,
	printMatches = false,
	printMismatches = true,
	printTrailingMismatches = false,

	outputFileName = None ):
		
	# It is more convenient for the leoComparePanel to set these directly.
	self.commands = commands
	
	self.appendOutput = appendOutput

	self.ignoreBlankLines = ignoreBlankLines
	self.ignoreFirstLine1 = ignoreFirstLine1
	self.ignoreFirstLine2 = ignoreFirstLine2
	self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
	self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
	self.ignoreSentinelLines = ignoreSentinelLines

	self.limitCount = limitCount
	self.limitToExtension = limitToExtension

	self.printBothMatches = printBothMatches
	self.printMatches = printMatches
	self.printMismatches = printMismatches
	self.printTrailingMismatches = printTrailingMismatches
	
	# For communication between methods...
	self.outputFileName = outputFileName
	self.fileName1 = None 
	self.fileName2 = None
	# Open files...
	self.outputFile = None</t>
<t tx="T2676"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
	
	# Ignore everything except the directory name.
	dir1 = os.path.dirname(path1)
	dir2 = os.path.dirname(path2)
	dir1 = os.path.normpath(dir1)
	dir2 = os.path.normpath(dir2)
	
	if dir1 == dir2:
		self.show("Directory names are identical.\nPlease pick distinct directories.")
		return
		
	try:
		list1 = os.listdir(dir1)
	except:
		self.show("invalid directory:" + dir1)
		return
	try:
		list2 = os.listdir(dir2)
	except:
		self.show("invalid directory:" + dir2)
		return
		
	if self.outputFileName:
		self.openOutputFile()
	ok = self.outputFileName == None or self.outputFile
	if not ok:
		return

	# Create files and files2, the lists of files to be compared.
	files1 = []
	files2 = []
	for f in list1:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files1.append(f)
		else:
			files1.append(f)
	for f in list2:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files2.append(f)
		else:
			files2.append(f)

	# Compare the files and set the yes, no and fail lists.
	yes = [] ; no = [] ; fail = []
	for f1 in files1:
		head,f2 = os.path.split(f1)
		if f2 in files2:
			try:
				name1 = os.path.join(dir1,f1)
				name2 = os.path.join(dir2,f2)
				val = filecmp.cmp(name1,name2,0)
				if val: yes.append(f1)
				else:    no.append(f1)
			except:
				self.show("exception in filecmp.cmp")
				es_exception()
				fail.append(f1)
		else:
			fail.append(f1)
	
	# Print the results.
	for kind, files in (
		("----- matches --------",yes),
		("----- mismatches -----",no),
		("----- not found ------",fail)):
		self.show(kind)
		for f in files:
			self.show(f)
	
	if self.outputFile:
		self.outputFile.close()
		self.outputFile = None</t>
<t tx="T2677">def compare_files (self, name1, name2):
	
	if name1 == name2:
		self.show("File names are identical.\nPlease pick distinct files.")
		return

	f1 = f2 = None
	try:
		f1 = self.doOpen(name1)
		f2 = self.doOpen(name2)
		if self.outputFileName:
			self.openOutputFile()
		ok = self.outputFileName == None or self.outputFile
		ok = choose(ok and ok != 0,1,0)
		if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
			self.compare_open_files(f1,f2,name1,name2)
	except:
		self.show("exception comparing files")
		es_exception()
	try:
		if f1: f1.close()
		if f2: f2.close()
		if self.outputFile:
			self.outputFile.close() ; self.outputFile = None
	except:
		self.show("exception closing files")
		es_exception()</t>
<t tx="T2678">def compare_lines (self,s1,s2):
	
	if self.ignoreLeadingWhitespace:
		s1 = string.lstrip(s1)
		s2 = string.lstrip(s2)

	if self.ignoreInteriorWhitespace:
		k1 = skip_ws(s1,0)
		k2 = skip_ws(s2,0)
		ws1 = s1[:k1]
		ws2 = s2[:k2]
		tail1 = s1[k1:]
		tail2 = s2[k2:]
		tail1 = string.replace(tail1," ","")
		tail1 = string.replace(tail1,"\t","")
		tail2 = string.replace(tail2," ","")
		tail2 = string.replace(tail2,"\t","")
		s1 = ws1 + tail1
		s2 = ws2 + tail2

	return s1 == s2</t>
<t tx="T2679">def compare_open_files (self, f1, f2, name1, name2):

	# self.show("compare_open_files")
	lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = true
	sentinelComment1 = sentinelComment2 = None
	if self.openOutputFile():
		self.show("1: " + name1)
		self.show("2: " + name2)
		self.show("")
	s1 = s2 = None
	&lt;&lt; handle opening lines &gt;&gt;
	while 1:
		if s1 == None:
			s1 = readlineForceUnixNewline(f1) ; lines1 += 1
		if s2 == None:
			s2 = readlineForceUnixNewline(f2) ; lines2 += 1
		&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
		n1 = len(s1) ; n2 = len(s2)
		if n1==0 and n2 != 0: self.show("1.eof***:")
		if n2==0 and n1 != 0: self.show("2.eof***:")
		if n1==0 or n2==0: break
		match = self.compare_lines(s1,s2)
		if not match: mismatches += 1
		&lt;&lt; print matches and/or mismatches &gt;&gt;
		&lt;&lt; warn if mismatch limit reached &gt;&gt;
		s1 = s2 = None # force a read of both lines.
	&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</t>
<t tx="T2680">if self.ignoreSentinelLines:
	
	s1 = readlineForceUnixNewline(f1) ; lines1 += 1
	s2 = readlineForceUnixNewline(f2) ; lines2 += 1
	# Note: isLeoHeader may return None.
	sentinelComment1 = self.isLeoHeader(s1)
	sentinelComment2 = self.isLeoHeader(s2)
	if not sentinelComment1: self.show("no @+leo line for " + name1)
	if not sentinelComment2: self.show("no @+leo line for " + name2)
		
if self.ignoreFirstLine1:
	if s1 == None:
		readlineForceUnixNewline(f1) ; lines1 += 1
	s1 = None

if self.ignoreFirstLine2:
	if s2 == None:
		readlineForceUnixNewline(f2) ; lines2 += 1
	s2 = None</t>
<t tx="T2681"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s1)) == 0:
		s1 = None ; continue
		
	if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
		s1 = None ; continue

if s2 and len(s2) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s2)) == 0:
		s2 = None ; continue

	if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
		s2 = None ; continue
</t>
<t tx="T2682">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

	if match and self.printMatches:
		
		if self.printBothMatches:
			self.dump(string.rjust("1." + `lines1`,6) + ' :',s1)
			self.dump(string.rjust("2." + `lines2`,6) + ' :',s2)
		else:
			self.dump(string.rjust(       `lines1`,6) + ' :',s1)
	
	if not match and self.printMismatches:
		
		self.dump(string.rjust("1." + `lines1`,6) + '*:',s1)
		self.dump(string.rjust("2." + `lines2`,6) + '*:',s2)</t>
<t tx="T2683">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:
	
	if printTrailing:
		self.show("")
		self.show("limit count reached")
		self.show("")
		printTrailing = false</t>
<t tx="T2684">if n1 &gt; 0: 
	lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)
	
if n2 &gt; 0:
	lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + `lines1`)
self.show("lines2:" + `lines2`)
self.show("mismatches:" + `mismatches`)</t>
<t tx="T2685">def filecmp (self,f1,f2):

	val = filecmp.cmp(f1,f2)
	if 1:
		if val: self.show("equal")
		else:   self.show("*** not equal")
	else:
		self.show("filecmp.cmp returns:")
		if val: self.show(`val` + " (equal)")
		else:   self.show(`val` + " (not equal)")
	return val</t>
<t tx="T2686"></t>
<t tx="T2687">def doOpen (self,name):

	try:
		f = open(name,'r')
		return f
	except:
		self.show("can not open:" + '"' + name + '"')
		return None</t>
<t tx="T2688">def dump (self,tag,s):

	cmp = self ; out = tag

	for ch in s[:-1]: # don't print the newline
	
		if cmp.makeWhitespaceVisible:
			if ch == '\t':
				out += "[" ; out += "t" ; out += "]"
			elif ch == ' ':
				out += "[" ; out += " " ; out += "]"
			else: out += ch
		else:
			if 1:
				out += ch
			else: # I don't know why I thought this was a good idea ;-)
				if ch == '\t' or ch == ' ':
					out += ' '
				else:
					out += ch

	self.show(out)</t>
<t tx="T2689">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

	trailingLines = 0
	while 1:
		if not s:
			s = readlineForceUnixNewline(f)
		if len(s) == 0: break
		trailingLines += 1
		if self.printTrailingMismatches and printTrailing:
			tag2 = string.rjust(tag + `line`,6) + "+:"
			self.dump(tag2,s)
		s = None

	self.show(tag + `trailingLines` + " trailing lines")
	return trailingLines</t>
<t tx="T2690">@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

	tag = "@+leo"
	j = string.find(s,tag)
	if j &gt; 0:
		i = skip_ws(s,0)
		if i &lt; j: return s[i:j]
		else: return None
	else: return None
		
def isSentinel (self,s,sentinelComment):

	i = skip_ws(s,0)
	return match(s,i,sentinelComment)</t>
<t tx="T2691">def show (self,s):
	
	# print s
	if self.outputFile:
		self.outputFile.write(s + '\n')
	elif self.commands:
		es(s)
	else:
		print s
		print</t>
<t tx="T2692">def showIvars (self):
	
	self.show("fileName1:"        + `self.fileName1`)
	self.show("fileName2:"        + `self.fileName2`)
	self.show("outputFileName:"   + `self.outputFileName`)
	self.show("limitToExtension:" + `self.limitToExtension`)
	self.show("")

	self.show("ignoreBlankLines:"         + `self.ignoreBlankLines`)
	self.show("ignoreFirstLine1:"         + `self.ignoreFirstLine1`)
	self.show("ignoreFirstLine2:"         + `self.ignoreFirstLine2`)
	self.show("ignoreInteriorWhitespace:" + `self.ignoreInteriorWhitespace`)
	self.show("ignoreLeadingWhitespace:"  + `self.ignoreLeadingWhitespace`)
	self.show("ignoreSentinelLines:"      + `self.ignoreSentinelLines`)
	self.show("")
	
	self.show("limitCount:"              + `self.limitCount`)
	self.show("printMatches:"            + `self.printMatches`)
	self.show("printMismatches:"         + `self.printMismatches`)
	self.show("printTrailingMismatches:" + `self.printTrailingMismatches`)</t>
<t tx="T2693">class baseLeoComparePanel:
	"""The base class for Leo's compare panel."""
	@others
	
class leoComparePanel (baseLeoComparePanel):
	"""A class that creates Leo's compare panel."""
	pass
</t>
<t tx="T2694">def browser (self,n):
	
	types = [
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py"),
		("Text files","*.txt"),
		("All files","*") ]

	fileName = tkFileDialog.askopenfilename(
		title="Choose compare file" + n,
		filetypes=types,
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		# The dialog also warns about this, so this may never happen.
		if not os.path.exists(fileName):
			self.show("not found: " + fileName)
			fileName = None
	else: fileName = None
		
	return fileName</t>
<t tx="T2695"># Initialize ivars from config parameters.

def finishCreate (self):

	config = app.config
	
	# File names.
	for i,option in (
		(0,"compare_file_1"),
		(1,"compare_file_2"),
		(2,"output_file") ):
			
		name = config.getComparePref(option)
		if name and len(name) &gt; 0:
			e = self.browseEntries[i]
			e.delete(0,"end")
			e.insert(0,name)
			
	name = config.getComparePref("output_file")
	b = choose(name and len(name) &gt; 0,1,0)
	self.useOutputFileVar.set(b)

	# File options.
	b = config.getBoolComparePref("ignore_first_line_of_file_1")
	if b == None: b = 0
	self.ignoreFirstLine1Var.set(b)
	
	b = config.getBoolComparePref("ignore_first_line_of_file_2")
	if b == None: b = 0
	self.ignoreFirstLine2Var.set(b)
	
	b = config.getBoolComparePref("append_output_to_output_file")
	if b == None: b = 0
	self.appendOutputVar.set(b)

	ext = config.getComparePref("limit_directory_search_extension")
	b = ext and len(ext) &gt; 0
	b = choose(b and b != 0,1,0)
	self.limitToExtensionVar.set(b)
	if b:
		e = self.extensionEntry
		e.delete(0,"end")
		e.insert(0,ext)
		
	# Print options.
	b = config.getBoolComparePref("print_both_lines_for_matches")
	if b == None: b = 0
	self.printBothMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_matching_lines")
	if b == None: b = 0
	self.printMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_mismatching_lines")
	if b == None: b = 0
	self.printMismatchesVar.set(b)
	
	b = config.getBoolComparePref("print_trailing_lines")
	if b == None: b = 0
	self.printTrailingMismatchesVar.set(b)
	
	n = config.getIntComparePref("limit_count")
	b = n and n &gt; 0
	b = choose(b and b != 0,1,0)
	self.stopAfterMismatchVar.set(b)
	if b:
		e = self.countEntry
		e.delete(0,"end")
		e.insert(0,`n`)

	# Whitespace options.
	b = config.getBoolComparePref("ignore_blank_lines")
	if b == None: b = 1 # unusual default.
	self.ignoreBlankLinesVar.set(b)
	
	b = config.getBoolComparePref("ignore_interior_whitespace")
	if b == None: b = 0
	self.ignoreInteriorWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_leading_whitespace")
	if b == None: b = 0
	self.ignoreLeadingWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_sentinel_lines")
	if b == None: b = 0
	self.ignoreSentinelLinesVar.set(b)
	
	b = config.getBoolComparePref("make_whitespace_visible")
	if b == None: b = 0
	self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="T2696">def show (self,s):
	
	self.cmp.show(s)</t>
<t tx="T2697">def setIvarsFromWidgets (self):

	cmp = self.cmp
	
	# File paths. cmp checks for valid file name.
	e = self.browseEntries[0]
	cmp.fileName1 = e.get()
	
	e = self.browseEntries[1]
	cmp.fileName2 = e.get()

	# Ignore first line settings.
	cmp.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
	cmp.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
	
	# Output file.  cmp checks for valid file name.
	if self.useOutputFileVar.get():
		e = self.browseEntries[2]
		name = e.get()
		if name != None and len(name) == 0:
			name = None
		cmp.outputFileName = name
	else:
		cmp.outputFileName = None

	# Extension settings.
	if self.limitToExtensionVar.get():
		cmp.limitToExtension = self.extensionEntry.get()
		if len(cmp.limitToExtension) == 0:
			cmp.limitToExtension = None
	else:
		cmp.limitToExtension = None
		
	cmp.appendOutput = self.appendOutputVar.get()
	
	# Whitespace options.
	cmp.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
	cmp.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
	cmp.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
	cmp.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
	cmp.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
	
	# Print options.
	cmp.printMatches            = self.printMatchesVar.get()
	cmp.printMismatches         = self.printMismatchesVar.get()
	cmp.printTrailingMismatches = self.printTrailingMismatchesVar.get()
	
	if cmp.printMatches:
		cmp.printBothMatches = self.printBothMatchesVar.get()
	else:
		cmp.printBothMatches = false
	
	if self.stopAfterMismatchVar.get():
		try:
			count = self.countEntry.get()
			cmp.limitCount = int(count)
		except: cmp.limitCount = 0
	else:
		cmp.limitCount = 0</t>
<t tx="T2698"></t>
<t tx="T2699">def onBrowse1 (self):
	
	fileName = self.browser("1")
	if fileName:
		e = self.browseEntries[0]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse2 (self):
	
	fileName = self.browser("2")
	if fileName:
		e = self.browseEntries[1]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse3 (self): # Get the name of the output file.

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.defaultOutputFileName,
		title="Set output file",
		filetypes=[("Text files", "*.txt")],
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		self.defaultOutputFileName = fileName
		self.useOutputFileVar.set(1) # The user will expect this.
		e = self.browseEntries[2]
		e.delete(0,"end")
		e.insert(0,fileName)</t>
<t tx="T2700">def onClose (self):
	
	self.top.withdraw()</t>
<t tx="T2701">def onCompareDirectories (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_directories(cmp.fileName1,cmp.fileName2)

def onCompareFiles (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_files(cmp.fileName1,cmp.fileName2)</t>
<t tx="T2702">def onPrintMatchedLines (self):
	
	v = self.printMatchesVar.get()
	b = self.printButtons[1]
	state = choose(v,"normal","disabled")
	b.configure(state=state)</t>
<t tx="T2703">@language python

from leoGlobals import *
import leoFind
import ConfigParser,exceptions,os,string,sys

class baseConfig:
	"""The base class for Leo's configuration handler."""
	&lt;&lt; define defaultsDict &gt;&gt;
	@others
	
class config (baseConfig):
	"""A class to manage configuration settings."""
	pass</t>
<t tx="T2704">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = choose(sys.platform=="win32",9,12)

defaultsDict = {
	# compare options...
	"ignore_blank_lines" : 1,
	"limit_count" : 9,
	"print_mismatching_lines" : 1,
	"print_trailing_lines" : 1,
	# find/change options...
	"search_body" : 1,
	"whole_word" : 1,
	# Prefs panel.
	"default_target_language" : "Python",
	"tab_width" : 4,
	"page_width" : 132,
	"output_doc_chunks" : 1,
	"tangle_outputs_header" : 1,
	# Syntax coloring options...
	# Defaults for colors are handled by leoColor.py.
	"color_directives_in_plain_text" : 1,
	"underline_undefined_section_names" : 1,
	# Window options...
	"allow_clone_drags" : 1,
	"body_pane_wraps" : 1,
	"body_text_font_family" : "Courier",
	"body_text_font_size" : defaultBodyFontSize,
	"body_text_font_slant" : "roman",
	"body_text_font_weight" : "normal",
	"enable_drag_messages" : 1,
	"headline_text_font_size" : 12,
	"headline_text_font_slant" : "roman",
	"headline_text_font_weight" : "normal",
	"log_text_font_size" : 12,
	"log_text_font_slant" : "roman",
	"log_text_font_weight" : "normal",
	"initial_window_height" : 600, # 7/24/03: In pixels.
	"initial_window_width" :  800, # 7/24/03: In pixels.
	"initial_window_left" : 10,
	"initial_window_top" : 10,
	"initial_splitter_orientation" : "vertical",
	"initial_vertical_ratio" : 0.5,
	"initial_horizontal_ratio" : 0.3,
	"initial_horizontal_secondary_ratio" : 0.5,
	"initial_vertical_secondary_ratio" : 0.7,
	"outline_pane_scrolls_horizontally" : 0,
	"split_bar_color" : "LightSteelBlue2",
	"split_bar_relief" : "groove",
	"split_bar_width" : 7 }</t>
<t tx="T2705">def __init__ (self):

	self.init()

def init (self):

	try:
		self.configDir = sys.leo_config_directory
	except:
		self.configDir = os.path.join(app.loadDir,"..","config")

	self.configFileName = os.path.join(self.configDir,"leoConfig.txt")
	self.configsExist = false # True when we successfully open leoConfig.txt.
	
	# These are now set in gui.getDefaultConfigFont
	self.defaultFont = None
	self.defaultFontFamily = None
	
	&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt;
	&lt;&lt; initialize ivars that may be set by config options &gt;&gt;

	self.open() # read and process the configuration file.</t>
<t tx="T2706"># Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.keysSection = "keyboard shortcuts"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"

# List of recent files.
self.recentFiles = []

# Section dictionaries
self.compareDict = {}
self.configDict = {} # 10/11/02: we use a dict even for ivars.
self.findDict = {}
self.keysDict = {}
self.prefsDict = {}
self.colorsDict = {}
self.windowDict = {}

# Associations of sections and dictionaries.
self.sectionInfo = (
	(self.configSection,self.configDict),
	(self.compareSection,self.compareDict),
	(self.findSection,self.findDict),
	(self.keysSection,self.keysDict),
	(self.prefsSection,self.prefsDict),
	(self.recentFilesSection,None),
	(self.colorsSection,self.colorsDict),
	(self.windowSection,self.windowDict) )</t>
<t tx="T2707"># 10/11/02: Defaults are specified only here.

self.config = None # The current instance of ConfigParser
self.at_root_bodies_start_in_doc_mode = true # For compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.create_nonexistent_directories = false
self.default_derived_file_encoding = "utf-8"
self.load_derived_files_immediately = 0
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.read_only = true # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = false
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = false
self.stylesheet = None
self.thin_at_file_trees = 0
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.use_plugins = false # Should never be true here!
self.write_old_format_derived_files = false # Use new format if leoConfig.txt does not exist.</t>
<t tx="T2708"></t>
<t tx="T2709">def getBoolFromDict (self,name,dict):
	val = self.getIntFromDict(name,dict)
	if val and val != None and val != 0: val = 1
	return val

def getFloatFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = float(val)
		except: val = None
	return val

def getFromDict (self,name,dict):
	val = dict.get(name)
	if val == "ignore":
		val = None
	elif val == None:
		val = self.defaultsDict.get(name)
	return val

def getIntFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = int(val)
		except: val = None
	return val

def setDict (self,name,val,dict):
	dict [name] = val
		
getStringFromDict = getFromDict
</t>
<t tx="T2710">def getBoolColorsPref (self,name):
	return self.getBoolFromDict(name,self.colorsDict)
	
# Basic getters and setters.

def getColorsPref (self,name):
	return self.getFromDict(name,self.colorsDict)

def setColorsPref (self,name,val):
	self.setDict(name,val,self.colorsDict)
	
getStringColorsPref = getColorsPref</t>
<t tx="T2711">def getBoolComparePref (self,name):
	return self.getBoolFromDict(name,self.compareDict)
	
def getIntComparePref (self,name):
	return self.getIntFromDict(name,self.compareDict)

# Basic getters and setters.

def getComparePref (self,name):
	return self.getFromDict(name,self.compareDict)

def setComparePref (self,name,val):
	self.setDict(name,val,self.compareDict)
	
getStringComparePref = getComparePref</t>
<t tx="T2712">def getBoolFindPref (self,name):
	return self.getBoolFromDict(name,self.findDict)

# Basic getters and setters.

def getFindPref (self,name):
	return self.getFromDict(name,self.findDict)

def setFindPref (self,name,val):
	self.setDict(name,val,self.findDict)
	
getStringFindPref = getFindPref</t>
<t tx="T2713">def getBoolPref (self,name):
	return self.getBoolFromDict(name,self.prefsDict)

def getIntPref (self,name):
	return self.getIntFromDict(name,self.prefsDict)
	
# Basic getters and setters.

def getPref (self,name):
	return self.getFromDict(name,self.prefsDict)

def setPref (self,name,val):
	self.setDict(name,val,self.prefsDict)
	
getStringPref = getPref</t>
<t tx="T2714">def getRecentFiles (self):
	
	return self.recentFiles

def setRecentFiles (self,files):
	
	self.recentFiles = files
</t>
<t tx="T2715">def getBoolWindowPref (self,name):
	return self.getBoolFromDict(name,self.windowDict)
	
def getFloatWindowPref (self,name):
	return self.getFloatFromDict(name,self.windowDict)
	
def getIntWindowPref (self,name):
	return self.getIntFromDict(name,self.windowDict)
	
# Basic getters and setters.

def getWindowPref (self,name):
	return self.getFromDict(name,self.windowDict)

def setWindowPref (self,name,val):
	self.setDict(name,val,self.windowDict)
	
getStringWindowPref = getWindowPref</t>
<t tx="T2716">@ A convenience method that computes a font from font parameters.
Arguments are the names of settings to be use.
We return None if there is no family setting so we can use system default fonts.
We default to size=12, slant="roman", weight="normal"
@c

def getFontFromParams(self,family,size,slant,weight):

	family = self.getWindowPref(family)
	if not family or family == "":
		# print tag,"using default"
		family = self.defaultFontFamily
		
	size = self.getIntWindowPref(size)
	if not size or size == 0: size = 12
	
	slant = self.getWindowPref(slant)
	if not slant or slant == "": slant = "roman"
	
	weight = self.getWindowPref(weight)
	if not weight or weight == "": weight = "normal"
	
	return app.gui.getFontFromParams(family,size,slant,weight)</t>
<t tx="T2717">def initConfigParam (self,name,defaultVal):
	try:
		val = self.config.get(self.configSection,name,raw=1) # 2/4/03
	except:
		val = defaultVal
	return val

def initBooleanConfigParam (self,name,defaultVal):
	try:
		val = self.config.getboolean(self.configSection,name)
	except:
		val = defaultVal
	return val
</t>
<t tx="T2718"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

	config = self
	&lt;&lt; set prefs ivars &gt;&gt;</t>
<t tx="T2719">val = config.getIntPref("tab_width")
if val:
	c.tab_width = val
	if 0: # 9/20/02: don't actually redraw.
		c.frame.setTabWidth(c.tab_width)

val = config.getIntPref("page_width")
if val: c.page_width = val

val = config.getIntPref("run_tangle_done.py")
if val: c.tangle_batch_flag = val

val = config.getIntPref("run_untangle_done.py")
if val: c.untangle_batch_flag = val

val = config.getIntPref("output_doc_chunks")
if val: c.output_doc_flag = val

val = config.getIntPref("tangle_outputs_header")
if val: c.use_header_flag = val

val = config.getPref("default_tangle_directory")
if val: c.tangle_directory = val

val = config.getPref("find_string")
if val: c.tangle_directory = val

c.target_language = "python" # default
val = config.getPref("default_target_language")
if val:
	try:
		val = string.lower(val)
		val = string.replace(val,"/","")
		if app.language_delims_dict.get(val):
			c.target_language = val
		
	except: pass</t>
<t tx="T2720"># Sets config ivars from c.

def setConfigIvars (self,c):
	
	if c.target_language and app.language_delims_dict.get(c.target_language):
		language = c.target_language
	else:
		language = "plain"
	self.setPref("default_tangle_directory",c.tangle_directory)
	self.setPref("default_target_language",language)
	self.setPref("output_doc_chunks",`c.output_doc_flag`)
	self.setPref("page_width",`c.page_width`)
	self.setPref("run_tangle_done.py",`c.tangle_batch_flag`)
	self.setPref("run_untangle_done.py",`c.untangle_batch_flag`)
	self.setPref("tab_width",`c.tab_width`)
	self.setPref("tangle_outputs_header",`c.use_header_flag`)
	
	self.setFindPref("batch",`c.batch_flag`)
	self.setFindPref("ignore_case",`c.ignore_case_flag`)
	self.setFindPref("mark_changes",`c.mark_changes_flag`)
	self.setFindPref("mark_finds",`c.mark_finds_flag`)
	self.setFindPref("pattern_match",`c.pattern_match_flag`)
	self.setFindPref("reverse",`c.reverse_flag`)
	self.setFindPref("search_body",`c.search_body_flag`)
	self.setFindPref("search_headline",`c.search_headline_flag`)
	self.setFindPref("suboutline_only",`c.suboutline_only_flag`)
	self.setFindPref("wrap",`c.wrap_flag`)
	self.setFindPref("whole_word",`c.whole_word_flag`)
	
	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T2721">def open (self):
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		cf = open(self.configFileName)
		config.readfp(cf)
		&lt;&lt; get config options &gt;&gt;
		&lt;&lt; get recent files &gt;&gt;
		for section, dict in self.sectionInfo:
			if dict != None:
				try:
					for opt in config.options(section):
						dict[string.lower(opt)]=config.get(section,opt,raw=1) # 2/4/03
				except: pass
		&lt;&lt; convert find/change options to unicode &gt;&gt;
		&lt;&lt; print options &gt;&gt;
		cf.close()
		self.configsExist = true
	except IOError:
		pass
	except:
		es("Exception opening " + self.configFileName)
		es_exception()
		pass
	self.config = None</t>
<t tx="T2722">section = self.recentFilesSection

if 0: # elegant, but may be a security hole.
	self.recentFiles = eval(config.get(section,"recentFiles",raw=1)) # 2/4/03
else: # easier to read in the config file.
	try:
		for i in xrange(10):
			self.recentFiles.append(config.get(section,"file" + `i`,raw=1)) # 2/4/03
	except: pass</t>
<t tx="T2723">if 0:
	print "\n\ncolorsDict:\n" ,self.colorsDict
	print "\n\ncompareDict:\n",self.compareDict
	print "\n\nfindDict:\n"   ,self.findDict
	print "\n\nprefsDict:\n"  ,self.prefsDict
	print "\n\nwindowDict:\n" ,self.windowDict
if 0:
	print "\n\nkeysDict:\n\n"
	for i in self.keysDict.items():
		print i
if 0:
	print "\n\nwindowDict:\n\n"
	for i in self.windowDict.keys():
		print i</t>
<t tx="T2724">@language python

from leoGlobals import *
import leoDialog
import string,Tkinter

Tk = Tkinter

@others</t>
<t tx="T2725">class aboutLeo (leoDialog):
	"""A class that creates the About Leo dialog."""
	@others
</t>
<t tx="T2726">def __init__ (self,version,copyright,url,email):
	
	"""Create an About Leo dialog."""

	leoDialog.__init__(self,"About Leo",resizeable=true) # Initialize the base class.
	
	self.copyright = copyright
	self.email = email
	self.url = url
	self.version = version

	self.createTopFrame()
	self.createFrame()
</t>
<t tx="T2727">def createFrame (self):
	
	"""Create the frame for an About Leo dialog."""
	
	frame = self.frame
	copyright = self.copyright ; email = self.email
	url = self.url ; version = self.version
	
	# Calculate the approximate height &amp; width. (There are bugs in Tk here.)
	lines = string.split(copyright,'\n')
	height = len(lines) + 8 # Add lines for version,url,email,spacing.
	width = 0
	for line in lines:
		width = max(width,len(line))
	width = max(width,len(url))
	width += 10 # 9/9/02

	frame.pack(padx=6,pady=4)
	
	self.text = text = Tk.Text(frame,height=height,width=width,bd=0,bg=frame.cget("background"))
	text.pack(pady=10)
	
	try:
		bitmap_name = os.path.join(app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
		image = Tkinter.PhotoImage(file=bitmap_name)
		text.image_create("1.0",image=image,padx=10)
	except:
		es("exception getting icon")
		es_exception()

	text.insert("end",version,"version")
	text.insert("end",copyright,"copyright")
	text.insert("end",'\n')
	text.insert("end",url,"url") # Add "url" tag.
	text.insert("end",'\n')
	text.insert("end",email,"email") # Add "email" tag.
	
	text.tag_config("version",justify="center")
	text.tag_config("copyright",justify="center",spacing1="3")
	
	text.tag_config("url",underline=1,justify="center",spacing1="10")
	text.tag_bind("url","&lt;Button-1&gt;",self.onAboutLeoUrl)
	text.tag_bind("url","&lt;Enter&gt;",self.setArrowCursor)
	text.tag_bind("url","&lt;Leave&gt;",self.setDefaultCursor)

	text.tag_config("email",underline=1,justify="center",spacing1="10")
	text.tag_bind("email","&lt;Button-1&gt;",self.onAboutLeoEmail)
	text.tag_bind("email","&lt;Enter&gt;",self.setArrowCursor)
	text.tag_bind("email","&lt;Leave&gt;",self.setDefaultCursor)

	text.configure(state="disabled")</t>
<t tx="T2728">def onAboutLeoEmail(self,event=None):
	
	"""Handle clicks in the email link in an About Leo dialog."""
	
	try:
		import webbrowser
		webbrowser.open("mailto:" + self.email)
	except:
		es("not found: " + self.email)</t>
<t tx="T2729">def onAboutLeoUrl(self,event=None):
	
	"""Handle clicks in the url link in an About Leo dialog."""

	try:
		import webbrowser
		webbrowser.open(self.url)
	except:
		es("not found: " + self.url)</t>
<t tx="T2730">def setArrowCursor (self,event=None):
	
	"""Set the cursor to an arrow in an About Leo dialog."""
	
	self.text.configure(cursor="arrow")
	
def setDefaultCursor (self,event=None):
	
	"""Set the cursor to the default cursor in an About Leo dialog."""
	
	self.text.configure(cursor="xterm")</t>
<t tx="T2731">class askLeoID (leoDialog):
	
	"""A class to create and run a dialog that asks for Id for gnx's."""
	
	@others</t>
<t tx="T2732">def __init__(self):
	
	"""Create the Leo Id dialog."""
	
	leoDialog.__init__(self,"Enter unique id",resizeable=false) # Initialize the base class.
	self.id_entry = None
	self.answer = None

	self.createTopFrame()
	self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
	self.top.bind("&lt;Key&gt;", self.onKey)
	
	message = (
		"leoID.txt not found\n\n" +
		"Please enter an id that identifies you uniquely.\n" +
		"Your cvs login name is a good choice.\n\n" +
		"Your id must contain only letters and numbers\n" +
		"and must be at least 4 characters in length.")
	self.createFrame(message)
	self.focus_widget = self.id_entry

	buttons = {"text":"OK","command":self.onButton,"default":true}, # Singleton tuple.
	buttonList = self.createButtons(buttons)
	self.ok_button = buttonList[0]</t>
<t tx="T2733">def createFrame(self,message):
	
	"""Create the frame for the Leo Id dialog."""
	
	f = self.frame

	label = Tk.Label(f,text=message)
	label.pack(pady=10)

	self.id_entry = text = Tk.Entry(f,width=20)
	text.pack()</t>
<t tx="T2734">def onCloseWindow (self):
	
	"""Prevent the Leo Id dialog from closing by ignoring close events."""

	pass</t>
<t tx="T2735">def onButton(self):
	
	"""Handle clicks in the Leo Id close button."""

	s = self.id_entry.get().strip()
	if len(s) &lt; 4:  # Require at least 4 characters in an id.
		return

	self.answer = s
	self.top.destroy() # terminates wait_window</t>
<t tx="T2736">def onKey(self,event):
	
	"""Handle keystrokes in the Leo Id dialog."""
	
	&lt;&lt; eliminate invalid characters &gt;&gt;
	&lt;&lt; enable the ok button if there are 4 or more valid characters &gt;&gt;
	
	ch = event.char.lower()
	if ch in ('\n','\r'):
		self.onButton()
	return "break"

</t>
<t tx="T2737">e = self.id_entry
s = e.get().strip()
i = 0 ; ok = true
while i &lt; len(s):
	ch = s[i]
	if ch not in string.ascii_letters and ch not in string.digits:
		e.delete(`i`)
		s = e.get()
		ok = false
	else:
		i += 1
if not ok: return</t>
<t tx="T2738">e = self.id_entry
b = self.ok_button

if len(e.get().strip()) &gt;= 4:
	b.configure(state="normal")
else:
	b.configure(state="disabled")</t>
<t tx="T2739">class askOk(leoDialog):
	"""A class that creates a dialog with a single OK button."""
	@others</t>
<t tx="T2740">def __init__ (self,title,message=None,text="Ok",resizeable=false):

	"""Create a dialog with one button"""

	leoDialog.__init__(self,title,resizeable) # Initialize the base class.
	self.text = text
	self.createTopFrame()
	self.top.bind("&lt;Key&gt;", self.onKey)

	if message:
		self.createMessageFrame(message)

	buttons = {"text":text,"command":self.okButton,"default":true}, # Singleton tuple.
	self.createButtons(buttons)</t>
<t tx="T2741">def onKey(self,event):
	
	"""Handle Key events in askOk dialogs."""

	ch = event.char.lower()

	if ch in (self.text[0].lower(),'\n','\r'):
		self.okButton()

	return "break"
</t>
<t tx="T2742">class askOkCancel (leoDialog):
	"""A class that creates a dialog with two buttons: Ok and Cancel."""
	@others</t>
<t tx="T2743">def __init__ (self,title,message=None,resizeable=false):
	
	"""Create a dialog having Ok and Cancel buttons."""

	leoDialog.__init__(self,title,resizeable) # Initialize the base class.
	self.createTopFrame()
	self.top.bind("&lt;Key&gt;",self.onKey)

	if message:
		self.createMessageFrame(message)
		
	buttons = (
		{"text":"Ok",    "command":self.okButton,     "default":true},
		{"text":"Cancel","command":self.cancelButton} )
	self.createButtons(buttons)
</t>
<t tx="T2744">def onKey(self,event):
	
	"""Handle keystrokes in a dialog having Ok and Cancel buttons."""

	ch = event.char.lower()
	if ch in ('o','\n','\r'):
		self.okButton()
	elif ch == 'c':
		self.cancelButton()

	return "break"</t>
<t tx="T2745">class  askOkCancelNumber (leoDialog):
	"""Create and run a modal dialog to get a number."""
	@others
</t>
<t tx="T2746">def __init__ (self,title,message):
	
	"""Create a number dialog"""

	leoDialog.__init__(self,title,resizeable=false) # Initialize the base class.
	self.answer = -1
	self.number_entry = None

	self.createTopFrame()
	self.top.bind("&lt;Key&gt;", self.onKey)

	self.createFrame(message)
	self.focus_widget = self.number_entry

	buttons = (
			{"text":"Ok",    "command":self.okButton,     "default":true},
			{"text":"Cancel","command":self.cancelButton} )
	buttonList = self.createButtons(buttons)
	self.ok_button = buttonList[0] # Override the default kind of Ok button.</t>
<t tx="T2747">def createFrame (self,message):
	
	"""Create the frame for a number dialog."""
	
	f = self.frame
	
	lab = Tk.Label(f,text=message)
	lab.pack(pady=10,side="left")
	
	self.number_entry = t = Tk.Entry(f,width=20)
	t.pack(side="left")</t>
<t tx="T2748">def okButton(self):
	
	"""Handle clicks in the ok button of a number dialog."""

	s = self.number_entry.get().strip()

	try:
		self.answer=int(s)
	except:
		self.answer=-1 # Cancel the operation.

	self.top.destroy()
	
def cancelButton(self):
	
	"""Handle clicks in the cancel button of a number dialog."""

	self.answer=-1
	self.top.destroy()</t>
<t tx="T2749">def onKey (self,event):
	
	&lt;&lt; eliminate non-numbers &gt;&gt;

	ch = event.char.lower()

	if ch in ('o','\n','\r'):
		self.okButton()
	elif ch == 'c':
		self.cancelButton()

	return "break"</t>
<t tx="T2750">e = self.number_entry
s = e.get().strip()

i = 0
while i &lt; len(s):
	ch = s[i]
	if ch not in string.digits:
		e.delete(`i`)
		s = e.get()
	else:
		i += 1</t>
<t tx="T2751">class askYesNo (leoDialog):
	"""A class that creates a dialog with two buttons: Yes and No."""
	@others

</t>
<t tx="T2752">def __init__ (self,title,message=None,resizeable=false):
	
	"""Create a dialog having yes and no buttons."""

	leoDialog.__init__(self,title,resizeable) # Initialize the base class.
	self.createTopFrame()
	self.top.bind("&lt;Key&gt;",self.onKey)

	if message:
		self.createMessageFrame(message)
		
	buttons = (
		{"text":"Yes","command":self.yesButton,  "default":true},
		{"text":"No", "command":self.noButton} )
	self.createButtons(buttons)
</t>
<t tx="T2753">def onKey(self,event):
	
	"""Handle keystroke events in dialogs having yes and no buttons."""

	ch = event.char.lower()

	if ch in ('y','\n','\r'):
		self.yesButton()
	elif ch == 'n':
		self.noButton()

	return "break"</t>
<t tx="T2754">class askYesNoCancel(leoDialog):
	
	"""A class to create and run dialogs having three buttons.
	
	By default, these buttons are labeled Yes, No and Cancel."""
	
	@others
</t>
<t tx="T2755">def __init__ (self,title,
	message=None,
	yesMessage="Yes",
	noMessage="No",
	defaultButton="Yes",
	resizeable=false):
		
	"""Create a dialog having three buttons."""

	leoDialog.__init__(self,title,resizeable) # Initialize the base class.
	self.yesMessage,self.noMessage = yesMessage,noMessage
	self.defaultButton = defaultButton

	self.createTopFrame()
	self.top.bind("&lt;Key&gt;",self.onKey)

	if message:
		self.createMessageFrame(message)
		
	buttons = (
		{"text":yesMessage,"command":self.yesButton,   "default":yesMessage==defaultButton},
		{"text":noMessage, "command":self.noButton,    "default":noMessage==defaultButton},
		{"text":"Cancel",  "command":self.cancelButton,"default":"Cancel"==defaultButton} )
	self.createButtons(buttons)

</t>
<t tx="T2756">def onKey(self,event):
	
	"""Handle keystrokes in dialogs with three buttons."""

	ch = event.char.lower()
	
	if ch in ('\n','\r'):
		ch = self.defaultButton[0].lower()

	if ch == self.yesMessage[0].lower():
		self.yesButton()
	elif ch == self.noMessage[0].lower():
		self.noButton()
	elif ch == 'c':
		self.cancelButton()

	return "break"</t>
<t tx="T2757">def noButton(self):
	
	"""Handle clicks in the 'no' (second) button in a dialog with three buttons."""
	
	self.answer=self.noMessage.lower()
	self.top.destroy()
	
def yesButton(self):
	
	"""Handle clicks in the 'yes' (first) button in a dialog with three buttons."""
	
	self.answer=self.yesMessage.lower()
	self.top.destroy()
</t>
<t tx="T2758">class listBoxDialog (leoDialog):
	"""A base class for dialogs containing a Tk Listbox"""
	@others</t>
<t tx="T2759">def __init__ (self,c,title,label):
	
	"""Constructor for the base listboxDialog class."""
	
	leoDialog.__init__(self,title,resizeable=true) # Initialize the base class.
	self.createTopFrame()
	self.top.protocol("WM_DELETE_WINDOW", self.destroy)

	# Initialize common ivars.
	self.c = c
	self.label = label
	self.vnodeList = []
	self.vnodeList = []
	self.buttonFrame = None
	
	# Fill in the frame.
	self.createFrame()
	self.fillbox()
	
	# Make the common bindings after creating self.box.
	
	self.box.bind("&lt;Double-Button-1&gt;",self.go)
</t>
<t tx="T2760">def addStdButtons (self,frame):
	
	"""Add stanadard buttons to a listBox dialog."""
	
	# Create the ok and cancel buttons.
	self.ok = ok = Tk.Button(frame,text="Go",width=6,command=self.go)
	self.hide = hide = Tk.Button(frame,text="Hide",width=6,command=self.hide)

	ok.pack(side="left",pady=2,padx=5)
	hide.pack(side="left",pady=2,padx=5)</t>
<t tx="T2761">def createFrame(self):
	
	"""Create the essentials of a listBoxDialog frame
	
	Subclasses will add buttons to self.buttonFrame"""
	
	self.outerFrame = f = Tk.Frame(self.frame)
	f.pack(expand=1,fill="both")
	
	if self.label:
		labf = Tk.Frame(f)
		labf.pack(pady=2)
		lab = Tk.Label(labf,text=self.label)
		lab.pack()
	
	f2 = Tk.Frame(f)
	f2.pack(expand=1,fill="both")
	
	self.box = box = Tk.Listbox(f2,height=20,width=30)
	box.pack(side="left",expand=1,fill="both")
	
	bar = Tk.Scrollbar(f2)
	bar.pack(side="left", fill="y")
	
	bar.config(command=box.yview)
	box.config(yscrollcommand=bar.set)</t>
<t tx="T2762">def destroy (self,event=None):
	
	"""Hide, do not destroy, a listboxDialog window
	
	subclasses may override to really destroy the window"""
	
	self.top.withdraw() # Don't allow this window to be destroyed.
</t>
<t tx="T2763">def hide (self):
	
	"""Hide a list box dialog."""
	
	self.top.withdraw()</t>
<t tx="T2764">def fillbox(self,event=None):
	
	"""Fill a listbox from information.
	
	Overridden by subclasses"""
	
	pass</t>
<t tx="T2765">def go(self,event=None):
	
	"""Handle clicks in the "go" button in a list box dialog."""
	
	c = self.c ; box = self.box
	
	# Work around an old Python bug.  Convert strings to ints.
	items = box.curselection()
	try:
		items = map(int, items)
	except ValueError: pass

	if items:
		n = items[0]
		v = self.vnodeList[n]
		c.beginUpdate()
		c.frame.expandAllAncestors(v)
		c.selectVnode(v,updateBeadList=true) # A case could be made for updateBeadList=false
		c.endUpdate()
		c.frame.idle_scrollTo(v)
</t>
<t tx="T2766">@language python

from leoGlobals import *
import leoDialog,leoNodes
import os,os.path,time

@ The list of language names that are written differently from the names in language_delims_dict in leoGlobals.py.  This is needed for compatibility with the borland version of Leo.

We convert from names in xml_language_names to names in language_delims_dict by converting the name to lowercase and by removing slashes.
@c

xml_language_names = (
	"CWEB","C","HTML","Java","LaTeX",
	"Pascal","PerlPod","Perl","Plain","Python","tcl/tk")

class BadLeoFile(Exception):
	def __init__(self, message):
		self.message = message
		Exception.__init__(self,message) # 4/26/03: initialize the base class.
	def __str__(self):
		return "Bad Leo File:" + self.message

class baseFileCommands:
	"""A base class for the fileCommands subcommander."""
	@others
	
class fileCommands (baseFileCommands):
	"""A class creating the fileCommands subcommander."""
	pass</t>
<t tx="T2767">def __init__(self,commands):

	# trace("__init__", "fileCommands.__init__")
	self.commands = commands
	self.frame = commands.frame
	self.initIvars()

def initIvars(self):

	# General
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.topVnode = None
	self.mFileName = ""
	self.fileDate = -1
	self.leo_file_encoding = app.config.new_leo_file_encoding
	# For reading
	self.fileFormatNumber = 0
	self.ratio = 0.5
	self.fileBuffer = None ; self.fileIndex = 0
	# For writing
	self.read_only = false
	self.outputFile = None # File for normal writing
	self.outputString = None # String for pasting
	self.openDirectory = None
	self.usingClipboard = false
	# New in 3.12
	self.copiedTree = None
	self.tnodesDict = {}</t>
<t tx="T2768"></t>
<t tx="T2769"></t>
<t tx="T2770">def getClipboardHeader (self):

	if self.getOpenTag("&lt;leo_header"):
		return # 11/24/02

	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T2771"># For compatibility with old file formats.

def getCloneWindows (self):

	if not self.matchTag("&lt;clone_windows&gt;"):
		return

	while self.matchTag("&lt;clone_window vtag=\"V"):
		self.getLong() ; self.getDquote() ; self.getTag("&gt;")
		if not self.getOpenTag("&lt;global_window_position"):
			self.getTag("&lt;global_window_position")
			self.getPosition()
			self.getTag("/&gt;")
		self.getTag("&lt;/clone_window&gt;")
	self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="T2772">def getEscapedString (self):

	# The next '&lt;' begins the ending tag.
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'&lt;',i)
	if j == -1:
		raise BadLeoFile("unterminated escaped string")
	else:
		# Allocates memory
		return self.xmlUnescape(self.fileBuffer[i:j])</t>
<t tx="T2773">def getGlobals (self):

	if self.getOpenTag("&lt;globals"):
		return

	self.getTag("body_outline_ratio=\"")
	self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

	self.getTag("&lt;global_window_position")
	y,x,h,w = self.getPosition() ; self.getTag("/&gt;")
	# print ("y,x,h,w:" + `y` + "," + `x` + "," + `h` + "," + `w`)
	
	# Bug fix: 7/15/02: use max, not min!!!
	y = max(y,0) ; x = max(x,0)
	geom = "%dx%d%+d%+d" % (w,h,x,y)
	self.frame.setTopGeometry(geom) ## self.frame.top.geometry(geom)
	# 7/15/02: Redraw the window before writing into it.
	self.frame.deiconify()
	self.frame.lift()
	self.frame.update()

	self.getTag("&lt;global_log_window_position")
	self.getPosition() ;
	self.getTag("/&gt;") # no longer used.

	self.getTag("&lt;/globals&gt;")</t>
<t tx="T2774">def getLeoHeader (self):

	# Set defaults.
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	if self.getOpenTag("&lt;leo_header"):
		return

	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.numberOfTnodes = self.getLong() ; self.getDquote()
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.maxTnodeIndex = self.getLong() ; self.getDquote()
		elif self.matchTag("clone_windows="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T2775">def getPosition (self):

	top = left = height = width = 0
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("top=\""):
			top = self.getLong() ; self.getDquote()
		elif self.matchTag("left=\""):
			left = self.getLong() ; self.getDquote()
		elif self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return top, left, height, width</t>
<t tx="T2776">def getPrefs (self):

	c = self.commands ; config = app.config
	
	if self.getOpenTag("&lt;preferences"):
		return

	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag("&gt;")
	while 1:
		if self.matchTag("&lt;defaultDirectory&gt;"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("&lt;/defaultDirectory&gt;")
			if not os.path.exists(c.tangle_directory):
				es("default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
			self.getEscapedString() # ignored
			self.getTag("&lt;/TSyntaxMemo_options&gt;")
		else: break
	self.getTag("&lt;/preferences&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	if config.configsExist:
		config.setCommandsIvars(c)</t>
<t tx="T2777"># Must match longer tags before short prefixes.

language = "c" # default

for name in app.language_delims_dict.keys():
	if self.matchTagWordIgnoringCase(name):
		language = name.replace("/","") # Bug fix: 10/20/03
		self.getDquote()
		break

c.target_language = language</t>
<t tx="T2778">def getSize (self):

	# New in version 1.7: attributes may appear in any order.
	height = 0 ; width = 0
	while 1:
		if self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return height, width</t>
<t tx="T2779">def getTnodeList (self):

	"""Parse a list of tnode indices terminated by a double quote."""

	fc = self ; 
	
	if fc.matchChar('"'):
		return []

	indexList = []
	while 1:
		index = fc.getIndex()
		indexList.append(index)
		if fc.matchChar('"'):
			break
		else:
			fc.getTag(',')
			
	# Resolve all indices.
	tnodeList = []
	for index in indexList:
		t = fc.tnodesDict.get(index)
		if t == None:
			# Not an error: create a new tnode and put it in fc.tnodesDict.
			t = self.newTnode(index)
		tnodeList.append(t)
	return tnodeList</t>
<t tx="T2780">def skipWs (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T2781">def skipWsAndNl (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T2782">def newTnode(self,index):

	if self.tnodesDict.has_key(index):
		es("bad tnode index: " + `index` + ". Using empty text.")
		return leoNodes.tnode()
	else:
		t = leoNodes.tnode()
		t.setFileIndex(index)
		self.tnodesDict[index] = t
		return t</t>
<t tx="T2783">def readOutlineOnly (self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	c.beginUpdate()
	ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=false)
	c.endUpdate()
	c.frame.deiconify()
	vflag,junk,secondary_ratio = self.frame.initialRatios()
	c.frame.resizePanesToRatio(ratio,secondary_ratio)
	# This should be done after the pane size has been set.
	if 0: # This can not be done at present.
		if self.topVnode:
			c.frame.scrollTo(self.topVnode)
			c.frame.Refresh()
	# delete the file buffer
	self.fileBuffer = ""
	return ok</t>
<t tx="T2784">def setAllJoinLinks (self,root=None):
	
	"""Update all join links in the tree"""
	
	# trace(root)

	if root: # Only update the subtree.
		v = root # 6/3/03
		after = root.nodeAfterTree()
		while v and v != after:
			if v not in v.t.joinList:
				v.t.joinList.append(v)
			v = v.threadNext()
	else: # Update everything.
		v = self.commands.rootVnode()
		while v:
			if v not in v.t.joinList:
				v.t.joinList.append(v)
			v = v.threadNext()</t>
<t tx="T2785">def xmlUnescape(self,s):

	if s:
		s = string.replace(s, '\r', '')
		s = string.replace(s, "&amp;lt;", '&lt;')
		s = string.replace(s, "&amp;gt;", '&gt;')
		s = string.replace(s, "&amp;amp;", '&amp;')
	return s</t>
<t tx="T2786"></t>
<t tx="T2787"></t>
<t tx="T2788">def putClipboardHeader (self):

	tnodes = 0
	&lt;&lt; count the number of tnodes &gt;&gt;
	self.put('&lt;leo_header file_format="1" tnodes=')
	self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=")
	self.put_in_dquotes(`tnodes`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2789">c=self.commands
c.clearAllVisited()

# Count the vnode and tnodes.
v = c.currentVnode()
after = v.nodeAfterTree()
while v and v != after:
	t = v.t
	if t and not t.isVisited() and (t.hasBody() or len(v.t.joinList) &gt; 0):
		t.setVisited()
		tnodes += 1
	v = v.threadNext()</t>
<t tx="T2790">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.
@c

def putEscapedString (self,s):

	if s and len(s) &gt; 0:
		self.put(self.xmlEscape(s))</t>
<t tx="T2791">def putGlobals (self):

	c=self.commands
	self.put("&lt;globals")
	&lt;&lt; put the body/outline ratio &gt;&gt;
	self.put("&gt;") ; self.put_nl()
	&lt;&lt; put the position of this frame &gt;&gt;
	&lt;&lt; put the position of the log window &gt;&gt;

	self.put("&lt;/globals&gt;") ; self.put_nl()</t>
<t tx="T2792"># Puts an innumerate number of digits

self.put(" body_outline_ratio=") ; self.put_in_dquotes(`c.frame.ratio`)</t>
<t tx="T2793">width,height,left,top = get_window_info(self.frame.top)
#print ("t,l,h,w:" + `top` + ":" + `left` + ":" + `height` + ":" + `width`)

self.put_tab()
self.put("&lt;global_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2794">top = left = height = width = 0 # no longer used
self.put_tab()
self.put("&lt;global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2795">def putHeader (self):

	tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

	self.put("&lt;leo_header")
	self.put(" file_format=") ; self.put_in_dquotes("2")
	self.put(" tnodes=") ; self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=") ; self.put_in_dquotes(`self.maxTnodeIndex`)
	self.put(" clone_windows=") ; self.put_in_dquotes(`clone_windows`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2796">def putPostlog (self):

	self.put("&lt;/leo_file&gt;") ; self.put_nl()</t>
<t tx="T2797">def putPrefs (self):

	c = self.commands ; config = app.config

	self.put("&lt;preferences")
	self.put(" allow_rich_text=") ; self.put_dquoted_bool(0) # no longer used
	
	&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/preferences&gt;") ; self.put_nl()</t>
<t tx="T2798">language = c.target_language
for name in xml_language_names:
	s = string.lower(name)
	s = string.replace(s,"/","")
	if s == language:
		language = name ; break

if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put(" tab_width=") ; self.put_in_dquotes(`c.tab_width`)
	self.put(" page_width=") ; self.put_in_dquotes(`c.page_width`)
	self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
	self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
	self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
	self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)
	self.put(" defaultTargetLanguage=") ; self.put_in_dquotes(language) # 10/11/02: fix reversion.

self.put("&gt;") ; self.put_nl()
# New in version 0.16
&lt;&lt; put default directory &gt;&gt;</t>
<t tx="T2799">if config.configsExist:
	pass # Has been done earlier.
elif len(c.tangle_directory) &gt; 0:
	self.put_tab()
	self.put("&lt;defaultDirectory&gt;")
	self.putEscapedString(c.tangle_directory)
	self.put("&lt;/defaultDirectory&gt;")
	self.put_nl()</t>
<t tx="T2800">def putTnodeList (self,v):
	
	"""Put the optional tnodeList attribute of a vnode."""

	fc = self
	if v.tnodeList:
		# trace("%4d" % len(v.tnodeList),v)
		fc.put(" tnodeList=") ; fc.put_dquote()
		s = ','.join([str(t.fileIndex) for t in v.tnodeList])
		fc.put(s) ; fc.put_dquote()</t>
<t tx="T2801">@ This writes full headline and body text for all vnodes, even orphan and @ignored nodes.  This allows all Leo outlines to be used as backup files.
@c

def putVnode (self,v,topVnode):

	fc = self ; c = fc.commands
	fc.put("&lt;v")
	&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
	&lt;&lt; Put attribute bits &gt;&gt;
	if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0:
		fc.putTnodeList(v) # New in 4.0
	if hasattr(v,"unknownAttributes"): # New in 4.0
		&lt;&lt; put unknown vnode attributes &gt;&gt;
	fc.put("&gt;")
	&lt;&lt; write the head text &gt;&gt;
	child = v.firstChild()
	if child:
		fc.put_nl()
		while child:
			fc.putVnode(child,topVnode)
			child = child.next()
	fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="T2802">t = v.t
if t and (t.hasBody() or len(v.t.joinList) &gt; 0):
	if t.fileIndex &gt; 0:
		fc.put(" t=") ; fc.put_in_dquotes("T" + `t.fileIndex`)
		v.t.setVisited() # Indicate we wrote the body text.
	else:
		es("error writing file(bad vnode)!")
		es("try using the Save To command")</t>
<t tx="T2803">current = c.currentVnode()
top = topVnode
if ( v.isCloned() or v.isExpanded() or v.isMarked() or
	v == current or v == top ):
	fc.put(" a=") ; fc.put_dquote()
	if v.isCloned(): fc.put("C")
	if v.isExpanded(): fc.put("E")
	if v.isMarked(): fc.put("M")
	if v.isOrphan(): fc.put("O")
	if v == top: fc.put("T")
	if v == current: fc.put("V")
	fc.put_dquote()</t>
<t tx="T2804">headString = v.headString()
if len(headString) &gt; 0:
	fc.put("&lt;vh&gt;")
	fc.putEscapedString(headString)
	fc.put("&lt;/vh&gt;")</t>
<t tx="T2805">attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  es(s, color="red")
		print attr, es(attr)</t>
<t tx="T2806">def saveAs(self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing() # Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)
</t>
<t tx="T2807">def saveTo (self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			es("saved: " + shortFileName(fileName))
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)
</t>
<t tx="T2808">def setDefaultDirectoryForNewFiles (self,fileName):
	
	"""Set c.openDirectory for new files for the benefit of leoAtFile.scanAllDirectives."""
	
	c = self.commands

	if not c.openDirectory or len(c.openDirectory) == 0:
		dir = os.path.dirname(fileName)
		if len(dir) &gt; 0 and os.path.isabs(dir) and os.path.exists(dir):
			c.openDirectory = dir</t>
<t tx="T2809">def write_LEO_file(self,fileName,outlineOnlyFlag):

	c=self.commands ; config = app.config

	if not outlineOnlyFlag:
		try:
			# Leo2: write all @file nodes and set orphan bits.
			at = c.atFileCommands
			at.writeAll()
		except:
			es_error("exception writing derived files")
			es_exception()
			return false
			
	if self.read_only:
		es_error("read only: " + fileName)
		return false

	try:
		&lt;&lt; create backup file &gt;&gt;
		self.mFileName = fileName
		self.outputFile = open(fileName, 'wb') # 9/18/02
		if not self.outputFile:
			es("can not open " + fileName)
			&lt;&lt; delete backup file &gt;&gt;
			return false
		
		# 8/6/02: Update leoConfig.txt completely here.
		c.setIvarsFromFind()
		config.setConfigFindIvars(c)
		c.setIvarsFromPrefs()
		config.setCommandsIvars(c)
		config.update()
		
		self.putProlog()
		self.putHeader()
		self.putGlobals()
		self.putPrefs()
		self.putFindSettings()
		self.putVnodes()
		self.putTnodes()
		self.putPostlog()
		# raise BadLeoFile # testing
	except:
		es("exception writing: " + fileName)
		es_exception() 
		if self.outputFile:
			try:
				self.outputFile.close()
				self.outputFile = None
			except:
				es("exception closing: " + fileName)
				es_exception()
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false

	if self.outputFile:
		try:
			self.outputFile.close()
			self.outputFile = None
		except:
			es("exception closing: " + fileName)
			es_exception()
		&lt;&lt; delete backup file &gt;&gt;
		return true
	else: # This probably will never happen because errors should raise exceptions.
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false</t>
<t tx="T2810"># rename fileName to fileName.bak if fileName exists.
if os.path.exists(fileName):
	try:
		backupName = os.path.join(app.loadDir,fileName)
		backupName = fileName + ".bak"
		if os.path.exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		utils_rename(fileName,backupName)
	except:
		es("exception creating " + backupName)
		es_exception()
		backupName = None
else:
	backupName = None</t>
<t tx="T2811">if backupName and os.path.exists(backupName):
	try:
		os.unlink(backupName)
	except:
		es("exception deleting " + backupName)
		es_exception()
</t>
<t tx="T2812">es("error writing " + fileName)

if fileName and os.path.exists(fileName):
	try:
		os.unlink(fileName)
	except:
		es("exception deleting " + fileName)
		es_exception()
		
if backupName:
	es("restoring " + fileName + " from " + backupName)
	try:
		# os.rename(backupName, fileName)
		utils_rename(backupName, fileName)
	except:
		es("exception renaming " + backupName + " to " + fileName)
		es_exception()
</t>
<t tx="T2813">def writeOutlineOnly (self):

	c=self.commands
	c.endEditing()
	self.compactFileIndices()
	self.write_LEO_file(self.mFileName,true) # outlineOnlyFlag</t>
<t tx="T2814"># Surprisingly, this is a time critical routine.

def xmlEscape(self,s):

	assert(s and len(s) &gt; 0) # check is made in putEscapedString
	s = string.replace(s, '\r', '')
	s = string.replace(s, '&amp;', "&amp;amp;")
	s = string.replace(s, '&lt;', "&amp;lt;")
	s = string.replace(s, '&gt;', "&amp;gt;")
	return s</t>
<t tx="T2815">@language python

&lt;&lt; Theory of operation of find/change &gt;&gt;

from leoGlobals import *
import leoDialog
import string,sys,Tkinter,types
Tk=Tkinter

@others</t>
<t tx="T2816">class leoFindBase (leoDialog.leoDialog):
	"""The base class for Leo's Find panel."""
	@others</t>
<t tx="T2817">def __init__(self,title,resizeable=false):

	leoDialog.leoDialog.__init__(self,title,resizeable)
	self.createTopFrame()
	self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)</t>
<t tx="T2818">def onCloseWindow(self):

	self.top.withdraw()</t>
<t tx="T2819">def resetWrap (self,event=None):

	self.wrapVnode = None
	self.onlyVnode = None</t>
<t tx="T2820">class leoFind (leoFindBase):
	"""A class that implements Leo's find commands."""
	@others</t>
<t tx="T2821"></t>
<t tx="T2822">
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

	self.setup_button()
	self.change()</t>
<t tx="T2823"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.changeAll()</t>
<t tx="T2824"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

	self.setup_button()
	self.changeThenFind()</t>
<t tx="T2825"># The user has pushed the "Find" button from the find panel.

def findButton(self):

	self.setup_button()
	self.findNext()</t>
<t tx="T2826"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.findAll()</t>
<t tx="T2827"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

	self.setup_command(c)
	self.change()</t>
<t tx="T2828"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

	self.setup_command(c)
	self.changeThenFind()</t>
<t tx="T2829"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

	self.setup_command(c)
	self.findNext()</t>
<t tx="T2830"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

	self.setup_command(c)
	c.reverse_flag = not c.reverse_flag
	self.findNext()
	c.reverse_flag = not c.reverse_flag</t>
<t tx="T2831"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

	self.commands = c = app.log.commands
	self.v = c.currentVnode()
	assert(c)
	c.bringToFront()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()
	return c</t>
<t tx="T2832"># Initializes a search when a command is invoked from the menu.

def setup_command(self,c):

	self.commands = c
	self.v = c.currentVnode()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()</t>
<t tx="T2833"></t>
<t tx="T2834">def change(self):

	if self.checkArgs():
		self.initInHeadline()
		self.changeSelection()</t>
<t tx="T2835"># Replace selection with c.change_text.
# If no selection, insert c.change_text at the cursor.

def changeSelection(self):
	
	c = self.commands ; v = self.v
	# trace(`self.in_headline`)
	t = choose(self.in_headline,v.edit_text(),c.body)
	oldSel = sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel
		if start == end:
			sel = None
	if len(sel) != 2:
		es("No text selected")
		return false
	# trace(`sel` + ", " + `c.change_text`)
	# Replace the selection
	start,end = oldSel
	t.delete(start,end)
	t.insert(start,c.change_text)
	# 2/7/02: Also update s_text in case we find another match on the same line.
	self.s_text.delete(start,end)
	self.s_text.insert(start,c.change_text)
	# Update the selection for the next match.
	setTextSelection(t,start,start + "+" + `len(c.change_text)` + "c")
	newSel = getTextSelection(t)
	set_focus(c,t)

	c.beginUpdate()
	if c.mark_changes_flag:
		v.setMarked()
		c.frame.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
	# update node, undo status, dirty flag, changed mark &amp; recolor
	if self.in_headline:
		c.frame.idle_head_key(v)
	else:
		c.frame.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)
	c.endUpdate(false) # No redraws here: they would destroy the headline selection.
	# trace(c.body.index("insert")+":"+c.body.get("insert linestart","insert lineend"))
	return true</t>
<t tx="T2836">def changeThenFind(self):

	if not self.checkArgs():
		return

	self.initInHeadline()
	if self.changeSelection():
		self.findNext(false) # don't reinitialize</t>
<t tx="T2837">def findNext(self,initFlag = true):

	c = self.commands
	if not self.checkArgs():
		return
		
	if initFlag:
		self.initInHeadline()
		data = self.save()
		self.initInteractiveCommands()
	else:
		data = self.save()
	
	c.beginUpdate()
	pos, newpos = self.findNextMatch()
	c.endUpdate(false) # Inhibit redraws so that headline remains selected.
	
	if pos:
		self.showSuccess(pos,newpos)
	else:
		if self.wrapping:
			es("end of wrapped search")
		else:
			es("not found: " + "'" + c.find_text + "'")
		self.restore(data)</t>
<t tx="T2838"># Selects the next node to be searched.

def selectNextVnode(self):

	c = self.commands ; v = self.v
	# trace(`v`)
	
	# Start suboutline only searches.
	if c.suboutline_only_flag and not self.onlyVnode:
		self.onlyVnode = v

	# Start wrapped searches.
	if self.wrapping and not self.wrapVnode:
		assert(self.wrapPos != None)
		self.wrapVnode = v

	if self.in_headline and c.search_body_flag:
		# just switch to body pane.
		self.in_headline = false
		self.initNextText()
		# trace(`v`)
		return v

	if c.reverse_flag:
		v = v.threadBack()
	else:
		v = v.threadNext()

	# Wrap if needed.
	if not v and self.wrapping and not c.suboutline_only_flag:
		v = c.rootVnode()
		if c.reverse_flag:
			# Set search_v to the last node of the tree.
			while v and v.next():
				v = v.next()
			if v: v = v.lastNode()

	# End wrapped searches.
	if self.wrapping and v and v == self.wrapVnode:
		# trace("ending wrapped search")
		v = None ; self.resetWrap()
		
	# End suboutline only searches.
	if (c.suboutline_only_flag and self.onlyVnode and v and
		(v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
		# trace("end outline-only")
		v = None ; self.onlyVnode = None

	self.v = v # used in initNextText().
	if v: # select v and set the search point within v.
		self.in_headline = c.search_headline_flag
		self.initNextText()
	return v</t>
<t tx="T2839">@ Searches the present headline or body text for c.find_text and returns true if found.
c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search.
@c

def search (self):

	c = self.commands ; v = self.v ; t = self.s_text
	assert(c and t and v)
	index = t.index("insert")
	stopindex = choose(c.reverse_flag,"1.0","end")
	while 1:
		# trace(`index`+":"+`stopindex`+":"+t.get(index+" linestart",index+" lineend"))
		pos = t.search(c.find_text,index,
			stopindex=stopindex,backwards=c.reverse_flag,
			regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
		if not pos:
			return None, None
		newpos = pos + "+" + `len(c.find_text)` + "c"
		if c.reverse_flag and t.compare(newpos,"==",index): # 10/3/02
			&lt;&lt; search again after getting stuck going backward &gt;&gt;
		# trace(`pos`+":"+`newpos`)
		&lt;&lt; return if we are passed the wrap point &gt;&gt;
		if c.whole_word_flag:
			index = t.index(choose(c.reverse_flag,pos,newpos))
			&lt;&lt; test for whole word match &gt;&gt;
			if not pos: continue
		# trace("found:" + `pos` + ":" + `newpos` + ":" + `v`)
		# set the insertion point.
		setTextSelection(t,pos,newpos)
		t.mark_set("insert",choose(c.reverse_flag,pos,newpos))
		return pos, newpos</t>
<t tx="T2840"># print "stuck"
index = newpos + "-" + `len(c.find_text)` + "c"
pos = t.search(c.find_text,index,
	stopindex=stopindex,backwards=c.reverse_flag,
	regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)

if not pos:
	return None, None
newpos = pos + "+" + `len(c.find_text)` + "c"</t>
<t tx="T2841">if self.wrapping and self.wrapPos and self.wrapVnode and self.v == self.wrapVnode:
	if c.reverse_flag and t.compare(pos, "&lt;", self.wrapPos):
		# trace("wrap done")
		return None, None
	if not c.reverse_flag and t.compare(newpos, "&gt;", self.wrapPos):
		return None, None</t>
<t tx="T2842"></t>
<t tx="T2843">def checkArgs (self):

	c = self.commands 
	val = true
	if not c.search_headline_flag and not c.search_body_flag:
		es("not searching headline or body")
		val = false
	if len(c.find_text) == 0:
		es("empty find patttern")
		val = false
	return val</t>
<t tx="T2844"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

	c = self.commands
	self.in_headline = c.search_headline_flag # Search headlines first.

	# Select the first node.
	if c.suboutline_only_flag:
		self.v = c.currentVnode()
	else:
		v = c.rootVnode()
		if c.reverse_flag:
			while v and v.next():
				v = v.next()
			v = v.lastNode()
		self.v = v
	
	# Set the insert point.
	self.initBatchText()</t>
<t tx="T2845">@ Returns s_text with "insert" point set properly for batch searches.
@c

def initBatchText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	self.wrapping = false # Only interactive commands allow wrapping.
	return st

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	return st</t>
<t tx="T2846"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

	c = self.commands ; v = self.v
	
	if c.search_headline_flag and c.search_body_flag:
		# Do not change this line without careful thought and extensive testing!
		self.in_headline = (v == c.frame.editVnode())
	else:
		self.in_headline = c.search_headline_flag</t>
<t tx="T2847"># For incremental searches

def initInteractiveCommands(self):

	c = self.commands ; v = self.v
	
	if self.in_headline:
		t = v.edit_text()
		c.frame.setEditVnode(v)
		pos = t.index("insert")
		# trace(`pos` + ":" + `self.in_headline` + ":" + `v==c.frame.editVnode()` + ":" + `v`)
	else:
		t = c.body
		pos = t.index("insert")

	st = self.initNextText()
	set_focus(c,t)
	st.mark_set("insert",pos)
	self.wrapping = c.wrap_flag
	if c.wrap_flag and self.wrapVnode == None:
		self.wrapPos = pos
		# Do not set self.wrapVnode here: that must be done after the first search.</t>
<t tx="T2848">def printLine (self,line,allFlag=false):

	c = self.commands
	both = c.search_body_flag and c.search_headline_flag
	context = c.batch_flag # "batch" now indicates context

	if allFlag and both and context:
		es(`self.v`)
		type = choose(self.in_headline,"head: ","body: ")
		es(type + line)
	elif allFlag and context and not self.v.isVisited():
		# We only need to print the context once.
		es(`self.v`)
		es(line)
		self.v.setVisited()
	else:
		es(line)</t>
<t tx="T2849"># Restores the screen after a search fails

def restore (self,data):

	c = self.commands
	in_headline,v,t,insert,start,end = data
	# trace(`insert` + ":" + `start` + ":" + `end`)
	# Don't try to reedit headline.
	c.selectVnode(v) 
	if not in_headline:
		if 0: # Looks bad.
			if start and end:
				setTextSelection(t,start,end)
		else: # Looks good and provides clear indication of failure or termination.
			t.tag_remove("sel","1.0","end")
		t.mark_set("insert",insert)
		t.see("insert")
		set_focus(c,t)</t>
<t tx="T2850">def save (self):

	c = self.commands ; v = self.v
	t = choose(self.in_headline,v.edit_text(),c.body)
	insert = t.index("insert")
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel
	else:
		start,end = None,None
	return (self.in_headline,v,t,insert,start,end)</t>
<t tx="T2851">@ This is used for displaying the final result.  It returns self.dummy_vnode, v.edit_text() or c.body with "insert" and "sel" points set properly.
@c

def showSuccess(self,pos,newpos):

	c = self.commands ; v = self.v
	
	c.beginUpdate()
	if 1: # range of update...
		c.selectVnode(v)
		c.frame.redraw_now() # Redraw now so selections are not destroyed.
		# Select the found vnode again after redraw.
		if self.in_headline:
			c.editVnode(v)
			c.frame.setNormalLabelState(v)
			assert(v.edit_text())
		else:
			c.selectVnode(v)
	c.endUpdate(false) # Do not draw again!

	t = choose(self.in_headline,v.edit_text(),c.body)
	# trace(`self.in_headline` + "," + `t`)
	insert = choose(c.reverse_flag,pos,newpos)
	t.mark_set("insert",insert)
	setTextSelection(t,pos,newpos)
	if not self.in_headline:
		t.see(insert)
	set_focus(c,t)
	if c.wrap_flag and not self.wrapVnode:
		self.wrapVnode = self.v</t>
<t tx="T2852">@language python

from leoGlobals import *
import exceptions,sys,string,Tkinter,tkFont

class baseLeoFontPanel:
	"""The base class for Leo's font panel."""
	@others
	
class leoFontPanel (baseLeoFontPanel):
	"""A class that creates Leo's font panel."""
	pass</t>
<t tx="T2853"></t>
<t tx="T2854">def onApply (self):
	
	self.update()
</t>
<t tx="T2855">def onCancel (self):

	self.onRevert()
	self.showSettings()
	self.hide()</t>
<t tx="T2856">def onOk (self):

	c = self.commands
	self.showSettings()
	
	&lt;&lt; update the configuration settings &gt;&gt;

	self.setRevertVars()
	self.hide()</t>
<t tx="T2857">set = app.config.setWindowPref

fn = c.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("body_text_font_family",name)
set("body_text_font_size",size)
set("body_text_font_slant",slant)
set("body_text_font_weight",weight)
	
fn = c.log.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("log_text_font_family",name)
set("log_text_font_size",size)
set("log_text_font_slant",slant)
set("log_text_font_weight",weight)
	
font = c.frame.getFont()
name,size,slant,weight = self.getFontSettings(font)
set("headline_text_font_family",name)
set("headline_text_font_size",size)
set("headline_text_font_slant",slant)
set("headline_text_font_weight",weight)</t>
<t tx="T2858">def onRevert (self):

	c = self.commands
	c.body.configure(font=self.revertBodyFont)
	c.log.configure (font=self.revertLogFont)
	c.frame.setFont (font=self.revertTreeFont)
	c.redraw()
	self.revertIvars()
	# Don't call update here.</t>
<t tx="T2859"></t>
<t tx="T2860">def selectFont (self,font):
	
	box = self.family_list_box
	
	# All selections come here.
	self.last_selected_font = font

	# The name should be on the list!
	name, size, slant, weight = self.getFontSettings(font)
	for i in xrange(0,box.size()):
		item = box.get(i)
		if name == item:
			box.select_clear(0,"end")
			box.select_set(i)
			box.see(i)
			self.last_selected_font = font
			# trace(name)
			return
	# print "not found:" + name</t>
<t tx="T2861">def onSizeEntryKey (self,event=None):
	
	self.size_entry.after_idle(self.idle_entry_key)
	
def idle_entry_key (self):
	
	size = self.size_entry.get() # Doesn't work until idle time.
	try:
		size = int(size)
		self.sizeVar.set(size)
	except: # The user typed an invalid number.
		return</t>
<t tx="T2862"># To do: Use config params for window height, width and bar color, relief and width.

@language python

from leoGlobals import *
import leoColor,leoCommands,leoCompare,leoDialog,leoFontPanel,leoNodes,leoPlugins,leoPrefs,leoTree
import os,string,sys,tempfile,time,traceback
import Tkinter,tkFileDialog,tkFont

Tk = Tkinter

class baseLeoFrame:
	"""A base class for Leo's main frame class."""
	instances = 0
	@others

class LeoFrame (baseLeoFrame):
	"""A class that represents a Leo window."""
	pass
</t>
<t tx="T2863"></t>
<t tx="T2864">def configureBar (self, bar, verticalFlag):
	
	config = app.config

	# Get configuration settings.
	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	relief = config.getWindowPref("split_bar_relief")
	if not relief: relief = "flat"
	color = config.getWindowPref("split_bar_color")
	if not color: color = "LightSteelBlue2"

	try:
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
	except: # Could be a user error. Use all defaults
		es("exception in user configuration for splitbar")
		es_exception()
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(height=7,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(width=7,cursor="sb_h_double_arrow")</t>
<t tx="T2865">def configureBarsFromConfig (self):
	
	config = app.config

	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	
	relief = config.getWindowPref("split_bar_relief")
	if not relief or relief == "": relief = "flat"

	color = config.getWindowPref("split_bar_color")
	if not color or color == "": color = "LightSteelBlue2"

	if self.splitVerticalFlag:
		bar1,bar2=self.bar1,self.bar2
	else:
		bar1,bar2=self.bar2,self.bar1
		
	try:
		bar1.configure(relief=relief,height=w,bg=color)
		bar2.configure(relief=relief,width=w,bg=color)
	except: # Could be a user error.
		es("exception in user configuration for splitbar")
		es_exception()</t>
<t tx="T2866">def reconfigureFromConfig (self):
	
	f = self ; c = f.commands
	
	# Not ready yet: just reset the width and color.
	# We need self.bar1 and self.bar2 ivars.
	# self.reconfigureBar(...)
	
	# The calls to redraw are workarounds for an apparent Tk bug.
	# Without them the text settings get applied to the wrong widget!
	# Moreover, only this order seems to work on Windows XP...
	f.tree.setFontFromConfig()
	f.setTreeColorsFromConfig()
	f.configureBarsFromConfig()
	c.redraw()
	f.setBodyFontFromConfig()
	f.setTabWidth(c.tab_width)
	c.redraw()
	f.setLogFontFromConfig()
	c.redraw()</t>
<t tx="T2867">def setBodyFontFromConfig (self):
	
	config = app.config ; body = self.body
	#print "body",self.body
	
	font = config.getFontFromParams(
		"body_text_font_family", "body_text_font_size",
		"body_text_font_slant",  "body_text_font_weight")

	body.configure(font=font)
	
	bg = config.getWindowPref("body_text_background_color")
	if bg:
		try: body.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("body_text_foreground_color")
	if fg:
		try: body.configure(fg=fg)
		except: pass
		
	# 1/24/03: Gareth McCaughan
	bg = config.getWindowPref("body_insertion_cursor_color")
	if bg:
		try: body.configure(insertbackground=bg)
		except: pass
		
	if sys.platform != "win32": # Maybe a Windows bug.
		fg = config.getWindowPref("body_cursor_foreground_color")
		bg = config.getWindowPref("body_cursor_background_color")
		# print fg, bg
		if fg and bg:
			cursor="xterm" + " " + fg + " " + bg
			try: body.configure(cursor=cursor)
			except:
				traceback.print_exc()</t>
<t tx="T2868">def setLogFontFromConfig (self):

	log = self.log ; config = app.config
	#print "log",self.log

	font = config.getFontFromParams(
		"log_text_font_family", "log_text_font_size",
		"log_text_font_slant",  "log_text_font_weight")
	
	log.configure(font=font)

	bg = config.getWindowPref("log_text_background_color")
	if bg:
		try: log.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("log_text_foreground_color")
	if fg:
		try: log.configure(fg=fg)
		except: pass

</t>
<t tx="T2869">def setTabWidth (self, w):
	
	try: # This can fail when called from scripts
		# Use the present font for computations.
		font = self.body.cget("font")
		root = app.root # 4/3/03: must specify root so idle window will work properly.
		font = tkFont.Font(root=root,font=font)
		tabw = font.measure(" " * abs(w)) # 7/2/02
		# tablist = `tabw` + ' ' + `2*tabw`
		self.body.configure(tabs=tabw)
		self.tab_width = w
		# print "frame.setTabWidth:" + `w` + "," + `tabw`
	except:
		es_exception()
		pass
</t>
<t tx="T2870">def setTreeColorsFromConfig (self):

	bg = app.config.getWindowPref("outline_pane_background_color")
	if bg:
		try: self.canvas.configure(bg=bg)
		except: pass
</t>
<t tx="T2871">def reconfigurePanes (self):
	
	border = app.config.getIntWindowPref('additional_body_text_border')
	if border == None: border = 0
	
	# The body pane needs a _much_ bigger border when tiling horizontally.
	border = choose(self.splitVerticalFlag,2+border,6+border)
	self.body.configure(bd=border)
	
	# The log pane needs a slightly bigger border when tiling vertically.
	border = choose(self.splitVerticalFlag,4,2) 
	self.log.configure(bd=border)</t>
<t tx="T2872">def longFileName (self):
	return self.commands.mFileName
	
def shortFileName (self):
	return shortFileName(self.commands.mFileName)</t>
<t tx="T2873">def getFocus(self):
	
	"""Returns the widget that has focus, or body if None."""

	f = self.top.focus_displayof()
	if f:
		return f
	else:
		return self.body</t>
<t tx="T2874">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
</t>
<t tx="T2875">def resizePanesToRatio(self,ratio,secondary_ratio):

	self.divideLeoSplitter(self.splitVerticalFlag, ratio)
	self.divideLeoSplitter(not self.splitVerticalFlag, secondary_ratio)
	# trace(`ratio`)
</t>
<t tx="T2876">def bindBar (self, bar, verticalFlag):
	
	if verticalFlag == self.splitVerticalFlag:
		bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

	else:
		bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)
</t>
<t tx="T2877"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		bar.place(rely=frac)
		pane1.place(relheight=frac)
		pane2.place(relheight=1-frac)
	else:
		# Panes arranged horizontally; vertical splitter bar
		bar.place(relx=frac)
		pane1.place(relwidth=frac)
		pane2.place(relwidth=1-frac)</t>
<t tx="T2878"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
	if self.splitVerticalFlag == verticalFlag:
		self.divideLeoSplitter1(frac,verticalFlag)
		self.ratio = frac # Ratio of body pane to tree pane.
	else:
		self.divideLeoSplitter2(frac,verticalFlag)
		self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
	self.divideAnySplitter(frac, verticalFlag,
		self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
	self.divideAnySplitter (frac, verticalFlag,
		self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="T2879">def initialRatios (self):

	config = app.config
	s = config.getWindowPref("initial_splitter_orientation")
	verticalFlag = s == None or (s != "h" and s != "horizontal")

	if verticalFlag:
		r = config.getFloatWindowPref("initial_vertical_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
		r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
	else:
		r = config.getFloatWindowPref("initial_horizontal_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
		r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

	# print (`r`,`r2`)
	return verticalFlag,r,r2</t>
<t tx="T2880">def onDragMainSplitBar (self, event):
	self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
	self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

	# x and y are the coordinates of the cursor relative to the bar, not the main window.
	bar = event.widget
	x = event.x
	y = event.y
	top = bar.winfo_toplevel()

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		wRoot	= top.winfo_rooty()
		barRoot = bar.winfo_rooty()
		wMax	= top.winfo_height()
		offset = float(barRoot) + y - wRoot
	else:
		# Panes arranged horizontally; vertical splitter bar
		wRoot	= top.winfo_rootx()
		barRoot = bar.winfo_rootx()
		wMax	= top.winfo_width()
		offset = float(barRoot) + x - wRoot

	# Adjust the pixels, not the frac.
	if offset &lt; 3: offset = 3
	if offset &gt; wMax - 2: offset = wMax - 2
	# Redraw the splitter as the drag is occuring.
	frac = float(offset) / wMax
	# trace(`frac`)
	self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="T2881">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
		pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
		bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
	else:
		# Panes arranged horizontally; vertical splitter bar
		# adj gives tree pane more room when tiling vertically.
		adj = choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
		pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
		pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
		bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="T2882">@first # -*- coding: utf-8 -*-

"""Global constants, variables and utility functions used throughout Leo."""

@language python

import exceptions,os,re,string,sys,time,Tkinter,traceback,types

&lt;&lt; define general constants &gt;&gt;

gApp = None # Used the leoProxy class below.

# Visible externally so plugins may add to the list of directives.

globalDirectiveList = [
	"color", "comment", "encoding", "header", "ignore",
	"language", "lineending", "nocolor", "noheader", "nowrap",
	"pagewidth", "path", "quiet", "root", "silent",
	"tabwidth", "terse", "unit", "verbose", "wrap"]

@others</t>
<t tx="T2883">body_newline = '\n'
body_ignored_newline = '\r'

try:
	true = True
	false = False
except:
	# print "True and False not defined"
	true = True = 1
	false = False = 0 # Better than None

assert(false!=None)</t>
<t tx="T2884"></t>
<t tx="T2885">def checkTopologyOfAllClones (c=None):
	
	if c == None: c = top()
	root = v = c.rootVnode()
	c.clearAllVisited()
	count = 0
	s = "Testing topology of all clones"
	es(s) ; print s
	while v:
		if not v.t.isVisited():
			v.t.setVisited()
			if v.isCloned:
				count += 1
				tlist = createTopologyList (c,v,useHeadlines=true)
			for v2 in v.t.joinList:
				if v2 != v:
					tlist2 = createTopologyList (c,v2,useHeadlines=true)
					if tlist != tlist2:
						s = "topology mismatch for %s" % v.headString()
						print s ; es(s)
						break
		v = v.threadNext()
	s = "Testing complete: %d clones tested" % count
	es(s) ; print s</t>
<t tx="T2886">@
CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is true
0 if comparison is false

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def CheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):
	import sre  # Unicode-aware regular expressions
	#
	# tokenize the stringCompare flags
	compareFlag = string.split( stringCompare, '.' )
	#
	# tokenize the version strings
	testVersion = string.split( version, delimiter )
	testAgainst = string.split( againstVersion, delimiter )
	#
	# find the 'precision' of the comparison
	tokenCount = 4
	if tokenCount &gt; len(testAgainst):
		tokenCount = len(testAgainst)
	if tokenCount &gt; len(testVersion):
		tokenCount = len(testVersion)
	#
	# Apply the stringCompare flags
	justInteger = sre.compile("^[0-9]+")
	for i in range(tokenCount):
		if "0" == compareFlag[i]:
			m = justInteger.match( testVersion[i] )
			testVersion[i] = m.group()
			m = justInteger.match( testAgainst[i] )
			testAgainst[i] = m.group()
		elif "1" != compareFlag[i]:
			errMsg = "stringCompare argument must be of " +\
				 "the form \"x.x.x.x\" where each " +\
				 "'x' is either '0' or '1'."
			raise EnvironmentError,errMsg
	#
	# Compare the versions
	if condition == "&gt;=":
		for i in range(tokenCount):
			if testVersion[i] &lt; testAgainst[i]:
				return 0
			if testVersion[i] &gt; testAgainst[i]:
				return 1 # it was greater than
		return 1 # it was equal
	if condition == "&gt;":
		for i in range(tokenCount):
			if testVersion[i] &lt; testAgainst[i]:
				return 0
			if testVersion[i] &gt; testAgainst[i]:
				return 1 # it was greater than
		return 0 # it was equal
	if condition == "==":
		for i in range(tokenCount):
			if testVersion[i] != testAgainst[i]:
				return 0 # any token was not equal
		return 1 # every token was equal
	if condition == "!=":
		for i in range(tokenCount):
			if testVersion[i] != testAgainst[i]:
				return 1 # any token was not equal
		return 0 # every token was equal
	if condition == "&lt;":
		for i in range(tokenCount):
			if testVersion[i] &gt;= testAgainst[i]:
				return 0
			if testVersion[i] &lt; testAgainst[i]:
				return 1 # it was less than
		return 0 # it was equal
	if condition == "&lt;=":
		for i in range(tokenCount):
			if testVersion[i] &gt; testAgainst[i]:
				return 0
			if testVersion[i] &lt; testAgainst[i]:
				return 1 # it was less than
		return 1 # it was equal
	#
	# didn't find a condition that we expected.
	raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."
</t>
<t tx="T2887"># From The Python Cookbook.

import operator

class Bunch:
	
	"""A class that represents a colection of things.
	
	Especially useful for representing a collection of related variables."""
	
	def __init__(self, **keywords):
		self.__dict__.update (keywords)

	def ivars(self):
		return self.__dict__.keys()
		
	def __setitem__ (self,key,value):
		return operator.setitem(self.__dict__,key,value)
		
	def __getitem__ (self,key):
		return operator.getitem(self.__dict__,key)
		
		
		
</t>
<t tx="T2888"></t>
<t tx="T2889">@ Returns a list of lines, consisting of the input lines wrapped to the given pageWidth.

Important note: this routine need not deal with leading whitespace.  Instead, the caller should simply reduce pageWidth by the width of leading whitespace wanted, then add that whitespace to the lines returned here.

The key to this code is the invarient that line never ends in whitespace.
@c
# DTHEIN 3-NOV-2002: handle indented first line (normal or hanging indent)

def wrap_lines (lines,pageWidth,firstLineWidth=None):
	
	if pageWidth &lt; 10:
		pageWidth = 10
		
	# DTHEIN 3-NOV-2002: First line is special
	if not firstLineWidth:
		firstLineWidth = pageWidth
	if firstLineWidth &lt; 10:
		firstLineWidth = 10
	outputLineWidth = firstLineWidth

	# trace(`lines`)
	result = [] # The lines of the result.
	line = "" # The line being formed.  It never ends in whitespace.
	for s in lines:
		i = 0
		while i &lt; len(s):
			assert(len(line) &lt; outputLineWidth)
			j = skip_ws(s,i)   # ;   ws = s[i:j]
			k = skip_non_ws(s,j) ; word = s[j:k]
			assert(k&gt;i)
			i = k
			if 1 + len(word) + len(line) &lt; outputLineWidth:
				if len(word) &gt; 0:
					&lt;&lt; place blank and word on the present line &gt;&gt;
				else: pass # discard the trailing whitespace.
			else:
				&lt;&lt; place word on a new line &gt;&gt;
	if len(line) &gt; 0:
		result.append(line)
	# trace(`result`)
	return result</t>
<t tx="T2890">if len(line) == 0:
	# Just add the word to the start of the line.
	line = word
else:
	# Add the word, preceeded by a blank.
	line = string.join((line,' ',word),'')</t>
<t tx="T2891"># End the previous line.
if len(line) &gt; 0:
	result.append(line)
	outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
	
# Discard the whitespace and put the word on a new line.
line = word

# Careful: the word may be longer than pageWidth.
if len(line) &gt;= pageWidth:
	result.append(line)
	outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
	line = ""
</t>
<t tx="T2892"></t>
<t tx="T2893"></t>
<t tx="T2894"># Returns a temporary file name.

def create_temp_name ():

	import tempfile
	temp = tempfile.mktemp()
	# trace(`temp`)
	return temp</t>
<t tx="T2895">def ensure_extension (name, ext):

	file, old_ext = os.path.splitext(name)
	if len(name) == 0:
		return name # don't add to an empty name.
	elif old_ext and old_ext == ext:
		return name
	else:
		return file + ext</t>
<t tx="T2896">@ This is a generalization of os.makedir.
It attempts to make all non-existent directories.
@c

def makeAllNonExistentDirectories (dir):

	if not app.config.create_nonexistent_directories:
		return None

	dir1 = dir = os.path.normpath(dir)
	# Split dir into all its component parts.
	paths = []
	while len(dir) &gt; 0:
		head,tail=os.path.split(dir)
		if len(tail) == 0:
			paths.append(head)
			break
		else:
			paths.append(tail)
			dir = head
	path = ""
	paths.reverse()
	for s in paths:
		path=os.path.join(path,s)
		if not os.path.exists(path):
			try:
				os.mkdir(path)
				es("created directory: "+path)
			except:
				es("exception creating directory: "+path)
				es_exception()
				return None
	return dir1 # All have been created.</t>
<t tx="T2897">@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim, while the windows versions force the string to use the Unix convention of using only "\n".  This routine causes the Unix readline to do the same.
@c

def readlineForceUnixNewline(f):

	s = f.readline()
	if len(s) &gt;= 2 and s[-2] == "\r" and s[-1] == "\n":
		s = s[0:-2] + "\n"
	return s
</t>
<t tx="T2898">class redirectClass:
	&lt;&lt; redirectClass methods &gt;&gt;

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

&lt;&lt; define convenience methods for redirecting streams &gt;&gt;

if 0: # Test code: may be safely and conveniently executed in the child node.
	&lt;&lt; test code &gt;&gt;</t>
<t tx="T2899">
# Redirect streams to the current log window.
def redirectStderr():
	global redirectStdErrObj
	redirectStdErrObj.redirect(stdout=false)

def redirectStdout():
	global redirectStdOutObj
	redirectStdOutObj.redirect()

# Restore standard streams.
def restoreStderr():
	global redirectStdErrObj
	redirectStdErrObj.undirect(stdout=false)
	
def restoreStdout():
	global redirectStdOutObj
	redirectStdOutObj.undirect()
		
def stdErrIsRedirected():
	global redirectStdErrObj
	return redirectStdErrObj.isRedirected()
	
def stdOutIsRedirected():
	global redirectStdOutObj
	return redirectStdOutObj.isRedirected()</t>
<t tx="T2900">from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import redirectStderr,redirectStdout
redirectStderr()
redirectStdout()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import restoreStderr
restoreStderr()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import restoreStdout
restoreStdout()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()</t>
<t tx="T2901">@ This prepares string s to be a valid file name:

- substitute '_' whitespace and characters used special path characters.
- eliminate all other non-alphabetic characters.
- strip leading and trailing whitespace.
- return at most 128 characters.
@c

def sanitize_filename(s):

	result = ""
	for ch in s.strip():
		if ch in string.ascii_letters:
			result += ch
		elif ch in string.whitespace: # Translate whitespace.
			result += '_'
		elif ch in ('.','\\','/',':'): # Translate special path characters.
			result += '_'
	while 1:
		n = len(result)
		result = result.replace('__','_')
		if len(result) == n:
			break
	result = result.strip()
	return result [:128]</t>
<t tx="T2902">def shortFileName (fileName):
	
	return os.path.basename(fileName)</t>
<t tx="T2903">@ Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoGlobals.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statment prints from s[i] to the end of the line if tracing for f has been enabled.

  j = skip_line(s,i) ; trace(s[i:j])

trace(function) exectutes the function if tracing for f has been enabled.  For example,

  trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

  init_trace("+*")         # enable all traces
  init_trace("+a","+b")    # enable traces for a and b
  init_trace(("+a","+b"))  # enable traces for a and b
  init_trace("-a")         # disable tracing for a
  traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

  trace_tag("-nocolor", self.disable_color)
</t>
<t tx="T2904"># Called by startup code.
# Args are all the arguments on the command line.

def init_sherlock (args):
	
	init_trace(args,echo=0)
	# trace("argv", "sys.argv: " + `sys.argv`)</t>
<t tx="T2905">@ It no args are given we attempt to get them from the "SherlockArgs" file.  If there are still no arguments we trace everything.  This default makes tracing much more useful in Python.
@c

def get_Sherlock_args (args):

	if not args or len(args)==0:
		try:
			f = open(os.path.join(app.loadDir,"SherlockArgs"))
			args = f.readlines()
			f.close()
		except: pass
	elif type(args[0]) == type(("1","2")):
		args = args[0] # strip away the outer tuple.

	# No args means trace everything.
	if not args or len(args)==0: args = ["+*"] 
	# print "get_Sherlock_args:", args
	return args</t>
<t tx="T2906">def init_trace(args,echo=1):

	t = app.trace_list
	args = get_Sherlock_args(args)

	for arg in args:
		if arg[0] in string.ascii_letters: prefix = '+'
		else: prefix = arg[0] ; arg = arg[1:]
		
		if prefix == '?':
			print "trace list:", t
		elif prefix == '+' and not arg in t:
			t.append(string.lower(arg))
			if echo:
				print "enabling:", arg
		elif prefix == '-' and arg in t:
			t.remove(string.lower(arg))
			if echo:
				print "disabling:", arg
		else:
			print "ignoring:", prefix + arg</t>
<t tx="T2907"># Convert all args to strings.
# Print if tracing for name has been enabled.

def trace_tag (name, *args):
	
	s = ""
	for arg in args:
		if type(arg) != type(""):
			arg = repr(arg)
		if len(s) &gt; 0:
			s = s + ", " + arg
		else:
			s = arg
	message = s

	t = app.trace_list
	# tracepoint names starting with '-' must match exactly.
	minus = len(name) &gt; 0 and name[0] == '-'
	if minus: name = name[1:]
	if (not minus and '*' in t) or name.lower() in t:
		s = name + ": " + message
		if 1: print s
		else: es(s)
</t>
<t tx="T2908"></t>
<t tx="T2909">def clear_stats():
	
	app.stats = {}
</t>
<t tx="T2910">def print_stats (name=None):
	
	if name:
		if type(name) != type(""):
			name = repr(name)
	else:
		name = callerName(n=2) # Get caller name 2 levels back.
	
	try:
		stats = app.stats
	except:
		print ; print "no statistics at", name ; print
		return
		
	items = stats.items()
	items.sort()
	print ; print "statistics at",name ; print
	for key,value in items:
		print key,value
		
	clear_stats()
</t>
<t tx="T2911">def stat (name=None):

	"""Increments the statistic for name in app.stats
	The caller's name is used by default.
	"""
	
	if name:
		if type(name) != type(""):
			name = repr(name)
	else:
		name = callerName(n=2) # Get caller name 2 levels back.

	try:
		stats = app.stats
	except:
		app.stats = stats = {}

	stats[name] = 1 + stats.get(name,0)
</t>
<t tx="T2912">@ pychecker bug: pychecker complains that there is no attribute time.clock
@c

def getTime():
	return time.clock()
	
def esDiffTime(message, start):
	es(message + ("%6.3f" % (time.clock()-start)))
	return time.clock()</t>
<t tx="T2913">def alert(message):

	es(message)

	import tkMessageBox
	tkMessageBox.showwarning("Alert", message)
</t>
<t tx="T2914"># Returns &lt; &lt; s &gt; &gt;

def angleBrackets(s):

	return ( "&lt;&lt;" + s +
		"&gt;&gt;") # must be on a separate line.

virtual_event_name = angleBrackets</t>
<t tx="T2915">def callerName (n=1):

	try: # get the function name from the call stack.
		f1 = sys._getframe(n) # The stack frame, n levels up.
		code1 = f1.f_code # The code object
		return code1.co_name # The code name
	except:
		es_exception()
		return "&lt;no caller name&gt;"
</t>
<t tx="T2916">def dump(s):
	
	out = ""
	for i in s:
		out += `ord(i)` + ","
	return out
		
def oldDump(s):

	out = ""
	for i in s:
		if i=='\n':
			out += "[" ; out += "n" ; out += "]"
		if i=='\t':
			out += "[" ; out += "t" ; out += "]"
		elif i==' ':
			out += "[" ; out += " " ; out += "]"
		else: out += i
	return out</t>
<t tx="T2917">def es_error (s):
	
	config = app.config
	if config: # May not exist during initialization.
		color = config.getWindowPref("log_error_color")
		es(s,color=color)
	else:
		es(s)</t>
<t tx="T2918">def es_event_exception (eventName,full=false):

	import traceback
	es("exception handling ", eventName, " event")
	typ,val,tb = sys.exc_info()
	if full:
		errList = traceback.format_exception(typ,val,tb)
	else:
		errList = traceback.format_exception_only(typ,val)
	for i in errList:
		es(i)
	traceback.print_exc()</t>
<t tx="T2919">def es_exception (full=true):

	import traceback
	typ,val,tb = sys.exc_info()
	if full:
		errList = traceback.format_exception(typ,val,tb)
	else:
		errList = traceback.format_exception_only(typ,val)
	for i in errList:
		es_error(i)
	traceback.print_exc()</t>
<t tx="T2920">@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):
	setattr(theClass,name or f.__name__,f)
	# trace(`name`)</t>
<t tx="T2921"># Very useful for tracing.

def get_line (s,i):

	nl = ""
	if is_nl(s,i):
		i = skip_nl(s,i)
		nl = "[nl]"
	j = find_line_start(s,i)
	k = skip_to_end_of_line(s,i)
	return nl + s[j:k]
	
def get_line_after (s,i):
	
	nl = ""
	if is_nl(s,i):
		i = skip_nl(s,i)
		nl = "[nl]"
	k = skip_to_end_of_line(s,i)
	return nl + s[i:k]
</t>
<t tx="T2922">def pause (s):
	
	print s
	
	i = 0
	while i &lt; 1000000L:
		i += 1</t>
<t tx="T2923">def print_bindings (name,window):

	bindings = window.bind()
	print
	print "Bindings for", name
	for b in bindings:
		print b</t>
<t tx="T2924">def printGlobals(message=None):
	
	# Get the list of globals.
	globs = list(globals())
	globs.sort()
	
	# Print the list.
	if message:
		leader = "-" * 10
		print leader, ' ', message, ' ', leader
	for glob in globs:
		print glob</t>
<t tx="T2925">def printLeoModules(message=None):
	
	# Create the list.
	mods = []
	for name in sys.modules.keys():
		if name and name[0:3] == "leo":
			mods.append(name)

	# Print the list.
	if message:
		leader = "-" * 10
		print leader, ' ', message, ' ', leader
	mods.sort()
	for m in mods:
		print m,
	print</t>
<t tx="T2926">def executeScript (name):
	
	"""Execute a script whose short python file name is given"""
	
	mod_name,ext = os.path.splitext(name)
	file = None
	try:
		# This code is in effect an import or a reload.
		# This allows the user to modify scripts without leaving Leo.
		import imp
		file,filename,description = imp.find_module(mod_name)
		imp.load_module(mod_name,file,filename,description)
	except:
		es("Exception executing " + name,color="red")
		es_exception()

	if file:
		file.close()

</t>
<t tx="T2927"></t>
<t tx="T2928">def attachLeoIcon (w):
	"""Attach the Leo icon to window w."""
	return app.gui.attachLeoIcon(w)
	
def center_dialog(dialog):
	"""Center the dialog."""
	return app.gui.center_dialog(dialog)
	
def create_labeled_frame (parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
	"""Create a labeled frame."""
	return app.gui.create_labeled_frame(parent,caption,relief,bd,padx,pady)
	
def get_window_info (window):
	"""Return the window information."""
	return app.gui.get_window_info(window)</t>
<t tx="T2929"></t>
<t tx="T2930">def canonicalizeMenuName (name):
	
	name = name.lower() ; newname = ""
	for ch in name:
		# if ch not in (' ','\t','\n','\r','&amp;'):
		if ch in string.ascii_letters:
			newname = newname+ch
	return newname
	
def canonicalizeTranslatedMenuName (name):
	
	name = name.lower() ; newname = ""
	for ch in name:
		if ch not in (' ','\t','\n','\r','&amp;'):
		# if ch in string.ascii_letters:
			newname = newname+ch
	return newname
</t>
<t tx="T2931"># 11/17/02: Fail gracefully if the item name does not exist.
def enableMenu (menu,name,val):
	state = choose(val,"normal","disabled")
	try:
		menu.entryconfig(name,state=state)
	except:
		try:
			realName = app.getRealMenuName(name)
			realName = realName.replace("&amp;","")
			menu.entryconfig(realName,state=state)
		except:
			print "enableMenu menu,name,val:",menu,name,val
			es_exception()
			pass

def disableMenu (menu,name):
	try:
		menu.entryconfig(name,state="disabled")
	except: 
		try:
			realName = app.getRealMenuName(name)
			realName = realName.replace("&amp;","")
			menu.entryconfig(realName,state="disabled")
		except:
			print "disableMenu menu,name:",menu,name
			es_exception()
			pass

def setMenuLabel (menu,name,label,underline=-1):
	try:
		if type(name) == type(0):
			# "name" is actually an index into the menu.
			menu.entryconfig(name,label=label,underline=underline)
		else:
			# Bug fix: 2/16/03: use translated name.
			realName = app.getRealMenuName(name)
			realName = realName.replace("&amp;","")
			# Bug fix: 3/25/03" use tranlasted label.
			label = app.getRealMenuName(label)
			label = label.replace("&amp;","")
			menu.entryconfig(realName,label=label,underline=underline)
	except:
		print "setMenuLabel menu,name,label:",menu,name,label
		es_exception()
		pass</t>
<t tx="T2932"></t>
<t tx="T2933">def importFromPath (name,path):
	
	import imp

	try:
		file = None ; result = None
		try:
			fn = shortFileName(name)
			mod_name,ext = os.path.splitext(fn)
			path = os.path.normpath(path)
			data = imp.find_module(mod_name,[path]) # This can open the file.
			if data:
				file,pathname,description = data
				result = imp.load_module(mod_name,file,pathname,description)
		except:
			es_exception()

	# Bug fix: 6/12/03: Put no return statements before here!
	finally: 
		if file: file.close()

	return result</t>
<t tx="T2934"></t>
<t tx="T2935">def appendToList(out, s):

	for i in s:
		out.append(i)</t>
<t tx="T2936">def flattenList (theList):

	result = []
	for item in theList:
		if type(item) == types.ListType:
			result.extend(flattenList(item))
		else:
			result.append(item)
	return result</t>
<t tx="T2937">def listToString(theList):

	if list:
		theList = flattenList(theList)
		return string.join(theList,"")
	else:
		return ""</t>
<t tx="T2938"># From the Python cookbook.

def makeDict(**keys):
	
	"""Returns a Python dictionary from using the optional keyword arguments."""

	return keys</t>
<t tx="T2939"># These are guaranteed always to exist for scripts.
</t>
<t tx="T2940">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b</t>
<t tx="T2941"></t>
<t tx="T2942">def windows():
	return app.windowList</t>
<t tx="T2943"></t>
<t tx="T2944">def scanAtFileOptions (h,err_flag=false):
	
	assert(match(h,0,"@file"))
	i = len("@file")
	atFileType = "@file"
	optionsList = []

	while match(h,i,'-'):
		&lt;&lt; scan another @file option &gt;&gt;
		
	# Convert atFileType to a list of options.
	for fileType,option in (
		("@silentfile","asis"),
		("@nosentinelsfile","nosent"),
		("@rawfile","noref")):
		if atFileType == fileType:
			optionsList.append(option)
			
	# trace(atFileType,optionsList)

	return i,atFileType,optionsList</t>
<t tx="T2945">i += 1 ; err = -1

if match_word(h,i,"asis"):
	if atFileType == "@file":
		atFileType = "@silentfile"
	elif err_flag:
		es("using -asis option in:" + h)
elif match(h,i,"noref"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@rawfile"
	elif atFileType == "@nosentinelsfile":
		atFileType = "@silentfile"
	elif err_flag:
		es("ignoring redundant -noref in:" + h)
elif match(h,i,"nosent"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@nosentinelsfile"
	elif atFileType == "@rawfile":
		atFileType = "@silentfile"
	elif err_flag:
		es("ignoring redundant -nosent in:" + h)
else:
	for option in ("fat","new","now","old","thin","wait"):
		if match_word(h,i,option):
			optionsList.append(option)
	if len(option) == 0:
		err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
	i += 1
if err &gt; -1:
	es("unknown option:" + h[err:i] + " in " + h)</t>
<t tx="T2946">def scanAtRootOptions (s,i,err_flag=false):
	
	assert(match(s,i,"@root"))
	i += len("@root")
	mode = None 
	while match(s,i,'-'):
		&lt;&lt; scan another @root option &gt;&gt;

	if mode == None:
		doc = app.config.at_root_bodies_start_in_doc_mode
		mode = choose(doc,"doc","code")
	return i,mode</t>
<t tx="T2947">i += 1 ; err = -1

if match_word(s,i,"code"): # Just match the prefix.
	if not mode: mode = "code"
	elif err_flag: es("modes conflict in:" + get_line(s,i))
elif match(s,i,"doc"): # Just match the prefix.
	if not mode: mode = "doc"
	elif err_flag: es("modes conflict in:" + get_line(s,i))
else:
	err = i-1
	
# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','-'):
	i += 1

if err &gt; -1 and err_flag:
	es("unknown option:" + s[err:i] + " in " + get_line(s,i))</t>
<t tx="T2948">@ It seems dubious to bump the Tangle error count here.  OTOH, it really doesn't hurt.
@c

def scanError(s):

	# Bump the error count in the tangle command.
	top().tangleCommands.errors += 1

	es(s)</t>
<t tx="T2949"># A quick and dirty sscanf.  Understands only %s and %d.

def scanf (s,pat):
	import re
	count = pat.count("%s") + pat.count("%d")
	pat = pat.replace("%s","(\S+)")
	pat = pat.replace("%d","(\d+)")
	parts = re.split(pat,s)
	result = []
	for part in parts:
		if len(part) &gt; 0 and len(result) &lt; count:
			result.append(part)
	# trace("scanf returns:",result)
	return result
	
if 0: # testing
	from leoGlobals import trace
	scanf("1.0","%d.%d",)</t>
<t tx="T2950">@ These scanners all call scanError() directly or indirectly, so they will call es() if they find an error.  scanError() also bumps commands.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="T2951"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

	assert(match(s,i,"/*"))
	j = i ; i += 2 ; n = len(s)
	
	k = string.find(s,"*/",i)
	if k == -1:
		scanError("Run on block comment: " + s[j:i])
		return n
	else: return k + 2</t>
<t tx="T2952">@ Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

	# start = get_line(s,i)
	assert(match(s,i,'{'))
	level = 0 ; n = len(s)
	while i &lt; n:
		c = s[i]
		if c == '{':
			level += 1 ; i += 1
		elif c == '}':
			level -= 1
			if level &lt;= 0: return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,'//'): i = skip_to_end_of_line(s,i)
		elif match(s,i,'/*'): i = skip_block_comment(s,i)
		# 7/29/02: be more careful handling conditional code.
		elif match_word(s,i,"#if") or match_word(s,i,"#ifdef") or match_word(s,i,"#ifndef"):
			i,delta = skip_pp_if(s,i)
			level += delta
		else: i += 1
	return i</t>
<t tx="T2953">@ 08-SEP-2002 DTHEIN: Added for PHP import support
Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, and only for PHP imports.
@c

def skip_php_braces(s,i):

	# start = get_line(s,i)
	assert(match(s,i,'{'))
	level = 0 ; n = len(s)
	while i &lt; n:
		c = s[i]
		if c == '{':
			level += 1 ; i += 1
		elif c == '}':
			level -= 1
			if level &lt;= 0: return i + 1
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"&lt;&lt;&lt;"): i = skip_heredoc_string(s,i)
		elif match(s,i,'//') or match(s,i,'#'): i = skip_to_end_of_line(s,i)
		elif match(s,i,'/*'): i = skip_block_comment(s,i)
		else: i += 1
	return i
</t>
<t tx="T2954">@ Skips from the opening ( to the matching ) . If no matching is found i is set to len(s)
@c

def skip_parens(s,i):
	level = 0 ; n = len(s)
	assert(match(s,i,'('))
	while i &lt; n:
		c = s[i]
		if c == '(':
			level += 1 ; i += 1
		elif c == ')':
			level -= 1
			if level &lt;= 0:  return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2955">@ Skips from begin to matching end.
If found, i points to the end. Otherwise, i &gt;= len(s)
The end keyword matches begin, case, class, record, and try.
@c

def skip_pascal_begin_end(s,i):

	assert(match_c_word(s,i,"begin"))
	level = 1 ; i = skip_c_id(s,i) # Skip the opening begin.
	while i &lt; len(s):
		ch = s[i]
		if ch =='{' : i = skip_pascal_braces(s,i)
		elif ch =='"' or ch == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif match_c_word(s,i,"end"):
			level -= 1 ;
			if level == 0:
				# lines = s[i1:i+3] ; trace('\n' + lines + '\n')
				return i
			else: i = skip_c_id(s,i)
		elif is_c_id(ch):
			j = i ; i = skip_c_id(s,i) ; name = s[j:i]
			if name in ["begin", "case", "class", "record", "try"]:
				level += 1
		else: i += 1
	return i</t>
<t tx="T2956"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
	
	j = i
	assert(match(s,i,"(*"))
	i = string.find(s,"*)",i)
	if i &gt; -1: return i + 2
	else:
		scanError("Run on comment" + s[j:i])
		return len(s)

#   n = len(s)
#   while i &lt; n:
#       if match(s,i,"*)"): return i + 2
#       i += 1
#   scanError("Run on comment" + s[j:i])
#   return i</t>
<t tx="T2957">def skip_pascal_string(s,i):

	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')

	while i &lt; len(s):
		if s[i] == delim:
			return i + 1
		else: i += 1

	scanError("Run on string: " + s[j:i])
	return i</t>
<t tx="T2958">@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

  &lt;&lt;&lt;EOS
  This is my string.
  It is mine. I own it.
  No one else has it.
  EOS

It begins with &lt;&lt;&lt; plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.

@c
def skip_heredoc_string(s,i):
	
	import re
	
	j = i
	assert(match(s,i,"&lt;&lt;&lt;"))
	m = re.match("\&lt;\&lt;\&lt;([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
	if (None == m):
		i += 3
		return i

	# 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
	delim = m.group(1) + '\n' 
	
	i = skip_line(s,i) # 14-SEP-2002 DTHEIN: look after \n, not before
	n = len(s)
	while i &lt; n and not match(s,i,delim):
		i = skip_line(s,i) # 14-SEP-2002 DTHEIN: move past \n
		
	if i &gt;= n:
		scanError("Run on string: " + s[j:i])
	elif match(s,i,delim):
		i += len(delim)
	return i
</t>
<t tx="T2959"># Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

	while i &lt; len(s):
		if is_nl(s,i):
			if escaped(s,i): i = skip_nl(s,i)
			else: break
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2960"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):
	
	start_line = get_line(s,i) # used for error messages.
	# trace(start_line)

	assert(
		match_word(s,i,"#if") or
		match_word(s,i,"#ifdef") or
		match_word(s,i,"#ifndef"))

	i = skip_line(s,i)
	i,delta1 = skip_pp_part(s,i)
	i = skip_ws(s,i)
	if match_word(s,i,"#else"):
		i = skip_line(s,i)
		i = skip_ws(s,i)
		i,delta2 = skip_pp_part(s,i)
		if delta1 != delta2:
			es("#if and #else parts have different braces: " + start_line)
	i = skip_ws(s,i)
	if match_word(s,i,"#endif"):
		i = skip_line(s,i)
	else:
		es("no matching #endif: " + start_line)
		
	# trace(`delta1` + ":" + start_line)
	return i,delta1
</t>
<t tx="T2961"># Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s,i):

	# trace(get_line(s,i))

	delta = 0
	while i &lt; len(s):
		c = s[i]
		if 0:
			if c == '\n':
				trace(`delta` + ":" + get_line(s,i))
		if match_word(s,i,"#if") or match_word(s,i,"#ifdef") or match_word(s,i,"#ifndef"):
			i,delta1 = skip_pp_if(s,i)
			delta += delta1
		elif match_word(s,i,"#else") or match_word(s,i,"#endif"):
			return i,delta
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif c == '{':
			delta += 1 ; i += 1
		elif c == '}':
			delta -= 1 ; i += 1
		elif match(s,i,"//"): i = skip_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i,delta</t>
<t tx="T2962">def skip_python_string(s,i):

	if match(s,i,"'''") or match(s,i,'"""'):
		j = i ; delim = s[i]*3 ; i += 3
		k = string.find(s,delim,i)
		if k &gt; -1: return k+3
		scanError("Run on triple quoted string: " + s[j:i])
		return len(s)
	else:
		return skip_string(s,i)</t>
<t tx="T2963">def skip_string(s,i):
	
	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i] == '\\' : i += 2
		else: i += 1

	if i &gt;= n:
		scanError("Run on string: " + s[j:i])
	elif s[i] == delim:
		i += 1
	return i</t>
<t tx="T2964"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c == ';': return i
		elif c == '\'' or c == '"' : i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2965">def skip_typedef(s,i):

	n = len(s)
	while i &lt; n and is_c_id(s[i]):
		i = skip_c_id(s,i)
		i = skip_ws_and_nl(s,i)
	if match(s,i,'{'):
		i = skip_braces(s,i)
		i = skip_to_semicolon(s,i)
	return i</t>
<t tx="T2966"></t>
<t tx="T2967"># Returns true if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

	count = 0
	while i-1 &gt;= 0 and s[i-1] == '\\':
		count += 1
		i -= 1
	return (count%2) == 1</t>
<t tx="T2968">def find_line_start(s,i):

	# bug fix: 11/2/02: change i to i+1 in rfind
	i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
	if i == -1: return 0
	else: return i + 1</t>
<t tx="T2969">def find_on_line(s,i,pattern):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	j = string.find(s,'\n',i)
	if j == -1: j = len(s)
	k = string.find(s,pattern,i,j)
	if k &gt; -1: return k
	else: return None</t>
<t tx="T2970">def is_c_id(ch):

	return ch in string.ascii_letters or ch in string.digits or ch == '_'</t>
<t tx="T2971">def is_nl(s,i):

	return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="T2972">@ Return true if the body text contains the @ directive.

We no longer require that the directive appear befor any @c directive or section definition.
@c

def is_special(s,i,directive):

	# j = skip_line(s,i) ; trace(`s[i:j]` + " : " + `directive`)
	assert (directive and directive [0] == '@' )

	# 10/23/02: all directives except @others must start the line.
	skip_flag = directive == "@others"
	while i &lt; len(s):
		if match_word(s,i,directive):
			return true, i
		else:
			i = skip_line(s,i)
			if skip_flag:
				i = skip_ws(s,i)
	return false, -1</t>
<t tx="T2973">def is_ws(c):

	return c == '\t' or c == ' '
	
def is_ws_or_nl(s,i):

	return is_nl(s,i) or (i &lt; len(s) and is_ws(s[i]))</t>
<t tx="T2974"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

	return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="T2975">def match_c_word (s,i,name):

	if name == None: return false
	n = len(name)
	if n == 0: return false
	return name == s[i:i+n] and (i+n == len(s) or not is_c_id(s[i+n]))</t>
<t tx="T2976">def match_ignoring_case(s1,s2):

	if s1 == None or s2 == None: return false
	return string.lower(s1) == string.lower(s2)</t>
<t tx="T2977">def match_word(s,i,pattern):

	if pattern == None: return false
	j = len(pattern)
	if j == 0: return false
	if string.find(s,pattern,i,i+j) != i:
		return false
	if i+j &gt;= len(s):
		return true
	c = s[i+j]
	return not (c in string.ascii_letters or c in string.digits or c == '_')</t>
<t tx="T2978">def skip_blank_lines(s,i):

	while i &lt; len(s):
		if is_nl(s,i) :
			i = skip_nl(s,i)
		elif is_ws(s[i]):
			j = skip_ws(s,i)
			if is_nl(s,j):
				i = j
			else: break
		else: break
	return i</t>
<t tx="T2979">def skip_c_id(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c in string.ascii_letters or c in string.digits or c == '_':
			i += 1
		else: break
	return i</t>
<t tx="T2980">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i + 1
		
def skip_to_end_of_line (s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i</t>
<t tx="T2981">def skip_long(s,i):
	
	"""Scan s[i:] for a valid int.
	Return (i, val) or (i, None) if s[i] does not point at a number.
	"""

	digits = string.digits
	val = 0
	i = skip_ws(s,i)
	n = len(s)
	if i &gt;= n or s[i] not in "+-" + digits:
		return i, None
	# Rewritten: 7/18/02.
	j = i
	if s[i] in '+-':    # whr allow sign if first digit
		i +=1
	while i &lt; n and s[i] in digits:
		i += 1
	try: # 4/24/03: There may be no digits, which would raise an exception.
		val = int(s[j:i])
		return i, val
	except:
		return i,None
</t>
<t tx="T2982">def skip_matching_delims(s,i,delim1,delim2):
	
	assert(match(s,i,delim1))

	i += len(delim1)
	k = string.find(s,delim2,i)
	if k == -1:
		return len(s)
	else:
		return k + len(delim2)</t>
<t tx="T2983">@ This function skips a single "logical" end-of-line character.  We need this function because different systems have different end-of-line conventions.
@c

def skip_nl (s,i):

	if match(s,i,"\r\n"): return i + 2
	elif match(s,i,'\n') or match(s,i,'\r'): return i + 1
	else: return i</t>
<t tx="T2984">def skip_non_ws (s,i):

	n = len(s)
	while i &lt; n and not is_ws(s[i]):
		i += 1
	return i</t>
<t tx="T2985"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

	# No constructs are recognized inside Pascal block comments!
	k = string.find(s,'}',i)
	if i == -1: return len(s)
	else: return k</t>
<t tx="T2986">def skip_to_char(s,i,ch):
	
	j = string.find(s,ch,i)
	if j == -1:
		return len(s),s[i:]
	else:
		return j,s[i:j]
</t>
<t tx="T2987">def skip_ws(s,i):

	n = len(s)
	while i &lt; n and is_ws(s[i]):
		i += 1
	return i
	
def skip_ws_and_nl(s,i):

	n = len(s)
	while i &lt; n and (is_ws(s[i]) or is_nl(s,i)):
		i += 1
	return i</t>
<t tx="T2988"></t>
<t tx="T2989"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

	if width &lt;= 0:
		return ""
	if tab_width &gt; 1:
		tabs   = width / tab_width
		blanks = width % tab_width
		return ('\t' * tabs) + (' ' * blanks)
	else: # 7/3/02: negative tab width always gets converted to blanks.
		return (' ' * width)</t>
<t tx="T2990"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):
		
	w = 0
	for ch in s:
		if ch == '\t':
			w += (abs(tab_width) - (w % abs(tab_width)))
		else:
			w += 1
	return w</t>
<t tx="T2991">def get_leading_ws(s):
	
	"""Returns the leading whitespace of 's'."""

	i = 0 ; n = len(s)
	while i &lt; n and s[i] in (' ','\t'):
		i += 1
	return s[0:i]
</t>
<t tx="T2992"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

	i, width = skip_leading_ws_with_indent(line,0,tab_width)
	s = computeLeadingWhitespace(width,tab_width) + line[i:]
	return s</t>
<t tx="T2993"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

	j = 0 ; ws = 0
	for ch in s:
		if ws &gt;= first_ws:
			break
		elif ch == ' ':
			j += 1 ; ws += 1
		elif ch == '\t':
			j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
		else: break
	if j &gt; 0:
		s = s[j:]
	return s</t>
<t tx="T2994"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

	j = len(s)-1
	while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
		j -= 1
	return s[:j+1]
</t>
<t tx="T2995"># Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

	count = 0
	while count &lt; ws and i &lt; len(s):
		ch = s[i]
		if ch == ' ':
			count += 1
			i += 1
		elif ch == '\t':
			count += (abs(tab_width) - (count % abs(tab_width)))
			i += 1
		else: break

	return i</t>
<t tx="T2996">@ Skips leading whitespace and returns (i, indent), where i points after the whitespace and indent is the width of the whitespace, assuming tab_width wide tabs.
@c

def skip_leading_ws_with_indent(s,i,tab_width):

	count = 0 ; n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch == ' ':
			count += 1
			i += 1
		elif ch == '\t':
			count += (abs(tab_width) - (count % abs(tab_width)))
			i += 1
		else: break

	return i, count</t>
<t tx="T2997">@first # -*- coding: utf-8 -*-

"""A module containing all of Leo's default gui code.

Plugins may define their own gui classes by setting app.gui."""

from leoGlobals import *
import leoCommands,leoFind,leoFrame,leoTree
import os,sys,tkFont,Tkinter,traceback

Tk = Tkinter

@others</t>
<t tx="T2998">class leoGui:
	
	"""The base class of all gui classes.
	
	Subclasses are expected to override all do-nothing methods of this class."""
	
	@others</t>
<t tx="T2999">def __init__ (self,guiName):
	
	# trace("leoGui",guiName)
	
	self.leoIcon = None
	self.mGuiName = guiName
	self.mainLoop = None
	self.root = None
</t>
<t tx="T3000">def guiName(self):
	
	try:
		return self.mGuiName
	except:
		return "invalid gui name"</t>
<t tx="T3001">def oops (self):
	
	print "oops", callerName(2), "should be overridden in subclass"</t>
<t tx="T3002">@ Leo's core code calls these routine to create commanders and the corresponding frame objects.</t>
<t tx="T3003">def destroyLeoFrame (self,frame):

	self.oops()</t>
<t tx="T3004">def destroy (self,widget):
	self.oops()</t>
<t tx="T3005">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.</t>
<t tx="T3006">def createRootWindow(self):
	"""Create the hidden root window for the gui.
	
	Nothing needs to be done if the root window need not exist."""
	self.oops()
	
def finishCreate (self):
	"""Do any remaining chores after the root window has been created."""
	self.oops()

def killGui(self,exitFlag=true):
	"""Destroy the gui.
	
	The entire Leo application should terminate if exitFlag is true."""
	self.oops()

def recreateRootWindow(self):
	"""Create the hidden root window of the gui
    after a previous gui has terminated with killGui(false)."""
	self.oops()
</t>
<t tx="T3007">def runMainLoop(self):

	"""Run the gui's main loop."""
	self.oops()</t>
<t tx="T3008">def newColorFrame(self,commander):
	"""Create a colorFrame."""
	self.oops()

def newColorNameFrame(self,commander):
	"""Create a colorNameFrame."""
	self.oops()

def newCompareFrame(self,commander):
	"""Create a compareFrame."""
	self.oops()

def newFindFrame(self,commander):
	"""Create a findFrame."""
	self.oops()

def newFontFrame(self,commander):
	"""Create a fontFrame."""
	self.oops()

def newLeoFrame(self,title):
	"""Create a view frame for the Leo main window."""
	self.oops()

def newPrefsFrame(self,commander):
	"""Create a prefsFrame."""
	self.oops()</t>
<t tx="T3009">def newAboutLeoDialog(self,commander):
	"""Create an About Leo dialog."""
	self.oops()

def newAskOkDialog(self,commander):
	"""Create an askOK dialog ."""
	self.oops()

def newAskOkCancelDialog(self,commander):
	"""Create an askOkCancel dialog."""
	self.oops()

def newAskOkCancelNumberDialog(self,commander):
	"""Create an askOkCancelNumber dialog ."""
	self.oops()

def newAskYesNoDialog(self,commander):
	"""Create an askYesNo dialog."""
	self.oops()

def newAskYesNoCancelDialg(self,commander):
	"""Create an askYesNoCancel dialog ."""
	self.oops()</t>
<t tx="T3010">def attachLeoIcon (self,window):
	"""Attach the Leo icon to a window."""
	self.oops()
	
def center_dialog(self,dialog):
	"""Center a dialog."""
	self.oops()
	
def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
	"""Create a labeled frame."""
	self.oops()
	
def get_window_info (self,window):
	"""Return the window information."""
	self.oops()
</t>
<t tx="T3011">def get_focus(self,top):
	"""Return the widget that has focus, or the body widget if None."""
	self.oops()
	
def set_focus(self,commander,widget):
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	self.oops()
	
def force_focus(self,commander,widget):
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	self.oops()</t>
<t tx="T3012">class tkinterGui(leoGui):
	
	"""A class encapulating all calls to tkinter."""
	
	@others</t>
<t tx="T3013"></t>
<t tx="T3014">def __init__ (self):
	
	# trace("tkinterGui")
	
	# Initialize the base class.
	leoGui.__init__(self,"tkinter")
	
	self.bitmap_name = None
	self.bitmap = None</t>
<t tx="T3015">def createRootWindow(self):

	"""Create a hidden Tk root window."""

	self.root = root = Tkinter.Tk()
	root.title("Leo Main Window")
	root.withdraw()
	
	self.setDefaultIcon()
	self.getDefaultConfigFont(app.config)
	self.setEncoding()
	self.createGlobalWindows()

	return root</t>
<t tx="T3016">@ According to Martin v. Lwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):

	for (encoding,src) in (
		(app.config.tkEncoding,"config"),
		#(locale.getdefaultlocale()[1],"locale"),
		(getpreferredencoding(),"locale"),
		(sys.getdefaultencoding(),"sys"),
		("utf-8","default")):
	
		if isValidEncoding (encoding): # 3/22/03
			app.tkEncoding = encoding
			# trace(app.tkEncoding,src)
			break
		elif encoding and len(encoding) &gt; 0:
			trace("ignoring invalid " + src + " encoding: " + `encoding`)
			
	color = choose(app.tkEncoding=="ascii","red","blue")
	es("Text encoding = " + app.tkEncoding, color=color)
			
	# trace(app.tkEncoding)</t>
<t tx="T3017">def getDefaultConfigFont(self,config):
	
	"""Get the default font from a new text widget."""

	t = Tkinter.Text()
	fn = t.cget("font")
	font = tkFont.Font(font=fn)
	config.defaultFont = font
	config.defaultFontFamily = font.cget("family")</t>
<t tx="T3018">def createGlobalWindows (self):
	
	"""Create the global windows for the application."""

	app.findFrame = leoFind.leoFind()
	app.findFrame.top.withdraw()
	app.globalWindows.append(app.findFrame)</t>
<t tx="T3019">def destroyLeoFrame (self,frame):

	self.destroy(frame.top)</t>
<t tx="T3020">def destroy(self,widget):
	
	widget.destroy()</t>
<t tx="T3021">def finishCreate (self):
	
	pass
	
</t>
<t tx="T3022">def killGui(self,exitFlag=true):
	
	"""Destroy a gui and terminate Leo if exitFlag is true."""

	pass # Not ready yet.

</t>
<t tx="T3023">def recreateRootWindow(self):
	"""A do-nothing base class to create the hidden root window of a gui

	after a previous gui has terminated with killGui(false)."""
	pass

</t>
<t tx="T3024">def runMainLoop(self):

	"""Run tkinter's main loop."""

	# trace("tkinterGui")
	self.root.mainloop()</t>
<t tx="T3025"></t>
<t tx="T3026">def getFontFromParams(self,family,size,slant,weight):
	
	family_name = family
	
	try:
		font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
		#print family_name,family,size,slant,weight
		#print "actual_name:",font.cget("family")
		return font
	except:
		es("exception setting font from " + `family_name`)
		es("family,size,slant,weight:"+
			`family`+':'+`size`+':'+`slant`+':'+`weight`)
		es_exception()
		return app.config.defaultFont</t>
<t tx="T3027">def newAboutLeoDialog(self,commander):
	"""A do-nothing base class to create an About Leo dialog."""
	pass

def newAskOkDialog(self,commander):
	"""A do-nothing base class to create an askOK dialog ."""
	pass

def newAskOkCancelDialog(self,commander):
	"""A do-nothing base class to create an askOkCancel dialog."""
	pass

def newAskOkCancelNumberDialog(self,commander):
	"""A do-nothing base class to create an askOkCancelNumber dialog ."""
	pass

def newAskYesNoDialog(self,commander):
	"""A do-nothing base class to create an askYesNo dialog."""
	pass

def newAskYesNoCancelDialg(self,commander):
	"""A do-nothing base class to create an askYesNoCancel dialog ."""
	pass</t>
<t tx="T3028"></t>
<t tx="T3029">def get_focus(self,top):
	
	"""Returns the widget that has focus, or body if None."""

	return top.focus_displayof()</t>
<t tx="T3030">def set_focus(self,commands,widget):
	
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	
	focus = commands.frame.top.focus_displayof()
	if focus != widget:
		widget.focus_set()</t>
<t tx="T3031">def force_focus(self,commands,widget):
	
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	
	focus = commands.frame.top.focus_displayof()
	if focus != widget:
		widget.focus_force() # Apparently it is not a good idea to call focus_force.</t>
<t tx="T3032"></t>
<t tx="T3033"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
	
	top.update_idletasks() # Required to get proper info.

	# Get the information about top and the screen.
	geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
	dim,x,y = string.split(geom,'+')
	w,h = string.split(dim,'x')
	w,h,x,y = int(w),int(h),int(x),int(y)
	
	return w,h,x,y</t>
<t tx="T3034"># Center the dialog on the screen.
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def center_dialog(self,top):

	sw = top.winfo_screenwidth()
	sh = top.winfo_screenheight()
	w,h,x,y = get_window_info(top)
	
	# Set the new window coordinates, leaving w and h unchanged.
	x = (sw - w)/2
	y = (sh - h)/2
	top.geometry("%dx%d%+d%+d" % (w,h,x,y))
	
	return w,h,x,y</t>
<t tx="T3035"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
	caption=None,relief="groove",bd=2,padx=0,pady=0):
	
	Tk = Tkinter
	# Create w, the master frame.
	w = Tk.Frame(parent)
	w.grid(sticky="news")
	
	# Configure w as a grid with 5 rows and columns.
	# The middle of this grid will contain f, the expandable content area.
	w.columnconfigure(1,minsize=bd)
	w.columnconfigure(2,minsize=padx)
	w.columnconfigure(3,weight=1)
	w.columnconfigure(4,minsize=padx)
	w.columnconfigure(5,minsize=bd)
	
	w.rowconfigure(1,minsize=bd)
	w.rowconfigure(2,minsize=pady)
	w.rowconfigure(3,weight=1)
	w.rowconfigure(4,minsize=pady)
	w.rowconfigure(5,minsize=bd)

	# Create the border spanning all rows and columns.
	border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
	border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
	
	# Create the content frame, f, in the center of the grid.
	f = Tk.Frame(w,bd=bd)
	f.grid(row=3,column=3,sticky="news")
	
	# Add the caption.
	if caption and len(caption) &gt; 0:
		caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
		caption.tkraise(w)
		caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

	return w,f</t>
<t tx="T3036">@language python

from leoGlobals import *

&lt;&lt; scripts &gt;&gt;

class baseLeoImportCommands:
	"""The base class for Leo's import commands."""
	@others
	
class leoImportCommands (baseLeoImportCommands):
	"""A class that implements Leo's import commands."""
	pass</t>
<t tx="T3037">def __init__ (self,commands):

	self.commands = commands
	
	# Set by ImportFilesFommand.
	self.treeType = "@file" # "@root" or "@file"
	# Set by ImportWebCommand.
	self.webType = "@noweb" # "cweb" or "noweb"

	# Set by create_outline.
	self.fileName = None # The original file name, say x.cpp
	self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
	self.fileType = None # ".py", ".c", etc.
	self.rootLine = "" # Empty or @root + self.fileName

	# Support of output_newline option
	self.output_newline = getOutputNewline()
	
	# Used by Importers.
	self.web_st = []
	self.encoding = app.tkEncoding # 2/25/03: was "utf-8"
</t>
<t tx="T3038">@others</t>
<t tx="T3039"></t>
<t tx="T3040">def importFilesCommand (self,files,treeType):

	c = self.commands
	if c == None: return
	v = current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.treeType = treeType
	c.beginUpdate()
	if 1: # range of update...
		if len(files) == 2:
			&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
		for i in xrange(len(files)):
			fileName = files[i]
			v = self.createOutline(fileName,current)
			if v: # 8/11/02: createOutline may fail.
				es("imported " + fileName)
				v.contract()
				v.setDirty()
				c.setChanged(true)
		c.validateOutline()
		current.expand()
	c.endUpdate()
	c.selectVnode(current)</t>
<t tx="T3041">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = os.path.splitext(name0)
prefix1, junk = os.path.splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
	current = current.insertAsLastChild()
	junk, nameExt = os.path.split(prefix1)
	name,ext = os.path.splitext(prefix1)
	current.initHeadString(name)</t>
<t tx="T3042"></t>
<t tx="T3043"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

	c = self.commands
	if len(strings) == 0: return None
	if not self.stringsAreValidMoreFile(strings): return None
	c.beginUpdate()
	firstLevel, junk = self.moreHeadlineLevel(strings[0])
	lastLevel = -1 ; theRoot = lastVnode = None
	index = 0
	while index &lt; len(strings):
		progress = index
		s = strings[index]
		level, newFlag = self.moreHeadlineLevel(s)
		level -= firstLevel
		if level &gt;= 0:
			&lt;&lt; Link a new vnode v into the outline &gt;&gt;
			&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
			&lt;&lt; Count the number of following body lines &gt;&gt;
			&lt;&lt; Add the lines to the body text of v &gt;&gt;
			v.setDirty()
		else: index += 1
		assert progress &lt; index
	if theRoot:
		theRoot.setDirty()
		c.setChanged(true)
	c.endUpdate()
	return theRoot</t>
<t tx="T3044">assert(level &gt;= 0)
if not lastVnode:
	theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
	v = lastVnode.insertAfter()
elif level == lastLevel + 1:
	v = lastVnode.insertAsNthChild(0)
else:
	assert(level &lt; lastLevel)
	while level &lt; lastLevel:
		lastLevel -= 1
		lastVnode = lastVnode.parent()
		assert(lastVnode)
		assert(lastLevel &gt;= 0)
	v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level</t>
<t tx="T3045">j = 0
while match(s,j,'\t'):
	j += 1
if match(s,j,"+ ") or match(s,j,"- "):
	j += 2

v.initHeadString(s[j:])</t>
<t tx="T3046">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
	s = strings[index]
	level, junk = self.moreHeadlineLevel(s)
	level -= firstLevel
	if level &gt;= 0:
		break
	# Remove first backslash of the body line.
	if match(s,0,'\\'):
		strings[index] = s[1:]
	bodyLines += 1
	index += 1</t>
<t tx="T3047">if bodyLines &gt; 0:
	body = ""
	n = index - bodyLines
	while n &lt; index:
		body += strings[n]
		if n != index - 1:
			body += "\n"
		n += 1
	v.t.setTnodeText(body)</t>
<t tx="T3048"># On entry,files contains at most one file to convert.
def importFlattenedOutline (self,files):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.setEncoding()
	fileName = files[0]
	&lt;&lt; Read the file into array &gt;&gt;
	# Convert the string to an outline and insert it after the current node.
	newVnode = self.convertMoreStringsToOutlineAfter(array,current)
	if newVnode:
		c.undoer.setUndoParams("Import",newVnode,select=current)
		c.endEditing()
		c.validateOutline()
		c.editVnode(newVnode)
		newVnode.setDirty()
		c.setChanged(true)
	else:
		es(fileName + " is not a valid MORE file.")</t>
<t tx="T3049">try:
	file = open(fileName)
	s = file.read()
	s = string.replace(s,"\r","")
	s = toUnicode(s,self.encoding)
	array = string.split(s,"\n")
	file.close()
except:
	es_exception()
	array = []</t>
<t tx="T3050"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

	level = 0 ; i = 0
	while match(s,i,'\t'):
		level += 1
		i += 1
	plusFlag = choose(match(s,i,"+"),true,false)
	if match(s,i,"+ ") or match(s,i,"- "):
		return level, plusFlag
	else:
		return -1, plusFlag</t>
<t tx="T3051"># Used by paste logic.

def stringIsValidMoreFile (self,s):
	
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

	if len(strings) &lt; 1: return false
	level1, plusFlag = self.moreHeadlineLevel(strings[0])
	if level1 == -1: return false
	# Check the level of all headlines.
	i = 0 ; 	lastLevel = level1
	while i &lt; len(strings):
		s = strings[i] ; i += 1
		level, newFlag = self.moreHeadlineLevel(s)
		if level &gt; 0:
			if level &lt; level1 or level &gt; lastLevel + 1:
				return false # improper level.
			elif level &gt; lastLevel and plusFlag == false:
				return false # parent of this node has no children.
			elif level == lastLevel and plusFlag == true:
				return false # last node has missing child.
			else:
				lastLevel = level
				plusFlag = newFlag
	return true</t>
<t tx="T3052"></t>
<t tx="T3053">def createOutlineFromWeb (self,path,parent):

	c = self.commands ; current = c.currentVnode()
	junk, fileName = os.path.split(path)
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	v.initHeadString(fileName)
	if self.webType=="cweb":
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + "@language cweb")

	# Scan the file,creating one section for each function definition.
	self.scanWebFile(path,v)
	return v</t>
<t tx="T3054">def importWebCommand (self,files,webType):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.webType = webType
	c.beginUpdate()
	for i in xrange(len(files)):
		fileName = files[i]
		v = self.createOutlineFromWeb(fileName,current)
		v.contract()
		v.setDirty()
		c.setChanged(true)
	c.selectVnode(current)
	c.endUpdate()</t>
<t tx="T3055">def findFunctionDef (self,s,i):
	
	# Look at the next non-blank line for a function name.
	i = skip_ws_and_nl(s,i)
	k = skip_line(s,i)
	name = None
	while i &lt; k:
		if is_c_id(s[i]):
			j = i ; i = skip_c_id(s,i) ; name = s[j:i]
		elif s[i] == '(':
			if name: return name
			else: break
		else: i += 1
	return None</t>
<t tx="T3056">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):
	
	if self.webType == "cweb":
		&lt;&lt; scan cweb body for headline &gt;&gt;
	else:
		&lt;&lt; scan noweb body for headline &gt;&gt;
	return "@" # default.</t>
<t tx="T3057">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	# Allow constructs such as @ @c, or @ @&lt;.
	if self.isDocStart(s,i):
		i += 2 ; i = skip_ws(s,i)
	if match(s,i,"@d") or match(s,i,"@f"):
		# Look for a macro name.
		directive = s[i:i+2]
		i = skip_ws(s,i+2) # skip the @d or @f
		if i &lt; len(s) and is_c_id(s[i]):
			j = i ; skip_c_id(s,i) ; return s[j:i]
		else: return directive
	elif match(s,i,"@c") or match(s,i,"@p"):
		# Look for a function def.
		name = self.findFunctionDef(s,i+2)
		return choose(name,name,"outer function")
	elif match(s,i,"@&lt;"):
		# Look for a section def.
		# A small bug: the section def must end on this line.
		j = i ; k = find_on_line(s,i,"@&gt;")
		if k &gt; -1 and (match(s,k+2,"+=") or match(s,k+2,"=")):
			return s[j:k+2] # return the section ref.
	i = skip_line(s,i)</t>
<t tx="T3058">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if match(s,i,"&lt;&lt;"):
		k = find_on_line(s,i,"&gt;&gt;=")
		if k &gt; -1:
			ref = s[i:k+2]
			name = string.strip(s[i+2:k])
			if name != "@others":
				return ref
	else:
		name = self.findFunctionDef(s,i)
		if name:
			return name
	i = skip_line(s,i)</t>
<t tx="T3059">def scanWebFile (self,fileName,parent):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")

	try: # Read the file into s.
		f = open(fileName)
		s = f.read()
	except: s = None

	&lt;&lt; Create a symbol table of all section names &gt;&gt;
	&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
	while i &lt; len(s):
		progress = i
		&lt;&lt; Create a node for the next module &gt;&gt;
		assert(progress &lt; i)</t>
<t tx="T3060">i = 0 ; 	self.web_st = []
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if self.isDocStart(s,i):
		if type == "cweb": i += 2
		else: i = skip_line(s,i)
	elif type == "cweb" and match(s,i,"@@"):
		i += 2
	elif match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1: self.cstEnter(s[j:k])
	else: i += 1

# trace(self.cstDump())</t>
<t tx="T3061">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isModuleStart(s,i) or match(s,i,lb):
		break
	else: i = skip_line(s,i)
	
j = skip_ws(s,0)
if j &lt; i:
	self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if match(s,i,lb):
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break
		else: i = skip_line(s,i)
	self.createHeadline(parent,s[j:i],angleBrackets(" @ "))
	
# trace(`get_line(s,i)`)</t>
<t tx="T3062">if type=="cweb":
	assert(self.isModuleStart(s,i))
	start = i
	if self.isDocStart(s,i):
		i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i): break
			else: i = skip_line(s,i)
	&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
	assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
	start = i ; i = skip_line(s,i)
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i): break
		else: i = skip_line(s,i)
	
body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)</t>
<t tx="T3063">if match(s,i,"@d") or match(s,i,"@f"):
	i += 2 ; i = skip_line(s,i)
	# Place all @d and @f directives in the same node.
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if match(s,i,"@d") or match(s,i,"@f"): i = skip_line(s,i)
		else: break
	i = skip_ws_and_nl(s,i)
	
while i &lt; len(s) and not self.isModuleStart(s,i):
	i = skip_line(s,i)
	i = skip_ws_and_nl(s,i)

if match(s,i,"@c") or match(s,i,"@p"):
	i += 2 ; 
	while i &lt; len(s):
		i = skip_line(s,i)
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break</t>
<t tx="T3064"></t>
<t tx="T3065">@ We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.
@c

def cstCanonicalize (self,s,lower=true):
	
	if lower:
		s = string.lower(s)
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"\r","")
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T3066">def cstDump (self):

	self.web_st.sort()
	s = "Web Symbol Table...\n\n"
	for name in self.web_st:
		s += name + "\n"
	return s</t>
<t tx="T3067"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

	# Don't enter names that end in "..."
	s = string.rstrip(s)
	if s.endswith("..."): return
	
	# Put the section name in the symbol table, retaining capitalization.
	lower = self.cstCanonicalize(s,true)  # do lower
	upper = self.cstCanonicalize(s,false) # don't lower.
	for name in self.web_st:
		if string.lower(name) == lower:
			return
	self.web_st.append(upper)</t>
<t tx="T3068"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):
	
	# Do nothing if the ... convention is not used.
	target = string.strip(target)
	if not target.endswith("..."): return target
	# Canonicalize the target name, and remove the trailing "..."
	ctarget = target[:-3]
	ctarget = self.cstCanonicalize(ctarget)
	ctarget = string.strip(ctarget)
	found = false ; result = target
	for s in self.web_st:
		cs = self.cstCanonicalize(s)
		if cs[:len(ctarget)] == ctarget:
			if found:
				es("****** " + target + ": is also a prefix of: " + s)
			else:
				found = true ; result = s
				# es("replacing: " + target + " with: " + s)
	return result</t>
<t tx="T3069"></t>
<t tx="T3070">@  08-SEP-2002 DTHEIN: Added for PHP import support
Creates a child of parent for each class and function definition seen.

PHP uses both # and // as line comments, and /* */ as block comments
@c
def scanPHPText (self,s,parent):
	import re
	&lt;&lt; Append file if not pure PHP &gt;&gt;

	&lt;&lt; define scanPHPText vars &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@first ")	
	parent.appendStringToBody(s[:startOfCode])
	scan_start = i = startOfCode
	while i &lt; endOfCode:
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/' or ch == '#':
			&lt;&lt; handle possible PHP comments &gt;&gt;
		elif ch == '&lt;':
			&lt;&lt; handle possible heredoc string &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		# FIXME: probably want to capture 'var's as class member data
		elif ch == 'f' or ch =='c':
			&lt;&lt; handle possible class or function &gt;&gt;
		elif class_start and (ch == '}'):
			&lt;&lt; handle end of class &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@last ")	
	parent.appendStringToBody(s[endOfCode:])</t>
<t tx="T3071"># If the file does not begin with &lt;?php or end with ?&gt; then
# it is simply appended like a generic import would do.
s.strip() #remove inadvertent whitespace
if not s.startswith("&lt;?php") \
or not (s.endswith("?&gt;") or s.endswith("?&gt;\n") or s.endswith("?&gt;\r\n")):
	es("File seems to be mixed HTML and PHP; importing as plain text file.")
	parent.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	return</t>
<t tx="T3072">scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
</t>
<t tx="T3073">if match(s,i,"&lt;&lt;&lt;"):
	i = skip_heredoc_string(s,i)
else:
	i += 1
</t>
<t tx="T3074">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"#"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T3075">@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if match(s,i,"function "):
	#we want to make the function a subnode of either the @file node or a class node
	# 1. get the function name
	# 2. make a reference in the parent
	# 3. create the child node, and dump the function in it.
	function_start = i
	m = phpFunctionName.match(s[i:])
	if (None == m): # function keyword without function name
		i += len("function ")
	else:
		headline = angleBrackets(" function " + m.group(1) + " ")
		# find the end of the function
		openingBrace = s.find('{',i)
		function_end = skip_php_braces(s,openingBrace)
		function_end = skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
		# Insert skipped text into parent's body.
		if class_start:
			class_body += s[scan_start:function_start]
		else:
			parent.appendStringToBody(s[scan_start:function_start])
		# Append the headline to the parent's body.
		if class_start:
			class_body += (headline + "\n")
		else:
			parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
			function_start -= 1
		# Get the body and undent it
		function_body = s[function_start:function_end]
		function_body = self.undentBody(function_body)
		if self.treeType != "@file":
			function_body = "@code\n\n" + function_body
		# Create the new node
		if class_start:
			self.createHeadline(class_node,function_body,headline)
		else:
			self.createHeadline(parent,function_body,headline)
		i = function_end
		scan_start = i
		function_end = 0
		function_start = 0 #done with this function
		function_body = ""
		
elif match(s,i,"class "):
	# we want to make the class a subnode of the @file node
	# 1. get the class name
	# 2. make a reference in the parent
	# 3. create the child node and dump the function in it
	class_start = i
	class_body = ""
	m = phpClassName.match(s[i:])
	if (None == m): # class keyword without class name
		i += len("class ")
	else:
		# Insert skipped text into parent's body.
		parent.appendStringToBody(s[scan_start:class_start])
		# create the headline name
		headline = angleBrackets(" class " + m.group(1) + " ")
		# find the place to start looking for methods (functions)
		openingBrace = s.find('{',i)
		# find the end of the class
		class_end = skip_php_braces(s,openingBrace)
		class_end = skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
		# Append the headline to the parent's body.
		parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
			class_start -= 1
		scan_start = class_start
		# Create the new node
		class_node = self.createHeadline(parent,"",headline)
		i = openingBrace
	
else:
	i += 1</t>
<t tx="T3076"># Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
	class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
class_node.appendStringToBody(class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
</t>
<t tx="T3077">parent.appendStringToBody(s[scan_start:endOfCode])
</t>
<t tx="T3078"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

	&lt;&lt; define scanCText vars &gt;&gt;
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible C comments &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in C &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in C &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in C &gt;&gt;
		# These cases and the default case can create child nodes.
		elif ch == '#':
			&lt;&lt; handle # sign &gt;&gt;
		elif ch == '{':
			&lt;&lt; handle open curly bracket in C &gt;&gt;
		elif is_c_id(ch):
			&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T3079">c = self.commands
include_seen = method_seen = false
methodKind = choose(self.fileType==".c","functions","methods")
lparen = None   # Non-null if '(' seen at outer level.
scan_start = function_start = 0
name = None
i = 0</t>
<t tx="T3080"># if statements may contain function definitions.
i += 1  # Skip the '#'
if not include_seen and match_c_word(s,i,"include"):
	include_seen = true
	&lt;&lt; create a child node for all #include statements &gt;&gt;
else:
	j = i
	i = skip_pp_directive(s,i)</t>
<t tx="T3081"># Scan back to the start of the line.
include_start = i = find_line_start(s,i)

# Scan to the next line that is neither blank nor and #include.
i = skip_pp_directive(s,i)
i = skip_nl(s,i)
include_end = i
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if match_c_word(s,i,"#include"):
		i = skip_pp_directive(s,i)
		i = skip_nl(s,i)
		include_end = i
	elif i + 2 &lt; len(s) and s[i] == '\\':
		# Handle possible comment.
		if s[i+1] == '\\':
			i = skip_to_end_of_line(s,i)
		elif s[i+1] == '*':
			i = skip_block_comment(s,i + 2)
		else:
			i = include_end ; break
	else:
		i = include_end ; break
		

headline = angleBrackets(" " + self.methodName + " #includes ")
body = s[include_start:include_end]
body = self.undentBody(body)
prefix = choose(self.treeType == "@file","","@code\n\n")
self.createHeadline(parent,prefix + body,headline)
parent.appendStringToBody("@ignore\n" + self.rootLine + "@language c\n")

# Append any previous text to the parent's body.
save_ip = i ; i = scan_start
while i &lt; include_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; include_start:
	parent.appendStringToBody(s[i:include_start])
scan_start = function_start = i = save_ip
# Append the headline to the parent's body.
parent.appendStringToBody(headline + "\n")</t>
<t tx="T3082">j = i = skip_braces(s,i) # Skip all inner blocks.

# This may fail if #if's contain unmatched curly braces.
if (match(s,i,'}') and lparen and name and function_start):
	# Point i _after_ the last character of the function.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	if method_seen:
		# Include everything after the last function.
		function_start = scan_start 
	else:
		&lt;&lt; create a declaration node &gt;&gt;
		&lt;&lt; append C function/method reference to parent node &gt;&gt;
	headline = name
	body = s[function_start:function_end]
	body = self.massageBody(body,"functions")
	self.createHeadline(parent,body,headline)
	
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None
else:
	i += 1</t>
<t tx="T3083">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; function_start:
	headline = angleBrackets(" " + self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	if self.treeType == "@file":
		body = decls
	else:
		body = "@code\n\n" + decls
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T3084">if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	cweb = c.target_language == "cweb"
	lb = choose(cweb,"@&lt;","&lt;&lt;")
	rb = choose(cweb,"@&gt;","&gt;&gt;")
	parent.appendStringToBody(
		lb + " " + self.methodName + " " + methodKind + " " + rb + "\n")</t>
<t tx="T3085">if match_c_word(s,i,"typedef"):
	i = skip_typedef(s,i)
	lparen = None
elif match_c_word(s,i,"struct"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"union"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"namespace"):
	&lt;&lt; create children for the namespace &gt;&gt;
# elif match_c_word(s,i,"class"):
	# &lt; &lt; create children for the class &gt; &gt;
else:
	# Remember the last name before an open parenthesis.
	if lparen == None:
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
	else:
		i = skip_c_id(s,i)
	&lt;&lt; test for operator keyword &gt;&gt;</t>
<t tx="T3086">@ Namesspaces change the self.moduleName and recursively call self function with a text covering only the range of the namespace. This effectively changes the definition line of any created child nodes. The namespace is written to the top level.
@c

# skip the "namespace" keyword.
i += len("namespace")
i = skip_ws_and_nl(s,i)
# Skip the namespace name.
namespace_name_start = i
namespace_name_end = None
if i &lt; len(s) and is_c_id(s[i]):
	i = skip_c_id(s,i)
	namespace_name_end = i - 1
else: namespace_name_start = None
# Skip the '{'
i = skip_ws_and_nl(s,i)
if match(s,i,'{') and namespace_name_start:
	inner_ip = i + 1
	i = skip_braces(s,i)
	if match(s,i,'}'):
		# Append everything so far to the body.
		if inner_ip &gt; scan_start:
			parent.appendStringToBody(s[scan_start:inner_ip])
		# Save and change self.moduleName to namespaceName
		savedMethodName = self.methodName
		namespaceName = s[namespace_name_start:namespace_name_end]
		self.methodName = "namespace " + namespaceName
		# Recursively call this function .
		self.scanCText(s[inner_ip:],parent)
		# Restore self.moduleName and continue scanning.
		self.methodName = savedMethodName
		scan_start = function_start = i</t>
<t tx="T3087"># We treat a C++ a construct such as operator + as a function name.
if match(name,0,"operator"):
	j = i
	i = skip_ws(s,i) # Don't allow newline in headline.
	if (i &lt; len(s) and not is_c_id(s[i]) and
		s[i]!=' ' and s[i]!='\n' and s[i]!='\r'):
		while (i &lt; len(s) and not is_c_id(s[i]) and
			s[i]!=' ' and s[i]!='\n' and s[i] != '\r'):
			i += 1
		name = s[j:i] # extend the name.</t>
<t tx="T3088">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T3089">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T3090">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T3091">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T3092"># Used by C, Java and Pascal parsers.
# Do nothing if only whitespace is left.

i = skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
	parent.appendStringToBody(s[scan_start:])</t>
<t tx="T3093"># Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # true if at outer level.

	&lt;&lt; define scanJavaText vars &gt;&gt;
	# if not outerFlag: trace("inner:" + `s`)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible Java comments &gt;&gt;
		elif ch == '"' or ch == '\'': i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in Java &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in Java &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in Java &gt;&gt;
			class_seen = false
		# These cases can create child nodes.
		elif ch == '{':
			&lt;&lt; handle open curly bracket in Java &gt;&gt;
		elif is_c_id(s[i]):
			&lt;&lt; skip and remember the Java id &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T3094">method_seen = false
class_seen = false # true: class keyword seen at outer level.
interface_seen = false # true: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # choose(outerFlag, None, 0)
i = 0</t>
<t tx="T3095">brace_ip1 = i
i = skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not match (s,i,'}'):
	es("unmatched '{'")
elif not name:
	i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
	# trace("starting:"+name)
	# trace("outerFlag:"+`outerFlag`)
	# trace("lparen:"`lparen`)
	# trace("class_seen:"+`class_seen`)
	# trace("scan_start:"+get_line_after(s,scan_start))
	# trace("func_start:"+get_line_after(s,function_start))
	# trace("s:"+get_line(s,i))

	# Point i _after_ the last character of the method.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	headline = name
	if outerFlag:
		leader = "" ; decl_leader = ""
		if class_seen:
			headline = "class " + headline
			methodKind = "classes"
		else:
			headline = "interface " + headline
			methodKind = "interfaces"
	else:
		leader = "\t" # Indent only inner references.
		decl_leader = "\n"  # Declaration leader for inner references.
		methodKind = "methods"
	if method_seen:
		# Include everything after the last fucntion.
		function_start = scan_start
	else:
		&lt;&lt; create a Java declaration node &gt;&gt;
		&lt;&lt; append Java method reference to parent node &gt;&gt;
	if outerFlag: # Create a class.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:brace_ip1+1]
		body = self.massageBody(body,methodKind)
		v = self.createHeadline(parent,body,headline)
		&lt;&lt; recursively scan the text &gt;&gt;
		# Append the brace to the parent.
		v.appendStringToBody("}")
		i = brace_ip2 + 1 # Start after the closing brace.
	else: # Create a method.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:function_end]
		body = self.massageBody(body,methodKind)
		self.createHeadline(parent,body,headline)
		i = function_end
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None ; class_seen = false
else: i += 1</t>
<t tx="T3096">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
	
if outerFlag:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language java\n")

if i &lt; function_start:
	decl_headline = angleBrackets(" " + self.methodName + " declarations ")

	# Append the headline to the parent's body.
	parent.appendStringToBody(decl_leader + leader + decl_headline + "\n")
	scan_start = find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	body = choose(self.treeType == "@file",decls,"@code\n\n" + decls)
	self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i</t>
<t tx="T3097">if self.treeType == "@file":
	if outerFlag:
		parent.appendStringToBody("\n@others\n")
	else:
		parent.appendStringToBody("\n\t@others\n")
else:
	kind = choose(outerFlag,"classes","methods")
	ref_name = angleBrackets(" " + self.methodName + " " + kind + " ")
	parent.appendStringToBody(leader + ref_name + "\n")</t>
<t tx="T3098"># These mark the points in the present function.
# trace("recursive scan:" + `get_line(s,brace_ip1+ 1)`)
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
	v,false) # inner level
self.methodName = oldMethodName
</t>
<t tx="T3099">if match_c_word(s,i,"class") or match_c_word(s,i,"interface"):
	if match_c_word(s,i,"class"):
		class_seen = true
	else:
		interface_seen = true
	i = skip_c_id(s,i) # Skip the class or interface keyword.
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and is_c_id(s[i]):
		# Remember the class or interface name.
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
else:
	j = i ; i = skip_c_id(s,i)
	if not lparen and not class_seen:
		name = s[j:i] # Remember the name.</t>
<t tx="T3100">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T3101">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T3102">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T3103">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T3104"># Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

	method_seen = false ; methodKind = "methods"
	scan_start = function_start = i = 0
	name = None
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(s[i]):
			&lt;&lt; handle possible Pascal function &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T3105">if match_c_word(s,i,"begin"):
	i = skip_pascal_begin_end(s,i)
	if match_c_word(s,i,"end"):
		i = skip_c_id(s,i)
elif (match_c_word(s,i,"function")  or match_c_word(s,i,"procedure") or
	match_c_word(s,i,"constructor") or match_c_word(s,i,"destructor")):

	# line = get_line(s,i) ; trace(`line`)
	
	start = i
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	&lt;&lt; remember the function name, or continue &gt;&gt;
	&lt;&lt; skip the function definition, or continue &gt;&gt;
	if not method_seen:
		method_seen = true
		&lt;&lt; create a child node for leading declarations &gt;&gt;
		&lt;&lt; append noweb method reference to the parent node &gt;&gt;
		function_start = start
	else: function_start = scan_start
	&lt;&lt; create a child node for the function &gt;&gt;
else: i = skip_c_id(s,i)</t>
<t tx="T3106">save_ip = i
i = scan_start
while i &lt; start and is_ws_or_nl(s,i):
	i += 1
if i &lt; start:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language pascal\n")
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	if self.treeType == "@file":
		body = s[scan_start:start]
	else:
		body = "@code\n\n" + s[scan_start:start]
	body = self.undentBody(body)
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T3107"># Point i _after_ the last character of the function.
i = skip_ws(s,i)
if is_nl(s,i):
	i = skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i</t>
<t tx="T3108">if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	while i + 1 &lt; len(s) and s[i] == '.' and is_c_id(s[i+1]):
		i += 1 ; j = i
		i = skip_c_id(s,i)
	name = s[j:i]
else: continue</t>
<t tx="T3109">&lt;&lt; skip past the semicolon &gt;&gt;

if not match_c_word(s,i,"begin"):
	continue
# Skip to the matching end.
i = skip_pascal_begin_end(s,i)
if match_c_word(s,i,"end"):
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		i += 1
	i = skip_ws(s,i)
	if is_nl(s,i):
		i = skip_nl(s,i)
else: continue</t>
<t tx="T3110">while i &lt; len(s) and s[i] != ';':
	# The paremeter list may contain "inner" semicolons.
	if s[i] == '(':
		i = skip_parens(s,i)
		if match(s,i,')'):
			i += 1
		else: break
	else: i += 1
if match(s,i,';'):
	i += 1
i = skip_ws_and_nl(s,i)

if match_c_word(s,i,"var"):
	# Skip to the next begin.
	i = skip_c_id(s,i)
	done = false
	while i &lt; len(s) and not done:
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(ch):
			if match_c_word(s,i,"begin"): done = true
			else: i = skip_c_id(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		else: i += 1</t>
<t tx="T3111"># Append the headline to the parent's body.
if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n")</t>
<t tx="T3112"></t>
<t tx="T3113">@ Headlines not containing a section reference are ignored in noweb and generate index index in cweb.
@c

def convertCodePartToWeb (self,s,i,v,result):

	# trace(get_line(s,i))
	c = self.commands ; nl = self.output_newline
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	h = string.strip(v.headString())
	&lt;&lt; put v's headline ref in head_ref &gt;&gt;
	&lt;&lt; put name following @root or @file in file_name &gt;&gt;
	if match_word(s,i,"@root"):
		i = skip_line(s,i)
		&lt;&lt; append ref to file_name &gt;&gt;
	elif match_word(s,i,"@c") or match_word(s,i,"@code"):
		i = skip_line(s,i)
		&lt;&lt; append head_ref &gt;&gt;
	elif match_word(h,0,"@file"):
		# Only do this if nothing else matches.
		&lt;&lt; append ref to file_name &gt;&gt;
		i = skip_line(s,i) # 4/28/02
	else:
		&lt;&lt; append head_ref &gt;&gt;
	i,result = self.copyPart(s,i,result)
	return i, string.strip(result) + nl
	
@ %defs a b c</t>
<t tx="T3114">@ We look for either noweb or cweb brackets. head_ref does not include these brackets.
@c

head_ref = None
j = 0
if match(h,j,"&lt;&lt;"):
	k = string.find(h,"&gt;&gt;",j)
elif match(h,j,"&lt;@"):
	k = string.find(h,"@&gt;",j)
else:
	k = -1

if k &gt; -1:
	head_ref = string.strip(h[j+2:k])
	if len(head_ref) == 0:
		head_ref = None</t>
<t tx="T3115">if match(h,0,"@file") or match(h,0,"@root"):
	line = h[5:]
	line = string.strip(line)
	&lt;&lt; set file_name &gt;&gt;
else:
	file_name = line = None
</t>
<t tx="T3116"># set j &amp; k so line[j:k] is the file name.
# trace(`line`)

if match(line,0,"&lt;"):
	j = 1 ; k = string.find(line,"&gt;",1)
elif match(line,0,'"'):
	j = 1 ; k = string.find(line,'"',1)
else:
	j = 0 ; k = string.find(line," ",0)
if k == -1:
	k = len(line)

file_name = string.strip(line[j:k])
if file_name and len(file_name) == 0:
	file_name = None</t>
<t tx="T3117">if self.webType == "cweb":
	if not file_name:
		result += "@&lt;root@&gt;=" + nl
	else:
		result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
else:
	if not file_name:
		file_name = "*"
	result += lb + file_name + rb + "=" + nl
</t>
<t tx="T3118">if self.webType == "cweb":
	if not head_ref:
		result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
		result += "@c" + nl # @c denotes a new section.
	else: 
		escaped_head_ref = string.replace(head_ref,"@","@@")
		result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
else:
	if not head_ref:
		if v == c.currentVnode():
			head_ref = choose(file_name,file_name,"*")
		else:
			head_ref = "@others"

	result += lb + head_ref + rb + "=" + nl</t>
<t tx="T3119">def convertDocPartToWeb (self,s,i,result):
	
	nl = self.output_newline

	# trace(get_line(s,i))
	if match_word(s,i,"@doc"):
		i = skip_line(s,i)
	elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@*"):
		i += 2
	elif match(s,i,"@\n"):
		i += 1
	i = skip_ws_and_nl(s,i)
	i, result2 = self.copyPart(s,i,"")
	if len(result2) &gt; 0:
		# Break lines after periods.
		result2 = string.replace(result2,".  ","." + nl)
		result2 = string.replace(result2,". ","." + nl)
		result += nl+"@"+nl+string.strip(result2)+nl+nl
	else:
		# All nodes should start with '@', even if the doc part is empty.
		result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
	return i, result</t>
<t tx="T3120">@ This code converts a vnode to noweb text as follows:

Convert @doc to @
Convert @root or @code to &lt;&lt; name &gt;&gt;=, assuming the headline contains &lt;&lt; name &gt;&gt;
Ignore other directives
Format doc parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertVnodeToWeb (self,v):

	if not v: return ""
	startInCode = not app.config.at_root_bodies_start_in_doc_mode
	nl = self.output_newline
	s = v.bodyString()
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	i = 0 ; result = "" ; docSeen = false
	while i &lt; len(s):
		progress = i
		# trace(get_line(s,i))
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i) or match_word(s,i,"@doc"):
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		elif (match_word(s,i,"@code") or match_word(s,i,"@root") or
			match_word(s,i,"@c") or match(s,i,lb)):
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		elif self.treeType == "@file" or startInCode:
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		else:
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		assert(progress &lt; i)
	result = string.strip(result)
	if len(result) &gt; 0:
		result += nl
	return result</t>
<t tx="T3121">if not docSeen:
	docSeen = true
	result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)</t>
<t tx="T3122"># Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

	# trace(get_line(s,i))
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	type = self.webType
	while i &lt; len(s):
		progress = j = i # We should be at the start of a line here.
		i = skip_nl(s,i) ; i = skip_ws(s,i)
		if self.isDocStart(s,i):
			return i, result
		if (match_word(s,i,"@doc") or
			match_word(s,i,"@c") or
			match_word(s,i,"@root") or
			match_word(s,i,"@code")): # 2/25/03
			return i, result
		elif (match(s,i,"&lt;&lt;") and # must be on separate lines.
			find_on_line(s,i,"&gt;&gt;=") &gt; -1):
			return i, result
		else:
			# Copy the entire line, escaping '@' and
			# Converting @others to &lt; &lt; @ others &gt; &gt;
			i = skip_line(s,j) ; line = s[j:i]
			if type == "cweb":
				line = string.replace(line,"@","@@")
			else:
				j = skip_ws(line,0)
				if match(line,j,"@others"):
					line = string.replace(line,"@others",lb + "@others" + rb)
				elif match(line,0,"@"):
					# Special case: do not escape @ %defs.
					k = skip_ws(line,1)
					if not match(line,k,"%defs"):
						line = "@" + line
			result += line
		assert(progress &lt; i)
	return i, string.rstrip(result)</t>
<t tx="T3123">@ Properly removes all sentinel lines in s.  Only leading single-line comments may be sentinels.

line_delim, start_delim and end_delim are the comment delimiters.
@c

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

	i = 0 ; result = "" ; first = true
	while i &lt; len(s):
		start = i # The start of the next syntax element.
		if first or is_nl(s,i):
			first = false
			&lt;&lt; handle possible sentinel &gt;&gt;
		elif match(s,i,line_delim):
			i = skip_to_end_of_line(s,i)
		elif match(s,i,start_delim):
			i = skip_matching_delims(s,i,start_delim,end_delim)
		elif match(s,i,"'") or match(s,i,'"'):
			i = skip_string(s,i)
		else:
			i += 1
		assert(i==0 or start&lt;i)
		result += s[start:i]
	return result</t>
<t tx="T3124">i = skip_nl(s,i)
i = skip_ws(s,i)

if line_delim:
	if match(s,i,line_delim):
		j = i + len(line_delim)
		i = skip_to_end_of_line(s,i)
		if match(s,j,"@"):
			continue # Remove the sentinel.
elif start_delim:
	if match(s,i,start_delim):
		j = i + len(start_delim)
		i = skip_matching_delims(s,i,start_delim,end_delim)
		if match(s,j,"@"):
			continue # Remove the sentinel.</t>
<t tx="T3125"></t>
<t tx="T3126">def createHeadline (self,parent,body,headline):

	# trace("parent,headline:" + `parent` + ":" + `headline`)
	# Create the vnode.
	v = parent.insertAsLastChild()
	v.initHeadString(headline,self.encoding)
	# Set the body.
	if len(body) &gt; 0:
		v.setBodyStringOrPane(body,self.encoding)
	return v</t>
<t tx="T3127">def error (self,s): es(s)</t>
<t tx="T3128">@ This code returns the leading whitespace of a line, ignoring blank and comment lines.
@c

def getLeadingIndent (self,s,i):

	c = self.commands
	i = find_line_start(s,i)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		j = skip_ws(s,i) # Bug fix: 2/14/03
		if is_nl(s,j) or match(s,j,"#"): # Bug fix: 2/14/03
			i = skip_line(s,i) # ignore blank lines and comment lines.
		else:
			i, width = skip_leading_ws_with_indent(s,i,c.tab_width)
			# trace("returns:" + `width`)
			return width
	# trace("returns:0")
	return 0</t>
<t tx="T3129"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
	
	if not match(s,i,"@"):
		return false

	j = skip_ws(s,i+1)
	if match(s,j,"%defs"):
		return false
	elif self.webType == "cweb" and match(s,i,"@*"):
		return true
	else:
		return match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n")

def isModuleStart (self,s,i):

	if self.isDocStart(s,i):
		return true
	else:
		return self.webType == "cweb" and (
			match(s,i,"@c") or match(s,i,"@p") or
			match(s,i,"@d") or match(s,i,"@f"))
</t>
<t tx="T3130">def massageBody (self,s,methodKind):
	
	# trace(`s`)
	# trace(`get_line(s,0)`)
	c = self.commands
	if self.treeType == "@file":
		if self.fileType == ".py": # 7/31/02: was "py"
			return self.undentBody(s)
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n@c" + newLine + newBody
			else:
				return newBody
	else:
		# Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
		cweb = self.fileType == "c" and not c.use_noweb_flag
		lb = choose(cweb,"@&lt;","&lt;&lt;")
		rb = choose(cweb,"@&gt;=","&gt;&gt;=")
		intro = lb + " " + self.methodName + " " + methodKind + " " + rb
		if self.fileType == ".py": # 7/31/02: was "py"
			newBody = self.undentBody(s)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			return intro + newLine + newBody
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n" + intro + newLine + newBody
			else:
				return intro + newLine + newBody</t>
<t tx="T3131">@ Returns s with all runs of whitespace and newlines converted to a single blank.  It also removes leading and trailing whitespace.
@c

def massageComment (self,s):

	# trace(`get_line(s,0)`)
	s = string.strip(s)
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"\r"," ")
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T3132">def massageWebBody (self,s):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")
	&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
	&lt;&lt; Replace abbreviated names with full names &gt;&gt;
	s = string.rstrip(s)
	return s</t>
<t tx="T3133">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isDocStart(s,i):
		# Scan to end of the doc part.
		if match(s,i,"@ %def"):
			# Don't remove the newline following %def
			i = skip_line(s,i) ; start = end = i
		else:
			start = end = i ; i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i) or match(s,i,lb):
				end = i ; break
			elif type == "cweb": i += 1
			else: i = skip_to_end_of_line(s,i)
		# Remove newlines from start to end.
		doc = s[start:end]
		doc = string.replace(doc,"\n"," ")
		doc = string.replace(doc,"\r","")
		doc = string.strip(doc)
		if doc and len(doc) &gt; 0:
			if doc == "@":
				doc = choose(self.webType=="cweb", "@ ","@\n")
			else:
				doc += "\n\n"
			# trace("new doc:" + `doc`)
			s = s[:start] + doc + s[end:]
			i = start + len(doc)
	else: i = skip_line(s,i)</t>
<t tx="T3134">i = 0
while i &lt; len(s):
	# trace(`get_line(s,i)`)
	if match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1:
			name = s[j:k]
			name2 = self.cstLookup(name)
			if name != name2:
				# Replace name by name2 in s.
				# trace("replacing:" + `name` + ", by:" + `name2`)
				s = s[:j] + name2 + s[k:]
				i = j + len(name2)
	i = skip_line(s,i)</t>
<t tx="T3135">@ This skips all leading comments in s, returning the remaining body text and the massaged comment text.
Returns (body, comment)
@c

def skipLeadingComments (self,s):

	# trace(`get_line(s,0)`)
	s_original = s
	s = string.lstrip(s)
	i = 0 ; comment = ""
	if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
		&lt;&lt; scan for C-style comments &gt;&gt;
	elif self.fileType == ".pas":
		&lt;&lt; scan for Pascal comments &gt;&gt;
	elif self.fileType == ".py":
		&lt;&lt; scan for Python comments &gt;&gt;
	comment = string.strip(comment)
	if len(comment) == 0:
		return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
	elif self.treeType == "@file":
		return s[i:], "@ " + comment
	else:
		return s[i:], "@ " + comment + "\n"</t>
<t tx="T3136">while i &lt; len(s):
	if match(s,i,"//"): # Handle a C++ comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,"/*"): # Handle a block C comment.
		j = i + 2 ; i = skip_block_comment (s,i)
		k = choose(match(s,i-2,"*/"),i-2,i)
		if self.fileType == ".java":
			# 8/2/02: a hack: add leading whitespace then remove it.
			comment = self.undentBody(comment)
			comment2 = ' ' * 2 + s[j:k]
			comment2 = self.undentBody(comment2)
			comment = comment + comment2 + "\n"
		else:
			comment = comment + self.massageComment(s[j:k]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T3137">while i &lt; len(s):
	if match(s,i,"//"): # Handle a Pascal line comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,'(*'):
		j = i + 1 ; i = skip_pascal_block_comment(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T3138">while i &lt; len(s) and match(s,i,'#'):
	j = i + 1 ; i = skip_line(s,i)
	comment = self.undentBody(comment)
	comment = comment + self.massageComment(s[j:i]) + "\n"
	# 8/2/02: Preserve leading whitespace for undentBody
	i = skip_ws(s,i)
	i = skip_blank_lines(s,i)</t>
<t tx="T3139">@ Removes extra leading indentation from all lines.  We look at the first line to determine how much leading whitespace to delete.
@c

def undentBody (self,s):

	# trace(`s`)
	c = self.commands
	i = 0 ; result = ""
	# Copy an @code line as is.
	if match(s,i,"@code"):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		result += s[j:i]
	# Calculate the amount to be removed from each line.
	undent = self.getLeadingIndent(s,i)
	if undent == 0: return s
	while i &lt; len(s):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		line = s[j:i]
		# trace(`line`)
		line = removeLeadingWhitespace(line,undent,c.tab_width)
		result += line
	return result</t>
<t tx="T3140">@language python

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from leoGlobals import *
import time,types

@others</t>
<t tx="T3141">class baseTnode:
	"""The base class of the tnode class."""
	&lt;&lt; tnode constants &gt;&gt;
	@others
	
class tnode (baseTnode):
	"""A class that implements tnodes."""
	pass</t>
<t tx="T3142">dirtyBit =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit =	0x04</t>
<t tx="T3143"></t>
<t tx="T3144">def hasBody (self):

	return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="T3145">def loadBodyPaneFromTnode(self, body):

	s = self.bodyString
	if s and len(s) &gt; 0:
		body.delete(1,"end")
		body.insert(1,s)
	else:
		body.delete(1,"end")</t>
<t tx="T3146"></t>
<t tx="T3147">def isDirty (self):

	return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="T3148">def isRichTextBit (self):

	return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="T3149">def isVisited (self):

	return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="T3150"></t>
<t tx="T3151"></t>
<t tx="T3152">def clearDirty (self):

	self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="T3153">def clearRichTextBit (self):

	self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="T3154">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T3155">def setDirty (self):

	self.statusBits |= self.dirtyBit</t>
<t tx="T3156">def setRichTextBit (self):

	self.statusBits |= self.richTextBit</t>
<t tx="T3157">def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T3158">def setCloneIndex (self, index):

	self.cloneIndex = index</t>
<t tx="T3159">def setFileIndex (self, index):

	self.fileIndex = index</t>
<t tx="T3160">class baseVnode:
	"""The base class of the vnode class."""
	&lt;&lt; vnode constants &gt;&gt;
	@others
	
class vnode (baseVnode):
	"""A class that implements vnodes."""
	pass</t>
<t tx="T3161"></t>
<t tx="T3162">if 0: # not used
	def __cmp__(self,other):
		
		trace(`self` + "," + `other`)
		return not (self is other) # Must return 0, 1 or -1</t>
<t tx="T3163">def __init__ (self,commands,t):

	assert(t)
	
	# commands may be None for testing.
	# assert(commands)

	&lt;&lt; initialize vnode data members &gt;&gt;
</t>
<t tx="T3164">self.commands = commands # The commander for this vnode.
self.t = t # The tnode, i.e., the body text.
self.statusBits = 0 # status bits

# Structure links
self.mParent = self.mFirstChild = self.mNext = self.mBack = None

# The following are used by the tree class.
# Eventually they should be injected into vnodes by the tkingerGui class.

self.iconVal = -1 # The icon index.  -1 forces an update of icon.
self.iconx, self.icony = 0,0 # Coords of icon so icon can be redrawn separately.</t>
<t tx="T3165">def __repr__ (self):
	
	if self.t:
		return "&lt;vnode %d:%s&gt;" % (id(self),`self.t.headString`)
	else:
		return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
		
__str__ = __repr__
</t>
<t tx="T3166"></t>
<t tx="T3167"># 12/03/02: We now handle @file options here.

def afterHeadlineMatch(self,s):
	
	h = self.headString()

	if s != "@file" and match_word(h,0,s):
		# No options are valid.
		return string.strip(h[len(s):])
	elif match(h,0,"@file"):
		i,atFileType,junk = scanAtFileOptions(h)
		if s == atFileType:
			# print "s,h:",s,h
			return string.strip(h[i:])
		else: return ""
	else: return ""
</t>
<t tx="T3168">@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")
	
def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")
	
def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
</t>
<t tx="T3169"># Returns true if the receiver's headline starts with @file.
def isAtFileNode (self):
	s = self.atFileNodeName()
	return len(s) &gt; 0
	
# Returns true if the receiver's headline starts with @rawfile.
def isAtNoSentinelsFileNode (self):
	s = self.atNoSentinelsFileNodeName()
	return len(s) &gt; 0
	
# Returns true if the receiver's headline starts with @rawfile.
def isAtRawFileNode (self):
	s = self.atRawFileNodeName()
	return len(s) &gt; 0

# Returns true if the receiver's headline starts with @silentfile.
def isAtSilentFileNode (self):
	s = self.atSilentFileNodeName()
	return len(s) &gt; 0
</t>
<t tx="T3170">def isAnyAtFileNode (self):

	return (
		self.isAtFileNode() or
		self.isAtNoSentinelsFileNode() or
		self.isAtRawFileNode() or
		self.isAtSilentFileNode())
		
def anyAtFileNodeName (self):

	if self.isAtFileNode():
		return self.atFileNodeName()
	elif self.isAtNoSentinelsFileNode():
		return self.atNoSentinelsFileNodeName()
	elif self.isAtRawFileNode():
		return self.atRawFileNodeName()
	elif self.isAtSilentFileNode():
		return self.atSilentFileNodeName()
	else:
		return ""
</t>
<t tx="T3171">@ Returns true if the receiver contains @ignore in its body at the start of a line.
@c

def isAtIgnoreNode (self):

	flag, i = is_special(self.t.bodyString, 0, "@ignore")
	return flag</t>
<t tx="T3172">@ Returns true if the receiver contains @others in its body at the start of a line.
@c

def isAtOthersNode (self):

	flag, i = is_special(self.t.bodyString,0,"@others")
	return flag</t>
<t tx="T3173">@ Returns true if the headline matches the pattern ignoring whitespace and case.  The headline may contain characters following the successfully matched pattern.
@c

def matchHeadline (self,pattern):

	h = string.lower(self.headString())
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	p = string.lower(pattern)
	p = string.replace(p,' ','')
	p = string.replace(p,'\t','')

	# ignore characters in the headline following the match
	return p == h[0:len(p)]</t>
<t tx="T3174"></t>
<t tx="T3175"># Converts the outline to a string in "MORE" format

def convertTreeToString (self):

	v = self
	level1 = v.level()
	after = v.nodeAfterTree()
	s = ""
	while v and v != after:
		s += v.moreHead(level1) + "\n"
		body = v.moreBody()
		if len(body) &gt; 0:
			s += body + "\n"
		v = v.threadNext()
	return s</t>
<t tx="T3176"># Returns the headline string in MORE format.

def moreHead (self, firstLevel,useVerticalBar=false):

	v = self
	level = self.level() - firstLevel
	if level &gt; 0: s = "\t" * level
	else: s = ""
	s += choose(v.hasChildren(), "+ ", "- ")
	s += v.headString()
	return s</t>
<t tx="T3177">@ Returns the body string in MORE format.  It inserts a backslash before any leading plus, minus or backslash.

+ test line
- test line
\ test line
test line +
test line -
test line \

More lines...
@c

def moreBody (self):

	v = self ; list = []
	
	if 1: # new code: only escape the first non-blank character of the line.
		s =  v.t.bodyString ; result = []
		lines = string.split(s,'\n')
		for s in lines:
			i = skip_ws(s,0)
			if i &lt; len(s):
				ch = s[i]
				if ch == '+' or ch == '-' or ch == '\\':
					s = s[:i] + '\\' + s[i:]
			result.append(s)
		return string.join(result,'\n')

	else: # pre 3.1 code.
		for ch in v.t.bodyString:
			if ch == '+' or ch == '-' or ch == '\\':
				list.append('\\')
			list.append(ch)
		return string.join(list,'')</t>
<t tx="T3178"></t>
<t tx="T3179"></t>
<t tx="T3180"># childIndex and nthChild are zero-based.

def childIndex (self):

	parent=self.parent()
	if not parent: return 0

	child = parent.firstChild()
	n = 0
	while child:
		if child == self: return n
		n += 1 ; child = child.next()
	assert(false)</t>
<t tx="T3181"># Compatibility routine for scripts

def firstChild (self):

	return self.mFirstChild</t>
<t tx="T3182">def hasChildren (self):

	return self.firstChild() != None</t>
<t tx="T3183"># Compatibility routine for scripts

def lastChild (self):

	child = self.firstChild()
	while child and child.next():
		child = child.next()
	return child</t>
<t tx="T3184"># childIndex and nthChild are zero-based.

def nthChild (self, n):

	child = self.firstChild()
	if not child: return None
	while n &gt; 0 and child:
		n -= 1
		child = child.next()
	return child</t>
<t tx="T3185">def numberOfChildren (self):

	n = 0
	child = self.firstChild()
	while child:
		n += 1
		child = child.next()
	return n</t>
<t tx="T3186"></t>
<t tx="T3187">def isCloned (self):

	return ( self.statusBits &amp; vnode.clonedBit ) != 0</t>
<t tx="T3188">def isDirty (self):

	return self.t.isDirty()</t>
<t tx="T3189">def isExpanded (self):

	return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="T3190">def isMarked (self):

	return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="T3191">def isOrphan (self):

	return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="T3192">def isSelected (self):

	return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="T3193">def isTopBitSet (self):

	return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="T3194"># Returns true if all parents are expanded.

def isVisible (self):

	v = self.parent()
	while v:
		if not v.isExpanded():
			return false
		v = v.parent()
	return true</t>
<t tx="T3195">def isVisited (self):

	return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="T3196">def status (self):

	return self.statusBits</t>
<t tx="T3197"># Compatibility routine for scripts

def currentVnode (self):

	return self.commands.frame.currentVnode()</t>
<t tx="T3198">def edit_text (self):

	v = self
	return self.commands.frame.getEditTextDict(v)</t>
<t tx="T3199"># Compatibility routine for scripts

def findRoot (self):

	return self.commands.frame.rootVnode()
</t>
<t tx="T3200">def isAncestorOf (self, v):

	if not v:
		return false
	v = v.parent()
	while v:
		if v == self:
			return true
		v = v.parent()
	return false</t>
<t tx="T3201">def isRoot (self):

	return not self.parent() and not self.back()</t>
<t tx="T3202">def exists(self,c):
	
	"""Return true if v exists in c's tree"""
	
	v = self ; c = v.commands
	
	# This code must be fast.
	root = c.rootVnode()
	while v:
		if v == root:
			return true
		p = v.parent()
		if p:
			v = p
		else:
			v = v.back()
		
	return false</t>
<t tx="T3203"></t>
<t tx="T3204">def computeIcon (self):

	val = 0 ; v = self
	if v.t.hasBody(): val += 1
	if v.isMarked(): val += 2
	if v.isCloned(): val += 4
	if v.isDirty(): val += 8
	return val
	
def setIcon (self):

	pass # Compatibility routine for old scripts</t>
<t tx="T3205"></t>
<t tx="T3206"># Compatibility routine for scripts

def clearAllVisited (self):
	
	self.commands.clearAllVisited()
</t>
<t tx="T3207">def clearAllVisitedInTree (self):

	v = self ; c = v.commands
	after = v.nodeAfterTree()
	
	c.beginUpdate()
	while v and v != after:
		v.clearVisited()
		v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T3208">def clearClonedBit (self):

	self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T3209">def clearDirty (self):

	v = self
	v.t.clearDirty()

def clearDirtyJoined (self):

	# trace()
	v = self ; c = v.commands
	c.beginUpdate()
	v.t.clearDirty()
	c.endUpdate() # recomputes all icons</t>
<t tx="T3210">def clearOrphan (self):

	self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="T3211">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T3212">def clearVisitedInTree (self):

	after = self.nodeAfterTree()
	v = self
	while v and v != after:
		v.clearVisited()
		v = v.threadNext()</t>
<t tx="T3213">def contract(self):

	self.statusBits &amp;= ~ self.expandedBit

def expand(self):

	self.statusBits |= self.expandedBit

def initExpandedBit (self):

	self.statusBits |= self.expandedBit</t>
<t tx="T3214">def initStatus (self, status):

	self.statusBits = status</t>
<t tx="T3215">def setClonedBit (self):

	self.statusBits |= self.clonedBit

def initClonedBit (self, val):

	if val:
		self.statusBits |= self.clonedBit
	else:
		self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T3216">def setOrphan (self):

	self.statusBits |= self.orphanBit</t>
<t tx="T3217"># This only sets the selected bit.

def setSelected (self):

	self.statusBits |= self.selectedBit</t>
<t tx="T3218"># Compatibility routine for scripts

def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T3219">def setSelection (self, start, length):

	self.t.setSelection ( start, length )</t>
<t tx="T3220">def setT (self, t):

	if t != self:
		del self.t
		self.t = t</t>
<t tx="T3221">@ This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.
@c

def trimTrailingLines (self):

	v = self
	body = v.bodyString()
	# trace(`body`)
	lines = string.split(body,'\n')
	i = len(lines) - 1 ; changed = false
	while i &gt;= 0:
		line = lines[i]
		j = skip_ws(line,0)
		if j + 1 == len(line):
			del lines[i]
			i -= 1 ; changed = true
		else: break
	if changed:
		body = string.join(body,'') + '\n' # Add back one last newline.
		# trace(`body`)
		v.setBodyStringOrPane(body)
		# Don't set the dirty bit: it would just be annoying.</t>
<t tx="T3222"></t>
<t tx="T3223"># Compatibility routine for scripts

def back (self):

	return self.mBack</t>
<t tx="T3224">def lastNode (self):

	v = self
	level = self.level()
	result = None

	while v:
		result = v
		v = v.threadNext()
		if not v or v.level() &lt;= level:
			break

	return result</t>
<t tx="T3225">@ This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.
@c

def level (self):

	level = 0 ; parent = self.parent()
	while parent:
		level += 1
		parent = parent.parent()
	return level</t>
<t tx="T3226"># Compatibility routine for scripts

def next (self):

	return self.mNext</t>
<t tx="T3227"># Returns the vnode following the tree whose root is the receiver.

def nodeAfterTree (self):

	next = self.next()
	p = self.parent()

	while not next and p:
		next = p.next()
		p = p.parent()

	return next</t>
<t tx="T3228"># Compatibility routine for scripts

def parent (self):

	return self.mParent</t>
<t tx="T3229">def threadBack (self):
	
	"""Returns the previous element of the outline, or None if at the start of the outline"""

	back = self.back()
	if back:
		lastChild = back.lastChild()
		if lastChild:
			return lastChild.lastNode()
		else:
			return back
	else:
		return self.parent()</t>
<t tx="T3230">def threadNext (self):

	"""Returns node following the receiver in "threadNext" order"""

	# stat()
	v = self
	if v.firstChild():
		return v.firstChild()
	elif v.next():
		return v.next()
	else:
		p = v.parent()
		while p:
			if p.next():
				return p.next()
			p = p.parent()
		return None</t>
<t tx="T3231">def visBack (self):

	v = self.threadBack()
	while v and not v.isVisible():
		v = v.threadBack()
	return v</t>
<t tx="T3232">def visNext (self):

	v = self.threadNext()
	while v and not v.isVisible():
		v = v.threadNext()
	return v</t>
<t tx="T3233"></t>
<t tx="T3234"></t>
<t tx="T3235">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self, newVnode):

	"""Unlinks the receiver, but does not destroy it. May be undone"""

	v = self ; c = v.commands
	v.setDirty() # 1/30/02: mark @file nodes dirty!
	v.destroyDependents()
	v.unjoinTree()
	v.unlink()
	# Bug fix: 1/18/99: we must set the currentVnode here!
	c.selectVnode(newVnode)
	# Update all clone bits.
	c.initAllCloneBits()
	return self # We no longer need dvnodes: vnodes contain all needed info.</t>
<t tx="T3236">def insertAfter (self,t=None):

	"""Inserts a new vnode after the receiver"""

	if not t:
		t = tnode(headString="NewHeadline")
	v = vnode(self.commands,t)
	v.iconVal = 0
	v.linkAfter(self)
	return v</t>
<t tx="T3237">def insertAsLastChild (self,t=None):

	"""Inserts a new vnode as the last child of the receiver"""

	n = self.numberOfChildren()
	if not t:
		t = tnode(headString="NewHeadline")
	return self.insertAsNthChild(n,t)</t>
<t tx="T3238">def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""
	
	# trace(`n` + `self`)
	if not t:
		t = tnode(headString="NewHeadline")
	v = vnode(self.commands,t)
	v.iconVal = 0
	v.linkAsNthChild(self,n)
	return v</t>
<t tx="T3239">def moveToRoot (self, oldRoot = None):

	"""Moves the receiver to the root position"""

	v = self
	v.destroyDependents()
	v.unlink()
	v.linkAsRoot(oldRoot)
	v.createDependents()</t>
<t tx="T3240"># Restores (relinks) the dv tree in the position described by back and parent.

def restoreOutlineFromDVnodes (self, dv, parent, back):

	if back:
		dv.linkAfter(back)
	elif parent:
		dv.linkAsNthChild(parent, 0)
	else:
		dv.linkAsRoot()
	return dv</t>
<t tx="T3241"># Links the receiver after v.

def linkAfter (self,v):

	# stat()
	self.mParent = v.mParent
	self.mBack = v
	self.mNext = v.mNext
	v.mNext = self
	if self.mNext:
		self.mNext.mBack = self</t>
<t tx="T3242">def linkAsNthChild (self, p, n):

	"""Links the receiver as the n'th child of p"""

	v = self
	# stat() ; # trace(`v` + ", " + `p` + ", " + `n`)
	v.mParent = p
	if n == 0:
		v.mBack = None
		v.mNext = p.mFirstChild
		if p.mFirstChild:
			p.mFirstChild.mBack = v
		p.mFirstChild = v
	else:
		prev = p.nthChild(n-1) # zero based
		assert(prev)
		v.mBack = prev
		v.mNext = prev.mNext
		prev.mNext = v
		if v.mNext:
			v.mNext.mBack = v</t>
<t tx="T3243">@ Bug fix: 5/27/02.  We link in the rest of the tree only when oldRoot != None.  Otherwise, we are calling this routine from init code and we want to start with a pristine tree.
@c
def linkAsRoot(self, oldRoot = None):

	v = self ; c = v.commands
	# stat() ; # trace(`v`)
	# Bug fix 3/16/02:
	# Clear all links except the child link.
	# This allows a node with children to be moved up properly to the root position.
	# v.mFirstChild = None
	v.mParent = None
	v.mBack = None
	# 5/27/02
	if oldRoot: oldRoot.mBack = v
	v.mNext = oldRoot
	c.frame.setRootVnode(v)</t>
<t tx="T3244"># Used by scripts

def moveAfter (self,a):

	"""Moves the receiver after a"""

	v = self ; c = self.commands
	v.destroyDependents()
	v.unlink()
	v.linkAfter(a)
	v.createDependents()
	
	# 5/27/02: Moving a node after another node can create a new root node.
	if not a.parent() and not a.back():
		c.frame.setRootVnode(a)</t>
<t tx="T3245"></t>
<t tx="T3246"># This methods propagates clone bits from the receiver's tree to tree2.

def copyCloneBitsTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Set the bit in the root.
	if tree1.isCloned():
		tree2.setClonedBit()
	else:
		tree2.clearClonedBit()
	# Recursively set the bits in all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		if child1.isCloned():
			child2.setClonedBit()
		else:
			child2.clearClonedBit()
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T3247">@ This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.
@c

def destroyTree (self):

	pass</t>
<t tx="T3248">def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.parent()

	if parent:
		s += `parent`
	else:
		s += `self`

	alert ( s )</t>
<t tx="T3249">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The assert's guarantee that both trees have the same topology.
@c

def joinTreeTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Join the roots.
	tree1.joinNodeTo ( tree2 )
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		child1.joinTreeTo(child2)
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T3250">@ The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.

Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.
@c

def shouldBeClone (self):
	
	"""Returns True if the receiver should be a clone"""
	p = self.parent()
	n = self.childIndex()

	for v in self.t.joinList:
		if v != self:
			vp = v.parent()
			# self and v are structurally dissimilar if...
			if( (not p or not vp) or  # they are at the top level, or
				vp == p or  # have the same parent, or
				p.t != vp.t or  # have unjoined parents, or
				(v.childIndex() != n)): # have different child indices.

				# trace("true",v)
				return true

	# The receiver is structurally similar to all nodes joined to it.
	# trace("false",v)
	return false</t>
<t tx="T3251">def unlink (self):

	"""Unlinks the receiver from the tree before moving or deleting.
	
	The mFistChild link is not affected in the receiver."""

	v = self ; c = v.commands

	# stat() # trace(`v.mParent`+", child:"+`v.mFirstChild`+", back:"+`v.mBack`+", next:"+`v.mNext`)
	
	# Special case the root
	if v == c.frame.rootVnode():
		if not v.mNext: return # Should never happen.
		c.frame.setRootVnode(v.mNext)

	# Clear the links in other nodes
	if v.mBack:
		v.mBack.mNext = v.mNext
	if v.mNext:
		v.mNext.mBack = v.mBack
	if v.mParent and v == v.mParent.mFirstChild:
		v.mParent.mFirstChild = v.mNext

	# Clear the links in this node
	v.mParent = v.mNext = v.mBack = None</t>
<t tx="T3252"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices:
	
	"""A class to implement global node indices (gnx's)."""
	
	@others</t>
<t tx="T3253">def __init__ (self):
	
	"""ctor for nodeIndices class"""
	
	self.userId = app.leoID # 5/1/03: This never changes.
	self.defaultId = app.leoID # This probably will change.
	self.lastIndex = None
	self.timeString = None</t>
<t tx="T3254">def areEqual (self,gnx1,gnx2):
	
	"""Return True if all fields of gnx1 and gnx2 are equal"""

	id1,time1,n1 = gnx1
	id2,time2,n2 = gnx2
	return id1==id2 and time1==time2 and n1==n2</t>
<t tx="T3255"># These are used by the fileCommands read/write code.

def getDefaultId (self):
	
	"""Return the id to be used by default in all gnx's"""
	return self.defaultId
	
def setDefaultId (self,id):
	
	"""Set the id to be used by default in all gnx's"""
	self.defaultId = id
</t>
<t tx="T3256">def getNewIndex (self):
	
	"""Create a new gnx using self.timeString and self.lastIndex"""
	
	id = self.userId # Bug fix 5/1/03: always use the user's id for new ids!
	t = self.timeString
	assert(t)
	n = None

	# Set n if id and time match the previous index.
	last = self.lastIndex
	if last:
		lastId,lastTime,lastN = last
		if id==lastId and t==lastTime:
			if lastN == None: n = 1
			else: n = lastN + 1

	d = (id,t,n)
	self.lastIndex = d
	# trace(d)
	return d</t>
<t tx="T3257">def scanGnx (self,s,i):
	
	"""Create a gnx from its string representation"""

	if len(s) &gt; 0 and s[-1] == '\n':
		s = s[:-1]

	id,t,n=None,None,None
	i,id = skip_to_char(s,i,'.')
	if match(s,i,'.'):
		i,t = skip_to_char(s,i+1,'.')
		if match(s,i,'.'):
			i,n = skip_to_char(s,i+1,'.')
	# Use self.defaultId for missing id entries.
	if id == None or len(id) == 0:
		id = self.defaultId
	# Convert n to int.
	if n:
		try: n = int(n)
		except: pass
	d = (id,t,n)

	return d</t>
<t tx="T3258">def setTimestamp (self):

	"""Set the timestamp string to be used by getNewIndex until further notice"""

	self.timeString = time.strftime(
		"%m%d%y%H%M%S",  # compact timestamp is best
		time.localtime())</t>
<t tx="T3259">def toString (self,index,removeDefaultId=false):
	
	"""Convert a gnx (a tuple) to its string representation"""

	id,t,n = index

	if removeDefaultId and id == self.defaultId:
		id = ""

	if n == None:
		return "%s.%s" % (id,t)
	else:
		return "%s.%s.%d" % (id,t,n)</t>
<t tx="T3260">"""Install and run Leo plugins.

On startup:
- doPlugins() calls loadHandlers() to import all
  mod_XXXX.py files in the Leo directory.

- Imported files should register hook handlers using the
  registerHandler and registerExclusiveHandler functions.
  Only one "exclusive" function is allowed per hook.

After startup:
- doPlugins() calls doHandlersForTag() to handle the hook.
- The first non-None return is sent back to Leo.
"""

from leoGlobals import *

handlers = {}
count = 0 ; examined = 0

def doPlugins(tag,keywords):
	if tag == "start1":
		loadHandlers()
	return doHandlersForTag(tag,keywords)
		
@others</t>
<t tx="T3261">def loadHandlers():

	"""Load all plugins from the plugins directory"""
	import glob,os
	global count
	
	path = os.path.join(app.loadDir,"..","plugins")
	files = glob.glob(os.path.join(path,"*.py"))
	files.sort()
	if files:
		for file in files:
			importFromPath(file,path)
		es("%d plugins loaded, %d examined" % (count,len(files)), color="blue")</t>
<t tx="T3262">def doHandlersForTag (tag,keywords):
	
	"""Execute all handlers for a given tag, in alphabetical order"""

	global handlers

	if handlers.has_key(tag):
		handle_fns = handlers[tag]
		handle_fns.sort()
		for handle_fn in handle_fns:
			ret = handle_fn(tag,keywords)
			if ret is not None:
				return ret

	if handlers.has_key("all"):
		handle_fns = handlers["all"]
		handle_fns.sort()
		for handle_fn in handle_fns:
			ret = handle_fn(tag,keywords)
			if ret is not None:
				return ret
	return None</t>
<t tx="T3263">def registerHandler(tags,fn):
	
	""" Register one or more handlers"""
	
	import types

	if type(tags) in (types.TupleType,types.ListType):
		for tag in tags:
			registerOneHandler(tag,fn)
	else:
		registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
	
	"""Register one handler"""

	global handlers

	existing = handlers.setdefault(tag,[])
	try:
		existing.append(fn)
	except AttributeError:
		es("*** Two exclusive handlers for '%s'" % tag)
</t>
<t tx="T3264">def registerExclusiveHandler(tags, fn):
	
	""" Register one or more exclusive handlers"""
	
	import types
	
	if type(tags) in (types.TupleType,types.ListType):
		for tag in tags:
			registerOneExclusiveHandler(tag,fn)
	else:
		registerOneExclusiveHandler(tags,fn)
			
def registerOneExclusiveHandler(tag, fn):
	
	"""Register one exclusive handler"""
	
	global handlers
	
	if handlers.has_key(tag):
		es("*** Two exclusive handlers for '%s'" % tag)
	else:
		handlers[tag] = (fn,)
</t>
<t tx="T3265">@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):
	setattr(theClass,name or f.__name__,f)
	
# That's all!</t>
<t tx="T3266">@language python

from leoGlobals import *
import string,Tkinter

# Public constants used for defaults when leoConfig.txt can not be read.
default_page_width = 132
default_tab_width = 4
default_target_language = "python"
default_default_directory = None

ivars = [
	"tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width",
	"target_language" ]

class baseLeoPrefs:
	"""The base class of Leo's preferences panel."""
	@others
	
class LeoPrefs (baseLeoPrefs):
	"""A class that creates Leo's preferenes panel."""
	pass</t>
<t tx="T3267"></t>
<t tx="T3268">def onOK (self):
	app.config.setConfigIvars(self.commands)
	app.config.update()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()
	
def onCancel (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()

def onRevert (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)</t>
<t tx="T3269"># Global options
c.tangle_batch_flag = self.revert_tangle_batch_flag
c.untangle_batch_flag = self.revert_untangle_batch_flag
c.page_width = self.revert_page_width
c.tab_width = self.revert_tab_width

# Default Tangle Options
c.tangle_directory = self.revert_tangle_directory
c.output_doc_flag = self.revert_output_doc_flag
c.use_header_flag = self.revert_use_header_flag

# Default Target Language
c.target_language = self.revert_target_language</t>
<t tx="T3270">@language python

# Tangle and Untangle.

from leoGlobals import *
import os,string

&lt;&lt; about Tangle and Untangle &gt;&gt;
&lt;&lt; constants &amp; synonyms &gt;&gt;

@others</t>
<t tx="T3271"># Synonyms for multiple_parts_flag.
allow_multiple_parts = 1
disallow_multiple_parts = 2
unused_parts_flag = 3

# Synonyms for is_root_flag to st_enter.
is_root_name = 1 ; not_root_name = 0

# Synonyms for scanAllDirectives
report_errors = 1 ; dont_report_errors = 0
require_path = 1 ; done_require_path = 0

# Constants...
max_errors = 20

@ All these must be defined together, because they form a single enumeration.  Some of these are used by utility functions.
@c

if 1: # A single enum...

	# Used by token_type().
	plain_line = 1 # all other lines
	at_at	     = 2 # double-at sign.
	at_chapter = 3 # @chapter
	# at_c       = 4 # @c in noweb mode
	at_code	   = 5 # @code, or @c or @p in CWEB mode.
	at_doc	    = 6 # @doc
	at_other   = 7 # all other @directives
	at_root	   = 8 # @root or noweb * sections
	at_section = 9 # @section
	# at_space   = 10 # @space
	at_web	    = 11 # any CWEB control code, except at_at.
	
	# Returned by self.skip_section_name() and allies and used by token_type.
	bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
	section_ref	 = 13  # &lt; &lt; name &gt; &gt;
	section_def	 = 14  # &lt; &lt; name &gt; &gt; =
	
	# Returned by is_sentinal_line.
	non_sentinel_line   = 15
	start_sentinel_line = 16
	end_sentinel_line   = 17
	
	# Stephen P. Schaefer 9/13/2002
	# add support for @first
	at_last    = 18
</t>
<t tx="T3272"></t>
<t tx="T3273">class tst_node:
	@others</t>
<t tx="T3274">def __init__ (self,name,root_flag):

	# trace("tst_node.__init__" + `name`)
	self.name = name
	self.is_root = root_flag
	self.referenced = false
	self.parts = []</t>
<t tx="T3275">def __repr__ (self):

	return "tst_node:" + self.name</t>
<t tx="T3276">class part_node:
	@others</t>
<t tx="T3277">def __init__ (self,name,code,doc,is_root,is_dirty):

	# trace("part_node.__init__" + `name`)
	self.name = name # Section or file name.
	self.code = code # The code text.
	self.doc = doc # The doc text.
	self.is_dirty = is_dirty # true: vnode for body text is dirty.
	self.is_root = is_root # true: name is a root name.</t>
<t tx="T3278">def __repr__ (self):

	return "part_node:" + self.name</t>
<t tx="T3279">class ust_node:
	@others</t>
<t tx="T3280">@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,code,part,of,nl_flag,update_flag):

	# trace("ust_node.__init__", `name` +":"+ `part`)
	self.name = name # section name
	self.parts = {} # parts dict
	self.code = code # code text
	self.part = part # n in "(part n of m)" or zero.
	self.of = of  # m in "(part n of m)" or zero.
	self.nl_flag = nl_flag  # true: section starts with a newline.
	self.update_flag = update_flag # true: section corresponds to a section in the outline.</t>
<t tx="T3281">def __repr__ (self):

	return "ust_node:" + self.name</t>
<t tx="T3282">class def_node:
	@others</t>
<t tx="T3283">@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,indent,part,of,nl_flag,code):

	if 0:
		trace("def_node.__init__",
			"name:" + name + ", part:" + `part` + ", of:" + `of` + ", indent:" + `indent`)
	self.name = name
	self.indent = indent
	self.code = code
	if self.code == None: self.code = ""
	self.part = part
	self.of = of
	self.nl_flag = nl_flag</t>
<t tx="T3284">def __repr__ (self):

	return "def_node:" + self.name</t>
<t tx="T3285">@doc Stephen P. Schaefer, 9/2/2002
Collect the root node specific attributes in an
easy-to-use container.
@code
class root_attributes:
	@others</t>
<t tx="T3286">@ Stephen P. Schaefer, 9/2/2002
Keep track of the attributes of a root node
@c

def __init__ (self, tangle_state):

	if 0:
		&lt;&lt; trace the state &gt;&gt;
	self.language = tangle_state.language
	self.single_comment_string = tangle_state.single_comment_string
	self.start_comment_string = tangle_state.start_comment_string
	self.end_comment_string = tangle_state.end_comment_string
	self.use_header_flag = tangle_state.use_header_flag
	self.print_mode = tangle_state.print_mode
	
	# of all the state variables, this one isn't set in tangleCommands.__init__
	# peculiar
	try:
		self.path = tangle_state.path
	except AttributeError:
		self.path = None
	
	self.page_width = tangle_state.page_width
	self.tab_width = tangle_state.tab_width
	self.first_lines = tangle_state.first_lines # Stephen P. Schaefer 9/13/2002</t>
<t tx="T3287">try:
	if tangle_state.path: pass
except AttributeError:
	tangle_state.path = None
	
trace("def_root_attribute.__init__",
	"language:" + tangle_state.language +
	", single_comment_string: " + tangle_state.single_comment_string +
	", start_comment_string: " + tangle_state.start_comment_string +
	", end_comment_string: " + tangle_state.end_comment_string +
	", use_header_flag: " + choose(tangle_state.use_header_flag, "true", "false") +
	", print_mode: " + tangle_state.print_mode +
	", path: " + choose(tangle_state.path, tangle_state.path, "") +
	", page_width: " + tangle_state.page_width +
	", tab_width: " + tangle_state.tab_width +
	# Stephen P. Schaefer 9/13/2002
	", first_lines: " + tangle_state.first_lines)</t>
<t tx="T3288">def __repr__ (self):

	return ("root_attributes: language: " + self.language +
		", single_comment_string: " + self.single_comment_string +
		", start_comment_string: " +	self.start_comment_string +
		", end_comment_string: " +	self.end_comment_string +
		", use_header_flag: " + choose(self.use_header_flag, "true", "false") +
		", print_mode: " + self.print_mode +
		", path: " + self.path +
		", page_width: " + self.page_width +
		", tab_width: " + self.tab_width +
		# Stephen P. Schaefer 9/13/2002
		", first_lines: " + self.first_lines)
</t>
<t tx="T3289">class baseTangleCommands:
	"""The base class for Leo's tangle and untangle commands."""
	@others
	
class tangleCommands (baseTangleCommands):
	"""A class that implements Leo' tangle and untangle commands."""
	pass</t>
<t tx="T3290">def __init__ (self,commands):

	self.commands = commands
	self.init_ivars()</t>
<t tx="T3291">@ Only top-level drivers initialize ivars.
</t>
<t tx="T3292"># This code is called from tangleTree and untangleTree.

def cleanup (self):
	
	if self.errors == 0:
		&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;

	# Reinitialize the symbol tables and lists.
	self.tst = {}
	self.ust = {}
	self.root_list = []
	self.def_stack = []</t>
<t tx="T3293"># Create a list of root names:
root_names = []
dir = self.tangle_directory # Bug fix: 12/04/02
if not dir: dir = ""
for section in self.root_list:
	for part in section.parts:
		if part.is_root:
			root_names.append(os.path.join(dir,part.name))

if self.tangling and self.tangle_batch_flag:
	try:
		import tangle_done
		tangle_done.run(root_names)
	except:
		es("Can not execute tangle_done.run()")
		es_exception()
if not self.tangling and self.untangle_batch_flag:
	try:
		import untangle_done
		untangle_done.run(root_names)
	except:
		es("Can not execute tangle_done.run()")
		es_exception()</t>
<t tx="T3294">def initTangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Tangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = true</t>
<t tx="T3295">def initUntangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Untangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = false</t>
<t tx="T3296">def tangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initTangleCommand()
	self.tangleTree(v,report_errors)
	es("Tangle complete")</t>
<t tx="T3297">def tangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initTangleCommand()
	has_roots = false

	while v:
		ok = self.tangleTree(v,dont_report_errors)
		if ok: has_roots = true
		if self.path_warning_given:
			break # Fatal error.
		v = v.next()

	if not has_roots:
		self.warning("----- The outline contains no roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		self.warning("----- Tangle halted because of errors")
	else:
		es("Tangle complete")</t>
<t tx="T3298">def tangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	c.clearAllVisited() # No roots have been tangled yet.
	self.initTangleCommand()
	any_marked = false

	while v:
		is_ignore, i = is_special(v.bodyString(),0,"@ignore")
		# Only tangle marked and unvisited nodes.
		if is_ignore:
			v = v.nodeAfterTree()
		elif v.isMarked():
			ok = self.tangleTree(v,dont_report_errors)
			if ok: any_marked = true
			if self.path_warning_given:
				break # Fatal error.
			v = v.nodeAfterTree()
		else: v = v.threadNext()

	if not any_marked:
		self.warning("----- The outline contains no marked roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		self.warning("----- Tangle halted because of errors")
	else:
		es("Tangle complete")</t>
<t tx="T3299">@ This is the main routine of pass 1. It traverses the tree whose root is given, handling each headline and associated body text.
@c

def tanglePass1(self,v):

	next = v.nodeAfterTree()
	
	while v and v != next:
		self.v = v
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		is_ignore = dict.has_key("ignore")
		if is_ignore:
			v = v.nodeAfterTree()
			continue
		# This must be called after root_name has been set.
		if self.tangling:
			self.scanAllDirectives(v,require_path,report_errors) # calls init_directive_ivars.
		# Scan the headline and body text.
		self.skip_headline(v)
		self.skip_body(v)
		v = v.threadNext()
		if self.errors &gt;= max_errors:
			self.warning("----- Halting Tangle: too many errors")
			break

	if self.tangling:
		self.st_check()
		# trace(self.st_dump(verbose_flag=true))</t>
<t tx="T3300"># At this point v is the root of the tree that has been tangled.

def tanglePass2(self):

	self.v = None # self.v is not valid in pass 2.

	if self.errors &gt; 0:
		self.warning("----- No file written because of errors")
	elif self.root_list == None:
		self.warning("----- The outline contains no roots")
	else:
		self.put_all_roots() # pass 2 top level function.</t>
<t tx="T3301">@ This funtion tangles all nodes in the tree whose root is v. It reports on its results if report_flag is true.

This function is called only from the top level, so there is no need to initialize globals.
@c

def tangleTree(self,v,report_flag):

	assert(v)
	any_root_flag = false
	next = v.nodeAfterTree()
	self.path_warning_given = false

	while v and v != next:
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		is_ignore = dict.has_key("ignore")
		is_root = dict.has_key("root")
		is_unit = dict.has_key("unit")
		if is_ignore:
			v = v.nodeAfterTree()
		elif not is_root and not is_unit:
			v = v.threadNext()
		else:
			self.tanglePass1(v) # sets self.v
			if self.root_list and self.tangling:
				any_root_flag = true
				self.tanglePass2() # self.v invalid in pass 2.
			self.cleanup()
			v = v.nodeAfterTree()
			if self.path_warning_given: break # Fatal error.

	if self.tangling and report_flag and not any_root_flag:
		# This is done by Untangle if we are untangling.
		self.warning("----- The outline contains no roots")
	return any_root_flag</t>
<t tx="T3302">def untangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initUntangleCommand()
	
	c.beginUpdate()
	self.untangleTree(v,report_errors)
	c.endUpdate()
	es("Untangle complete")</t>
<t tx="T3303">def untangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	has_roots = false

	c.beginUpdate()
	while v:
		ok = self.untangleTree(v,false)
		if ok: has_roots = true
		v = v.next()
	c.endUpdate()
	
	if not has_roots:
		self.warning("----- The outline contains no roots")
	elif self.errors &gt; 0:
		self.warning("----- Untangle command halted because of errors")
	else:
		es("Untangle complete")</t>
<t tx="T3304">def untangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	marked_flag = false

	c.beginUpdate()
	while v:
		if v.isMarked():
			ok = self.untangleTree(v,dont_report_errors)
			if ok: marked_flag = true
			if self.errors &gt; 0: break
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()

	if not marked_flag:
		self.warning("----- The outline contains no marked roots")
	elif self.errors &gt; 0:
		self.warning("----- Untangle command halted because of errors")
	else:
		es("Untangle complete")</t>
<t tx="T3305">@ This method untangles the derived files in a vnode known to contain at least one @root directive. The work is done in two passes. The first pass creates the UST by scanning the derived file. The second pass updates the outline using the UST and a TST that is created during the pass.

We assume that all sections from root to end are contained in the derived file, and we attempt to update all such sections. The begin/end params indicate the range of nodes to be scanned when building the TST.
@c

def untangleRoot(self,root,begin,end):

	# trace("root,begin,end:" + `root` + `begin` + `end`)
	&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;
	&lt;&lt; return if @silent or unknown language &gt;&gt;
	&lt;&lt; Read the file into file_buf &gt;&gt;
	es("@root " + path)
	# Pass 1: Scan the C file, creating the UST
	self.scan_derived_file(file_buf)
	# trace(self.ust_dump())
	if self.errors == 0:
		&lt;&lt; Pass 2: Untangle the outline using the UST and a newly-created TST &gt;&gt;
	self.cleanup()</t>
<t tx="T3306">if self.language == "unknown":
	es("@comment disables Untangle for " + path, color="blue")
	return

if self.print_mode in ("quiet","silent"):
	es("@" + self.print_mode +  " inhibits Untangle for " + path, color="blue")
	return
</t>
<t tx="T3307">s = root.bodyString()
i = 0
while i &lt; len(s):
	code, junk = self.token_type(s,i,report_errors)
	if code == at_root:
		# token_type sets root_name unless there is a syntax error.
		if self.root_name: path = self.root_name
		break
	else: i = skip_line(s,i)
	
if not self.root_name:
	# A bad @root command.  token_type has already given an error.
	self.cleanup()
	return</t>
<t tx="T3308">f = None
try:
	path = os.path.join(self.tangle_directory,path)
	f = open(path)
	if f:
		file_buf = f.read()
		file_buf = string.replace(file_buf,body_ignored_newline,'')
except:
	if f: f.close()
	es("error reading: " + path)
	es_exception()
	self.cleanup()
	return</t>
<t tx="T3309">@ This code untangles the root and all its siblings. We don't call tangleTree here because we must handle all siblings.  tanglePass1 handles an entire tree.  It also handles @ignore.
@c

v = begin
while v and v != end:
	self.tanglePass1(v)
	if self.errors != 0:
		break
	v = v.nodeAfterTree()

self.ust_warn_about_orphans()</t>
<t tx="T3310"># This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,v,report_flag):

	# trace(`v`)
	c = self.commands
	any_root_flag = false
	afterEntireTree = v.nodeAfterTree()
	# Initialize these globals here: they can't be cleared later.
	self.head_root = None
	self.errors = 0
	c.clearAllVisited() # Used by untangle code.

	while v and v != afterEntireTree and self.errors == 0:
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		ignore = dict.has_key("ignore")
		root = dict.has_key("root")
		unit = dict.has_key("unit")
		if ignore:
			v = v.nodeAfterTree()
		elif unit:
			# Expand the context to the @unit directive.
			unitNode = v   # 9/27/99
			afterUnit = v.nodeAfterTree()
			v = v.threadNext()
			while v and v != afterUnit and self.errors == 0:
				self.setRootFromHeadline(v)
				dict = get_directives_dict(v.bodyString(),[self.head_root])
				root = dict.has_key("root")
				if root:
					any_root_flag = true
					end = None
					&lt;&lt; set end to the next root in the unit &gt;&gt;
					# trace("end:" + `end`)
					self.scanAllDirectives(v,require_path,report_errors)
					self.untangleRoot(v,unitNode,afterUnit)
					v = end
				else: v = v.threadNext()
		elif root:
			# Limit the range of the @root to its own tree.
			afterRoot = v.nodeAfterTree()
			any_root_flag = true
			self.scanAllDirectives(v,require_path,report_errors)
			self.untangleRoot(v,v,afterRoot) # 9/27/99
			v = afterRoot
		else:
			v = v.threadNext()
	if report_flag:
		if not any_root_flag:
			self.warning("----- The outline contains no roots")
		elif self.errors &gt; 0:
			self.warning("----- Untangle command halted because of errors")
	return any_root_flag</t>
<t tx="T3311">@ The untangle_root function will untangle an entire tree by calling untangleTree, so the following code ensures that the next @root node will not be an offspring of v.
@c

end = v.threadNext()
while end and end != afterUnit:
	flag, i = is_special(end.bodyString(),0,"@root")
	if flag and not v.isAncestorOf(end):
		break
	end = end.threadNext()
</t>
<t tx="T3312"></t>
<t tx="T3313"></t>
<t tx="T3314">@ This method handles newline processing while skipping a code section. It sets 'done' if the line contains an @directive or section definition that terminates the present code section. On entry: i should point to the first character of a line.  This routine scans past a line only if it could not contain a section reference.

Returns (i, done)
@c

def handle_newline(self,s,i):

	j = i ; done = false
	kind, end = self.token_type(s,i,dont_report_errors)
	# token_type will not skip whitespace in noweb mode.
	i = skip_ws(s,i)
	# trace(`kind` + "," + `get_line(s,i)`)

	if kind == plain_line:
		pass
	elif (kind == at_code or kind == at_doc or
		kind == at_root or kind == section_def):
		i = j ; done = true # Terminate this code section and rescan.
	elif kind == section_ref:
		# Enter the reference.
		ref = s[i:end]
		self.st_enter_section_name(ref,None,None,unused_parts_flag)
	# DTHEIN 13-OCT-2002: @first directives are OK in code sections
	elif (kind == at_other) and match_word(s,j,"@first"):
		pass
	elif kind == at_other or kind == at_chapter or kind == at_section:
		# We expect to see only @doc,@c or @root directives
		# while scanning a code section.
		i = skip_to_end_of_line(s,i)
		if 0: # 12/03/02: no longer needed
			self.error("directive not valid here: " + s[j:i])
	elif kind == bad_section_name:
		if self.use_cweb_flag:
			i = skip_to_end_of_line(s,i)
	elif kind == at_web or kind == at_at:
		i += 2 # Skip a CWEB control code.
	else: assert(false)

	return i, done</t>
<t tx="T3315"># This method handles all the body text.

def skip_body (self,v):

	# trace(`v`)
	s = v.bodyString()
	code_seen = false ; code = doc = None ; i = 0
	anyChanged = false
	
	if self.start_mode == "code":
		j = skip_blank_lines(s,i)
		i,code = self.skip_code(s,j)
		if code:
			&lt;&lt; Define a section for a leading code part &gt;&gt;

	if not code:
		i,doc = self.skip_doc(s,i) # Start in doc section by default.
		if i &gt;= len(s) and doc:
			&lt;&lt; Define a section containing only an @doc part &gt;&gt;

	while i &lt; len(s):
		progress = i # progress indicator
		# line = get_line(s,i) ; trace(`line`)
		kind, end = self.token_type(s,i,report_errors)
		# if is_nl(s,i): i = skip_nl(s,i)
		i = skip_ws(s,i)
		if kind == section_def:
			&lt;&lt; Scan and define a section definition &gt;&gt;
		elif kind == at_code:
			if self.use_cweb_flag:
				i += 2 # Skip the at-c or at-p
			else:
				i = skip_line(s,i)
			&lt;&lt; Scan and define an @code defininition &gt;&gt;
		elif kind == at_root:
			i = skip_line(s,i)
			&lt;&lt; Scan and define a root section &gt;&gt;
		elif kind == at_doc:
			if self.use_cweb_flag:
				i += 2 # Skip the at-space
			else:
				i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		elif kind == at_chapter or kind == at_section:
			i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		else:
			i = skip_line(s,i)
		assert(progress &lt; i) # we must make progress!
	# 3/4/02: Only call v.trimTrailingLines if we have changed its body.
	if anyChanged:
		v.trimTrailingLines()</t>
<t tx="T3316">@ The following subsections contain the interface between the Tangle and Untangle commands.  This interface is an important hack, and allows Untangle to avoid duplicating the logic in skip_tree and its allies.

The aha is this: just at the time the Tangle command enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.

To get whitespace exactly right we retain the outline's leading whitespace and remove leading whitespace from the updated definition.
</t>
<t tx="T3317">@ It's valid for an @doc directive to appear under a headline that does not contain a section name.  In that case, no section is defined.
@c

if self.header_name:
	# Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	# Untangle code.
	if not self.tangling: 
		# Untangle no longer updates doc parts.
		# 12/03/02: Mark the part as having been updated to suppress warning.
		junk,junk = self.ust_lookup(self.header_name,
			part,not_root_name,true) # set update flag

doc = None</t>
<t tx="T3318">if self.header_name:
	# Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	# Untangle code.
	if not self.tangling: 
		head = s[:j] ; tail = s[i:]
		s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
		if changed: anyChanged = true
	code_seen = true
	code = doc = None</t>
<t tx="T3319"># We enter the code part and any preceding doc part into the symbol table.

# Skip the section definition line.
k = i ; i, kind, junk = self.skip_section_name(s,i)
section_name = s[k:i]
# trace(`section_name`)
assert(kind == section_def)
i = skip_to_end_of_line(s,i)

# Tangle code: enter the section name even if the code part is empty.
j = skip_blank_lines(s,i)
i, code = self.skip_code(s,j)
flag = choose(kind==section_def,allow_multiple_parts,disallow_multiple_parts)
part = self.st_enter_section_name(section_name,code,doc,flag)
		
if not self.tangling: # Untangle code.
	head = s[:j] ; tail = s[i:]
	s,i,changed = self.update_def(section_name,part,head,code,tail,not_root_name)
	if changed: anyChanged = true
	
code = doc = None</t>
<t tx="T3320"># All @c or @code directives denote &lt; &lt; headline_name &gt; &gt; =
if self.header_name:

	# Tangle code.
	j = skip_blank_lines(s,i)
	i, code = self.skip_code(s,j)
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	if not self.tangling: # Untangle code.
		head = s[:j] ; tail = s[i:]
		s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
		if changed: anyChanged = true
else:
	self.error("@c expects the headline: " + self.header + " to contain a section name")

code_seen = true
code = doc = None</t>
<t tx="T3321"># We save the file name in case another @root ends the code section.
old_root_name = self.root_name

# Tangle code.
j = skip_blank_lines(s,i)
k, code = self.skip_code(s,j)

# Stephen Schaefer, 9/2/02, later
# st_enter_root_name relies on scanAllDirectives to have set
# the root attributes, such as language, *_comment_string,
# use_header_flag, etc.
self.st_enter_root_name(old_root_name,code,doc)

if not self.tangling: # Untangle code.
	part = 1 # Use 1 for root part.
	head = s[:j] ; tail = s[k:]
	s,i,changed = self.update_def(old_root_name,part,head,code,tail,is_root_name)
	if changed: anyChanged = true
	
code = doc = None</t>
<t tx="T3322">@ This method skips an entire code section. The caller is responsible for entering the completed section into the symbol table. On entry, i points at the line following the @directive or section definition that starts a code section. We skip code until we see the end of the body text or the next @ directive or section defintion that starts a code or doc part.
@c

def skip_code(self,s,i):

	# trace(`get_line(s,i)`)
	code1 = i
	nl_i = i # For error messages
	done = false # true when end of code part seen.
	if self.use_noweb_flag:
		&lt;&lt; skip a noweb code section &gt;&gt;
	else:
		&lt;&lt; skip a CWEB code section &gt;&gt;
	code = s[code1:i]
	# trace(returns: + `code`)
	return i,code</t>
<t tx="T3323">@ This code handles the following escape conventions: double at-sign at the start of a line and at-&lt;&lt; and at.&gt;.
@c

i, done = self.handle_newline(s,i)
while not done and i &lt; len(s):
	ch = s[i]
	if is_nl(s,i):
		nl_i = i = skip_nl(s,i)
		i, done = self.handle_newline(s,i)
	elif ch == '@' and (match(s,i+1,"&lt;&lt;") or # must be on different lines
		match(s,i+1,"&gt;&gt;")):
		i += 3 # skip the noweb escape sequence.
	elif ch == '&lt;':
		&lt;&lt; handle possible noweb section reference &gt;&gt;
	else: i += 1</t>
<t tx="T3324">j, kind, end = self.is_section_name(s,i)
if kind == section_def:
	k = skip_to_end_of_line(s,i)
	# We are in the middle of a line.
	i += 1
	self.error("chunk definition not valid here\n" + s[nl_i:k])
elif kind == bad_section_name:
	i += 1 # This is not an error.  Just skip the '&lt;'.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:end]
	self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = end</t>
<t tx="T3325"># This code is simple because CWEB control codes are valid anywhere.

while not done and i &lt; len(s):
	if s[i] == '@':
		&lt;&lt; handle CWEB control code &gt;&gt;
	else: i += 1</t>
<t tx="T3326">j, kind, end = self.is_section_name(s,i)

if kind == section_def:
	done = true
elif kind == bad_section_name:
	i += 2 # Any other control code.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:j]
	self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = j</t>
<t tx="T3327">def skip_doc(self,s,i):

	# trace(`get_line(s,i)`)
	# Skip @space, @*, @doc, @chapter and @section directives.
	doc1 = i
	while i &lt; len(s):
		if is_nl(s,i):
			doc1 = i = skip_nl(s,i)
		elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@*"):
			i = skip_ws(s,i+2) ; doc1 = i
		elif match(s,i,"@\n"):
			i += 1 ; doc1 = i
		elif (match_word(s,i,"@doc") or
			  match_word(s,i,"@chapter") or
			  match_word(s,i,"@section")):
			doc1 = i = skip_line(s,i)
		else: break

	while i &lt; len(s):
		kind, end = self.token_type(s,i,dont_report_errors)
		if kind == at_code or kind == at_root or kind == section_def:
			break
		i = skip_line(s,i)

	doc = s[doc1:i]
	# trace(doc)
	return i, doc</t>
<t tx="T3328">@ This function sets ivars that keep track of the indentation level. We also remember where the next line starts because it is assumed to be the first line of a documentation section.

A headline can contain a leading section name.  If it does, we substitute the section name if we see an @c directive in the body text.
@c

def skip_headline(self,v):

	# trace(`v`)
	self.header = s = v.headString()
	# Set self.header_name.
	j = i = skip_ws(s,0)
	i, kind, end = self.is_section_name(s,i)
	if kind == bad_section_name:
		self.header_name = None
	else:
		self.header_name = s[j:end]</t>
<t tx="T3329"></t>
<t tx="T3330">@ This method outputs a code section, expanding section references by their definition. We should see no @directives or section definitions that would end the code section.

Most of the differences bewteen noweb mode and CWEB mode are handled by token_type(called from put_newline). Here, the only difference is that noweb handles double-@ signs only at the start of a line.
@c

def put_code(self,s,no_first_lws_flag):

	# trace(`get_line(s,0)`)
	i = 0
	if i &lt; len(s):
		i = self.put_newline(s,i,no_first_lws_flag)
		# Double @ is valid in both noweb and CWEB modes here.
		if match(s,i,"@@"):
			self.os('@') ; i += 2
	while i &lt; len(s):
		progress = i
		ch = s[i]
		if (match(s,i,"&lt;&lt;") and self.use_noweb_flag or
			match(s,i,"@&lt;") and self.use_cweb_flag):
			&lt;&lt; put possible section reference &gt;&gt;
		elif ch == '@': # We are in the middle of a line.
			if self.use_cweb_flag:
				&lt;&lt; handle 2-character CWEB control codes &gt;&gt;
			else:
				&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;
		elif ch == body_ignored_newline:
			i += 1
		elif ch == body_newline:
			i += 1 ; self.onl()
			i = self.put_newline(s,i,false) # Put full lws
			if self.use_cweb_flag and match(s,i,"@@"):
				self.os('@') ; i += 2
		else: self.os(s[i]) ; i += 1
		assert(progress &lt; i)</t>
<t tx="T3331">j, kind, name_end = self.is_section_name(s,i)
if kind == section_def:
	# We are in the middle of a code section
	self.error(
		"Should never happen:\n" +
		"section definition while putting a section reference: " +
		s[i:j])
	i += 1
elif kind == bad_section_name:
	self.os(s[i]) ; i += 1 # This is not an error.
else:
	assert(kind == section_ref)
	name = s[i:name_end]
	self.put_section(s,i,name,name_end)
	i = j</t>
<t tx="T3332">if match(s,i,"@@"):
	# Handle double @ sign.
	self.os('@') ; i += 2
else:
	i += 1 # skip the @.
	if i+1 &gt;= len(s) or is_ws_or_nl(s,i):
		# A control code: at-backslash is not a valid CWEB control code.
		# We are in CWEB mode, so we can output C block comments.
		self.os("/*@" + s[i] + "*/") ; i += 1
	else:
		self.os("@") # The at sign is not part of a control code.</t>
<t tx="T3333">@ The user must ensure that neither @ &lt; &lt; nor @ &gt; &gt; occurs in comments or strings. However, it is valid for @ &lt; &lt; or @ &gt; &gt; to appear in the doc chunk or in a single-line comment.
@c

if match(s,i,"@&lt;&lt;"):
	self.os("/*@*/&lt;&lt;") ; i += 3

elif match(s,i,"@&gt;&gt;"):
	self.os("/*@*/&gt;&gt;") ; i += 3
	
else: self.os("@") ; i += 1</t>
<t tx="T3334"># This method outputs a doc section within a block comment.

def put_doc(self,s):

	# trace(`get_line(s,0)`)
	width = self.page_width
	words = 0 ; word_width = 0 ; line_width = 0
	# 8/1/02: can't use choose here!
	if self.single_comment_string == None: single_w = 0
	else: single_w = len(self.single_comment_string)
	# Make sure we put at least 20 characters on a line.
	if width - max(0,self.tangle_indent) &lt; 20:
		width = max(0,self.tangle_indent) + 20
	# Skip Initial white space in the doc part.
	i = skip_ws_and_nl(s,0)
	if i &lt; len(s) and (self.print_mode == "verbose" or self.print_mode == "quiet"):
		use_block_comment = self.start_comment_string and self.end_comment_string
		use_single_comment = not use_block_comment and self.single_comment_string
		# javadoc_comment = use_block_comment and self.start_comment_string == "/**"
		if use_block_comment or use_single_comment:
			if 0: # The section name ends in an self.onl().
				self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.start_comment_string)
			&lt;&lt; put the doc part &gt;&gt;
			self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.end_comment_string)
			self.onl()
		else: self.onl()</t>
<t tx="T3335">@ This code fills and outputs each line of a doc part. It keeps track of whether the next word will fit on a line,and starts a new line if needed.
@c

if use_single_comment:
	# New code: 5/31/00
	self.os(self.single_comment_string) ; self.otab()
	line_width =(single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
else:
	line_width = abs(self.tab_width)
	self.onl() ; self.otab()
self.put_leading_ws(self.tangle_indent)
line_width += max(0,self.tangle_indent)
words = 0 ; word_width = 0
while i &lt; len(s):
	&lt;&lt;output or skip whitespace or newlines&gt;&gt;
	if i &gt;= len(s):
		break
	&lt;&lt;compute the width of the next word&gt;&gt;
	if words == 0 or line_width + word_width &lt; width:
		words += 1
		&lt;&lt;output next word&gt;&gt;
		line_width += word_width
	else:
		# 11-SEP-2002 DTHEIN: Fixed linewrapping bug in
		# tab-then-comment sequencing
		self.onl()
		if use_single_comment:
			self.os(self.single_comment_string) ; self.otab()
			line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
		else:
			self.otab()
			line_width = abs(self.tab_width)
		words = 0
		self.put_leading_ws(self.tangle_indent)
		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)
</t>
<t tx="T3336">@ This outputs whitespace if it fits, and ignores it otherwise, and starts a new line if a newline is seen. The effect of self code is that we never start a line with whitespace that was originally at the end of a line.
@c

while is_ws_or_nl(s,i):
	ch = s[i]
	if ch == '\t':
		pad = abs(self.tab_width) - (line_width % abs(self.tab_width))
		line_width += pad
		if line_width &lt; width: self.otab()
		i += 1
	elif ch == ' ':
		line_width += 1
		if line_width &lt; width: self.os(ch)
		i += 1
	else:
		assert(is_nl(s,i))
		self.onl()
		if use_single_comment:
			# New code: 5/31/00
			self.os(self.single_comment_string) ; self.otab()
			line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
		else:
			self.otab()
			line_width = abs(self.tab_width)
		i = skip_nl(s,i)
		words = 0
		self.put_leading_ws(self.tangle_indent)
		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)
</t>
<t tx="T3337">j = i ; word_width = 0
while j &lt; len(s) and not is_ws_or_nl(s,j):
	word_width += 1
	j += 1</t>
<t tx="T3338">while i &lt; len(s) and not is_ws_or_nl(s,i):
	self.os(s[i])
	i += 1</t>
<t tx="T3339"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def put_leading_ws(self,n):

	# trace("tab_width:" + `self.tab_width` + ", indent:" + `indent`)
	w = self.tab_width

	if w &gt; 1:
		q,r = divmod(n,w) 
		self.otabs(q) 
		self.oblanks(r) 
	else:
		self.oblanks(n)
</t>
<t tx="T3340">@ This method handles scanning when putting the start of a new line. Unlike the corresponding method in pass one, this method doesn't need to set a done flag in the caller because the caller already knows where the code section ends.
@c

def put_newline(self,s,i,no_first_lws_flag):

	kind, end = self.token_type(s,i,dont_report_errors)
	&lt;&lt; Output leading white space except for blank lines &gt;&gt;
	if i &gt;= len(s):
		return i
	elif kind == at_web or kind == at_at:
		i += 2 # Allow the line to be scanned.
	elif kind == at_doc or kind == at_code:
		if self.use_cweb_flag:
			i += 2
	else:
		# These should have set limit in pass 1.
		assert(kind != section_def and kind != at_chapter and kind != at_section)
	return i</t>
<t tx="T3341">j = i ; i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	# Conditionally output the leading previous leading whitespace.
	if not no_first_lws_flag:
		self.put_leading_ws(self.tangle_indent)
	# Always output the leading whitespace of _this_ line.
	k, width = skip_leading_ws_with_indent(s,j,self.tab_width)
	self.put_leading_ws(width)</t>
<t tx="T3342"># This method outputs one part of a section definition.

def put_part_node(self,part,no_first_lws_flag):

	if 0:
		if part: name = part.name # can't use choose.
		else: name = "&lt;NULL part&gt;"
		trace(`name`)

	if part.doc and self.output_doc_flag and self.print_mode != "silent" and part.doc:
		self.put_doc(part.doc)

	if part.code:
		self.put_code(part.code,no_first_lws_flag)</t>
<t tx="T3343">@ This method outputs the definition of a section and all sections referenced from the section. name is the section's name. This code checks for recursive definitions by calling section_check(). We can not allow section x to expand to code containing another call to section x, either directly or indirectly.
@c

def put_section(self,s,i,name,name_end):

	j = skip_line(s,i)
	# trace("indent:" + `self.tangle_indent`  + ", " + `s[i:j]`)
	outer_old_indent = self.tangle_indent
	trailing_ws_indent = 0 # Set below.
	inner_old_indent = 0 # Set below.
	newline_flag = false  # True if the line ends with the reference.
	assert(match(name,0,"&lt;&lt;") or match(name,0,"@&lt;"))
	&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;
	&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;
	section = self.st_lookup(name,not_root_name)
	if section and section.parts:
		# Expand the section only if we are not already expanding it.
		if self.section_check(name):
			self.section_stack.append(name)
			&lt;&lt; put all parts of the section definition &gt;&gt;
			self.section_stack.pop()
	else:
		&lt;&lt; Put a comment about the undefined section &gt;&gt;
	if not newline_flag:
		self.put_leading_ws(trailing_ws_indent)
	self.tangle_indent = outer_old_indent
	return i, name_end</t>
<t tx="T3344"># Find the start of the line containing the reference.
j = i
while j &gt; 0 and not is_nl(s,j):
	j -= 1
if is_nl(s,j):
	j = skip_nl(s,j)

# Bump the indentation
j, width = skip_leading_ws_with_indent(s,j,self.tab_width)
self.tangle_indent += width
# trace("leading ws:" + `width` + " + new indent:" + `self.tangle_indent`)

# 4/27/01: Force no trailing whitespace in @silent mode.
if self.print_mode == "silent":
	trailing_ws_indent = 0
else:
	trailing_ws_indent = self.tangle_indent

# Increase the indentation if the section reference does not immediately follow
# the leading white space.  4/3/01: Make no adjustment in @silent mode.
if (j &lt; len(s) and self.print_mode != "silent" and
		((self.use_noweb_flag and s[j] != '&lt;') or
		(self.use_cweb_flag and s[j] != '@'))):
	self.tangle_indent += abs(self.tab_width)</t>
<t tx="T3345">if self.print_mode != "silent":
	i = name_end
	i = skip_ws(s,i)
	newline_flag = (i &gt;= len(s) or is_nl(s,i))</t>
<t tx="T3346">@ This section outputs each part of a section definition. We first count how many parts there are so that the code can output a comment saying 'part x of y'.
@c

# Output each part of the section.
sections = len(section.parts)
count = 0
for part in section.parts:
	count += 1
	# In @silent mode, there is no sentinel line to "use up" the previously output
	# leading whitespace.  We set the flag to tell put_part_node and put_code
	# not to call put_newline at the start of the first code part of the definition.
	no_first_leading_ws_flag = (count == 1 and self.print_mode == "silent")
	inner_old_indent = self.tangle_indent
	# 4/3/01: @silent inhibits newlines after section expansion.
	if self.print_mode != "silent":
		&lt;&lt; Put the section name in a comment &gt;&gt;
	self.put_part_node(part,no_first_leading_ws_flag)
	# 4/3/01: @silent inhibits newlines after section expansion.
	if count == sections and (self.print_mode != "silent" and self.print_mode != "quiet"):
		&lt;&lt; Put the ending comment &gt;&gt;
	# Restore the old indent.
	self.tangle_indent = inner_old_indent</t>
<t tx="T3347">if count &gt; 1:
	self.onl()
	self.put_leading_ws(self.tangle_indent)
	
# Don't print trailing whitespace
name = string.rstrip(name)
if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
else:
	assert(
		self.start_comment_string and len(self.start_comment_string) &gt; 0 and
		self.end_comment_string and len(self.end_comment_string)&gt; 0)
	self.os(self.start_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
	self.oblank() ; self.os(self.end_comment_string)

self.onl() # Always output a newline.</t>
<t tx="T3348">if sections &gt; 1:
	self.oblank()
	self.os("(" + `count` + " of " + `sections` + ")")</t>
<t tx="T3349">@ We do not produce an ending comment unless we are ending the last part of the section,and the comment is clearer if we don't say(n of m).
@c

self.onl() ; self.put_leading_ws(self.tangle_indent)
#  Don't print trailing whitespace
while name_end &gt; 0 and is_ws(s[name_end-1]):
	name_end -= 1

if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
else:
	self.os(self.start_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
	self.oblank() ; self.os(self.end_comment_string)
	
@ The following code sets a flag for untangle.

If something follows the section reference we must add a newline, otherwise the "something" would become part of the comment.  Any whitespace following the (!newline) should follow the section defintion when Untangled.
@c

if not newline_flag:
	self.os(" (!newline)") # LeoCB puts the leading blank, so we must do so too.
	# Put the whitespace following the reference.
	while name_end &lt; len(s) and is_ws(s[name_end]):
		self.os(s[name_end])
		name_end += 1
	self.onl() # We must supply the newline!</t>
<t tx="T3350">self.onl() ; self.put_leading_ws(self.tangle_indent)

if self.print_mode != "silent":
	if self.single_comment_string:
		self.os(self.single_comment_string)
		self.os(" undefined section: ") ; self.os(name) ; self.onl()
	else:
		self.os(self.start_comment_string)
		self.os(" undefined section: ") ; self.os(name)
		self.oblank() ; self.os(self.end_comment_string) ; self.onl()

self.error("Undefined section: " + name)</t>
<t tx="T3351">@ We can not allow a section to be defined in terms of itself, either directly or indirectly.

We push an entry on the section stack whenever beginning to expand a section and pop the section stack at the end of each section.  This method checks whether the given name appears in the stack. If so, the section is defined in terms of itself.
@c

def section_check (self,name):

	if name in self.section_stack:
		s = "Invalid recursive reference of " + name + "\n"
		for n in self.section_stack:
			s += "called from: " + n + "\n"
		self.error(s)
		return false
	return true</t>
<t tx="T3352"></t>
<t tx="T3353">@ This function checks the given symbol table for defined but never referenced sections.
@c

def st_check(self):

	keys = self.tst.keys()
	keys.sort()
	# trace(`keys`)
	for name in keys:
		section = self.tst[name]
		if not section.referenced:
			es(	' ' * 4 + "Warning: " +
				choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
				section.name +
				choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
				" has been defined but not used.")</t>
<t tx="T3354"># Dumps the given symbol table in a readable format.

def st_dump(self,verbose_flag=true):
	
	s = "\ndump of symbol table...\n"
	keys = self.tst.keys()
	keys.sort()
	for name in keys:
		section = self.tst[name]
		if verbose_flag:
			s += self.st_dump_node(section)
		else:
			type = choose(len(section.parts)&gt;0,"  ","un")
			s += ("\n" + type + "defined:[" + section.name + "]")
	return s</t>
<t tx="T3355"># Dumps each part of a section's definition.

def st_dump_node(self,section):

	s = ("\nsection: " + section.name +
		", referenced:" + `section.referenced` +
		", is root:" + `section.is_root`)
	
	if len(section.parts) &gt; 0:
		s += "\n----- parts of " + angleBrackets(section.name)
		n = 1 # part list is in numeric order
		for part in section.parts:
			s += "\n----- Part " + `n`
			n += 1
			s += "\ndoc:  [" + `part.doc`  + "]"
			s += "\ncode: [" + `part.code` + "]"
		s += "\n----- end of partList\n"
	return s</t>
<t tx="T3356">@ Enters names and their associated code and doc parts into the given symbol table.
`is_dirty` is used only when entering root names.
@c

def st_enter(self,name,code,doc,multiple_parts_flag,is_root_flag):
	
	# trace(`name`)
	section = self.st_lookup(name,is_root_flag)
	assert(section)
	if doc:
		doc = string.rstrip(doc) # remove trailing lines.
	if code:
		if self.print_mode != "silent": # @silent supresses newline processing.
			i = skip_blank_lines(code,0) # remove leading lines.
			if i &gt; 0: code = code[i:] 
			if code and len(code) &gt; 0: code = string.rstrip(code) # remove trailing lines.
		if len(code) == 0: code = None
	if code:
		&lt;&lt; check for duplicate code definitions &gt;&gt;
	if code or doc:
		part = part_node(name,code,doc,is_root_flag,false) # not dirty
		section.parts.append(part)
	else: # A reference
		section.referenced = true
	if is_root_flag:
		self.root_list.append(section)
		section.referenced = true # Mark the root as referenced.
		&lt;&lt;remember root node attributes&gt;&gt;
	# Stephen Schaefer, 9/2/02
	return len(section.parts) # part number
</t>
<t tx="T3357">for part in section.parts:

	if part.code and multiple_parts_flag == disallow_multiple_parts:
		# Give the message only for non-empty parts.
		self.error("Multiple parts not allowed for " + name)
		return 0 # part number

	if self.tangling and code and code == part.code:
		es("Warning: possible duplicate definition of: &lt;&lt;" +
			section.name + "&gt;&gt;")</t>
<t tx="T3358"># Stephen Schaefer, 9/2/02
# remember the language and comment characteristics
section.root_attributes = root_attributes(self)</t>
<t tx="T3359"># Enters a root name into the given symbol table.

def st_enter_root_name(self,name,code,doc):
	
	# assert(code)
	if name: # User errors can result in an empty @root name.
		self.st_enter(name,code,doc,disallow_multiple_parts,is_root_name)</t>
<t tx="T3360">@ This function enters a section name into the given symbol table.
The code and doc pointers are None for references.
@c

def st_enter_section_name(self,name,code,doc,multiple_parts_flag):
	
	return self.st_enter(name,code,doc,multiple_parts_flag,not_root_name)</t>
<t tx="T3361">@ This function looks up name in the symbol table and creates a tst_node for it if it does not exist.
@c

def st_lookup(self,name,is_root_flag):

	if is_root_flag:
		key = name
	else:
		key = self.standardize_name(name)

	if self.tst.has_key(key):
		section = self.tst[key]
		# trace("found:" + key)
		return section
	else:
		# trace("not found:" + key)
		section = tst_node(key,is_root_flag)
		self.tst [key] = section
		return section</t>
<t tx="T3362"></t>
<t tx="T3363">def ust_dump (self):

	s = "\n---------- Untangle Symbol Table ----------"
	keys = self.ust.keys()
	keys.sort()
	for name in keys:
		section = self.ust[name]
		s += "\n\n" + section.name
		for part in section.parts.values():
			assert(part.of == section.of)
			s += "\n----- part " + `part.part` + " of " + `part.of` + " -----\n"
			s += `get_line(part.code,0)`
	s += "\n--------------------"
	return s</t>
<t tx="T3364">@ This routine enters names and their code parts into the given table. The 'part' and 'of' parameters are taken from the "(part n of m)" portion of the line that introduces the section definition in the C code.

If no part numbers are given the caller should set the 'part' and 'of' parameters to zero.  The caller is reponsible for checking for duplicate parts.

This function handles names scanned from a source file; the corresponding st_enter routine handles names scanned from outlines.
@c

def ust_enter (self,name,part,of,code,nl_flag,is_root_flag):

	if not is_root_flag:
		name = self.standardize_name(name)
	&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;
	u = ust_node(name,code,part,of,nl_flag,false) # update_flag
	if not self.ust.has_key(name):
		self.ust[name] = u
	section = self.ust[name]
	section.parts[part]=u # Parts may be defined in any order.
	# trace("section name: [" + name + "](" + `part` + " of " + `of` + ")..."+`get_line(code,0)`)</t>
<t tx="T3365">i = skip_blank_lines(code,0)
if i &gt; 0:
	code = code[i:]
	code = string.rstrip(code)
</t>
<t tx="T3366"># Searches the given table for a part matching the name and part number.

def ust_lookup (self,name,part_number,is_root_flag,update_flag):
	
	# trace(`name` + ":" + `part_number`)
	
	if not is_root_flag:
		name = self.standardize_name(name)

	if part_number == 0: part_number = 1 # A hack: zero indicates the first part.
	if self.ust.has_key(name):
		section = self.ust[name]
		if section.parts.has_key(part_number):
			part = section.parts[part_number]
			if update_flag: part.update_flag = true
			# trace("found:" + name + " (" + `part_number` + ")...\n" + `get_line(part.code,0)`)
			return part, true

	# trace("not found:" + name + " (" + `part_number` + ")...\n")
	return None, false</t>
<t tx="T3367">@ This function issues a warning about any sections in the derived file for which no corresponding section has been seen in the outline.
@c

def ust_warn_about_orphans (self):

	for section in self.ust.values():
		# trace(`section`)
		for part in section.parts.values():
			assert(part.of == section.of)
			if not part.update_flag:
				es("Warning: " +
					choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
					part.name +
					choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
					" is not in the outline")
				break # One warning per section is enough.</t>
<t tx="T3368"></t>
<t tx="T3369">@ This function compares the interior of comments and returns true if they are identical except for whitespace or newlines. It is up to the caller to eliminate the opening and closing delimiters from the text to be compared.
@c

def compare_comments (self,s1,s2):

	tot_len = 0
	if self.comment: tot_len += len(self.comment)
	if self.comment_end: tot_len += len(self.comment_end)
	CWEB_flag = (self.language == "c" and not self.use_noweb_flag)
	
	p1, p2 = 0, 0
	while p1 &lt; len(s1) and p2 &lt; len(s2):
		p1 = skip_ws_and_nl(s1,p1)
		p2 = skip_ws_and_nl(s2,p2)
		if self.comment and self.comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		if p1 &gt;= len(s1) or p2 &gt;= len(s2):
			break
		if s1[p1] != s2[p2]:
			return false
		p1 += 1 ; p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	return p1 == len(s1) and p2 == len(s2)
</t>
<t tx="T3370">@ This code is used in forgiving_compare()and in compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
In CWEB mode we allow / * @ ? * / (without the spaces)to be equal to @?.
at-backslash is not a valid CWEB control code, so we don't have to equate
/ * @ \\ * / with at-backslash.

We must be careful not to run afoul of this very convention here!
@c

if p1 &lt; len(s1) and s1[p1] == '@':
	if match(s2,p2,self.comment + '@' + self.comment_end):
		p1 += 1
		p2 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		match(s2,p2,self.comment + '@' + s1[p1+1])):
		p1 += 2
		p2 += tot_len + 2
		continue
elif p2 &lt; len(s2) and s2[p2] == '@':
	if match(s1,p1,self.comment + '@' + self.comment_end):
		p2 += 1
		p1 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		match(s1,p1,self.comment + '@' + s2[p2+1])):
		p2 += 2
		p1 += tot_len + 2
		continue
</t>
<t tx="T3371">@ This function is called to massage an @doc part in the ust. We call this routine only after a mismatch in @doc parts is found between the ust and tst. On entry, the parameters point to the inside of a block C comment: the opening and closing delimiters are not part of the text handled by self routine.

This code removes newlines that may have been inserted by the Tangle command in a block comment. Tangle may break lines differently in different expansions, but line breaks are ignored by forgiving_compare() and doc_compare() within block C comments.

We count the leading whitespace from the first non-blank line and remove this much whitespace from all lines. We also remove singleton newlines and replace sequences of two or more newlines by a single newline.
@c

def massage_block_comment (self,s):

	c = self.commands
	newlines = 0  # Consecutive newlines seen.
	i = skip_blank_lines(s,0)
	# Copy the first line and set n
	i, n = skip_leading_ws_with_indent(s,i,c.tab_width)
	j = i ; i = skip_to_end_of_line(s,i)
	result = s[j:i]
	while i &lt; len(s):
		assert(is_nl(s,i))
		newlines += 1
		# Replace the first newline with a blank.
		result += ' ' ; i += 1
		while i &lt; len(s) and is_nl(s,i):
			i += 1 # skip the newline.
		j = i ; i = skip_ws(s,i)
		if is_nl(s,i)and newlines &gt; 1:
			# Skip blank lines.
			while is_nl(s,i):
				i += 1
		else:
			# Skip the leading whitespace.
			i = j # back track
			i = skip_leading_ws(s,i,n,c.tab_width)
			newlines = 0
			# Copy the rest of the line.
			j = i ; i = skip_to_end_of_line(s,i)
			result += s[j:i]
	return result
</t>
<t tx="T3372">@ This is the "forgiving compare" function.  It compares two texts and returns true if they are identical except for comments or non-critical whitespace.  Whitespace inside strings or preprocessor directives must match exactly.
@c

def forgiving_compare (self,name,part,s1,s2):

	if 0:
		trace(`name`+":"+`part`+
			  "\n1:"+`get_line(s1,0)`+
			  "\n2:"+ `get_line(s2,0)`)
	s1 = toUnicode(s1,self.encoding) # 4/4/03
	s2 = toUnicode(s2,self.encoding) # 4/4/03
	&lt;&lt; Define forgiving_compare vars &gt;&gt;
	p1 = skip_ws_and_nl(s1,0) 
	p2 = skip_ws_and_nl(s2,0)
	result = true
	while result and p1 &lt; len(s1) and p2 &lt; len(s2):
		first1 = p1 ; first2 = p2
		if self.comment and self.comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		ch1 = s1[p1]
		if ch1 == '\r' or ch1 == '\n':
			&lt;&lt; Compare non-critical newlines &gt;&gt;
		elif ch1 ==  ' ' or ch1 == '\t':
			&lt;&lt; Compare non-critical whitespace &gt;&gt;
		elif ch1 == '\'' or ch1 == '"':
			&lt;&lt; Compare possible strings &gt;&gt;
		elif ch1 == '#':
			&lt;&lt; Compare possible preprocessor directives &gt;&gt;
		elif ch1 == '&lt;' or ch1 == '@':
			&lt;&lt; Compare possible section references &gt;&gt;
		else:
			&lt;&lt; Compare comments or single characters &gt;&gt;
	&lt;&lt; Make sure both parts have ended &gt;&gt;
	if not result:
		&lt;&lt; trace the mismatch &gt;&gt;
	return result</t>
<t tx="T3373"># scan_derived_file has set the ivars describing comment delims.
first1 = first2 = 0

tot_len = 0
if self.comment: tot_len += len(self.comment)
if self.comment_end: tot_len += len(self.comment_end)

CWEB_flag = (self.language == "c" and not self.use_noweb_flag)</t>
<t tx="T3374">p1 = skip_ws_and_nl(s1,p1)
p2 = skip_ws_and_nl(s2,p2)
</t>
<t tx="T3375">p1 = skip_ws(s1,p1)
p2 = skip_ws(s2,p2)</t>
<t tx="T3376">if self.language == "c":
	&lt;&lt; compare preprocessor directives &gt;&gt;
else:
	&lt;&lt; compare single characters &gt;&gt;
</t>
<t tx="T3377">assert(p1 &lt; len(s1) and p2 &lt; len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")</t>
<t tx="T3378"># We cannot assume that newlines are single characters.

result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if is_nl(s1,p1):
		result = is_nl(s2,p2)
		if not result or self.is_end_of_directive(s1,p1):
			break
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
if not result:
	self.mismatch("Mismatched preprocessor directives")</t>
<t tx="T3379"># This code implicitly assumes that string1_len == string2_len == 1.
# The match test ensures that the language actually supports strings.

if (match(s1,p1,self.string1) or match(s1,p1,self.string2)) and s1[p1] == s2[p2]:

	if self.language == "pascal":
		&lt;&lt; Compare Pascal strings &gt;&gt;
	else:
		&lt;&lt; Compare C strings &gt;&gt;
	if not result:
		self.mismatch("Mismatched strings")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T3380">delim = s1[p1]
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1

while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if s1[p1] == delim and self.is_end_of_string(s1,p1,delim):
		result =(s2[p2] == delim and self.is_end_of_string(s2,p2,delim))
		p1 += 1 ; p2 += 1
		break
	elif is_nl(s1,p1) and is_nl(s2,p2):
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
</t>
<t tx="T3381">@ We assume the Pascal string is on a single line so the problems with cr/lf do not concern us.
@c

first1 = p1 ; first2 = p2
p1 = skip_pascal_string(s1,p1)
p2 = skip_pascal_string(s2,p2)
result = s1[first1,p1] == s2[first2,p2]
</t>
<t tx="T3382">if s1[p1] == '@' and CWEB_flag:  start_ref = "@&lt;"
elif s1[p1] == '&lt;' and not CWEB_flag:  start_ref = "&lt;&lt;"
else: start_ref = None

# Tangling may insert newlines.
p2 = skip_ws_and_nl(s2,p2)

junk, kind1, junk2 = self.is_section_name(s1,p1)
junk, kind2, junk2 = self.is_section_name(s2,p2)

if start_ref and (kind1 != bad_section_name or kind2 != bad_section_name):
	result = self.compare_section_names(s1[p1:],s2[p2:])
	if result:
		p1, junk1, junk2 = self.skip_section_name(s1,p1)
		p2, junk1, junk2 = self.skip_section_name(s2,p2)
	else: self.mismatch("Mismatched section names")
else:
	# Neither p1 nor p2 points at a section name.
	result = s1[p1] == s2[p2]
	p1 += 1 ; p2 += 1
	if not result:
		self.mismatch("Mismatch at '@' or '&lt;'")</t>
<t tx="T3383">if match(s1,p1,self.sentinel) and match(s2,p2,self.sentinel):
	first1 = p1 ; first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		self.mismatch("Mismatched sentinel comments")
elif match(s1,p1,self.line_comment) and match(s2,p2,self.line_comment):
	first1 = p1 ; first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		self.mismatch("Mismatched single-line comments")
elif match(s1,p1,self.comment) and match(s2,p2,self.comment):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match(s1,p1,self.comment_end) and not match(s2,p2,self.comment_end)):
		# ws doesn't have to match exactly either!
		if is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match(s1,p1,self.comment_end) and match(s2,p2,self.comment_end):
		first1 = p1 ; first2 = p2
		p1 += len(self.comment_end)
		p2 += len(self.comment_end)
		result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		self.mismatch("Mismatched block comments")
elif match(s1,p1,self.comment2) and match(s2,p2,self.comment2):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match(s1,p1,self.comment2_end) and not match(s2,p2,self.comment2_end)):
		# ws doesn't have to match exactly either!
		if  is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match(s1,p1,self.comment2_end) and match(s2,p2,self.comment2_end):
		first1 = p1 ; first2 = p2
		p1 += len(self.comment2_end)
		p2 += len(self.comment2_end)
		result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		self.mismatch("Mismatched alternalte block comments")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T3384">if result:
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	result = p1 &gt;= len(s1) and p2 &gt;= len(s2)
	if not result:
		# Show the ends of both parts.
		p1 = len(s1)
		p2 = len(s2)
		self.mismatch("One part ends before the other.")</t>
<t tx="T3385">if 0:
	trace(self.message +
		"\nPart " + `part` + ", section " + name +
		"\n1:" + get_line(s1,p1) +
		"\n2:" + get_line(s2,p2) )</t>
<t tx="T3386">def mismatch (self,message):

	self.message = message</t>
<t tx="T3387">@ This function scans an entire derived file in s, discovering section or part definitions.

This is the easiest place to delete leading whitespace from each line: we simply don't copy it.  We also ignore leading blank lines and trailing blank lines.  The resulting definition must compare equal using the "forgiving" compare to any other definitions of that section or part.

We use a stack to handle nested expansions.  The outermost level of expansion corresponds to the @root directive that created the file.  When the stack is popped, the indent variable is restored.

self.root_name is the name of the file mentioned in the @root directive.

The caller has deleted all body_ignored_newlines from the text.
@c

def scan_derived_file (self,s):

	c = self.commands
	self.def_stack = []
	&lt;&lt; set the private global matching vars &gt;&gt;
	line_indent = 0  # The indentation to use if we see a section reference.
	# indent is the leading whitespace to be deleted.
	i, indent = skip_leading_ws_with_indent(s,0,self.tab_width)
	&lt;&lt; Skip the header line output by tangle &gt;&gt;
	# The top level of the stack represents the root.
	self.push_new_def_node(self.root_name,indent,1,1,true)
	while i &lt; len(s):
		ch = s[i]
		if ch == body_ignored_newline:
			i += 1 # ignore
		elif ch == body_newline:
			&lt;&lt; handle the start of a new line &gt;&gt;
		elif match(s,i,self.sentinel) and self.is_sentinel_line(s,i):
			&lt;&lt; handle a sentinel line  &gt;&gt;
		elif match(s,i,self.line_comment) or match(s,i,self.verbatim):
			&lt;&lt; copy the entire line &gt;&gt;
		elif match(s,i,self.comment):
			&lt;&lt; copy a multi-line comment &gt;&gt;
		elif match(s,i,self.comment2):
			&lt;&lt; copy an alternate multi-line comment &gt;&gt;
		elif match(s,i,self.string1) or match(s,i,self.string2):
			&lt;&lt; copy a string &gt;&gt;
		else:
			self.copy(ch) ; i += 1
	&lt;&lt; end all open sections &gt;&gt;</t>
<t tx="T3388"># Set defaults from the public globals set by the @comment command.
if self.single_comment_string:
	self.sentinel = self.single_comment_string
	self.sentinel_end = None
elif self.end_comment_string:
	self.sentinel = self.start_comment_string
	self.sentinel_end = self.end_comment_string
else:
	self.sentinel = self.sentinel_end = None
	
if 0:
	trace("single,start,end,sentinel:"+
		`self.single_comment_string` +":"+ `self.start_comment_string` +":"+
		`self.end_comment_string` +":"+ `self.sentinel`)

# Set defaults.  See set_delims_from_langauge.
self.line_comment = self.single_comment_string
self.comment = self.start_comment_string
self.comment_end = self.end_comment_string
self.comment2 = self.comment2_end = None
self.string1 = "\""
self.string2 = "'"
self.verbatim = None

# Set special cases.
if self.language == "plain":
	self.string1 = self.string2 = None # This is debatable.
	self.line_comment = None
if self.language == "pascal":
	self.comment2 = "(*" ; self.comment2_end = "*)"
if self.language == "latex": # 3/10/03: Joo-won Jung
	self.string1 = self.string2 = None # This is debatable.
</t>
<t tx="T3389">if self.sentinel or self.comment:
	line = choose(self.sentinel,self.sentinel,self.comment) + " Created by Leo from" 
	if match(s,i,line):
		# Even a block comment will end on the first line.
		i = skip_to_end_of_line(s,i)</t>
<t tx="T3390">self.copy(ch) ; i += 1 # This works because we have one-character newlines.

# Set line_indent, used only if we see a section reference.
junk, line_indent = skip_leading_ws_with_indent(s,i,c.tab_width)
i = skip_leading_ws(s,i,indent,c.tab_width) # skip indent leading white space.</t>
<t tx="T3391">@ This is the place to eliminate the proper amount of whitespace from the start of each line. We do this by setting the 'indent' variable to the leading whitespace of the first _non-blank_ line following the opening sentinel.

Tangle increases the indentation by one tab if the section reference is not the first non-whitespace item on the line,so self code must do the same.
@c

# trace(`get_line(s,i)`)
result,junk,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
assert(result==true)
&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;

if kind == start_sentinel_line:
	indent = line_indent
	# Increase line_indent by one tab width if the
	# the section reference does not start the line.
	j = i - 1
	while j &gt;= 0:
		if is_nl(s,j):
			break
		elif not is_ws(s[j]):
			indent += abs(self.tab_width) ; break
		j -= 1
	# copy the section reference to the _present_ section,
	# but only if this is the first part of the section.
	if part &lt; 2: self.copy(name)
	# Skip to the first character of the new section definition.
	i = skip_to_end_of_line(s,i)
	# Start the new section.
	self.push_new_def_node(name,indent,part,of,nl_flag)
else:
	assert(kind == end_sentinel_line)
	# Skip the sentinel line.
	i = skip_to_end_of_line(s,i)
	# Skip a newline only if it was added after(!newline)
	if not nl_flag:
		i = skip_ws(s,i)
		i = skip_nl(s,i)
		i = skip_ws(s,i)
		# Copy any whitespace following the (!newline)
		while end and is_ws(s[end]):
			self.copy(s[end])
			end += 1
	# Restore the old indentation level.
	if len(self.def_stack) &gt; 0:
		indent = self.def_stack[-1].indent</t>
<t tx="T3392">@ We have just seen a sentinel line. Any kind of sentinel line will terminate a previous part of the present definition. For end sentinel lines, the present section name must match the name on the top of the stack.
@c

if len(self.def_stack) &gt; 0:
	dn = self.def_stack[-1]
	if self.compare_section_names(name,dn.name):
		dn = self.def_stack.pop()
		if len(dn.code) &gt; 0:
			thePart, found = self.ust_lookup(name,dn.part,false,false) # not root, not update
			# Check for incompatible previous definition.
			if found and not self.forgiving_compare(name,dn.part,dn.code,thePart.code):
				self.error("Incompatible definitions of " + name)
			elif not found:
				self.ust_enter(name,dn.part,dn.of,dn.code,dn.nl_flag,false) # not root
	elif kind == end_sentinel_line:
		self.error("Missing sentinel line for: " + name)</t>
<t tx="T3393">j = i ; i = skip_to_end_of_line(s,i)
self.copy(s[j:i])
</t>
<t tx="T3394">j = i
if self.language == "pascal":
	i = skip_pascal_string(s,i)
else:
	i = skip_string(s,i)
self.copy(s[j:i])</t>
<t tx="T3395">assert(self.comment_end)

# Scan for the ending delimiter.
j = i ; i += len(self.comment)
while i &lt; len(s) and not match(s,i,self.comment_end):
	i += 1
if match(s,i,self.comment_end):
	i += len(self.comment_end)
self.copy(s[j:i])</t>
<t tx="T3396">assert(self.comment2_end)
j = i
# Scan for the ending delimiter.
i += len(self.comment2)
while i &lt; len(s) and not match(s,i,self.comment2_end):
	i += 1
if match(s,i,self.comment2_end):
	i += len(self.comment2)
self.copy(s[j:i])</t>
<t tx="T3397">dn= None
while len(self.def_stack) &gt; 0:
	dn = self.def_stack.pop()
	if len(self.def_stack) &gt; 0:
		self.error("Unterminated section: " + dn.name)
if dn:
	# Terminate the root setcion.
	i = len(s)
	if dn.code and len(dn.code) &gt; 0:
		self.ust_enter(dn.name,dn.part,dn.of,dn.code,dn.nl_flag,true) # is_root_flag
	else:
		self.error("Missing root part")
else:
	self.error("Missing root section")</t>
<t tx="T3398">@ This function handles the actual updating of section definitions in the web.  Only code parts are updated, never doc parts.

During pass 2 of Untangle, skip_body() calls this routine when it discovers the definition of a section in the outline.  We look up the name in the ust. If an entry exists, we compare the code (the code part of an outline node) with the code part in the ust. We update the code part if necessary.

We use the forgiving_compare() to compare code parts. It's not possible to change only trivial whitespace using Untangle because forgiving_compare() ignores trivial whitespace.
@c

# Major change: 2/23/01: Untangle never updates doc parts.

def update_def (self,name,part_number,head,code,tail,is_root_flag): # Doc parts are never updated!

	# trace(`name` + ":" + `part_number` + ":" + `code`)
	v = self.v ; body = v.bodyString()
	if not head: head = ""
	if not tail: tail = ""
	if not code: code = ""
	false_ret = head + code + tail, len(head) + len(code), false
	part, found = self.ust_lookup(name,part_number,is_root_flag,true) # Set update
	if not found:
		return false_ret  # Not an error.
	ucode = toUnicode(part.code,self.encoding) # 4/4/03
	&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;
	# trace(`ucode`)
	if not ucode or len(ucode) == 0:
		return false_ret # Not an error.
	if code and self.forgiving_compare(name,part,code,ucode):
		return false_ret # Not an error.
	# Update the body.
	es("***Updating: " + v.headString())
	i = skip_blank_lines(ucode,0)
	ucode = ucode[i:]
	ucode = string.rstrip(ucode)
	# Add the trailing whitespace of code to ucode.
	code2 = string.rstrip(code)
	trail_ws = code[len(code2):]
	ucode = ucode + trail_ws
	body = head + ucode + tail
	self.update_current_vnode(body)
	if 0:
		trace("head:" + `head`)
		trace("ucode:" + `ucode`)
		trace("tail:" + `tail`)
	return body, len(head) + len(ucode),true
</t>
<t tx="T3399">@ We assume that any leading comments came from an @doc part.  This isn't always valid and this code will eliminate such leading comments.  This is a defect in Untangle; it can hardly be avoided.
@c

i = skip_blank_lines(ucode,0)
j = skip_ws(ucode,i)
# trace("comment,end,single:"+`self.comment`+":"+`self.comment_end`+":"+`self.line_comment`)

if self.comment and self.comment_end:
	if ucode and match(ucode,j,self.comment):
		# Skip to the end of the block comment.
		i = j + len(self.comment)
		i = string.find(ucode,self.comment_end,i)
		if i == -1: ucode = None # An unreported problem in the user code.
		else:
			i += len(self.comment_end)
			i = skip_blank_lines(ucode,i)
elif self.line_comment:
	while ucode and match(ucode,j,self.line_comment):
		i = skip_line(ucode,i)
		i = skip_blank_lines(ucode,i)
		j = skip_ws(ucode,i)
# Only the value of ucode matters here.
if ucode: ucode = ucode[i:]</t>
<t tx="T3400">@ This function is called from within the Untangle logic to update the body text of self.v.
@c

def update_current_vnode (self,s):

	c = self.commands ; v = self.v
	assert(self.v)
	v.setBodyStringOrPane(s)

	c.beginUpdate()
	c.setChanged(true)
	v.setDirty()
	v.setMarked()
	c.endUpdate()</t>
<t tx="T3401">@ These utilities deal with tangle ivars, so they should be methods.
</t>
<t tx="T3402"># Compares section names or root names.
# Arbitrary text may follow the section name on the same line.

def compare_section_names (self,s1,s2):

	# trace(`get_line(s1,0)` + ":" + `get_line(s2,0)`)
	if match(s1,0,"&lt;&lt;") or match(s1,0,"@&lt;"):
		# Use a forgiving compare of the two section names.
		delim = choose(self.use_cweb_flag,"@&gt;","&gt;&gt;")
		i1 = i2 = 0
		while i1 &lt; len(s1) and i2 &lt; len(s2):
			ch1 = s1[i1] ; ch2 = s2[i2]
			if is_ws(ch1) and is_ws(ch2):
				i1 = skip_ws(s1,i1)
				i2 = skip_ws(s2,i2)
			elif match(s1,i1,delim) and match(s2,i2,delim):
				return true
			elif string.lower(ch1) == string.lower(ch2):
				i1 += 1 ; i2 += 1
			else: return false
		return false
	else: # A root name.
		return s1 == s2</t>
<t tx="T3403">def copy (self, s):

	assert(len(self.def_stack) &gt; 0)
	dn = self.def_stack[-1] # Add the code at the top of the stack.
	dn.code += s</t>
<t tx="T3404">def error (self,s):
	self.errors += 1
	es_error(s)
	
def pathError (self,s):
	if not self.path_warning_given:
		self.path_warning_given = true
		self.error(s)
	
def warning (self,s):
	es_error(s)
</t>
<t tx="T3405"># This function returns true if we are at the end of preprocessor directive.

def is_end_of_directive (self,s,i):

	return is_nl(s,i) and not self.is_escaped(s,i)</t>
<t tx="T3406">def is_end_of_string (self,s,i,delim):

	return i &lt; len(s) and s[i] == delim and not self.is_escaped(s,i)</t>
<t tx="T3407"># This function returns true if the s[i] is preceded by an odd number of back slashes.

def is_escaped (self,s,i):

	back_slashes = 0 ; i -= 1
	while i &gt;= 0 and s[i] == '\\':
		back_slashes += 1
		i -= 1
	return (back_slashes &amp; 1) == 1
</t>
<t tx="T3408">def is_section_name(self,s,i):

	kind = bad_section_name ; end = -1

	if self.use_cweb_flag :
		if match(s,i,"@&lt;"):
			i, kind, end = self.skip_cweb_section_name(s,i)
	elif match(s,i,"&lt;&lt;"):
		i, kind, end = self.skip_noweb_section_name(s,i)

	# trace(`kind` + ":" + `get_line(s,end)`)
	return i, kind, end</t>
<t tx="T3409">@ This function returns true if i points to a line a sentinel line of one of the following forms:

start_sentinel &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel &lt;&lt;section name&gt;&gt; (n of m) end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; (n of m) end_sentinel

start_sentinel: the string that signals the start of sentinel lines\
end_sentinel:   the string that signals the endof sentinel lines.

end_sentinel may be None,indicating that sentinel lines end with a newline.

Any of these forms may end with (!newline), indicating that the section reference was not followed by a newline in the orignal text.  We set nl_flag to false if such a string is seen. The name argument contains the section name.

The valid values of kind param are:

non_sentinel_line,   # not a sentinel line.
start_sentinel_line, #   /// &lt;section name&gt; or /// &lt;section name&gt;(n of m)
end_sentinel_line  //  /// -- end -- &lt;section name&gt; or /// -- end -- &lt;section name&gt;(n of m).
@c
def is_sentinel_line (self,s,i):

	result,i,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
	return result

def is_sentinel_line_with_data (self,s,i):

	start_sentinel = self.sentinel
	end_sentinel = self.sentinel_end
	&lt;&lt; Initialize the return values &gt;&gt;
	&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;
	&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;
	&lt;&lt; Make sure we have a section reference &gt;&gt;
	&lt;&lt; Set part and of if they exist &gt;&gt;
	&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;
	&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;
	kind = choose(end_flag,end_sentinel_line,start_sentinel_line)
	return true,i,kind,name,part,of,end,nl_flag</t>
<t tx="T3410">name = end = None
part = of = 1
kind = non_sentinel_line
nl_flag = true
false_data = (false,i,kind,name,part,of,end,nl_flag)
</t>
<t tx="T3411">if is_nl(s,i): i = skip_nl(s,i)
i = skip_ws(s,i)

# 4/18/00: We now require an exact match of the sentinel.
if match(s,i,start_sentinel):
	i += len(start_sentinel)
else:
	return false_data</t>
<t tx="T3412"># If i points to "-- end --", this code skips it and sets end_flag.

end_flag = false
i = skip_ws(s,i)
if match(s,i,"--"):
	while i &lt; len(s) and s[i] == '-':
		i += 1
	i = skip_ws(s,i)
	if not match(s,i,"end"):
		return false_data # Not a valid sentinel line.
	i += 3 ; i = skip_ws(s,i)
	if not match(s,i,"--"):
		return false_data # Not a valid sentinel line.
	while i &lt; len(s) and s[i] == '-':
		i += 1
	end_flag = true</t>
<t tx="T3413">i = skip_ws(s,i)

if (self.use_noweb_flag and match(s,i,"&lt;&lt;") or
	self.use_cweb_flag  and match(s,i,"@&lt;") ):

	j = i ; i, kind, end = self.skip_section_name(s,i)
	if kind != section_ref:
		return false_data
	name = s[j:i]
else:
	return false_data</t>
<t tx="T3414"># This code handles (m of n), if it exists.
i = skip_ws(s,i)
if match(s,i,'('):
	j = i
	i += 1 ; i = skip_ws(s,i)
	i, part = self.scan_short_val(s,i)
	if part == -1:
		i = j # back out of the scanning for the number.
		part = 1
	else:
		i = skip_ws(s,i)
		if not match(s,i,"of"):
			return false_data
		i += 2 ; i = skip_ws(s,i)
		i, of = self.scan_short_val(s,i)
		if of == -1:
			return false_data
		i = skip_ws(s,i)
		if match(s,i,')'):
			i += 1 # Skip the paren and do _not_ return.
		else:
			return false_data</t>
<t tx="T3415">line = "(!newline)"
i = skip_ws(s,i)
if match(s,i,line):
	i += len(line)
	nl_flag = false
</t>
<t tx="T3416">i = skip_ws(s,i)
if end_sentinel:
	# Make sure the line ends with the end sentinel.
	if match(s,i,end_sentinel):
		i += len(end_sentinel)
	else:
		return false_data

end = i # Show the start of the whitespace.
i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	return false_data</t>
<t tx="T3417"># This function pushes a new def_node on the top of the section stack.

def push_new_def_node (self,name,indent,part,of,nl_flag):
		
	# trace(`name` + ":" + `part`)
	node = def_node(name,indent,part,of,nl_flag,None)
	self.def_stack.append(node)</t>
<t tx="T3418"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):

	if i &gt;= len(s) or s[i] not in string.digits:
		return i, -1

	j = i
	while i &lt; len(s) and s[i] in string.digits:
		i += 1

	val = int(s[j:i])
	# trace(s[j:i] + ":" + `val`)
	return i, val</t>
<t tx="T3419">def setRootFromHeadline (self,v):

	# trace(`v`)
	s = v.headString()

	if s[0:5] == "@root":
		i,self.start_mode = scanAtRootOptions(s,0)
		i = skip_ws(s,i)

		if i &lt; len(s): # Non-empty file name.
			# self.root_name must be set later by token_type().
			self.root = s[i:]</t>
<t tx="T3420">@ This function skips past a section name that starts with @&lt; and ends with @&gt;. This code also skips any = following the section name.

Returns (i, kind, end), where kind is:

	bad_section_name:  @ &lt; with no matching @ &gt;
	section_ref: @ &lt; name @ &gt;
	section_def: @ &lt; name @ &gt; =

Unlike noweb, bad section names generate errors.
@c

def skip_cweb_section_name(self,s,i):
	
	j = i # Used for error message.
	kind = bad_section_name ; end = -1
	runon = false ; empty_name = true
	assert(s[i:i+2]=="@&lt;")
	i += 2
	while i &lt; len(s):
		if match(s,i,"@&gt;="):
			i += 3 ; end = i-1 ; kind = section_def ; break
		elif match(s,i,"@&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif match(s,i,"@&lt;"):
			runon = true ; break
		elif match(s,i,"@@"): i += 2
		elif is_ws_or_nl(s,i): i += 1
		else:
			i += 1 ; empty_name = false

	if empty_name:
		scanError("empty CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	elif i &gt;= len(s) or runon:
		scanError("Run on CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	else:
		return i, kind, end</t>
<t tx="T3421">@ This function skips past a section name that starts with &lt; &lt; and might end with &gt; &gt; or &gt; &gt; =. The entire section name must appear on the same line.

Note: this code no longer supports extended noweb mode.

Returns (i, kind, end),
	end indicates the end of the section name itself (not counting the =).
	kind is one of:
		bad_section_name: "no matching "&gt;&gt;" or "&gt;&gt;"  This is _not_ a user error!
		section_ref: &lt; &lt; name &gt; &gt;
		section_def: &lt; &lt; name &gt; &gt; =
		at_root:     &lt; &lt; * &gt; &gt; =
@c
def skip_noweb_section_name(self,s,i):
	
	assert(match(s,i,"&lt;&lt;"))
	i += 2
	j = i # Return this value if no section name found.
	kind = bad_section_name ; end = -1 ; empty_name = true

	# Scan for the end of the section name.
	while i &lt; len(s) and not is_nl(s,i):
		if match(s,i,"&gt;&gt;="):
			i += 3 ; end = i - 1 ; kind = section_def ; break
		elif match(s,i,"&gt;&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif is_ws_or_nl(s,i):
			i += 1
		elif empty_name and s[i] == '*':
			empty_name = false
			i = skip_ws(s,i+1) # skip the '*'
			if match(s,i,"&gt;&gt;="):
				i += 3 ; end = i - 1 ; kind = at_root ; break
		else:
			i += 1 ; empty_name = false

	if empty_name:
		kind = bad_section_name
	if kind == bad_section_name:
		i = j
	return i, kind, end</t>
<t tx="T3422"># Returns a tuple (i, kind, end)

def skip_section_name(self,s,i):

	if self.use_noweb_flag:
		return self.skip_noweb_section_name(s,i)
	else:
		return self.skip_cweb_section_name(s,i)</t>
<t tx="T3423">@ This code removes leading and trailing brackets, converts white space to a single blank and converts to lower case.
@c

def standardize_name (self,name):

	# Convert to lowercase.
	name = string.lower(name)
	# Convert whitespace to a single space.
	name = string.replace(name,'\t',' ')
	name = string.replace(name,'  ',' ')
	# Remove leading '&lt;'
	i = 0 ; n = len(name)
	while i &lt; n and name[i] == '&lt;':
		i += 1
	j = i
	# Find the first '&gt;'
	while i &lt; n and name [i] != '&gt;':
		i += 1
	name = string.strip(name[j:i])
	# trace(`name`)
	return name</t>
<t tx="T3424">@ This method returns a code indicating the apparent kind of token at the position i. The caller must determine whether section definiton tokens are valid.

returns (kind, end) and sets global root_name using setRootFromText().
@c

def token_type(self,s,i,err_flag):

	kind = plain_line ; end = -1
	if self.use_noweb_flag:
		&lt;&lt; set token_type in noweb mode &gt;&gt;
	else:
		&lt;&lt; set token_type for CWEB mode &gt;&gt;
	if kind == at_other :
		&lt;&lt; set kind for directive &gt;&gt;
	# trace(`kind` + ":" + `get_line(s,i)`)
	return kind, end</t>
<t tx="T3425">if match(s,i,"&lt;&lt;"):
	i, kind, end = self.skip_section_name(s,i)
	if kind == bad_section_name:
		kind = plain_line # not an error.
	elif kind == at_root:
		if self.head_root:
			self.setRootFromText(self.head_root,err_flag)
		else:
			kind = bad_section_name # The warning has been given.
elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
	# 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.
	kind = choose(self.raw_cweb_flag,plain_line,at_doc)
elif match(s,i,"@@"): kind = at_at
elif i &lt; len(s) and s[i] == '@': kind = at_other
else: kind = plain_line</t>
<t tx="T3426">i = skip_ws(s,i)
if match(s,i,"@*") or match(s,i,"@ "): kind = at_doc
elif match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif match(s,i,"@@"): kind = at_at
elif match_word(s,i,"@c") or match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
	if   i + 1 &gt;= len(s): kind = at_doc
	elif i + 1 &lt; len(s) and s[i+1] not in string.ascii_letters:
		kind = at_web
	else: kind = at_other # Set kind later
else: kind = plain_line</t>
<t tx="T3427"># This code will return at_other for any directive other than those listed.

if match_word(s,i,"@c"):
	# 10/30/02: Only @code starts a code section in raw cweb mode.
	kind = choose(self.raw_cweb_flag,plain_line,at_code)
else:
	for name, type in [
		("@chapter", at_chapter),
		("@code", at_code),
		("@doc", at_doc),
		("@root", at_root),
		("@section", at_section) ]:
		if match_word(s,i,name):
			kind = type ; break
		
if self.raw_cweb_flag and kind == at_other:
	# 10/30/02: Everything else is plain text in raw cweb mode.
	kind = plain_line

if kind == at_root:
	i = self.setRootFromText(s[i:],err_flag)</t>
<t tx="T3428">@language python

&lt;&lt; about the tree classes &gt;&gt;

from leoGlobals import *
import leoColor
import os,string,Tkinter,tkFont,types

&lt;&lt; about drawing and events &gt;&gt;
&lt;&lt; drawing constants &gt;&gt;

class baseLeoTree:
	"""The base class of the Leo's tree class."""
	callbacksInjected = false
	@others
	
class leoTree (baseLeoTree):
	"""A class that draws and handles events in an outline."""
	pass</t>
<t tx="T3429">@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.
</t>
<t tx="T3430">box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = true # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height</t>
<t tx="T3431"></t>
<t tx="T3432">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="T3433">def beginUpdate (self):

	self.updateCount += 1</t>
<t tx="T3434">def endUpdate (self,flag=true):

	assert(self.updateCount &gt; 0)
	self.updateCount -= 1
	if flag and self.updateCount == 0:
		self.redraw()</t>
<t tx="T3435">@ Returns the proper width of the entry widget for the headline. This has been a problem.
@c

def headWidth(self,v):

	return max(10,5 + len(v.headString()))</t>
<t tx="T3436"># Returns the last visible node of the screen.

def lastVisible (self):

	v = self.rootVnode
	while v:
		last = v
		if v.firstChild():
			if v.isExpanded():
				v = v.firstChild()
			else:
				v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	return last</t>
<t tx="T3437">def setLineHeight (self,font):
	
	try:
		metrics = font.metrics()
		linespace = metrics ["linespace"]
		self.line_height = linespace + 5 # Same as before for the default font on Windows.
		# print metrics
	except:
		self.line_height = line_height # was 17 + 2
		es("exception setting outline line height")
		es_exception()</t>
<t tx="T3438">def forceFullRecolor (self):
	
	self.forceFullRecolorFlag = true</t>
<t tx="T3439">def getFont (self):

	return self.font
		
# Called by leoFontPanel.
def setFont (self, font=None, fontName=None):
	
	if fontName:
		self.fontName = fontName
		self.font = tkFont.Font(font=fontName)
	else:
		self.fontName = None
		self.font = font
		
	self.setLineHeight(self.font)
	
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

	font = app.config.getFontFromParams(
		"headline_text_font_family", "headline_text_font_size",
		"headline_text_font_slant",  "headline_text_font_weight")

	self.setFont(font)</t>
<t tx="T3440">def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		fullname = os.path.join(app.loadDir,"..","Icons",name)
		fullname = os.path.normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		es("Exception loading: " + fullname)
		es_exception()
		return None</t>
<t tx="T3441">def numberOfVisibleNodes(self):
	
	n = 0 ; v = self.rootVnode
	while v:
		n += 1
		v = v.visNext()
	return n</t>
<t tx="T3442">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:", `v1`
	root = self.rootVnode
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:", h, `v1`
	return h

# Returns the visible height of the tree and all sibling trees, stopping at v1

def yoffsetTree(self,v,v1):

	h = 0
	while v:
		# print "yoffsetTree:", `v`
		if v == v1:
			return h, true
		h += self.line_height
		child = v.firstChild()
		if v.isExpanded() and child:
			h2, flag = self.yoffsetTree(child,v1)
			h += h2
			if flag: return h, true
		v = v.next()
	return h, false</t>
<t tx="T3443"></t>
<t tx="T3444">def updateNode (self,v,x,y):
	
	"""Draw a node that may have become visible as a result of a scrolling operation"""

	if self.inExpandedVisibleArea(y):
		# This check is a major optimization.
		if not v.edit_text():
			return self.force_draw_node(v,x,y)
		else:
			return self.line_height

	return self.line_height</t>
<t tx="T3445">@language python

# Undo manager for leo.py.

&lt;&lt; How Leo implements unlimited undo &gt;&gt;
&lt;&lt; Define optional ivars &gt;&gt;

from leoGlobals import *

import types

class baseUndoer:
	"""The base class of the undoer class."""
	@others
	
class undoer (baseUndoer):
	"""A class that implements unlimited undo and redo."""
	pass</t>
<t tx="T3446">optionalIvars = (
	"lastChild",
	"parent","oldParent",
	"back","oldBack",
	"n","oldN","oldV",
	"oldText","newText",
	"oldSel","newSel",
	"sort","select",
	"oldTree","newTree", # Added newTree 10/14/03
	"yview",
	# For incremental undo typing...
	"leading","trailing",
	"oldMiddleLines","newMiddleLines",
	"oldNewlines","newNewlines")</t>
<t tx="T3447"></t>
<t tx="T3448">@ This method clears then entire Undo state.  All non-undoable commands should call this method.
@c

def clearUndoState (self):
	
	u = self
	
	if 0: # Bug fix: 12/16/02: setUndo/Redo type needs the old values.
		u.redoMenuLabel = "Can't Redo" 
		u.undoMenuLabel = "Can't Undo"
	
	if 0: # Wrong: set realLabel only when calling setMenuLabel.
		realLabel = app.getRealMenuName("Can't Redo")
		u.realRedoMenuLabel = realLabel.replace("&amp;","")
		realLabel = app.getRealMenuName("Can't Undo")
		u.realUndoMenuLabel = realLabel.replace("&amp;","")
		
	u.setRedoType("Can't Redo")
	u.setUndoType("Can't Undo")
	u.beads = [] # List of undo nodes.
	u.bead = -1 # Index of the present bead: -1:len(beads)
	u.clearIvars()</t>
<t tx="T3449"># Translation does not affect these routines.

def canRedo (self):

	u = self
	return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

	u = self
	return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="T3450">def enableMenuItems (self):

	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")

	enableMenu(menu,u.redoMenuLabel,u.canRedo())
	enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="T3451">def redoMenuName (self,name):

	if name=="Can't Redo":
		return name
	else:
		return "Redo " + name

def undoMenuName (self,name):

	if name=="Can't Undo":
		return name
	else:
		return "Undo " + name</t>
<t tx="T3452"># These routines update both the ivar and the menu label.
def setRedoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.redoMenuName(type)
	if name != u.redoMenuLabel:
		# Update menu using old name.
		realLabel = app.getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
		u.redoMenuLabel = name
		u.realRedoMenuLabel = realLabel

def setUndoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.undoMenuName(type)
	if name != u.undoMenuLabel:
		# Update menu using old name.
		realLabel = app.getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
		u.undoType = type
		u.undoMenuLabel = name
		u.realUndoMenuLabel = realLabel</t>
<t tx="T3453">@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,v,**keywords):
	
	# trace(undo_type)

	u = self
	if u.redoing or u.undoing: return None
	if undo_type == None:
		return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	# trace(undo_type,v)
	# Set the type: set the menu labels later.
	u.undoType = undo_type
	# Calculate the standard derived information.
	u.v = v
	u.parent = v.parent()
	u.back = v.back()
	u.n = v.childIndex()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead,keywords)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `keywords`)
	# Recalculate the menu labels.
	u.setUndoTypes()
	return d</t>
<t tx="T3454">def setUndoTypes (self):
	
	u = self
	# trace(`u.bead` + ":" + `len(u.beads)`)

	# Set the undo type and undo menu label.
	d = u.peekBead(u.bead)
	if d:
		u.setUndoType(d["undoType"])
	else:
		u.setUndoType("Can't Undo")

	# Set only the redo menu label.
	d = u.peekBead(u.bead+1)
	if d:
		u.setRedoType(d["undoType"])
	else:
		u.setRedoType("Can't Redo")



</t>
<t tx="T3455">def redo (self):
	
	# clear_stats() ; stat()
	u = self ; c = u.commands
	if not u.canRedo(): return
	if not u.getBead(u.bead+1): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead+1` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead+1)`)
	u.redoing = true
	redrawFlag = true
	c.beginUpdate()
	redoType = u.undoType # Use the type of the next bead.
	if 1: # range...
		&lt;&lt; redo clone cases &gt;&gt;
		&lt;&lt; redo insert cases &gt;&gt;
		&lt;&lt; redo delete cases &gt;&gt;
		&lt;&lt; redo move &amp; drag cases &gt;&gt;
		&lt;&lt; redo promote and demote cases &gt;&gt;
		&lt;&lt; redo replace cases &gt;&gt;
		&lt;&lt; redo sort cases &gt;&gt;
		&lt;&lt; redo typing cases &gt;&gt;
		else: trace("Unknown case: " + `redoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/08/02
	u.redoing = false
	u.bead += 1
	u.setUndoTypes()
	# print_stats()</t>
<t tx="T3456">if redoType in ("Clone","Drag &amp; Clone"):

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T3457">elif redoType == "Delete Outline" or redoType == "Cut Node":

	c.selectVnode(u.v)
	c.deleteHeadline()</t>
<t tx="T3458">elif redoType in ["Import","Insert Outline","Paste Node"]:

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T3459">elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	if u.parent:
		u.v.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.v.moveAfter(u.back)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.frame.rootVnode()) # 5/27/02
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
	
elif redoType == "Drag":

	u.v.moveToNthChildOf(u.parent,u.n)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)</t>
<t tx="T3460">elif redoType == "Demote":

	c.selectVnode(u.v)
	c.demote()
	
elif redoType == "Promote":

	c.selectVnode(u.v)
	c.promote()</t>
<t tx="T3461">elif redoType == "Sort Children":

	c.selectVnode(u.v)
	c.sortChildren()

elif redoType == "Sort Siblings":

	c.selectVnode(u.v)
	c.sortSiblings()
	
elif redoType == "Sort Top Level":
	
	c.selectVnode(u.v)
	c.sortTopLevel()
	u.v = None # don't mark u.v dirty
</t>
<t tx="T3462">@ This function and its allies undo the operation described by the undo parmaters.
@c

def undo (self):
	
	# clear_stats() ; # stat()
	u = self ; c = u.commands
	if not u.canUndo(): return
	if not u.getBead(u.bead): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead)`)
	c.endEditing()# Make sure we capture the headline for a redo.
	u.undoing = true
	c.beginUpdate()
	undoType = u.undoType
	redrawFlag = true
	if 1: # range...
		&lt;&lt; undo clone cases &gt;&gt;
		&lt;&lt; undo delete cases &gt;&gt;
		&lt;&lt; undo insert cases &gt;&gt;
		&lt;&lt; undo move &amp; drag cases &gt;&gt;
		&lt;&lt; undo promote and demote cases &gt;&gt;
		&lt;&lt; undo replace cases &gt;&gt;
		&lt;&lt; undo sort cases &gt;&gt;
		&lt;&lt; undo typing cases &gt;&gt;
		else: trace("Unknown case: " + `u.undoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/9/02
	u.undoing = false
	u.bead -= 1
	u.setUndoTypes()
	# print_stats()</t>
<t tx="T3463"># We can immediately delete the clone because clone() can recreate it using only v.

if undoType == "Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.back)
	
elif undoType == "Drag &amp; Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.oldV)</t>
<t tx="T3464">@ Deleting a clone is _not_ the same as undoing a clone: the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Outline" or undoType == "Cut Node":
	
	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()
	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T3465">elif undoType in ["Import","Insert Outline","Paste Node"]:
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	if u.select:
		# trace("Insert/Paste:" + `u.select`)
		c.selectVnode(u.select)</t>
<t tx="T3466">elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	if u.oldParent:
		u.v.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.v.moveAfter(u.oldBack)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.frame.rootVnode())
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
</t>
<t tx="T3467">@ Promote and demote operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Demote":

	u.undoDemote()

elif undoType == "Promote":
	
	u.undoPromote()</t>
<t tx="T3468">@ Sort operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Sort Children":
	
	u.undoSortChildren()

elif undoType == "Sort Siblings":
	
	u.undoSortSiblings()
	
elif undoType == "Sort Top Level":
	
	u.undoSortTopLevel()
	u.v = None # don't mark u.v dirty</t>
<t tx="T3469"></t>
<t tx="T3470">def findSharedVnode (self,target):

	u = self ; c = u.commands ; v = c.rootVnode()
	while v:
		if v != target and v.t == target.t:
			return v
		v = v.threadNext()
	return None</t>
<t tx="T3471"># undoes the previous demote operation.
def undoDemote (self):

	u = self ; c = u.commands
	ins = v = u.v
	last = u.lastChild
	child = v.firstChild()
	assert(child)
	c.beginUpdate()
	# 3/19/03: do not undemote children up to last.
	if last:
		while child and child != last:
			child = child.next()
		if child:
			child = child.next()
	while child:
		next = child.next()
		child.moveAfter(ins)
		ins = child
		child = next
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T3472"># Undoes the previous promote operation.
def undoPromote (self):

	u = self ; c = u.commands
	v = v1 = u.v
	assert(v1)
	last = u.lastChild
	next = v.next()
	assert(next)
	c.beginUpdate()
	while next:
		v = next
		next = v.next()
		n = v1.numberOfChildren()
		v.moveToNthChildOf(v1,n)
		if v == last: break
	c.selectVnode(v1)
	c.endUpdate()</t>
<t tx="T3473">def undoSortChildren (self):

	u = self ; c = u.commands ; v = u.v
	assert(v)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for child in u.sort:
			child.moveToNthChildOf(v,index)
			index += 1
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T3474">def undoSortSiblings (self):
	
	u = self ; c = u.commands ; v = u.v
	parent = v.parent()
	assert(v and parent)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for sib in u.sort:
			sib.moveToNthChildOf(parent,index)
			index += 1
		parent.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T3475">def undoSortTopLevel (self):
	
	u = self ; c = u.commands
	root = c.rootVnode()
	
	c.beginUpdate()
	c.endEditing()
	v = u.sort[0]
	v.moveToRoot(oldRoot=root)
	for next in u.sort[1:]:
		next.moveAfter(v)
		v = next
	c.setChanged(true)
	c.endUpdate()
</t>
<t tx="T3476"></t>
<t tx="T3477"># N.B. Yoj must restart Leo if any part of Leo's code changes.
# For this reason, running this script in leoTest.leo may be more convenient.

import unittest
import leoTest
reload(leoTest)

colorSuite = unittest.makeSuite(leoTest.colorTests)

if 1: # Run a single test.
	suite = colorSuite
else: # Run several tests.
	suite = unittest.TestSuite()
	suite.addTest(leoTest.colorTests("testC"))
	# suite.addTest(leoTest.colorSuite)

runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="T3478">"""Unit tests for Leo"""

from leoGlobals import *
import unittest

@ Run the unit tests from the "Leo Unit Tests" node in test/test.leo, like this:

- update the tests here
- save this file (LeoPy.leo)
- rerun the tests immediately in test.leo using the Execute Script command.

The reload(leoTest) statement
@c

@others</t>
<t tx="T3479"></t>
<t tx="T3480">@ Changes made to get unit tests to work:

- vnodes now allow commands to be None.
- colorizer now allows commands to be None.

@c

import leoColor,leoCommands,leoFrame,leoNodes
import Tkinter
Tk = Tkinter

@others</t>
<t tx="T3481">class colorTests(unittest.TestCase):
	
	@others</t>
<t tx="T3482">def color (self,language,text):
	
	self.text = text
	self.body.insert("1.0",text)
	self.colorizer.language = language
	val = self.colorizer.colorizeAnyLanguage(self.v,self.body)
	assert(val=="ok")
</t>
<t tx="T3483">def setUp(self):

	# 7/15/03: Hacked the vnode and colorizer classes to work if c == None.	
	c = None
	self.t = t = leoNodes.tnode()
	self.v = leoNodes.vnode(c,t)
	self.body = Tk.Text()
	self.colorizer = leoColor.colorizer(c)
	self.colorizer.incremental = false
</t>
<t tx="T3484">def tearDown (self):
	
	self.body.destroy()
	self.body = None
	self.colorizer = None
	self.t = self.v = None</t>
<t tx="T3485">def testC (self):
	
	"""Test coloring for C."""
	
	self.color("c","""abc""")</t>
<t tx="T3486">def testHTML1(self):
	
	"""Test coloring for HTML."""
	
	s = """@language html
@color
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;"""
	
	self.color("html",s)</t>
<t tx="T3487">def testHTML2 (self):
	
	s = """@language html
@color
&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""

	self.color("html",s)</t>
<t tx="T3488">def testPHP (self):
	
	s = """@language php
@ doc
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;"""

	self.color("php",s)</t>
<t tx="T3489">def testPython1(self):
	
	"""Test python coloring 1."""
	
	s = '''"""python
string"""d

'this\
is'''

	self.color("python",s)</t>
<t tx="T3490">def testPython2(self):
	
	s = """# This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
        # Copy the headline and icon values v.copyNode(root,v)
        # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result

	self.color("python",s)</t>
<t tx="T3491">def testRebol (self):
	
	s = """@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?"""

	self.color("rebol",s)</t>
<t tx="T3492"></t>
<t tx="T3493">import leoNodes</t>
<t tx="T3494">class cloneTests(unittest.TestCase):
	
	"""tests of cloning and inserts and deletes involving clones"""
	
	@others</t>
<t tx="T3495">def testCone(self):
	pass
</t>
<t tx="T3496">def testMoveIntoClone(self):
	pass
</t>
<t tx="T3497">def testMoveOutOfClone(self):
	pass
</t>
<t tx="T3498">def testInsertInsideClone(self):
	pass
</t>
<t tx="T3499">def testDeleteInsideClone(self):
	pass
</t>
<t tx="T3500">def testInsertInsideClone(self):
	pass
	
</t>
<t tx="T3501">def testDeleteInsideClone(self):
	pass
</t>
<t tx="T3502">class leoNodeError(Exception):
	pass
	

</t>
<t tx="T3503">class moveTests(unittest.TestCase):
	
	"""test that moves work properly, especially when clones are involved"""
	
	pass # no tests yet.
</t>
<t tx="T3504">class nodeSanityTests(unittest.TestCase):

	"""Tests that links, joinLists and related getters are consistent"""
	
	@others</t>
<t tx="T3505">def testNextBackLinks(self):
	
	"""Sanity checks for v.mNext and v.mBack"""
	pass
</t>
<t tx="T3506">def testParentChildLinks(self):
	
	"""Sanity checks for v.mParent and v.mFirstChild"""
	pass
</t>
<t tx="T3507">def testJoinLists(self):
	
	"""Sanity checks for join lists"""
	pass</t>
<t tx="T3508">def testThreadNextBack(self):
	
	"""Sanity checks for v.threadNext() and v.threadBack()"""
	pass
</t>
<t tx="T3509">def testNextBack(self):
	
	"""Sanity checks for v.vext() and v.vack()"""
	pass
</t>
<t tx="T3510">def testVisNextBack(self):
	
	"""Sanity checks for v.visNext() and v.visBack()"""
	pass
</t>
<t tx="T3511">def testFirstChildParent(self):
	
	"""Sanity checks for v.firstChild() and v.parent()"""
	pass
</t>
<t tx="T3512">class statusBitsChecks(unittest.TestCase):
	
	"""Tests that status bits are handled properly"""
	
	@others</t>
<t tx="T3513">def testDirtyBits(self):
	
	"""Test that dirty bits are set, especially in anscestor nodes and cloned nodes"""
	pass
</t>
<t tx="T3514">class undoTests(unittest.TestCase):
	
	"""test that undo works properly, especially when clones are involved"""
	
	@others</t>
<t tx="T3515">def testUndoMoveLeft(self):
	pass
</t>
<t tx="T3516">def testRedoMoveLeft(self):
	pass</t>
<t tx="T3517">class LeoOutlineError(Exception):
	pass

class outlineConsistencyTests(unittest.TestCase):
	
	"""test the consistency of .leo files"""

	pass # No tests yet.
</t>
<t tx="T3518">@ These functions set up trees for testing and compare the result of a test with the expected result.
</t>
<t tx="T3519">def numberOfNodesInOutline (root):
	
	"""Returns the total number of nodes in an outline"""
	
	n = 0 ; v = root
	while v:
		n +=1
		v = v.threadNext()
	return n
	
def numberOfClonesInOutline (root):
	
	"""Returns the number of cloned nodes in an outline"""

	n = 0 ; v = root
	while v:
		if v.isCloned():
			n += 1
		v = v.threadNext()</t>
<t tx="T3520">def createTestOutline():
	
	"""Creates a complex outline suitable for testing clones"""
	pass</t>
<t tx="T3521">def loadTestLeoFile (leoFileName):
	
	"""Loads a .leo file containing a test outline"""</t>
<t tx="T3522">def copyTestOutline ():
	
	"""Copies an outline so that all join Links are "equivalent" to the original"""
	pass</t>
<t tx="T3523">def compareTwoOutlines (root1,root2):
	
	"""Compares two outlines, making sure that their topologies,
	content and join lists are equivent"""
	pass</t>
<t tx="T3524">def compareLeoFiles (commander1, commander2):
	
	"""Compares the outlines in two Leo files"""
	
	c1 = commander1 ; c2 = commander2
	root1 = c1.rootVnode()
	root2 = c2.rootVnode()
</t>
<t tx="T3525">def validateOutline (root):
	
	"""Checks an outline for consistency"""
	pass</t>
<t tx="T3526">if 0:
	checkForMismatchedJoinedNodes()
	
	print createTopologyList(c=top(),root=top().currentVnode().parent(),useHeadlines=false)
	
	checkTopologiesOfLinkedNodes()
	
	checkForPossiblyBrokenLinks()</t>
<t tx="T3527">def checkForMismatchedJoinedNodes (c=None):
	
	"""Checks outline for possible broken join lists"""

	if not c: c = top()
	d = {} # Keys are tnodes, values are headlines.
	v = c.rootVnode()
	while v:
		aTuple = d.get(v.t)
		if aTuple:
			head,body = aTuple
			if v.headString()!= head:
				es("headline mismatch in joined nodes",`v`)
			if v.bodyString()!= body:
				es("body mismatch in joined nodes",`v`)
		else:
			d[v.t] = (v.headString(),v.bodyString())
		v = v.threadNext()

	es("end of checkForMismatchedJoinedNodes")
</t>
<t tx="T3528">def checkForPossiblyBrokenLinks (c=None):
	
	"""Checks outline for possible broken join lists"""
	
	if not c: c = top()
	d = {} # Keys are headlines, values are (tnodes,parent) tuples
	v = c.rootVnode()
	while v:
		h = v.headString()
		parent = v.parent()
		aTuple = d.get(h)
		if aTuple:
			t,p = aTuple
			if (t != v.t and p and parent and p.t != parent.t and
				p.headString() == parent.headString() and
				len(h) &gt; 1 and h != "NewHeadline"):
				es("different tnodes with same headline and parent headlines: " + v.headString())
		else:
			d[h] = (v.t,parent)
		v = v.threadNext()
</t>
<t tx="T3529">def checkTopologiesOfLinkedNodes(c=None):
	
	if not c: c = top()
	d = {} # Keys are tnodes, values are topology lists.
	v = c.rootVnode()
	count = 0
	while v:
		top1 = createTopologyList(c=c,root=v)
		top2 = d.get(v.t)
		if top2:
			count += 1
			if top1 != top1:
				es("mismatched topologies for two vnodes with the same tnode!",`v`)
		else:
			d[v.t] = top1
		v = v.threadNext()
	es("end of checkTopologiesOfLinkedNodes. Checked nodes: " + `count`)
</t>
<t tx="T3530">@ Nodes with the same topologies should be joined PROVIDED:
	- Topologies are non-trivial.
	- Topologies include tnodes somehow.
	- Topologies include headlines somehow.
</t>
<t tx="T3531">@

Leo 4.0.1                         October 22, 2003

This is a bug fix release:
	
- Fixes several crashers.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.</t>
<t tx="T3532">from leoGlobals import *
checkTopologyOfAllClones()</t>
<t tx="T3533"># Disabled traces for 4.0.1</t>
<t tx="T3534"></t>
<t tx="T3535"></t>
<t tx="T3536"></t>
<t tx="T3537">from leoGlobals import *

reportBadChars ("\u9999","ascii")
</t>
<t tx="T3538"></t>
</tnodes>
</leo_file>
