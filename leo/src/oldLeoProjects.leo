<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2201" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="127" left="276" height="827" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20040801060323" a="E"><vh>Old Projects</vh>
<v t="ekr.20031218072017.1135"><vh> Bindings</vh>
<v t="ekr.20031218072017.1136"><vh>(up-down arrows )</vh>
<v t="ekr.20031218072017.1137"><vh> Original proc moveUpDown</vh></v>
<v t="ekr.20031218072017.1138"><vh> New notes from Brian</vh></v>
<v t="ekr.20031218072017.1139"><vh> Request</vh></v>
<v t="ekr.20031218072017.1140"><vh> Test</vh></v>
<v t="ekr.20031218072017.1141"><vh>tree.moveUpDown</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1131"><vh> Drawing</vh>
<v t="ekr.20031218072017.1132"><vh>(Scrollwheel)</vh></v>
</v>
<v t="ekr.20031218072017.1924"><vh> Waiting for help from Linux people</vh>
<v t="ekr.20031218072017.1925"><vh>Paste bug (Linux only)</vh>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1926"><vh>Linux headline bug</vh></v>
</v>
<v t="ekr.20040105210752"><vh>(Keystrokes)</vh>
<v t="ekr.20040105214540"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3960"><vh>Creating the status area</vh>
<v t="ekr.20031218072017.3961"><vh>createStatusLine</vh></v>
<v t="ekr.20031218072017.3962"><vh>clearStatusLine</vh></v>
<v t="EKR.20040424153344"><vh>enable/disableStatusLine &amp; isEnabled</vh></v>
<v t="ekr.20031218072017.3963"><vh>putStatusLine</vh></v>
<v t="EKR.20040424154804"><vh>setFocusStatusLine</vh></v>
<v t="ekr.20031218072017.1733"><vh>updateStatusRowCol</vh></v>
</v>
<v t="ekr.20031218072017.1330"><vh>onBodyKey</vh>
<v t="ekr.20040105223536"><vh>handleStatusLineKey</vh>
<v t="ekr.20040105223536.1"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.838"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20031218072017.1724"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1726"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1727"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1729"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2177"><vh>&lt;&lt; create the toplevel frame &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1341"><vh>(scanAllDirectives, scanDirectives, related utils)</vh>
<v t="ekr.20031218072017.1342"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="ekr.20031218072017.1343"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1344"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1345"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1346"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1347"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1348"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1349"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1350"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1351"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1352"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1353"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1354"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1355"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1356"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="ekr.20031218072017.1357"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1358"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1359"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="ekr.20031218072017.1360"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20031218072017.1361"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1362"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1363"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1364"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1365"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1366"><vh>&lt;&lt; Test for @path &gt;&gt; in tangleScanAllDirectives</vh>
<v t="ekr.20031218072017.1367"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1368"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1369"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1370"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1371"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1372"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1373"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20031218072017.1374"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1375"><vh>scanForTabWidth</vh>
<v t="ekr.20031218072017.1376"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1377"><vh>scanColorDirectives</vh>
<v t="ekr.20031218072017.1378"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1379"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1380"><vh>Directive utils...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.1385"><vh>findReference</vh></v>
<v t="ekr.20031218072017.1260"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20031218072017.1261"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1262"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1386"><vh>getOutputNewline</vh></v>
<v t="ekr.20031218072017.1387"><vh>scanAtEncodingDirective</vh></v>
<v t="ekr.20031218072017.1388"><vh>scanAtLineendingDirective</vh></v>
<v t="ekr.20031218072017.1389"><vh>scanAtPagewidthDirective</vh></v>
<v t="ekr.20031218072017.1390"><vh>scanAtTabwidthDirective</vh></v>
<v t="ekr.20040715155607"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20040712084911.1"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1401"><vh>Tests</vh>
<v t="ekr.20031218072017.1402"><vh>@rawfile c:\prog\test\rawFileTest.txt</vh>
<v t="ekr.20031218072017.1403"><vh>node 1</vh></v>
<v t="ekr.20031218072017.1404"><vh>node 2</vh></v>
</v>
<v t="ekr.20031218072017.1405"><vh>@silentfile c:\prog\test\silentFileTest.txt</vh></v>
<v t="ekr.20031218072017.1406"><vh>@root c:\prog\test\tangleTest.txt</vh>
<v t="ekr.20031218072017.1407"><vh>ref</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.1655"><vh>(Support for LeoN)</vh>
<v t="ekr.20031218072017.1656"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh>
<v t="ekr.20041012082437"><vh>redirectClass.__init__</vh></v>
<v t="ekr.20041012082437.1"><vh>isRedirected</vh></v>
<v t="ekr.20041012082437.2"><vh>flush</vh></v>
<v t="ekr.20041012091252"><vh>rawPrint</vh></v>
<v t="ekr.20041012082437.3"><vh>redirect</vh></v>
<v t="ekr.20041012082437.4"><vh>undirect</vh></v>
<v t="ekr.20041012082437.5"><vh>write</vh></v>
</v>
<v t="ekr.20031218072017.1657"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20040809102904"><vh>4.2 rc1 projects</vh>
<v t="ekr.20040809095716"><vh>(Restored the "iconclick1/2" hooks)</vh>
<v t="ekr.20040803072955.81"><vh>onIconBoxClick</vh></v>
</v>
<v t="ekr.20040830210600"><vh>(Made sure a proper message is given with invalid versions of Python)</vh>
<v t="ekr.20040831063427"><vh>Report</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
<v t="ekr.20041124083125"><vh>completeFileName (leo.py)</vh></v>
</v>
<v t="ekr.20040831093934"><vh>(Fixed problem with tabs on MacOs)</vh>
<v t="ekr.20040831093934.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.1330"><vh>onBodyKey</vh>
<v t="ekr.20040105223536"><vh>handleStatusLineKey</vh>
<v t="ekr.20040105223536.1"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040829101055"><vh>(Fixed Import Derived Files command)</vh>
<v t="ekr.20040831095613"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1809"><vh>importDerivedFile</vh></v>
</v>
<v t="ekr.20040831104303"><vh>(Fixed parsing of minimal &lt;preferences&gt; tag</vh>
<v t="ekr.20040831104303.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2062"><vh>getPrefs</vh>
<v t="ekr.20031218072017.2063"><vh>getTargetLanguage</vh></v>
</v>
</v>
<v t="ekr.20040831110923"><vh>(Allow longer headlines for to support long url's)</vh>
<v t="ekr.20040831111203"><vh>Report</vh></v>
<v t="ekr.20040803072955.91"><vh>idle_head_key</vh>
<v t="ekr.20040803072955.92"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040803072955.93"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040803072955.95"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.96"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.97"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040831120106"><vh>(Fixed read errors with @language html)</vh>
<v t="ekr.20040831120106.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.1753"><vh>readLastDocLine</vh>
<v t="ekr.20031218072017.1754"><vh>&lt;&lt; new code &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1755"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040831113849"><vh>(Removed spurious "Warning: updating changed text" message)</vh>
<v t="ekr.20040831121549.1"><vh>Report</vh></v>
<v t="ekr.20040904080309"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040901061935"><vh>(Added option to disable left click logic in outline pane)</vh>
<v t="ekr.20040906081644"><vh>Notes: expanded_click_area</vh></v>
<v t="ekr.20040803072955.16"><vh>__init__</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.20"><vh>createPermanentBindings</vh></v>
<v t="ekr.20040803072955.7"><vh>newBox</vh></v>
<v t="ekr.20040803072955.37"><vh>drawClickBox</vh>
<v t="ekr.20040803072955.38"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040812033107"><vh>(Fix bugs in perfect import)  *** Disabled perfect import</vh>
<v t="ekr.20040828161347"><vh>Report</vh></v>
<v t="ekr.20040907083404"><vh>Notes</vh></v>
<v t="EKR.20040504150046"><vh>class mulderUpdateAlgorithm (leoGlobals)</vh>
<v t="EKR.20040504150046.3"><vh>__init__</vh></v>
<v t="EKR.20040504150046.9"><vh>copy_sentinels</vh></v>
<v t="EKR.20040504155109"><vh>copy_time</vh></v>
<v t="EKR.20040504150046.6"><vh>create_mapping</vh></v>
<v t="EKR.20040505080156"><vh>Get or remove sentinel lines</vh>
<v t="EKR.20040505081121"><vh>separateSentinelsFromFile/Lines</vh></v>
<v t="EKR.20040505080156.2"><vh>removeSentinelsFromFile/Lines</vh>
<v t="ekr.20040716105102"><vh>&lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;</vh></v>
</v>
<v t="EKR.20040505080156.3"><vh>getSentinelsFromFile/Lines</vh></v>
</v>
<v t="EKR.20040504150046.10"><vh>propagateDiffsToSentinelsFile</vh>
<v t="EKR.20040504150046.11"><vh>&lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;</vh></v>
<v t="EKR.20040504150046.12"><vh>&lt;&lt;paranoia check&gt;&gt;</vh></v>
</v>
<v t="EKR.20040504145804.1"><vh>propagateDiffsToSentinelsLines (called from perfect import)</vh>
<v t="EKR.20040504145804.2"><vh>&lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;</vh></v>
<v t="EKR.20040504145804.3"><vh>&lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;</vh></v>
<v t="EKR.20040504145804.4"><vh>&lt;&lt; update and check the loop invariant&gt;&gt;</vh></v>
<v t="EKR.20040504145804.5"><vh>&lt;&lt; handle 'equal' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.6"><vh>&lt;&lt; handle 'replace' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.7"><vh>&lt;&lt; handle 'delete' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.8"><vh>&lt;&lt; handle 'insert' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.9"><vh>&lt;&lt; copy the sentinels at the end of the file &gt;&gt;</vh></v>
</v>
<v t="EKR.20040504150046.5"><vh>report_mismatch</vh></v>
<v t="ekr.20040718101315"><vh>stripWhitespaceFromBlankLines(before_lines)</vh></v>
<v t="EKR.20040504160820"><vh>write_if_changed</vh>
<v t="EKR.20040504160820.1"><vh>&lt;&lt; make backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040506075328.2"><vh>perfectImport</vh>
<v t="ekr.20040717112739"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20040716065356"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20040716064333"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20040716064333.1"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20040717132539"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20040717113036"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20040718035658"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20040718045423"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3212"><vh>importFilesCommand</vh>
<v t="ekr.20031218072017.3213"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3319"><vh>undentBody</vh></v>
<v t="ekr.20031218072017.3202"><vh>removeLeadingWhitespace</vh></v>
<v t="ekr.20031218072017.2256"><vh>Python scanners</vh>
<v t="ekr.20031218072017.2257"><vh>scanPythonClass</vh>
<v t="ekr.20031218072017.2258"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2259"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2260"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="ekr.20031218072017.2261"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2262"><vh>&lt;&lt; append any other class material &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2263"><vh>scanPythonDef</vh>
<v t="ekr.20031218072017.2264"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2265"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2266"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2267"><vh>scanPythonDecls</vh>
<v t="ekr.20031218072017.2268"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2269"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2270"><vh>scanPythonText</vh>
<v t="ekr.20031218072017.2271"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2272"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2273"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040831112005"><vh>(Investigated control-v problems on the Mac)</vh>
<v t="ekr.20040831112005.1"><vh>Report</vh></v>
</v>
<v t="EKR.20040422132037.8"><vh>Mouse / Paste Anomalies (email sent)</vh></v>
<v t="ekr.20040910064225"><vh>(Removed assert from colorizer)</vh>
<v t="ekr.20040910064225.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.1880"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="ekr.20031218072017.1602"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="ekr.20031218072017.1603"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="ekr.20031218072017.1881"><vh>&lt;&lt; all state ivars match &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1882"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="ekr.20031218072017.1883"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1884"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1885"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1886"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1887"><vh>&lt;&lt; non-incrementally color the text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1890"><vh>&lt;&lt; completely recolor in two passes &gt;&gt;</vh>
<v t="ekr.20031218072017.1891"><vh>&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1888"><vh>&lt;&lt; update state ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1889"><vh>&lt;&lt; set state ivars to "unknown" &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040913111703"><vh>(Fixed bugs in Tangle/Untangle)</vh>
<v t="ekr.20040914074643"><vh>Report</vh></v>
</v>
<v t="ekr.20040914081306"><vh>(Shifted all Alt-shortcuts to Ctrl shortcuts on the Mac)</vh>
<v t="ekr.20040914081306.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040914082436"><vh>(Added c.frame.openDirectory to sys.path when executing scripts)</vh>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040107064101.1"><vh>4.2 Projects</vh>
<v t="ekr.20040629162300"><vh>In 4.2 a1</vh>
<v t="ekr.20040403104315"><vh>March 2004</vh>
<v t="ekr.20040325203859"><vh>3/11 to 3/20</vh>
<v t="ekr.20040302094109"><vh>(p.level bug)</vh>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040305084926"><vh>(clone command)</vh>
<v t="ekr.20031218072017.1762"><vh>c.clone</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20031218072017.3424"><vh>v.clone</vh></v>
<v t="ekr.20031218072017.1765"><vh>c.validateOutline</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040307101707"><vh>(Read code hangs)</vh>
<v t="ekr.20031218072017.2626"><vh> top_df.readAll</vh></v>
<v t="ekr.20031218072017.2989"><vh>c.setChanged</vh></v>
<v t="ekr.20031218072017.3368"><vh>v.isCloned (4.2)</vh></v>
<v t="ekr.20031218072017.3437"><vh>v.shouldBeClone</vh></v>
</v>
<v t="ekr.20040309041826"><vh>(Problems with injected methods)</vh>
<v t="ekr.20040309045858"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1000"><vh>drawBox (tag_bind)</vh></v>
<v t="ekr.20031218072017.1002"><vh>drawIcon (tag_bind)</vh>
<v t="EKR.20040602150338"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1956"><vh>tree.injectCallbacks (class method)</vh>
<v t="ekr.20031218072017.1957"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20031218072017.1958"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.1959"><vh>OnDrag</vh></v>
<v t="ekr.20031218072017.1960"><vh>OnEndDrag</vh></v>
<v t="ekr.20031218072017.1961"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="ekr.20031218072017.1962"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20031218072017.1963"><vh>OnHeadlineKey</vh></v>
<v t="ekr.20031218072017.1964"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20031218072017.1965"><vh>OnHyperLinkLeave</vh></v>
<v t="ekr.20031218072017.1966"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20031218072017.1967"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2336"><vh>Event handers (tree)</vh>
<v t="EKR.20040608110312"><vh>Dragging (tk tree)</vh>
<v t="ekr.20031218072017.2342"><vh>tree.OnContinueDrag</vh>
<v t="ekr.20031218072017.2343"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="ekr.20031218072017.2344"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1776"><vh>tree.OnDrag</vh></v>
<v t="ekr.20031218072017.1777"><vh>tree.OnEndDrag</vh>
<v t="ekr.20031218072017.1778"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1332"><vh>headline key handlers (tree)</vh>
<v t="ekr.20031218072017.1333"><vh>onHeadChanged</vh></v>
<v t="ekr.20031218072017.1334"><vh>OnHeadlineKey</vh></v>
<v t="ekr.20031218072017.1335"><vh>idle_head_key</vh>
<v t="ekr.20031218072017.1337"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="EKR.20040614075003"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1336"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1338"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1339"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1340"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2337"><vh>OnActivate</vh>
<v t="ekr.20031218072017.2338"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2339"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.2341"><vh>tree.findVnodeWithIconId</vh></v>
<v t="ekr.20031218072017.2345"><vh>tree.OnCtontrolT</vh></v>
<v t="ekr.20031218072017.2340"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20031218072017.2346"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20031218072017.2348"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20031218072017.2349"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20031218072017.2249"><vh>createPopupMenu</vh>
<v t="ekr.20031218072017.2250"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2350"><vh>enablePopupMenuItems</vh>
<v t="ekr.20031218072017.2351"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2352"><vh>showPopupMenu</vh></v>
</v>
</v>
</v>
<v t="ekr.20040310062415.1"><vh>(Revised p.link/unlink routines)</vh>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20040305222007"><vh>(undo/redo)</vh>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2030"><vh>redo &amp; allies</vh>
<v t="EKR.20040526090701.1"><vh>redoChangeAll</vh></v>
<v t="EKR.20040526090701.2"><vh>redoChangeHeadline</vh></v>
<v t="EKR.20040526072519.1"><vh>redoClone</vh></v>
<v t="EKR.20040526072519.2"><vh>redoDeleteNode</vh></v>
<v t="EKR.20040526072519.3"><vh>redoHoist &amp; redoDehoist</vh></v>
<v t="EKR.20040526072519.4"><vh>redoInsertNodes</vh></v>
<v t="EKR.20040526075238.1"><vh>redoMoveNode</vh></v>
<v t="EKR.20040526075238.2"><vh>redoDemote &amp; redoPromote</vh></v>
<v t="EKR.20040526075238.3"><vh>redoReplaceNodes &amp; replaceNodesContents</vh></v>
<v t="EKR.20040526075238.4"><vh>redoSortChildren/Siblings/TopLevel</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20031218072017.2039"><vh>undo &amp; allies</vh>
<v t="EKR.20040526090701.5"><vh>undoChangeAll</vh></v>
<v t="EKR.20040526090701.6"><vh>undoChangeHeadline</vh></v>
<v t="EKR.20040526083847"><vh>undoClone &amp; undoDragClone</vh></v>
<v t="EKR.20040526083847.1"><vh>undoDeleteNode</vh></v>
<v t="ekr.20031218072017.3620"><vh>undoDemote</vh></v>
<v t="EKR.20040526083847.2"><vh>undoHoist and undoDehoist</vh></v>
<v t="EKR.20040526084140"><vh>undoInsertNodes</vh></v>
<v t="EKR.20040526084140.1"><vh>undoMoveNode</vh></v>
<v t="ekr.20031218072017.3621"><vh>undoPromote</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1714"><vh>undoReplace</vh></v>
<v t="EKR.20040526090701.3"><vh>undoReplaceNodes &amp; undoReplaceNodesContents</vh></v>
<v t="ekr.20031218072017.3622"><vh>undoSortChildren</vh></v>
<v t="ekr.20031218072017.3623"><vh>undoSortSiblings</vh></v>
<v t="ekr.20031218072017.3624"><vh>undoSortTopLevel</vh></v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
</v>
<v t="ekr.20031218072017.3612"><vh>getBead, peekBead, setBead</vh>
<v t="EKR.20040526150818"><vh>getBeed</vh></v>
<v t="EKR.20040526150818.1"><vh>peekBeed</vh></v>
<v t="EKR.20040526150818.2"><vh>setBeed</vh></v>
</v>
<v t="ekr.20031218072017.3615"><vh>setUndoParams</vh></v>
</v>
<v t="ekr.20040310104639"><vh>(Get move working)</vh>
<v t="ekr.20031218072017.1760"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20031218072017.1766"><vh>Move... (Commands)</vh>
<v t="ekr.20031218072017.1767"><vh>demote</vh></v>
<v t="ekr.20031218072017.1768"><vh>moveOutlineDown</vh>
<v t="ekr.20031218072017.1769"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1770"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
<v t="ekr.20031218072017.1772"><vh>moveOutlineUp</vh>
<v t="ekr.20031218072017.1773"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1774"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20040311081401"><vh>(Get write working)</vh>
<v t="ekr.20031218072017.2387"><vh>old_df.scanAllDirectives</vh>
<v t="ekr.20031218072017.2388"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2389"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20031218072017.2390"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2391"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2392"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2393"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2394"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.2395"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2396"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2397"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2398"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2399"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2400"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1570"><vh>assignFileIndices &amp; compactFileIndices</vh>
<v t="ekr.20031218072017.1571"><vh>&lt;&lt; assign missing gnx's, converting ints to gnx's &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1572"><vh>&lt;&lt; reassign all tnode indices &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1577"><vh>putTnode</vh></v>
<v t="ekr.20031218072017.2002"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
</v>
<v t="ekr.20040308153521"><vh>(Read Leo file to 4.2 format)</vh>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
<v t="ekr.20040326054052"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1560"><vh>getTnodes</vh></v>
<v t="ekr.20031218072017.1561"><vh>getTnode</vh>
<v t="ekr.20031218072017.1564"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040311133449"><vh>(Cut/paste outlines)</vh>
<v t="ekr.20031218072017.1559"><vh>getLeoOutline (from clipboard)</vh>
<v t="EKR.20040610134756"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1551"><vh>pasteOutline</vh>
<v t="ekr.20050418084539"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050418084539.2"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1557"><vh>finishPaste</vh>
<v t="ekr.20031218072017.1558"><vh>&lt;&lt; reassign tnode indices and clear all clone links &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
<v t="ekr.20040326054052"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040325203859.1"><vh>3/21</vh>
<v t="ekr.20040312024615"><vh>(Fixed bug in sortTopLevel)</vh>
<v t="ekr.20040312145256"><vh>v.dump</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20031218072017.2896"><vh>c.sortTopLevel</vh>
<v t="ekr.20031218072017.2897"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
</v>
<v t="ekr.20040314103754"><vh>(Fixed hoist command)</vh>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2028"><vh>Hoist &amp; dehoist &amp; enablers</vh></v>
<v t="ekr.20031218072017.1761"><vh>c.insertHeadline</vh></v>
<v t="ekr.20040131170659"><vh>canClone (new for hoist)</vh></v>
</v>
<v t="ekr.20040314110927.1"><vh>(Got all unit tests working)</vh>
<v t="ekr.20040315031219.1"><vh>Flatten outline</vh>
<v t="ekr.20031218072017.1147"><vh>flattenOutline</vh></v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20040312120107"><vh>(Fixed move/drawing/level bugs)</vh>
<v t="ekr.20040312213623"><vh> Notes</vh></v>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040313083810"><vh>commands stuff...</vh>
<v t="ekr.20031218072017.1766"><vh>Move... (Commands)</vh>
<v t="ekr.20031218072017.1767"><vh>demote</vh></v>
<v t="ekr.20031218072017.1768"><vh>moveOutlineDown</vh>
<v t="ekr.20031218072017.1769"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1770"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
<v t="ekr.20031218072017.1772"><vh>moveOutlineUp</vh>
<v t="ekr.20031218072017.1773"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1774"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20040313083810.2"><vh>position stuff...</vh>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040313083810.1"><vh>tree stuff...</vh>
<v t="ekr.20031218072017.1004"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040317171729"><vh>force_draw_node (new)</vh></v>
<v t="ekr.20040318090335"><vh>force_draw_node (old)</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4161"><vh>tree.expandAllAncestors</vh></v>
<v t="ekr.20031218072017.4157"><vh>Selecting &amp; editing (tree)</vh>
<v t="ekr.20040725044521.1"><vh>tree.edit_text</vh></v>
<v t="ekr.20031218072017.4158"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20031218072017.4159"><vh>editLabel</vh></v>
<v t="ekr.20031218072017.4160"><vh>endEditLabel</vh></v>
<v t="ekr.20031218072017.4161"><vh>tree.expandAllAncestors</vh></v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4162"><vh>tree.set...LabelState</vh>
<v t="ekr.20031218072017.4163"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4164"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4165"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1018"><vh>tree.idle_scrollTo</vh>
<v t="ekr.20040314092716"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040314092716.1"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040313083810.3"><vh>vnode stuff</vh>
<v t="ekr.20040301071824"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20031218072017.3419"><vh>v.insertAfter</vh></v>
<v t="ekr.20031218072017.3421"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20031218072017.2355"><vh>v.linkAfter</vh></v>
<v t="ekr.20031218072017.3425"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20031218072017.3426"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3422"><vh>v.moveToRoot</vh></v>
<v t="ekr.20031218072017.3438"><vh>v.unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20040314111426"><vh>(Fixed @+leo encoding bug)</vh>
<v t="ekr.20040317084001"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2789"><vh>putOpenLeoSentinel 4.x</vh></v>
<v t="ekr.20031218072017.2695"><vh>putOpenLeoSentinel 3.x</vh></v>
</v>
<v t="ekr.20040312092455.2"><vh>(Enable and test atFile read logic)</vh>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20040316075317"><vh>reading...</vh>
<v t="ekr.20031218072017.2626"><vh> top_df.readAll</vh></v>
<v t="ekr.20031218072017.2007"><vh>findChild 4.x</vh>
<v t="ekr.20040716061450"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2008"><vh>getTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040316075317.1"><vh>writing...</vh>
<v t="ekr.20031218072017.1570"><vh>assignFileIndices &amp; compactFileIndices</vh>
<v t="ekr.20031218072017.1571"><vh>&lt;&lt; assign missing gnx's, converting ints to gnx's &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1572"><vh>&lt;&lt; reassign all tnode indices &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2322"><vh>old_df.write</vh>
<v t="ekr.20031218072017.2323"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2324"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2325"><vh>&lt;&lt; write then entire @file tree &gt;&gt; (3.x)</vh>
<v t="ekr.20031218072017.2326"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (3.x)</vh></v>
<v t="ekr.20031218072017.2327"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="ekr.20031218072017.2328"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (3.x)</vh></v>
</v>
<v t="ekr.20031218072017.2330"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="ekr.20031218072017.2002"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040325203859.2"><vh>3/22</vh>
<v t="ekr.20040318112729"><vh>(trace p.copy)</vh>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
</v>
<v t="ekr.20040318112908"><vh>(Properly mark @file nodes dirty)</vh>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
<v t="ekr.20040301071824"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20031218072017.3419"><vh>v.insertAfter</vh></v>
<v t="ekr.20031218072017.3421"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20031218072017.2355"><vh>v.linkAfter</vh></v>
<v t="ekr.20031218072017.3425"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20031218072017.3426"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3422"><vh>v.moveToRoot</vh></v>
<v t="ekr.20031218072017.3438"><vh>v.unlink</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
</v>
<v t="ekr.20040318092028"><vh>(Big performance bug in selecting/redraw/expand/contract)</vh>
<v t="ekr.20040318100124"><vh>Coloringing...</vh>
<v t="ekr.20031218072017.3677"><vh>Coloring</vh></v>
<v t="ekr.20031218072017.2801"><vh>colorize &amp; recolor_range</vh></v>
<v t="ekr.20031218072017.2805"><vh>useSyntaxColoring</vh></v>
<v t="ekr.20031218072017.2804"><vh>updateSyntaxColorer</vh></v>
<v t="ekr.20031218072017.1377"><vh>scanColorDirectives</vh>
<v t="ekr.20031218072017.1378"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1379"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040318100124.1"><vh>Tree select/bindings...</vh>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4142"><vh>tree.deleteBindings</vh></v>
<v t="ekr.20031218072017.4143"><vh>tree.deleteWidgets</vh></v>
</v>
<v t="ekr.20040318100124.2"><vh>Expand/contract...</vh>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1958"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.2339"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.3395"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20031218072017.4161"><vh>tree.expandAllAncestors</vh></v>
</v>
</v>
<v t="ekr.20040318161816"><vh>(Moving,expanding,contracting nodes can create HUGE numbers of positions)</vh>
<v t="ekr.20031218072017.1772"><vh>moveOutlineUp</vh>
<v t="ekr.20031218072017.1773"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1760"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
</v>
<v t="ekr.20040318164450"><vh>(Saving a .leo file created too many positions)</vh>
<v t="ekr.20031218072017.1760"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040325203859.3"><vh>3/24</vh>
<v t="ekr.20040323072005"><vh>(Fixed select headline bug)</vh>
<v t="ekr.20031218072017.3716"><vh>Getters/Setters (tree)</vh></v>
<v t="ekr.20031218072017.4157"><vh>Selecting &amp; editing (tree)</vh>
<v t="ekr.20040725044521.1"><vh>tree.edit_text</vh></v>
<v t="ekr.20031218072017.4158"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20031218072017.4159"><vh>editLabel</vh></v>
<v t="ekr.20031218072017.4160"><vh>endEditLabel</vh></v>
<v t="ekr.20031218072017.4161"><vh>tree.expandAllAncestors</vh></v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4162"><vh>tree.set...LabelState</vh>
<v t="ekr.20031218072017.4163"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4164"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4165"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040322121338.1"><vh>(Fixed bug in setAllAncestorAtFileNodesDirty)</vh>
<v t="ekr.20040323073825"><vh>Notes</vh></v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
</v>
<v t="ekr.20040323090456.2"><vh>(Removed v.parents field)</vh>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20031218072017.1968"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040301071824"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20031218072017.3419"><vh>v.insertAfter</vh></v>
<v t="ekr.20031218072017.3421"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20031218072017.2355"><vh>v.linkAfter</vh></v>
<v t="ekr.20031218072017.3425"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20031218072017.3426"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3422"><vh>v.moveToRoot</vh></v>
<v t="ekr.20031218072017.3438"><vh>v.unlink</vh></v>
</v>
<v t="ekr.20040323100443"><vh>v.directParents (new method in 4.2)</vh></v>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040322123611"><vh>(Added Check Outline command)</vh></v>
<v t="ekr.20040323084605"><vh>(Speeded up menu enablers)</vh>
<v t="ekr.20040323171453"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3776"><vh>Gui-independent menu enablers</vh>
<v t="ekr.20031218072017.3777"><vh>updateAllMenus</vh></v>
<v t="ekr.20031218072017.3778"><vh>updateFileMenu</vh></v>
<v t="ekr.20031218072017.836"><vh>updateEditMenu</vh>
<v t="ekr.20040130164211"><vh>&lt;&lt; enable cut/paste &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3779"><vh>updateOutlineMenu</vh>
<v t="ekr.20040131171020"><vh>&lt;&lt; enable top level outline menu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.1"><vh>&lt;&lt; enable expand/Contract submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.2"><vh>&lt;&lt; enable move submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.3"><vh>&lt;&lt; enable go to submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.4"><vh>&lt;&lt; enable mark submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3780"><vh>hasSelection</vh></v>
</v>
<v t="ekr.20031218072017.2955"><vh>Enabling Menu Items</vh>
<v t="ekr.20040323172420"><vh>Slow routines: no longer used</vh>
<v t="ekr.20031218072017.2966"><vh>canGoToNextDirtyHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2967"><vh>canGoToNextMarkedHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2968"><vh>canMarkChangedHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2969"><vh>canMarkChangedRoots (slow)</vh></v>
</v>
<v t="ekr.20040131170659"><vh>canClone (new for hoist)</vh></v>
<v t="ekr.20031218072017.2956"><vh>canContractAllHeadlines</vh></v>
<v t="ekr.20031218072017.2957"><vh>canContractAllSubheads</vh></v>
<v t="ekr.20031218072017.2958"><vh>canContractParent</vh></v>
<v t="ekr.20031218072017.2959"><vh>canContractSubheads</vh></v>
<v t="ekr.20031218072017.2960"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="ekr.20031218072017.2961"><vh>canDemote</vh></v>
<v t="ekr.20031218072017.2962"><vh>canExpandAllHeadlines</vh></v>
<v t="ekr.20031218072017.2963"><vh>canExpandAllSubheads</vh></v>
<v t="ekr.20031218072017.2964"><vh>canExpandSubheads</vh></v>
<v t="ekr.20031218072017.2287"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="ekr.20031218072017.2965"><vh>canFindMatchingBracket</vh></v>
<v t="ekr.20040303165342"><vh>canHoist &amp; canDehoist</vh></v>
<v t="ekr.20031218072017.2970"><vh>canMoveOutlineDown (changed for hoist)</vh></v>
<v t="ekr.20031218072017.2971"><vh>canMoveOutlineLeft (changed for hoist)</vh></v>
<v t="ekr.20031218072017.2972"><vh>canMoveOutlineRight (changed for hoist)</vh></v>
<v t="ekr.20031218072017.2973"><vh>canMoveOutlineUp (changed for hoist)</vh></v>
<v t="ekr.20031218072017.2974"><vh>canPasteOutline</vh></v>
<v t="ekr.20031218072017.2975"><vh>canPromote</vh></v>
<v t="ekr.20031218072017.2976"><vh>canRevert</vh></v>
<v t="ekr.20031218072017.2977"><vh>canSelect....</vh></v>
<v t="ekr.20031218072017.2978"><vh>canShiftBodyLeft/Right</vh></v>
<v t="ekr.20031218072017.2979"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="ekr.20031218072017.2980"><vh>canUndo &amp; canRedo</vh></v>
<v t="ekr.20031218072017.2981"><vh>canUnmarkAll</vh></v>
</v>
</v>
<v t="ekr.20040323194538"><vh>(Speeded up Contract All command)</vh>
<v t="ekr.20031218072017.2900"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20031218072017.2910"><vh>contractSubtree</vh></v>
</v>
</v>
<v t="ekr.20040325203859.4"><vh>3/25</vh>
<v t="ekr.20040325104344"><vh>(Optimized drawing and saving recursions)</vh>
<v t="ekr.20031218072017.4144"><vh>Drawing (tkTree)</vh>
<v t="ekr.20031218072017.4145"><vh>About drawing and updating</vh></v>
<v t="ekr.20031218072017.1000"><vh>drawBox (tag_bind)</vh></v>
<v t="ekr.20031218072017.1002"><vh>drawIcon (tag_bind)</vh>
<v t="EKR.20040602150338"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1004"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040317171729"><vh>force_draw_node (new)</vh></v>
<v t="ekr.20040318090335"><vh>force_draw_node (old)</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317095510"><vh>drawUserIcon</vh>
<v t="ekr.20040317173849"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040317095153"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040317095153.1"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
<v t="ekr.20040317100702"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317094609"><vh>drawUserIcons</vh></v>
<v t="ekr.20031218072017.1010"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040710050236"><vh>tree.drawClickFrame</vh></v>
<v t="ekr.20031218072017.4147"><vh>tree.getIconImage</vh></v>
<v t="ekr.20031218072017.1018"><vh>tree.idle_scrollTo</vh>
<v t="ekr.20040314092716"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040314092716.1"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4148"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="ekr.20040322122232"><vh>tree.scrollTo</vh></v>
<v t="ekr.20031218072017.4149"><vh>tree.yoffset</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040325111920"><vh>(Drastically reduced positions created by Read Outline Only)</vh>
<v t="ekr.20040325115038"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3398"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
<v t="ekr.20040326054052"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040324080004"><vh>(Improved speed of Save command)</vh>
<v t="ekr.20040324085927"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3137"><vh>Timing</vh></v>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040325142015"><vh>p.equal</vh></v>
<v t="ekr.20031218072017.1765"><vh>c.validateOutline</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303212445"><vh>v.childIndex</vh></v>
<v t="ekr.20031218072017.2985"><vh>c.clearAllVisited</vh></v>
<v t="ekr.20031218072017.3401"><vh>t.setVisited</vh></v>
<v t="ekr.20031218072017.1999"><vh>toString</vh></v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080359.2"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20040324080819.2"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040324080819.3"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3049"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2002"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040323084434.1"><vh>(reduced calls to drawTopTree)</vh>
<v t="ekr.20040323191536"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1017"><vh>tree.__init__</vh></v>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1473"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="EKR.20040423082910.2"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.3"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4160"><vh>endEditLabel</vh></v>
<v t="ekr.20031218072017.1011"><vh>Updating routines (tree)...</vh>
<v t="ekr.20031218072017.1012"><vh>tree.redraw</vh></v>
<v t="ekr.20040106095546"><vh>tkTree.redrawAfterException</vh></v>
<v t="ekr.20031218072017.1013"><vh>force_redraw</vh></v>
<v t="ekr.20031218072017.1014"><vh>redraw_now</vh></v>
<v t="ekr.20031218072017.1015"><vh>idle_redraw</vh>
<v t="ekr.20040324090957"><vh>&lt;&lt; return if disabled, or quitting or dragging &gt;&gt;</vh></v>
<v t="ekr.20040324090957.1"><vh>&lt;&lt; Erase and redraw the entire tree &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1016"><vh>idle_second_redraw</vh></v>
</v>
</v>
<v t="ekr.20040325125426"><vh>(Fixed problem with first screen draw)</vh>
<v t="ekr.20040325203859.5"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1015"><vh>idle_redraw</vh>
<v t="ekr.20040324090957"><vh>&lt;&lt; return if disabled, or quitting or dragging &gt;&gt;</vh></v>
<v t="ekr.20040324090957.1"><vh>&lt;&lt; Erase and redraw the entire tree &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040326040442.1"><vh>3/26</vh>
<v t="ekr.20040326033431"><vh>(Made sure second argument to p.__cmp__ is always a position)</vh>
<v t="ekr.20040326035757"><vh>Notes</vh></v>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2626"><vh> top_df.readAll</vh></v>
</v>
<v t="ekr.20040324093353"><vh>(Restore current and top nodes)</vh>
<v t="ekr.20040326061545"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3019"><vh>leoFileCommands._init_</vh></v>
<v t="ekr.20040326052245"><vh>convertStackToPosition</vh></v>
<v t="ekr.20040326063413"><vh>getExistingVnode</vh></v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
<v t="ekr.20040326054052"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
</v>
<v t="ekr.20040326063733"><vh>(Disambiguated clones when selecting)</vh>
<v t="ekr.20040326072847"><vh>Notes</vh></v>
<v t="ekr.20040326101817"><vh>Birth &amp; death...</vh>
<v t="ekr.20031218072017.3705"><vh>  tree.__init__ (base class)</vh></v>
<v t="ekr.20031218072017.4141"><vh>tree.Birth &amp; death (Tkinter)</vh>
<v t="ekr.20031218072017.1017"><vh>tree.__init__</vh></v>
<v t="ekr.20031218072017.4142"><vh>tree.deleteBindings</vh></v>
<v t="ekr.20031218072017.4143"><vh>tree.deleteWidgets</vh></v>
<v t="ekr.20031218072017.1956"><vh>tree.injectCallbacks (class method)</vh>
<v t="ekr.20031218072017.1957"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20031218072017.1958"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.1959"><vh>OnDrag</vh></v>
<v t="ekr.20031218072017.1960"><vh>OnEndDrag</vh></v>
<v t="ekr.20031218072017.1961"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="ekr.20031218072017.1962"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20031218072017.1963"><vh>OnHeadlineKey</vh></v>
<v t="ekr.20031218072017.1964"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20031218072017.1965"><vh>OnHyperLinkLeave</vh></v>
<v t="ekr.20031218072017.1966"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20031218072017.1967"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040326101817.1"><vh>edit_text mods...</vh>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3716"><vh>Getters/Setters (tree)</vh></v>
</v>
<v t="ekr.20031218072017.1335"><vh>idle_head_key</vh>
<v t="ekr.20031218072017.1337"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="EKR.20040614075003"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1336"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1338"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1339"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1340"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4144"><vh>Drawing (tkTree)</vh>
<v t="ekr.20031218072017.4145"><vh>About drawing and updating</vh></v>
<v t="ekr.20031218072017.1000"><vh>drawBox (tag_bind)</vh></v>
<v t="ekr.20031218072017.1002"><vh>drawIcon (tag_bind)</vh>
<v t="EKR.20040602150338"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1004"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040317171729"><vh>force_draw_node (new)</vh></v>
<v t="ekr.20040318090335"><vh>force_draw_node (old)</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317095510"><vh>drawUserIcon</vh>
<v t="ekr.20040317173849"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040317095153"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040317095153.1"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
<v t="ekr.20040317100702"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317094609"><vh>drawUserIcons</vh></v>
<v t="ekr.20031218072017.1010"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040710050236"><vh>tree.drawClickFrame</vh></v>
<v t="ekr.20031218072017.4147"><vh>tree.getIconImage</vh></v>
<v t="ekr.20031218072017.1018"><vh>tree.idle_scrollTo</vh>
<v t="ekr.20040314092716"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040314092716.1"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4148"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="ekr.20040322122232"><vh>tree.scrollTo</vh></v>
<v t="ekr.20031218072017.4149"><vh>tree.yoffset</vh></v>
</v>
<v t="ekr.20031218072017.4157"><vh>Selecting &amp; editing (tree)</vh>
<v t="ekr.20040725044521.1"><vh>tree.edit_text</vh></v>
<v t="ekr.20031218072017.4158"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20031218072017.4159"><vh>editLabel</vh></v>
<v t="ekr.20031218072017.4160"><vh>endEditLabel</vh></v>
<v t="ekr.20031218072017.4161"><vh>tree.expandAllAncestors</vh></v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4162"><vh>tree.set...LabelState</vh>
<v t="ekr.20031218072017.4163"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4164"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4165"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040327132739.2"><vh>3/27</vh>
<v t="ekr.20031218072017.862"><vh>(Added useNullUndoer option to nullFrame class)</vh>
<v t="ekr.20031218072017.2222"><vh>class nullFrame</vh>
<v t="ekr.20040327105706"><vh>__init__</vh></v>
<v t="ekr.20041130065921"><vh>deiconfy, lift, update</vh></v>
<v t="ekr.20041120073824"><vh>destroySelf</vh></v>
<v t="ekr.20040327105706.1"><vh>__getattr__ NOT USED</vh></v>
<v t="ekr.20040327105706.2"><vh>finishCreate</vh></v>
<v t="ekr.20041130065718"><vh>get_window_info</vh></v>
<v t="ekr.20041130065921.1"><vh>lift</vh></v>
<v t="ekr.20040327105706.3"><vh>oops</vh></v>
<v t="ekr.20041130090749"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20041130065718.1"><vh>setTopGeometry</vh></v>
</v>
</v>
</v>
<v t="ekr.20040328082044"><vh>3/28</vh>
<v t="ekr.20040323090456.1"><vh>(Fixed bugs in up isAnyAtFileNode &amp; related routines)</vh>
<v t="ekr.20031218072017.3152"><vh>g.scanAtFileOptions (used in 3.x read code)</vh>
<v t="ekr.20031218072017.3153"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
</v>
<v t="ekr.20040328093126"><vh>(Cleaned up using @file type names)</vh>
<v t="ekr.20031218072017.2389"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20031218072017.2628"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
</v>
<v t="ekr.20040328063421"><vh>(Converted to less confusing @file type names)</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20031218072017.2626"><vh> top_df.readAll</vh></v>
<v t="ekr.20031218072017.2122"><vh>new_df.norefWrite</vh>
<v t="ekr.20031218072017.2123"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20031218072017.2124"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2125"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2126"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2127"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
</v>
</v>
<v t="ekr.20040331080343"><vh>3/31</vh>
<v t="ekr.20040331074940"><vh>(Fixed bug in hoist)</vh>
<v t="ekr.20031218072017.2028"><vh>Hoist &amp; dehoist &amp; enablers</vh></v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040403104315.1"><vh>April 2004</vh>
<v t="ekr.20040403104315.3"><vh>4/3</vh>
<v t="ekr.20040403091954"><vh>(Problems with marking nodes in a script)</vh>
<v t="ekr.20040403095129"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040409081506"><vh>4/8</vh>
<v t="ekr.20040106115311"><vh>* Expanding the +- box</vh>
<v t="ekr.20040409074345"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2339"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2346"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20031218072017.1000"><vh>drawBox (tag_bind)</vh></v>
<v t="ekr.20031218072017.1002"><vh>drawIcon (tag_bind)</vh>
<v t="EKR.20040602150338"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040409080127"><vh>(Fixed failed assert in undo)</vh>
<v t="ekr.20031218072017.2035"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2044"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409081506.1"><vh>(Assert failed in lastVisible)</vh>
<v t="ekr.20040409081716"><vh>Traceback</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.1018"><vh>tree.idle_scrollTo</vh>
<v t="ekr.20040314092716"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040314092716.1"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040411091047"><vh>4/11</vh>
<v t="ekr.20040411081633.1"><vh>(Installed psyco &amp; added use_psyco option)</vh>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1934"><vh>run &amp; allies</vh>
<v t="ekr.20041219072112"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20041219072416.1"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20040411081633"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1935"><vh>&lt;&lt; print encoding info &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
<v t="ekr.20031218072017.1937"><vh>computeLoadDir</vh></v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20031218072017.1938"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20031218072017.1939"><vh>getBatchScript</vh></v>
<v t="ekr.20041130093254"><vh>reportDirectories</vh></v>
</v>
</v>
</v>
<v t="ekr.20040412061129"><vh>4/12</vh>
<v t="ekr.20040412061129.1"><vh>Created Dump Outline command</vh></v>
<v t="ekr.20040409083211"><vh>(Fixed problems deleting cloned nodes &amp; trees)</vh>
<v t="ekr.20040409083211.1"><vh>tracebacks</vh></v>
<v t="ekr.20040409160021"><vh>Notes</vh></v>
<v t="ekr.20040409130322"><vh>commands &amp; fileCommands methods...</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1193"><vh>c.deleteOutline</vh></v>
</v>
<v t="ekr.20040312145256"><vh>v.dump</vh></v>
<v t="ekr.20040409130322.2"><vh>position methods ...</vh>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
</v>
<v t="ekr.20040409163052"><vh>Undo</vh>
<v t="ekr.20031218072017.2034"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2041"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040414073612"><vh>4/14</vh>
<v t="ekr.20040414073612.1"><vh>Fixed several minor bugs in Tangle logic</vh></v>
</v>
<v t="EKR.20040422101256"><vh>4/22</vh>
<v t="EKR.20040422101256.1"><vh>changed v=v to p=v in some calls to scanDirectives</vh></v>
<v t="EKR.20040422130619.1"><vh>(Added ResizeToScreen command)</vh>
<v t="ekr.20031218072017.3979"><vh>Gui-dependent commands</vh>
<v t="ekr.20031218072017.3980"><vh>Edit Menu...</vh>
<v t="ekr.20031218072017.3981"><vh>abortEditLabelCommand</vh></v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste body text</vh>
<v t="ekr.20031218072017.841"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="ekr.20031218072017.842"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
</v>
<v t="ekr.20031218072017.3982"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20031218072017.3983"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20031218072017.3984"><vh>Window Menu...</vh>
<v t="ekr.20031218072017.3985"><vh>toggleActivePane</vh></v>
<v t="ekr.20031218072017.3986"><vh>cascade</vh></v>
<v t="ekr.20031218072017.3987"><vh>equalSizedPanes</vh></v>
<v t="ekr.20031218072017.3988"><vh>hideLogWindow</vh></v>
<v t="ekr.20031218072017.3989"><vh>minimizeAll</vh></v>
<v t="ekr.20031218072017.3990"><vh>toggleSplitDirection</vh></v>
<v t="EKR.20040422130619"><vh>resizeToScreen</vh></v>
</v>
<v t="ekr.20031218072017.3991"><vh>Help Menu...</vh>
<v t="ekr.20031218072017.3992"><vh>leoHelp</vh>
<v t="ekr.20031218072017.3993"><vh>showProgressBar</vh>
<v t="ekr.20031218072017.3994"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="EKR.20040422131742"><vh>(Improved Find dialog)</vh>
<v t="EKR.20040422131742.1"><vh>Linux bug: paste does not work in find panel</vh></v>
<v t="EKR.20040422131742.2"><vh>double-paste in searchbox</vh></v>
<v t="ekr.20031218072017.3082"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20031218072017.3083"><vh>checkArgs</vh></v>
<v t="ekr.20031218072017.3084"><vh>initBatchCommands</vh></v>
<v t="ekr.20031218072017.3085"><vh>initBatchText &amp; initNextText</vh></v>
<v t="ekr.20031218072017.3086"><vh>initInHeadline</vh></v>
<v t="ekr.20031218072017.3087"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20031218072017.3088"><vh>printLine</vh></v>
<v t="ekr.20031218072017.3089"><vh>restore</vh></v>
<v t="ekr.20031218072017.3090"><vh>save</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20031218072017.3902"><vh>find.createFrame</vh>
<v t="ekr.20031218072017.3904"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20041026092141"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3903"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3905"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040422131023"><vh>(Force update of log pane when reading derived files)</vh>
<v t="ekr.20031218072017.1473"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="EKR.20040423082910.2"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.3"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
</v>
<v t="EKR.20040422132037.1"><vh>(Use clover keys for Mac)</vh>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040424151409"><vh>4/22</vh>
<v t="EKR.20040424091902"><vh>(Ignore line endings when comparing derived files while writing)</vh>
<v t="ekr.20031218072017.2023"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="ekr.20031218072017.2024"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2025"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2026"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="EKR.20040424085407"><vh>atFile.compareFilesIgnoringLineEndings</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040519080820"><vh>In 4.2 a2</vh>
<v t="ekr.20040629162300.1"><vh>May 2004</vh>
<v t="ekr.20040319104735"><vh>(@file-thin)</vh>
<v t="EKR.20040428060432"><vh>Theory of operation</vh></v>
<v t="ekr.20040321064134.1"><vh>To do</vh></v>
<v t="EKR.20040427145035"><vh>What I did</vh></v>
<v t="EKR.20040427073852"><vh>fileCommands</vh>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080359.2"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20040324080819.2"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040324080819.3"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3049"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040321095547"><vh>Comparisons</vh>
<v t="ekr.20031218072017.3152"><vh>g.scanAtFileOptions (used in 3.x read code)</vh>
<v t="ekr.20031218072017.3153"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
</v>
<v t="EKR.20040427075250"><vh>Top level atFile</vh>
<v t="EKR.20040429081306"><vh>Read</vh>
<v t="ekr.20031218072017.2626"><vh> top_df.readAll</vh></v>
<v t="ekr.20031218072017.2757"><vh>new_df.readOpenFile</vh></v>
<v t="ekr.20031218072017.1812"><vh>top_df.read</vh>
<v t="ekr.20031218072017.1813"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1814"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="ekr.20031218072017.1815"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1816"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1817"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1818"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1819"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040429081306.1"><vh>Write</vh>
<v t="ekr.20031218072017.2720"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2015"><vh>top_df.writeAll</vh>
<v t="ekr.20031218072017.2016"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2017"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2018"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2642"><vh>top_df.writeOld/NewDerivedFiles</vh></v>
</v>
</v>
<v t="EKR.20040427180451"><vh>commands, position &amp; vnode methods...</vh>
<v t="ekr.20031218072017.1770"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040323100443"><vh>v.directParents (new method in 4.2)</vh></v>
<v t="ekr.20031218072017.3425"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
</v>
<v t="EKR.20040429082121"><vh>4.2 Code Gen Read</vh>
<v t="ekr.20031218072017.2758"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2760"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2761"><vh>readNormalLine</vh>
<v t="ekr.20031218072017.2762"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2763"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2764"><vh>start sentinels</vh>
<v t="EKR.20040430081719"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20031218072017.1752"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20031218072017.2765"><vh>readStartLeo</vh></v>
<v t="EKR.20040524070500"><vh>readStartMiddle</vh></v>
<v t="ekr.20031218072017.2766"><vh>readStartNode</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2769"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20031218072017.2770"><vh>end sentinels</vh>
<v t="EKR.20040430081719.1"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20031218072017.1954"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20031218072017.2771"><vh>readEndLeo</vh></v>
<v t="EKR.20040524071414"><vh>readEndMiddle</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2773"><vh>readEndOthers</vh></v>
<v t="ekr.20031218072017.1753"><vh>readLastDocLine</vh>
<v t="ekr.20031218072017.1754"><vh>&lt;&lt; new code &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1755"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2774"><vh>Unpaired sentinels</vh>
<v t="ekr.20031218072017.2775"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20031218072017.2776"><vh>readAfterRef</vh></v>
<v t="EKR.20040520093903"><vh>readClone</vh></v>
<v t="ekr.20031218072017.2777"><vh>readComment</vh></v>
<v t="ekr.20031218072017.2778"><vh>readDelims</vh></v>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2780"><vh>readNl</vh></v>
<v t="ekr.20031218072017.2781"><vh>readNonl</vh></v>
<v t="ekr.20031218072017.2782"><vh>readRef</vh></v>
<v t="ekr.20031218072017.2783"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20031218072017.2784"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20040321064134.5"><vh>createThinChild (4.2)</vh></v>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2766"><vh>readStartNode</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040429080901.1"><vh>4.2 Code Gen Write</vh>
<v t="ekr.20031218072017.2136"><vh>directiveKind (4.x)</vh></v>
<v t="EKR.20040429083147.3"><vh> Sentinels</vh>
<v t="ekr.20031218072017.2786"><vh>nodeSentinelText 4.x</vh>
<v t="ekr.20031218072017.2787"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="EKR.20040427095028"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20031218072017.2788"><vh>putLeadInSentinel</vh></v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
</v>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2755"><vh>newDerivedFile.__init__</vh>
<v t="EKR.20040427134616"><vh>&lt;&lt; Create the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2130"><vh>code lines... (4.x)</vh>
<v t="EKR.20040430081109.1"><vh>@all</vh>
<v t="EKR.20040430080943.1"><vh>putAtAllLine</vh></v>
<v t="EKR.20040430104717"><vh>putatAllBody</vh>
<v t="EKR.20040430104717.1"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
</v>
<v t="EKR.20040430081109.2"><vh>@others</vh>
<v t="ekr.20031218072017.2131"><vh>inAtOthers</vh></v>
<v t="ekr.20031218072017.2132"><vh>putAtOthersChild</vh></v>
<v t="ekr.20031218072017.2133"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20031218072017.2134"><vh>putCodeLine</vh></v>
<v t="ekr.20031218072017.2106"><vh>putRefLine &amp; allies</vh>
<v t="EKR.20040430081109"><vh>putRefLine</vh></v>
<v t="ekr.20031218072017.2107"><vh>putRefAt</vh></v>
<v t="ekr.20031218072017.2108"><vh>putAfterLastRef</vh></v>
<v t="ekr.20031218072017.2109"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20040128174042"><vh>atFile.warnAboutOrpanAndIgnoredNodes</vh></v>
</v>
</v>
<v t="EKR.20040425130443"><vh>(Clone bug)</vh>
<v t="EKR.20040502120243"><vh>Report &amp; fix</vh></v>
<v t="EKR.20040502123721"><vh>Changed code</vh>
<v t="ekr.20031218072017.2988"><vh>c.rootPosition &amp; c.setRootPosition</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3426"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
</v>
</v>
<v t="EKR.20040427074150"><vh>(Fixed problems with sboutline only option)</vh>
<v t="EKR.20040503071007"><vh>Notes</vh></v>
<v t="EKR.20040503070514"><vh>handleUserClick</vh></v>
<v t="EKR.20040503072338.1"><vh>Event handlers</vh>
<v t="ekr.20031218072017.2339"><vh>OnBoxClick</vh></v>
<v t="ekr.20031218072017.2346"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20031218072017.2337"><vh>OnActivate</vh>
<v t="ekr.20031218072017.2338"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040503090928.1"><vh>(Don't write top-level body text in @file-thin nodes)</vh>
<v t="EKR.20040503093407.1"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="ekr.20040128174042"><vh>atFile.warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20031218072017.2985"><vh>c.clearAllVisited</vh></v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
</v>
<v t="EKR.20040503064147.2"><vh>(Added -thin field to @+leo sentinel)</vh>
<v t="EKR.20040503105740"><vh>To do: override read logic if -thin seen</vh></v>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2789"><vh>putOpenLeoSentinel 4.x</vh></v>
</v>
<v t="EKR.20040517084551"><vh>(problems with tnodeList)</vh>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080359.2"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20040324080819.2"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040324080819.3"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3049"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2015"><vh>top_df.writeAll</vh>
<v t="ekr.20031218072017.2016"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2017"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2018"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2641"><vh>top_df.write, norefWrite, asisWrite</vh></v>
<v t="ekr.20031218072017.2122"><vh>new_df.norefWrite</vh>
<v t="ekr.20031218072017.2123"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20031218072017.2124"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2125"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2126"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2127"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040610082855"><vh>(Fixed crasher in openRecentFile)</vh>
<v t="EKR.20040610082855.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2081"><vh>openRecentFile</vh>
<v t="ekr.20031218072017.2082"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1596"><vh>g.doHook</vh></v>
</v>
</v>
</v>
<v t="EKR.20040601083927"><vh>In 4.2 a3</vh>
<v t="ekr.20040629162300.2"><vh>May 2004</vh>
<v t="EKR.20040519073926.1"><vh>(Fixed @file-thin copy bug)</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040519083814"><vh>(Fixed bug reading leo.nsi)</vh>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2387"><vh>old_df.scanAllDirectives</vh>
<v t="ekr.20031218072017.2388"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2389"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20031218072017.2390"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2391"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2392"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2393"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2394"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.2395"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2396"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2397"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2398"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2399"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2400"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040520080309"><vh>(Ignore directives in @all range)</vh>
<v t="EKR.20040430081109.1"><vh>@all</vh>
<v t="EKR.20040430080943.1"><vh>putAtAllLine</vh></v>
<v t="EKR.20040430104717"><vh>putatAllBody</vh>
<v t="EKR.20040430104717.1"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
</v>
</v>
<v t="EKR.20040520092739"><vh>(clone-sibling sentinel)</vh>
<v t="EKR.20040430081109.1"><vh>@all</vh>
<v t="EKR.20040430080943.1"><vh>putAtAllLine</vh></v>
<v t="EKR.20040430104717"><vh>putatAllBody</vh>
<v t="EKR.20040430104717.1"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20031218072017.2766"><vh>readStartNode</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="EKR.20040427095028"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20040321064134.5"><vh>createThinChild (4.2)</vh></v>
<v t="EKR.20040520093903"><vh>readClone</vh></v>
</v>
<v t="EKR.20040524050229"><vh>( @+-middle sentinels:  allow sections to be defined in grandchildren)</vh>
<v t="ekr.20031218072017.2621"><vh>&lt;&lt; global atFile constants &gt;&gt;</vh></v>
<v t="EKR.20040524053657"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2107"><vh>putRefAt</vh></v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="EKR.20040427095028"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2758"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2760"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2761"><vh>readNormalLine</vh>
<v t="ekr.20031218072017.2762"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2763"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2764"><vh>start sentinels</vh>
<v t="EKR.20040430081719"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20031218072017.1752"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20031218072017.2765"><vh>readStartLeo</vh></v>
<v t="EKR.20040524070500"><vh>readStartMiddle</vh></v>
<v t="ekr.20031218072017.2766"><vh>readStartNode</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2769"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20031218072017.2770"><vh>end sentinels</vh>
<v t="EKR.20040430081719.1"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20031218072017.1954"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20031218072017.2771"><vh>readEndLeo</vh></v>
<v t="EKR.20040524071414"><vh>readEndMiddle</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2773"><vh>readEndOthers</vh></v>
<v t="ekr.20031218072017.1753"><vh>readLastDocLine</vh>
<v t="ekr.20031218072017.1754"><vh>&lt;&lt; new code &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1755"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2774"><vh>Unpaired sentinels</vh>
<v t="ekr.20031218072017.2775"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20031218072017.2776"><vh>readAfterRef</vh></v>
<v t="EKR.20040520093903"><vh>readClone</vh></v>
<v t="ekr.20031218072017.2777"><vh>readComment</vh></v>
<v t="ekr.20031218072017.2778"><vh>readDelims</vh></v>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2780"><vh>readNl</vh></v>
<v t="ekr.20031218072017.2781"><vh>readNonl</vh></v>
<v t="ekr.20031218072017.2782"><vh>readRef</vh></v>
<v t="ekr.20031218072017.2783"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20031218072017.2784"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
</v>
<v t="EKR.20040524152405"><vh>(Fixed change headline bug)</vh>
<v t="EKR.20040524164424"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
<v t="ekr.20031218072017.1014"><vh>redraw_now</vh></v>
</v>
<v t="EKR.20040520075421.4"><vh>(Allow @thin as an abbreviation for @file-thin)</vh>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
</v>
<v t="EKR.20040520075421.5"><vh>(Got rid of spurious "Not written x.tmp" message after write errors)</vh>
<v t="EKR.20040525084847"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2720"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
</v>
<v t="EKR.20040526072519.5"><vh>(Made undo extensible)</vh>
<v t="ekr.20031218072017.3606"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20031218072017.3607"><vh>clearIvars</vh></v>
<v t="ekr.20031218072017.3604"><vh>&lt;&lt; Define optional ivars &gt;&gt;</vh></v>
<v t="EKR.20040526072519"><vh>&lt;&lt; define redoDispatchDict &gt;&gt;</vh></v>
<v t="EKR.20040526075238"><vh>&lt;&lt; define undoDispatchDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2030"><vh>redo &amp; allies</vh>
<v t="EKR.20040526090701.1"><vh>redoChangeAll</vh></v>
<v t="EKR.20040526090701.2"><vh>redoChangeHeadline</vh></v>
<v t="EKR.20040526072519.1"><vh>redoClone</vh></v>
<v t="EKR.20040526072519.2"><vh>redoDeleteNode</vh></v>
<v t="EKR.20040526072519.3"><vh>redoHoist &amp; redoDehoist</vh></v>
<v t="EKR.20040526072519.4"><vh>redoInsertNodes</vh></v>
<v t="EKR.20040526075238.1"><vh>redoMoveNode</vh></v>
<v t="EKR.20040526075238.2"><vh>redoDemote &amp; redoPromote</vh></v>
<v t="EKR.20040526075238.3"><vh>redoReplaceNodes &amp; replaceNodesContents</vh></v>
<v t="EKR.20040526075238.4"><vh>redoSortChildren/Siblings/TopLevel</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20031218072017.2039"><vh>undo &amp; allies</vh>
<v t="EKR.20040526090701.5"><vh>undoChangeAll</vh></v>
<v t="EKR.20040526090701.6"><vh>undoChangeHeadline</vh></v>
<v t="EKR.20040526083847"><vh>undoClone &amp; undoDragClone</vh></v>
<v t="EKR.20040526083847.1"><vh>undoDeleteNode</vh></v>
<v t="ekr.20031218072017.3620"><vh>undoDemote</vh></v>
<v t="EKR.20040526083847.2"><vh>undoHoist and undoDehoist</vh></v>
<v t="EKR.20040526084140"><vh>undoInsertNodes</vh></v>
<v t="EKR.20040526084140.1"><vh>undoMoveNode</vh></v>
<v t="ekr.20031218072017.3621"><vh>undoPromote</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1714"><vh>undoReplace</vh></v>
<v t="EKR.20040526090701.3"><vh>undoReplaceNodes &amp; undoReplaceNodesContents</vh></v>
<v t="ekr.20031218072017.3622"><vh>undoSortChildren</vh></v>
<v t="ekr.20031218072017.3623"><vh>undoSortSiblings</vh></v>
<v t="ekr.20031218072017.3624"><vh>undoSortTopLevel</vh></v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
</v>
<v t="EKR.20040526094429"><vh>registerUndoHandlers &amp; registerHandler</vh></v>
</v>
<v t="EKR.20040507093503"><vh>(Fixed problems saving unknownAttribute field)</vh>
<v t="EKR.20040526210456"><vh>Report 1</vh></v>
<v t="EKR.20040512084726"><vh>Report 2</vh></v>
<v t="EKR.20040526204036"><vh>getUnknownTag</vh></v>
<v t="EKR.20040526204036.1"><vh>getUnknownAttribute</vh></v>
<v t="ekr.20031218072017.1561"><vh>getTnode</vh>
<v t="ekr.20031218072017.1564"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1577"><vh>putTnode</vh></v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="EKR.20040526202501"><vh>putUnknownAttributes</vh></v>
</v>
<v t="EKR.20040529124312"><vh>(Fixed bugs in Dump Outline command)</vh>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20031218072017.3345"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="ekr.20040312145256"><vh>v.dump</vh></v>
</v>
<v t="EKR.20040525135323"><vh>(Created c, p, v iterators)</vh>
<v t="ekr.20040312090934"><vh>c.iterators</vh>
<v t="EKR.20040529091232"><vh>c.all_positions_iter == allNodes_iter</vh></v>
<v t="EKR.20040529091232.1"><vh>c.all_tnodes_iter</vh></v>
<v t="EKR.20040529091232.2"><vh>c.all_unique_tnodes_iter</vh></v>
<v t="EKR.20040529091232.3"><vh>c.all_vnodes_iter</vh></v>
<v t="EKR.20040529091232.4"><vh>c.all_unique_vnodes_iter</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="EKR.20040528151551"><vh>v.Iterators</vh>
<v t="EKR.20040528151551.2"><vh>self_subtree_iter</vh></v>
<v t="EKR.20040528151551.3"><vh>unique_subtree_iter</vh></v>
</v>
</v>
<v t="EKR.20040528070309.2"><vh>(Fixed undoReplaceNodes)</vh>
<v t="ekr.20031218072017.2983"><vh>c.currentPosition &amp; c.setCurrentPosition</vh></v>
<v t="ekr.20031218072017.1708"><vh>extractSection</vh>
<v t="ekr.20031218072017.1709"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1823"><vh>createLastChildNode</vh></v>
<v t="EKR.20040530115450"><vh>v.createUndoInfo</vh></v>
<v t="EKR.20040530121847"><vh>v.restoreUndoInfo</vh></v>
<v t="EKR.20040530120245"><vh>t.createUndoInfo</vh></v>
<v t="EKR.20040530121847.2"><vh>t.restoreUndoInfo</vh></v>
<v t="EKR.20040528075307"><vh>u.saveTree</vh>
<v t="EKR.20040530114124"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
</v>
<v t="EKR.20040530121329"><vh>u.restoreTree</vh></v>
<v t="EKR.20040526075238.3"><vh>redoReplaceNodes &amp; replaceNodesContents</vh></v>
<v t="EKR.20040526090701.3"><vh>undoReplaceNodes &amp; undoReplaceNodesContents</vh></v>
<v t="ekr.20031218072017.1714"><vh>undoReplace</vh></v>
<v t="EKR.20040528151551.4"><vh>v.updateVnodeListsFrom</vh></v>
<v t="EKR.20040528151551"><vh>v.Iterators</vh>
<v t="EKR.20040528151551.2"><vh>self_subtree_iter</vh></v>
<v t="EKR.20040528151551.3"><vh>unique_subtree_iter</vh></v>
</v>
<v t="EKR.20040528111420.1"><vh>v.swapIntoTree, v.swapLinks</vh></v>
</v>
</v>
</v>
<v t="EKR.20040610102329"><vh>In 4.2 b1</vh>
<v t="EKR.20040612121907"><vh>6/04</vh>
<v t="ekr.20040330092305.1"><vh>(Made "end1" and "ilde"events work again)</vh>
<v t="EKR.20040602113145"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1934"><vh>run &amp; allies</vh>
<v t="ekr.20041219072112"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20041219072416.1"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20040411081633"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1935"><vh>&lt;&lt; print encoding info &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
<v t="ekr.20031218072017.1937"><vh>computeLoadDir</vh></v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20031218072017.1938"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20031218072017.1939"><vh>getBatchScript</vh></v>
<v t="ekr.20041130093254"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20031218072017.1732"><vh>app.finishQuit</vh></v>
<v t="ekr.20031218072017.1596"><vh>g.doHook</vh></v>
<v t="ekr.20031218072017.1315"><vh>idle time functions (leoGlobals)</vh>
<v t="EKR.20040602125018"><vh>enableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.1"><vh>disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20031218072017.2611"><vh>app.destroyAllGlobalWindows</vh></v>
<v t="ekr.20031218072017.2616"><vh>app.forceShutdown</vh></v>
<v t="ekr.20031218072017.3442"><vh>doHandlersForTag</vh></v>
<v t="ekr.20031218072017.3443"><vh>registerHandler</vh></v>
</v>
<v t="ekr.20040105080119.4"><vh>(Put drawing hooks back in)</vh>
<v t="EKR.20040602144908"><vh>What I did</vh></v>
<v t="ekr.20031218072017.4144"><vh>Drawing (tkTree)</vh>
<v t="ekr.20031218072017.4145"><vh>About drawing and updating</vh></v>
<v t="ekr.20031218072017.1000"><vh>drawBox (tag_bind)</vh></v>
<v t="ekr.20031218072017.1002"><vh>drawIcon (tag_bind)</vh>
<v t="EKR.20040602150338"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1004"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040317171729"><vh>force_draw_node (new)</vh></v>
<v t="ekr.20040318090335"><vh>force_draw_node (old)</vh></v>
</v>
<v t="ekr.20031218072017.1005"><vh>drawText (bind)</vh>
<v t="ekr.20031218072017.1006"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
<v t="ekr.20040709194954"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1008"><vh>drawTree</vh>
<v t="ekr.20031218072017.1009"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317095510"><vh>drawUserIcon</vh>
<v t="ekr.20040317173849"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040317095153"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040317095153.1"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
<v t="ekr.20040317100702"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040317094609"><vh>drawUserIcons</vh></v>
<v t="ekr.20031218072017.1010"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040710050236"><vh>tree.drawClickFrame</vh></v>
<v t="ekr.20031218072017.4147"><vh>tree.getIconImage</vh></v>
<v t="ekr.20031218072017.1018"><vh>tree.idle_scrollTo</vh>
<v t="ekr.20040314092716"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040314092716.1"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4148"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="ekr.20040322122232"><vh>tree.scrollTo</vh></v>
<v t="ekr.20031218072017.4149"><vh>tree.yoffset</vh></v>
</v>
</v>
<v t="ekr.20040310092400"><vh>(Allowed &lt;/leo_header&gt; tag)</vh>
<v t="EKR.20040603092958"><vh>Report</vh></v>
<v t="ekr.20031218072017.3022"><vh>getClipboardHeader</vh></v>
<v t="ekr.20031218072017.1970"><vh>getLeoHeader</vh></v>
</v>
<v t="EKR.20040422091601.1"><vh>(Fixed syntax colouring Bug in html mode)</vh>
<v t="EKR.20040603103215"><vh>Report</vh></v>
<v t="ekr.20031218072017.1612"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2809"><vh>skip_string</vh></v>
</v>
<v t="ekr.20040206075634.1"><vh>Colorizing fixes</vh>
<v t="ekr.20031218072017.367"><vh>How to add support for a new language</vh>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20031218072017.369"><vh>&lt;&lt; Create the Target Language frame &gt;&gt; frame</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
<v t="ekr.20031218072017.371"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="ekr.20031218072017.372"><vh>actionscript keywords</vh></v>
<v t="ekr.20040206072057"><vh>c# keywords</vh></v>
<v t="ekr.20031218072017.373"><vh>c/c++ keywords</vh></v>
<v t="ekr.20040401103539"><vh>css keywords</vh></v>
<v t="ekr.20031218072017.374"><vh>elisp keywords</vh></v>
<v t="ekr.20031218072017.375"><vh>html keywords</vh></v>
<v t="ekr.20031218072017.376"><vh>java keywords</vh></v>
<v t="ekr.20031218072017.377"><vh>latex keywords</vh></v>
<v t="ekr.20031218072017.378"><vh>pascal keywords</vh></v>
<v t="ekr.20031218072017.379"><vh>perl keywords</vh></v>
<v t="ekr.20031218072017.380"><vh>php keywords</vh></v>
<v t="ekr.20031218072017.381"><vh>python keywords</vh></v>
<v t="ekr.20040331145826"><vh>rapidq keywords</vh></v>
<v t="ekr.20031218072017.382"><vh>rebol keywords</vh></v>
<v t="ekr.20040401111125"><vh>shell keywords</vh></v>
<v t="ekr.20031218072017.383"><vh>tcl/tk keywords</vh></v>
</v>
</v>
<v t="ekr.20040331145826.1"><vh>(done) RapidQ support</vh>
<v t="ekr.20040331145826"><vh>rapidq keywords</vh></v>
</v>
<v t="ekr.20040117111755"><vh>(done) css support</vh>
<v t="ekr.20040401104931"><vh>Notes</vh></v>
<v t="ekr.20040401103539"><vh>css keywords</vh></v>
<v t="ekr.20031218072017.1898"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1899"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1900"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1901"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20041107093219.3"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040117113539.1"><vh>(done) Coloring for Shell Scripts (Davide)</vh>
<v t="ekr.20040401111308"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1617"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20040106145421"><vh>(done) PHP syntax coloring</vh>
<v t="ekr.20040401110507"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1910"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1896"><vh>doNormalState</vh>
<v t="ekr.20031218072017.1897"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20031218072017.1898"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1899"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1900"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1901"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20041107093219.3"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1902"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1903"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1904"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1617"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1619"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1905"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1906"><vh>Vaid only in latex mode</vh>
<v t="ekr.20031218072017.1907"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1908"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20031218072017.1612"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1909"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1910"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1911"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1912"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1913"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1898"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1899"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1900"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1901"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20041107093219.3"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1902"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1903"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1904"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1617"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1619"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1905"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1907"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1612"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1909"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1910"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1911"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1912"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1913"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040218053305"><vh>(Replaced the word "Leo" with Leo icon in Find/Compare/Prefs windows)</vh></v>
<v t="EKR.20040603150347"><vh>(Improved Import command slightly)</vh>
<v t="ekr.20031218072017.3210"><vh>createOutline</vh>
<v t="ekr.20031218072017.3211"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040216153243.5"><vh>(Fixed Select All bug)</vh>
<v t="EKR.20040603151855"><vh>Report</vh></v>
<v t="ekr.20031218072017.3902"><vh>find.createFrame</vh>
<v t="ekr.20031218072017.3904"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20041026092141"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3903"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3905"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.839"><vh>&lt;&lt; define editMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4023"><vh>selectAllText</vh></v>
</v>
<v t="ekr.20031218072017.744"><vh>(Fixed bugs in @tab_width: support backspace with negative tab width)</vh>
<v t="EKR.20040604083436"><vh>Report</vh></v>
<v t="ekr.20031218072017.1390"><vh>scanAtTabwidthDirective</vh></v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040523193958"><vh>(Fixed bugs in Remove Sentinel command)</vh>
<v t="EKR.20040604160917"><vh>Report &amp; What I did</vh></v>
<v t="EKR.20040604155223.1"><vh>top_df.parseLeoSentinel</vh>
<v t="EKR.20040604155223"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2635"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2636"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="EKR.20040503105354"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2637"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2638"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3300"><vh>removeSentinelsCommand</vh>
<v t="ekr.20031218072017.3301"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3302"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1149"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3303"><vh>removeSentinelLines</vh>
<v t="ekr.20031218072017.3304"><vh>&lt;&lt; handle possible sentinel &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040512081330.1"><vh>(Eliminated spurious error in Import Derived File)</vh>
<v t="EKR.20040605172003"><vh>Report</vh></v>
<v t="EKR.20040605173101"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1810"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2387"><vh>old_df.scanAllDirectives</vh>
<v t="ekr.20031218072017.2388"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2389"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20031218072017.2390"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2391"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2392"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2393"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2394"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.2395"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2396"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2397"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2398"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2399"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2400"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2627"><vh>top_df.scanDefaultDirectory</vh>
<v t="ekr.20031218072017.2628"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2629"><vh>&lt;&lt; handle @path &gt;&gt; in df.scanDeafaultDirectory in leoAtFile.py</vh>
<v t="ekr.20031218072017.2630"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2631"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2632"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1812"><vh>top_df.read</vh>
<v t="ekr.20031218072017.1813"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1814"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="ekr.20031218072017.1815"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1816"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1817"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1818"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1819"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040605173241"><vh>(Removed gnx in headlines when importing thin derived files)</vh>
<v t="EKR.20040605175309"><vh>Report</vh></v>
<v t="ekr.20031218072017.1812"><vh>top_df.read</vh>
<v t="ekr.20031218072017.1813"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1814"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="ekr.20031218072017.1815"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1816"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1817"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1818"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1819"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040605181231"><vh>(Made sure change all doesn't keep redrawing the screen)</vh>
<v t="ekr.20031218072017.3069"><vh>changeAll</vh></v>
<v t="ekr.20031218072017.2029"><vh>drawTopTree (tag_bind)</vh>
<v t="ekr.20040710060809"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040606191836"><vh>Added 3 files to distribution lists</vh></v>
<v t="EKR.20040608092709"><vh>(Supported @tabwidth in indent/dedent)</vh>
<v t="EKR.20040608093403"><vh>Report</vh></v>
<v t="ekr.20031218072017.1824"><vh>dedentBody</vh></v>
<v t="ekr.20031218072017.1830"><vh>indentBody</vh></v>
</v>
<v t="EKR.20040606204504"><vh>(Fixed bugs reading 4.1 files)</vh>
<v t="EKR.20040606204504.1"><vh>Report</vh></v>
<v t="EKR.20040608095611"><vh>The file</vh></v>
<v t="ekr.20031218072017.2633"><vh>top_df.scanHeader</vh>
<v t="ekr.20031218072017.2634"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604155223.1"><vh>top_df.parseLeoSentinel</vh>
<v t="EKR.20040604155223"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2635"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2636"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="EKR.20040503105354"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2637"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2638"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.859"><vh>(Experimented with clone dragging)</vh>
<v t="EKR.20040608110312"><vh>Dragging (tk tree)</vh>
<v t="ekr.20031218072017.2342"><vh>tree.OnContinueDrag</vh>
<v t="ekr.20031218072017.2343"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="ekr.20031218072017.2344"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1776"><vh>tree.OnDrag</vh></v>
<v t="ekr.20031218072017.1777"><vh>tree.OnEndDrag</vh>
<v t="ekr.20031218072017.1778"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040609090913"><vh>(Fixed Open With bug)</vh>
<v t="EKR.20040609090913.1"><vh>Traceback</vh></v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>openWithTempFilePath</vh></v>
</v>
</v>
<v t="ekr.20040322074056"><vh>(Fixed Go To Line Number command)</vh>
<v t="EKR.20040604155223.1"><vh>top_df.parseLeoSentinel</vh>
<v t="EKR.20040604155223"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2635"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2636"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="EKR.20040503105354"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2637"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2638"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2864"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20031218072017.2865"><vh>&lt;&lt; set root to the nearest ancestor @file node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2866"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2867"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2868"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20031218072017.2869"><vh>&lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;</vh>
<v t="ekr.20041111093404"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="EKR.20040609110138"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2870"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20031218072017.2871"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2872"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2873"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2874"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2875"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2876"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2877"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20031218072017.2878"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2879"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20031218072017.2880"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2881"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2882"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
</v>
<v t="EKR.20040609160237"><vh>(Fixed crash when importing Borland wstring.cpp)</vh>
<v t="EKR.20040609160237.1"><vh>Traceback</vh></v>
<v t="ekr.20031218072017.3160"><vh>skip_braces</vh></v>
<v t="ekr.20031218072017.3250"><vh>scanCText</vh>
<v t="ekr.20031218072017.3251"><vh>&lt;&lt; define scanCText vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3260"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3261"><vh>&lt;&lt; handle equal sign in C&gt;&gt;</vh></v>
<v t="ekr.20031218072017.3262"><vh>&lt;&lt; handle open paren in C &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3263"><vh>&lt;&lt; handle semicolon in C &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3252"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="ekr.20031218072017.3253"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3254"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt; (scans function)</vh>
<v t="ekr.20031218072017.3255"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3256"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3257"><vh>&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="ekr.20031218072017.3258"><vh>&lt;&lt; create children for the namespace &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3259"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3264"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040329094003.3"><vh>(Import now creates absolute path)</vh>
<v t="ekr.20031218072017.3210"><vh>createOutline</vh>
<v t="ekr.20031218072017.3211"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040521084602"><vh>(Checked PHP import bug: works for me)</vh>
<v t="EKR.20040610082623"><vh>Report</vh></v>
<v t="EKR.20040610082623.1"><vh>Reply</vh></v>
</v>
</v>
<v t="EKR.20040612121907.1"><vh>6/11</vh>
<v t="ekr.20040115163454"><vh>(Created @killcolor directive)</vh>
<v t="ekr.20031218072017.1595"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="EKR.20040610094819"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1260"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20031218072017.1261"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1262"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2805"><vh>useSyntaxColoring</vh></v>
<v t="ekr.20031218072017.1377"><vh>scanColorDirectives</vh>
<v t="ekr.20031218072017.1378"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1379"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040610123559"><vh>(Fixed bug in insertBodyTime)</vh>
<v t="EKR.20040610123559.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.1832"><vh>getTime</vh></v>
</v>
<v t="EKR.20040603074929"><vh>(Added Paste Retaining Clones command)</vh>
<v t="EKR.20040610131603"><vh>What I did</vh></v>
<v t="ekr.20031218072017.3768"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1557"><vh>finishPaste</vh>
<v t="ekr.20031218072017.1558"><vh>&lt;&lt; reassign tnode indices and clear all clone links &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1559"><vh>getLeoOutline (from clipboard)</vh>
<v t="EKR.20040610134756"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2004"><vh>canonicalTnodeIndex</vh></v>
<v t="ekr.20031218072017.1561"><vh>getTnode</vh>
<v t="ekr.20031218072017.1564"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1548"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20031218072017.1549"><vh>cutOutline</vh></v>
<v t="ekr.20031218072017.1550"><vh>copyOutline</vh></v>
<v t="ekr.20031218072017.1551"><vh>pasteOutline</vh>
<v t="ekr.20050418084539"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050418084539.2"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="EKR.20040610130943"><vh>pasteOutlineRetainingClones</vh></v>
</v>
</v>
<v t="EKR.20040610174603"><vh>(Fixed bug when pasting large text into headlines)</vh>
<v t="EKR.20040610174603.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
<v t="ekr.20031218072017.1333"><vh>onHeadChanged</vh></v>
<v t="ekr.20031218072017.1335"><vh>idle_head_key</vh>
<v t="ekr.20031218072017.1337"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="EKR.20040614075003"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1336"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1338"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1339"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1340"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040611081747.2"><vh>(Fixed bug in delete command)</vh>
<v t="ekr.20031218072017.2863"><vh>delete</vh></v>
<v t="ekr.20031218072017.4023"><vh>selectAllText</vh></v>
</v>
</v>
<v t="EKR.20040612121907.2"><vh>6/12</vh>
<v t="EKR.20040612112111"><vh>Mass code changes to test.leo, leoPy.leo and leoPlugins.leo</vh></v>
<v t="EKR.20040612113045"><vh>(Fixed oops: nullGui setIdleTimeHook)</vh>
<v t="ekr.20031218072017.3739"><vh>Idle time</vh></v>
</v>
<v t="EKR.20040612094305"><vh>Added readLineGenerator &amp; readLineClass to leoGlobals</vh></v>
<v t="EKR.20040612093706"><vh>(Investigated clone-drag bug in 4.1)</vh>
<v t="EKR.20040612093706.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2945"><vh>Dragging (commands)</vh>
<v t="ekr.20031218072017.2353"><vh>c.dragAfter</vh></v>
<v t="ekr.20031218072017.2946"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="ekr.20031218072017.2947"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20031218072017.2948"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="EKR.20040608110312"><vh>Dragging (tk tree)</vh>
<v t="ekr.20031218072017.2342"><vh>tree.OnContinueDrag</vh>
<v t="ekr.20031218072017.2343"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="ekr.20031218072017.2344"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1776"><vh>tree.OnDrag</vh></v>
<v t="ekr.20031218072017.1777"><vh>tree.OnEndDrag</vh>
<v t="ekr.20031218072017.1778"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
</v>
<v t="EKR.20040612141359"><vh>(Fixed problems with trailing newlines and spurious changed bit)</vh>
<v t="EKR.20040612152431"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1019"><vh>tree.select</vh>
<v t="ekr.20031218072017.1020"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1021"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20031218072017.1022"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1023"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1024"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1025"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2989"><vh>c.setChanged</vh></v>
</v>
<v t="EKR.20040612213138"><vh>(Much better error handling in executeScript)</vh>
<v t="EKR.20040613000310"><vh>What I did</vh></v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3112"><vh>es_exception</vh>
<v t="ekr.20050220030850"><vh>test_g_es_exception</vh></v>
<v t="ekr.20040731211839"><vh>&lt;&lt; look for lines containing a specific message &gt;&gt;</vh>
<v t="EKR.20040612223431"><vh>&lt;&lt; compute n from the line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040731204831"><vh>getLastTracebackLineNumber</vh></v>
</v>
<v t="ekr.20031218072017.2864"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20031218072017.2865"><vh>&lt;&lt; set root to the nearest ancestor @file node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2866"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2867"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2868"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20031218072017.2869"><vh>&lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;</vh>
<v t="ekr.20041111093404"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="EKR.20040609110138"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2870"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20031218072017.2871"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2872"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2873"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2874"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2875"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2876"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2877"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20031218072017.2878"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2879"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20031218072017.2880"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2881"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2882"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="EKR.20040612232221"><vh>goToScriptLineNumber</vh></v>
</v>
</v>
<v t="EKR.20040614151841.1"><vh>6/14</vh>
<v t="EKR.20040614071102"><vh>(Created getScript)</vh>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh>
<v t="ekr.20050211100535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040614072333"><vh>(Fixed headline key handling)</vh>
<v t="ekr.20031218072017.1335"><vh>idle_head_key</vh>
<v t="ekr.20031218072017.1337"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="EKR.20040614075003"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1336"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1338"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1339"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1340"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040617063837"><vh>6/15</vh>
<v t="EKR.20040615105613.2"><vh>(Fixed Problems executing script)</vh>
<v t="EKR.20040615105613.3"><vh>Report</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20031218072017.2387"><vh>old_df.scanAllDirectives</vh>
<v t="ekr.20031218072017.2388"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2389"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20031218072017.2390"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2391"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2392"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2393"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2394"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.2395"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2396"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2397"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2398"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2399"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2400"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040617072908"><vh>(Fixed problem with PHP and @last)</vh>
<v t="EKR.20040617155244"><vh>Reports</vh>
<v t="EKR.20040617072908.2"><vh>@last fails with multiple newlines</vh></v>
<v t="EKR.20040617072908.3"><vh>@last always end with a newline character</vh></v>
</v>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
</v>
</v>
<v t="EKR.20040617083707"><vh>6/17</vh>
<v t="EKR.20040615010747"><vh>(Fixed bug when writing unknownAttributes</vh>
<v t="EKR.20040615010747.1"><vh>Report</vh></v>
<v t="ekr.20040317094609"><vh>drawUserIcons</vh></v>
</v>
<v t="EKR.20040617063225"><vh>(Fixed bugs opening a second file)</vh>
<v t="EKR.20040617063225.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2188"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20031218072017.2189"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
<v t="ekr.20031218072017.2052"><vh>openWithFileName</vh></v>
<v t="ekr.20031218072017.3995"><vh>Tk bindings...</vh></v>
</v>
<v t="EKR.20040615105613"><vh>(Recovered nodes when reading .leo files containing topology errors)</vh>
<v t="EKR.20040615105613.1"><vh>Report</vh></v>
<v t="EKR.20040616102910"><vh>Workaround</vh></v>
<v t="EKR.20040617103332"><vh>Fix</vh></v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
<v t="ekr.20040326054052"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1860"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20031218072017.1861"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040326063413"><vh>getExistingVnode</vh></v>
<v t="ekr.20031218072017.2004"><vh>canonicalTnodeIndex</vh></v>
</v>
</v>
<v t="EKR.20040621080839"><vh>6/20</vh>
<v t="EKR.20040620094529.4"><vh>(Generalized write-to-string logic)</vh>
<v t="ekr.20031218072017.2138"><vh>os and allies</vh>
<v t="EKR.20040620094529"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="EKR.20040620094529.1"><vh>onl &amp; onl_sent</vh></v>
<v t="EKR.20040620094529.2"><vh>os</vh></v>
</v>
<v t="ekr.20031218072017.2645"><vh>&lt;&lt; init atFile ivars &gt;&gt;</vh></v>
<v t="ekr.20040331083824.1"><vh>g.fileLikeObject</vh>
<v t="ekr.20050404151753"><vh> ctor</vh></v>
<v t="ekr.20050404151753.1"><vh>clear</vh></v>
<v t="ekr.20050404151753.2"><vh>close</vh></v>
<v t="ekr.20050404151753.3"><vh>flush</vh></v>
<v t="ekr.20050404151753.4"><vh>get &amp; getvalue</vh></v>
<v t="ekr.20050404151753.5"><vh>readline</vh></v>
<v t="ekr.20050404151753.6"><vh>write</vh></v>
</v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh>
<v t="ekr.20050211100535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20031218072017.2720"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
<v t="ekr.20031218072017.2718"><vh>old_df.closeWriteFile</vh></v>
<v t="ekr.20031218072017.2113"><vh>new_df.closeWriteFile</vh></v>
</v>
<v t="EKR.20040618071040"><vh>(Fixed bug: @last silently fails when extra lines exist)</vh>
<v t="EKR.20040618071040.1"><vh>Report</vh></v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
</v>
</v>
<v t="EKR.20040622083920"><vh>6/22</vh>
<v t="EKR.20040622060649.1"><vh>(Fixed hang when dragging from one clone copy to another)</vh>
<v t="EKR.20040608110312"><vh>Dragging (tk tree)</vh>
<v t="ekr.20031218072017.2342"><vh>tree.OnContinueDrag</vh>
<v t="ekr.20031218072017.2343"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="ekr.20031218072017.2344"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1776"><vh>tree.OnDrag</vh></v>
<v t="ekr.20031218072017.1777"><vh>tree.OnEndDrag</vh>
<v t="ekr.20031218072017.1778"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040623090054.1"><vh>(Added case_sensitiveLanguage to colorizer)</vh>
<v t="EKR.20040623090054"><vh>&lt;&lt; define global colorizer data &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1606"><vh>&lt;&lt; ivars for communication between colorizeAnyLanguage and its allies &gt;&gt;</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
</v>
<v t="EKR.20040624091333"><vh>6/24</vh>
<v t="EKR.20040624081759"><vh>(Fixed crash in Write Missing)</vh>
<v t="EKR.20040624081759.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2019"><vh>top_df.writeMissing</vh>
<v t="ekr.20031218072017.2020"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2021"><vh>&lt;&lt; create df.outputFile &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2022"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2113"><vh>new_df.closeWriteFile</vh></v>
</v>
</v>
<v t="EKR.20040625092523"><vh>6/25</vh>
<v t="EKR.20040622104344"><vh>(Clone-sib is only generated for @all trees)</vh>
<v t="EKR.20040625085548"><vh>Resolution</vh></v>
<v t="ekr.20040321064134.5"><vh>createThinChild (4.2)</vh></v>
<v t="EKR.20040523104815"><vh>scanForClonedSibs</vh></v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
<v t="ekr.20031218072017.2132"><vh>putAtOthersChild</vh></v>
</v>
<v t="EKR.20040625090549.1"><vh>(Write entire @thin tree on write errors</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080359.2"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20040324080819.2"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040324080819.3"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3049"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040625090549"><vh>(Fixed bug in getScript)</vh>
<v t="EKR.20040625093305"><vh>Report</vh></v>
<v t="ekr.20031218072017.2720"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh>
<v t="ekr.20050211100535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="EKR.20040619122528"><vh>(Fixed problems with @all)</vh>
<v t="EKR.20040621081709"><vh>What I did</vh></v>
<v t="ekr.20031218072017.3179"><vh>is_special</vh></v>
<v t="ekr.20031218072017.1620"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="ekr.20040128174042"><vh>atFile.warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20031218072017.2136"><vh>directiveKind (4.x)</vh></v>
<v t="ekr.20031218072017.2111"><vh>Writing (4.x)</vh>
<v t="ekr.20031218072017.2112"><vh>Top level</vh>
<v t="ekr.20031218072017.2113"><vh>new_df.closeWriteFile</vh></v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2122"><vh>new_df.norefWrite</vh>
<v t="ekr.20031218072017.2123"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20031218072017.2124"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2125"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2126"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2127"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2130"><vh>code lines... (4.x)</vh>
<v t="EKR.20040430081109.1"><vh>@all</vh>
<v t="EKR.20040430080943.1"><vh>putAtAllLine</vh></v>
<v t="EKR.20040430104717"><vh>putatAllBody</vh>
<v t="EKR.20040430104717.1"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
</v>
<v t="EKR.20040430081109.2"><vh>@others</vh>
<v t="ekr.20031218072017.2131"><vh>inAtOthers</vh></v>
<v t="ekr.20031218072017.2132"><vh>putAtOthersChild</vh></v>
<v t="ekr.20031218072017.2133"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20031218072017.2134"><vh>putCodeLine</vh></v>
<v t="ekr.20031218072017.2106"><vh>putRefLine &amp; allies</vh>
<v t="EKR.20040430081109"><vh>putRefLine</vh></v>
<v t="ekr.20031218072017.2107"><vh>putRefAt</vh></v>
<v t="ekr.20031218072017.2108"><vh>putAfterLastRef</vh></v>
<v t="ekr.20031218072017.2109"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1745"><vh>doc lines... (write)</vh>
<v t="ekr.20031218072017.1746"><vh>putBlankDocLine</vh></v>
<v t="ekr.20031218072017.1747"><vh>putStartDocLine</vh></v>
<v t="ekr.20031218072017.1748"><vh>putDocLine</vh>
<v t="ekr.20031218072017.1749"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1750"><vh>putEndDocLine</vh></v>
<v t="ekr.20031218072017.1751"><vh>putPending</vh></v>
</v>
<v t="ekr.20031218072017.2135"><vh>Writing Utils...</vh>
<v t="ekr.20031218072017.2136"><vh>directiveKind (4.x)</vh></v>
<v t="ekr.20031218072017.2137"><vh>hasSectionName</vh></v>
<v t="ekr.20031218072017.2138"><vh>os and allies</vh>
<v t="EKR.20040620094529"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="EKR.20040620094529.1"><vh>onl &amp; onl_sent</vh></v>
<v t="EKR.20040620094529.2"><vh>os</vh></v>
</v>
<v t="ekr.20031218072017.1921"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20031218072017.1922"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="EKR.20040625103148"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625103148.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040623101617.4"><vh>(Handled inner @language and @comment properly)</vh>
<v t="EKR.20040625095103.1"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.1921"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20031218072017.1922"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="EKR.20040625103148"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625103148.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1380"><vh>Directive utils...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.1385"><vh>findReference</vh></v>
<v t="ekr.20031218072017.1260"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20031218072017.1261"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1262"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1386"><vh>getOutputNewline</vh></v>
<v t="ekr.20031218072017.1387"><vh>scanAtEncodingDirective</vh></v>
<v t="ekr.20031218072017.1388"><vh>scanAtLineendingDirective</vh></v>
<v t="ekr.20031218072017.1389"><vh>scanAtPagewidthDirective</vh></v>
<v t="ekr.20031218072017.1390"><vh>scanAtTabwidthDirective</vh></v>
<v t="ekr.20040715155607"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20040712084911.1"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040626110541"><vh>6/28</vh>
<v t="EKR.20040623101617"><vh>(Fixed double print in Execute Script command)</vh>
<v t="EKR.20040623101617.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040623102728"><vh>(Improved error handling for unknownAttributes)</vh>
<v t="EKR.20040623102728.1"><vh>Report</vh></v>
<v t="EKR.20040623102728.2"><vh>Patch (Won't do)</vh></v>
<v t="ekr.20031218072017.1561"><vh>getTnode</vh>
<v t="ekr.20031218072017.1564"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="EKR.20040526204036"><vh>getUnknownTag</vh></v>
<v t="EKR.20040526204036.1"><vh>getUnknownAttribute</vh></v>
<v t="EKR.20040526202501"><vh>putUnknownAttributes</vh></v>
</v>
</v>
<v t="EKR.20040628084530"><vh>6/29</vh>
<v t="EKR.20040628080251.2"><vh>(Fixed bug reading leo.nsi)</vh>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040610125924"><vh>(Changed install script as suggested by Scott Beardsley)</vh>
<v t="EKR.20040610125924.1"><vh>Report1</vh>
<v t="EKR.20040628080251"><vh>(done) Use @first #!/bin/sh</vh></v>
<v t="EKR.20040628080251.1"><vh>(done) bin dir is not created</vh></v>
</v>
<v t="EKR.20040617074620.2"><vh>(done) Report 2</vh></v>
</v>
<v t="EKR.20040524053657.1"><vh>(Better reporting of body text conflicts)</vh>
<v t="ekr.20031218072017.853"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1812"><vh>top_df.read</vh>
<v t="ekr.20031218072017.1813"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1814"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="ekr.20031218072017.1815"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1816"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1817"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1818"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1819"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040904081433"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh></v>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040623101617.4"><vh>(Handled inner @language and @comment properly)</vh>
<v t="EKR.20040625095103.1"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.1921"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20031218072017.1922"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="EKR.20040625103148"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625103148.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1380"><vh>Directive utils...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20031218072017.1381"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20031218072017.1382"><vh>set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>set_language</vh></v>
</v>
<v t="ekr.20031218072017.1385"><vh>findReference</vh></v>
<v t="ekr.20031218072017.1260"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20031218072017.1261"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1262"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1386"><vh>getOutputNewline</vh></v>
<v t="ekr.20031218072017.1387"><vh>scanAtEncodingDirective</vh></v>
<v t="ekr.20031218072017.1388"><vh>scanAtLineendingDirective</vh></v>
<v t="ekr.20031218072017.1389"><vh>scanAtPagewidthDirective</vh></v>
<v t="ekr.20031218072017.1390"><vh>scanAtTabwidthDirective</vh></v>
<v t="ekr.20040715155607"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20040712084911.1"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040701065235"><vh>in 4.2 b2</vh>
<v t="EKR.20040614151841.2"><vh>(More changes to read/write logic) New in 4.2 Beta 2</vh>
<v t="ekr.20040630070900.1"><vh>Savedmarks and expantion state in &lt;v&gt; elements for @thin nodes</vh></v>
<v t="ekr.20040701083349.1"><vh>Made sure to write @ignored @thin trees</vh></v>
<v t="EKR.20040626110728"><vh>Notes</vh></v>
<v t="ekr.20040701065235.4"><vh>Writing...</vh>
<v t="ekr.20031218072017.1577"><vh>putTnode</vh></v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="EKR.20040526202501"><vh>putUnknownAttributes</vh></v>
<v t="EKR.20040627113418"><vh>putDescendentUnknownAttributes</vh></v>
<v t="ekr.20040701065235.2"><vh>putDescendentAttributes</vh></v>
</v>
<v t="ekr.20040701065235.5"><vh>Reading...</vh>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="EKR.20040526204036.1"><vh>getUnknownAttribute</vh></v>
<v t="EKR.20040627114602"><vh>getDescendentUnknownAttributes</vh></v>
<v t="ekr.20040701065235.1"><vh>getDescendentAttributes</vh></v>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040701193902"><vh>(Fixed major pychecker warnings)</vh>
<v t="ekr.20040701193902.1"><vh>leoAtFile.py</vh></v>
<v t="ekr.20040701193902.2"><vh>leoColor.py</vh></v>
<v t="ekr.20040701193902.3"><vh>leoCommands.py</vh></v>
<v t="ekr.20040701193902.4"><vh>leoFileCommands.py</vh></v>
<v t="ekr.20040701193902.5"><vh>leoFind.py</vh></v>
<v t="ekr.20040701193902.6"><vh>leoImport.py</vh></v>
<v t="ekr.20040701193902.7"><vh>leoNodes.py</vh></v>
<v t="ekr.20040701193902.8"><vh>leoTkinterFind.py</vh></v>
<v t="ekr.20040701193902.9"><vh>leoTkinterFrame.py</vh></v>
<v t="ekr.20040701193902.10"><vh>leoTkinterTree.py</vh></v>
<v t="ekr.20040701193902.11"><vh>leoUndo.py</vh></v>
</v>
<v t="ekr.20040701194847"><vh>(Suppressed more pychecker errors)</vh>
<v t="ekr.20040701203211"><vh>Reports</vh></v>
<v t="ekr.20031218072017.1979"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
</v>
<v t="ekr.20040701212305"><vh>(Fixed still more pychecker errors)</vh></v>
<v t="ekr.20040702080759"><vh>(Marked all related @thin nodes dirty when a node changesd)</vh>
<v t="ekr.20040702090737"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2039"><vh>undo &amp; allies</vh>
<v t="EKR.20040526090701.5"><vh>undoChangeAll</vh></v>
<v t="EKR.20040526090701.6"><vh>undoChangeHeadline</vh></v>
<v t="EKR.20040526083847"><vh>undoClone &amp; undoDragClone</vh></v>
<v t="EKR.20040526083847.1"><vh>undoDeleteNode</vh></v>
<v t="ekr.20031218072017.3620"><vh>undoDemote</vh></v>
<v t="EKR.20040526083847.2"><vh>undoHoist and undoDehoist</vh></v>
<v t="EKR.20040526084140"><vh>undoInsertNodes</vh></v>
<v t="EKR.20040526084140.1"><vh>undoMoveNode</vh></v>
<v t="ekr.20031218072017.3621"><vh>undoPromote</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1714"><vh>undoReplace</vh></v>
<v t="EKR.20040526090701.3"><vh>undoReplaceNodes &amp; undoReplaceNodesContents</vh></v>
<v t="ekr.20031218072017.3622"><vh>undoSortChildren</vh></v>
<v t="ekr.20031218072017.3623"><vh>undoSortSiblings</vh></v>
<v t="ekr.20031218072017.3624"><vh>undoSortTopLevel</vh></v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
</v>
<v t="ekr.20031218072017.2030"><vh>redo &amp; allies</vh>
<v t="EKR.20040526090701.1"><vh>redoChangeAll</vh></v>
<v t="EKR.20040526090701.2"><vh>redoChangeHeadline</vh></v>
<v t="EKR.20040526072519.1"><vh>redoClone</vh></v>
<v t="EKR.20040526072519.2"><vh>redoDeleteNode</vh></v>
<v t="EKR.20040526072519.3"><vh>redoHoist &amp; redoDehoist</vh></v>
<v t="EKR.20040526072519.4"><vh>redoInsertNodes</vh></v>
<v t="EKR.20040526075238.1"><vh>redoMoveNode</vh></v>
<v t="EKR.20040526075238.2"><vh>redoDemote &amp; redoPromote</vh></v>
<v t="EKR.20040526075238.3"><vh>redoReplaceNodes &amp; replaceNodesContents</vh></v>
<v t="EKR.20040526075238.4"><vh>redoSortChildren/Siblings/TopLevel</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
<v t="ekr.20031218072017.1319"><vh>(Key handlers)</vh>
<v t="ekr.20031218072017.1320"><vh>body key handlers</vh>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (called from core)</vh></v>
<v t="ekr.20031218072017.1330"><vh>onBodyKey</vh>
<v t="ekr.20040105223536"><vh>handleStatusLineKey</vh>
<v t="ekr.20040105223536.1"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
</v>
<v t="ekr.20031218072017.1332"><vh>headline key handlers (tree)</vh>
<v t="ekr.20031218072017.1333"><vh>onHeadChanged</vh></v>
<v t="ekr.20031218072017.1334"><vh>OnHeadlineKey</vh></v>
<v t="ekr.20031218072017.1335"><vh>idle_head_key</vh>
<v t="ekr.20031218072017.1337"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="EKR.20040614075003"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1336"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1338"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1339"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1340"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1766"><vh>Move... (Commands)</vh>
<v t="ekr.20031218072017.1767"><vh>demote</vh></v>
<v t="ekr.20031218072017.1768"><vh>moveOutlineDown</vh>
<v t="ekr.20031218072017.1769"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1770"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
<v t="ekr.20031218072017.1772"><vh>moveOutlineUp</vh>
<v t="ekr.20031218072017.1773"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1774"><vh>promote</vh></v>
</v>
<v t="ekr.20031218072017.2945"><vh>Dragging (commands)</vh>
<v t="ekr.20031218072017.2353"><vh>c.dragAfter</vh></v>
<v t="ekr.20031218072017.2946"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="ekr.20031218072017.2947"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20031218072017.2948"><vh>c.dragCloneAfter</vh></v>
</v>
</v>
<v t="ekr.20040704102411"><vh>(Fixed bug when reading  4.1 files with topology errors)</vh>
<v t="ekr.20040326063413"><vh>getExistingVnode</vh></v>
</v>
</v>
<v t="ekr.20040809071510"><vh>in 4.2 b3</vh>
<v t="ekr.20040809071510.1"><vh>(Cleaned up recognition of @file nodes)</vh>
<v t="ekr.20040809071510.2"><vh>g.scanAtFileOptions (used in 3.x read code)</vh>
<v t="ekr.20040809071510.3"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.4"><vh>skip_id</vh></v>
<v t="ekr.20040809071510.5"><vh>p.Comparisons</vh></v>
<v t="ekr.20040809071510.6"><vh>v.Comparisons</vh>
<v t="ekr.20040809071510.7"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20040809071510.8"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20040809071510.9"><vh>at...FileNodeName</vh></v>
<v t="ekr.20040809071510.10"><vh>isAtAllNode</vh></v>
<v t="ekr.20040809071510.11"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040809071510.12"><vh>isAt...FileNode</vh></v>
<v t="ekr.20040809071510.13"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20040809071510.14"><vh>isAtOthersNode</vh></v>
<v t="ekr.20040809071510.15"><vh>matchHeadline</vh></v>
</v>
</v>
<v t="ekr.20040809071510.16"><vh>(Made sure the user is given a chance to save read-only files)</vh>
<v t="ekr.20040809071510.17"><vh>Notes</vh></v>
<v t="ekr.20040809071510.18"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20040809071510.19"><vh>promptForSave</vh>
<v t="ekr.20040809071510.20"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.21"><vh>save</vh></v>
<v t="ekr.20040809071510.22"><vh>write_Leo_file</vh>
<v t="ekr.20040809071510.23"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.24"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20040809071510.25"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040809071510.26"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20040809071510.27"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.28"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040809071510.29"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20040809071510.30"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040809071510.31"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20040809071510.32"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20040809071510.27"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.33"><vh>(Added p.copyTreeAfter, copyTreeTo)</vh>
<v t="ekr.20040809071510.34"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
</v>
<v t="ekr.20040809071510.35"><vh>(Improved unit testing)</vh>
<v t="ekr.20040809071510.36"><vh>What I did</vh></v>
<v t="ekr.20040809071510.37"><vh>g.getScript</vh></v>
<v t="ekr.20040809071510.38"><vh>c.executeScript</vh>
<v t="ekr.20040809071510.39"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20040809071510.40"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.41"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.42"><vh>c.checkOutline</vh>
<v t="ekr.20040809071510.43"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040809071510.44"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040809071510.45"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040809071510.46"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040809071510.47"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040809071510.48"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040809071510.49"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040809071510.50"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040809071510.51"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040809071510.52"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040809071510.53"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040809071510.54"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040809071510.55"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.56"><vh>(Added 3 .css files to cvs and distribution)</vh></v>
<v t="ekr.20040809071510.57"><vh>(Fixed double-click-drag) Now reverted</vh>
<v t="ekr.20040809071510.58"><vh>Patch</vh></v>
<v t="ekr.20040809071510.59"><vh>In app.gui.Tkinter.utils</vh>
<v t="ekr.20040809071510.60"><vh>setTextSelection</vh></v>
</v>
<v t="ekr.20040809071510.61"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="ekr.20040809071510.62"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20040809071510.63"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20040809071510.64"><vh>OnActivateBody</vh></v>
</v>
<v t="ekr.20040809071510.65"><vh>(Scroll the tree pane on Shift left/right click)</vh>
<v t="ekr.20040809071510.66"><vh>Changed find_closest to find_overlapping</vh></v>
<v t="ekr.20040809071510.67"><vh>f.createCanvas</vh>
<v t="ekr.20040809071510.68"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.69"><vh>(Underline tree nodes when entered)</vh></v>
<v t="ekr.20040809071510.70"><vh>(Allowed multiple files in import dialogs)</vh>
<v t="ekr.20040809071510.71"><vh>Report</vh></v>
<v t="ekr.20040809071510.72"><vh>CheckVersion (Dave Hein)</vh></v>
<v t="ekr.20040809071510.73"><vh>app.gui.Tkinter file dialogs</vh></v>
<v t="ekr.20040809071510.74"><vh>Changed import commands to accept lists of paths</vh>
<v t="ekr.20040809071510.75"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20040809071510.76"><vh>exportHeadlines</vh></v>
<v t="ekr.20040809071510.77"><vh>flattenOutline</vh></v>
<v t="ekr.20040809071510.78"><vh>importAtRoot</vh></v>
<v t="ekr.20040809071510.79"><vh>importAtFile</vh></v>
<v t="ekr.20040809071510.80"><vh>importCWEBFiles</vh></v>
<v t="ekr.20040809071510.81"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20040809071510.82"><vh>importNowebFiles</vh></v>
<v t="ekr.20040809071510.83"><vh>outlineToCWEB</vh></v>
<v t="ekr.20040809071510.84"><vh>outlineToNoweb</vh></v>
<v t="ekr.20040809071510.85"><vh>removeSentinels</vh></v>
<v t="ekr.20040809071510.86"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20040809071510.87"><vh>Changed import helpers to accept lists of paths</vh>
<v t="ekr.20040809071510.88"><vh>removeSentinelsCommand</vh>
<v t="ekr.20040809071510.89"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20040809071510.90"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20040809071510.91"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.92"><vh>importWebCommand</vh></v>
<v t="ekr.20040809071510.93"><vh>importFilesCommand</vh>
<v t="ekr.20040809071510.94"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.95"><vh>importDerivedFiles</vh></v>
<v t="ekr.20040809071510.96"><vh>createOutline</vh>
<v t="ekr.20040809071510.97"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.98"><vh>(Improved g.importFromPath)</vh>
<v t="ekr.20040809071510.99"><vh>g,importFromPath</vh></v>
</v>
<v t="ekr.20040809071510.100"><vh>(Removed scriptfile support)</vh>
<v t="ekr.20040809071510.37"><vh>g.getScript</vh></v>
</v>
<v t="ekr.20040809071510.101"><vh>(Fixed major bug in write logic)</vh>
<v t="ekr.20040809071510.102"><vh>Notes</vh></v>
<v t="ekr.20040809071510.103" a="M"><vh>new_df.write</vh>
<v t="ekr.20040809071510.104"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.105"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.106"><vh>(Fix open bug)</vh>
<v t="ekr.20040809071510.107"><vh>Report</vh></v>
<v t="ekr.20040809071510.73"><vh>app.gui.Tkinter file dialogs</vh></v>
<v t="ekr.20040809071510.108"><vh>open</vh>
<v t="ekr.20040809071510.109"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.110"><vh>(Removed headline check logic in atFile read logic)</vh>
<v t="ekr.20040809071510.111"><vh>Report</vh></v>
<v t="ekr.20040809071510.112"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040809071510.113"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.114"><vh>(Fix pretty-printing bug)</vh>
<v t="ekr.20040809071510.115"><vh>Report</vh></v>
</v>
<v t="ekr.20040809071510.116"><vh>(Finished all commands in the Outline Check submenu)</vh>
<v t="ekr.20040809071510.117"><vh>To do</vh></v>
<v t="ekr.20040809071510.118"><vh>Notes</vh></v>
<v t="ekr.20040809071510.119"><vh>undo...</vh>
<v t="ekr.20040809071510.120"><vh>redoChangeAll</vh></v>
<v t="ekr.20040809071510.121"><vh>undoChangeAll</vh></v>
<v t="ekr.20040809071510.122"><vh>undoRedoText</vh>
<v t="ekr.20040809071510.123"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20040809071510.124"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20040809071510.125"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20040809071510.126"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.127"><vh>selection stuff</vh>
<v t="ekr.20040809071510.128"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040809071510.129"><vh>setTextSelection (tkinterBody)</vh></v>
<v t="ekr.20040809071510.130"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20040809071510.131"><vh>in leoGlobals...</vh>
<v t="ekr.20040809071510.37"><vh>g.getScript</vh></v>
<v t="ekr.20040809071510.132"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20040809071510.133"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20040809071510.134"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.135"><vh>scanDirectives (utils)</vh>
<v t="ekr.20040809071510.136"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20040809071510.137"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20040809071510.138"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20040809071510.139"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20040809071510.140"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20040809071510.141"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20040809071510.142"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.143"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20040809071510.144"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.145"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20040809071510.146"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20040809071510.147"><vh>es_exception</vh>
<v t="ekr.20040809071510.148"><vh>&lt;&lt; look for lines containing a specific message &gt;&gt;</vh>
<v t="ekr.20040809071510.149"><vh>&lt;&lt; compute n from the line &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.150"><vh>Write stuff...</vh>
<v t="ekr.20040809071510.151"><vh>putBody (4.x)</vh>
<v t="ekr.20040809071510.152"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20040809071510.153"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20040809071510.154"><vh>Writing (4.x)</vh>
<v t="ekr.20040809071510.155"><vh>Top level</vh>
<v t="ekr.20040809071510.156"><vh>new_df.closeWriteFile</vh></v>
<v t="ekr.20040809071510.103" a="M"><vh>new_df.write</vh>
<v t="ekr.20040809071510.104"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.105"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.157"><vh>new_df.writeOpenFile</vh>
<v t="ekr.20040809071510.158"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20040809071510.159"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20040809071510.160"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20040809071510.161"><vh>new_df.norefWrite</vh>
<v t="ekr.20040809071510.162"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20040809071510.163"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20040809071510.164"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20040809071510.165"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20040809071510.166"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.151"><vh>putBody (4.x)</vh>
<v t="ekr.20040809071510.152"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20040809071510.153"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20040809071510.167"><vh>code lines... (4.x)</vh>
<v t="ekr.20040809071510.168"><vh>@all</vh>
<v t="ekr.20040809071510.169"><vh>putAtAllLine</vh></v>
<v t="ekr.20040809071510.170"><vh>putatAllBody</vh>
<v t="ekr.20040809071510.171"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.172"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20040809071510.173"><vh>@others</vh>
<v t="ekr.20040809071510.174"><vh>inAtOthers</vh></v>
<v t="ekr.20040809071510.175"><vh>putAtOthersChild</vh></v>
<v t="ekr.20040809071510.176"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20040809071510.177"><vh>putCodeLine</vh></v>
<v t="ekr.20040809071510.178"><vh>putRefLine &amp; allies</vh>
<v t="ekr.20040809071510.179"><vh>putRefLine</vh></v>
<v t="ekr.20040809071510.180"><vh>putRefAt</vh></v>
<v t="ekr.20040809071510.181"><vh>putAfterLastRef</vh></v>
<v t="ekr.20040809071510.182"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20040809071510.183"><vh>doc lines... (write)</vh>
<v t="ekr.20040809071510.184"><vh>putBlankDocLine</vh></v>
<v t="ekr.20040809071510.185"><vh>putStartDocLine</vh></v>
<v t="ekr.20040809071510.186"><vh>putDocLine</vh>
<v t="ekr.20040809071510.187"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.188"><vh>putEndDocLine</vh></v>
<v t="ekr.20040809071510.189"><vh>putPending</vh></v>
</v>
<v t="ekr.20040809071510.190"><vh>Writing Utils...</vh>
<v t="ekr.20040809071510.191"><vh>directiveKind (4.x)</vh></v>
<v t="ekr.20040809071510.192"><vh>hasSectionName</vh></v>
<v t="ekr.20040809071510.193"><vh>os and allies</vh>
<v t="ekr.20040809071510.194"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="ekr.20040809071510.195"><vh>onl &amp; onl_sent</vh></v>
<v t="ekr.20040809071510.196"><vh>os</vh></v>
</v>
<v t="ekr.20040809071510.197"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20040809071510.198"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="ekr.20040809071510.199"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20040809071510.200"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.175"><vh>putAtOthersChild</vh></v>
</v>
<v t="ekr.20040809071510.207"><vh>Menu stuff...</vh>
<v t="ekr.20040809071510.208"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="ekr.20040809071510.209"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20040809071510.210"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20040809071510.211"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20040809071510.212"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20040809071510.213"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.214"><vh>defineMenuTables</vh>
<v t="ekr.20040809071510.215"><vh>&lt;&lt; define edit menu tables &gt;&gt;</vh>
<v t="ekr.20040809071510.216"><vh>&lt;&lt; define editMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.217"><vh>&lt;&lt; define editMenuEditBodyTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.218"><vh>&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.219"><vh>&lt;&lt; define editMenuFindMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.220"><vh>&lt;&lt; define editMenuTop2Table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.221"><vh>&lt;&lt; define file menu tables &gt;&gt;</vh>
<v t="ekr.20040809071510.222"><vh>&lt;&lt; define fileMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.223"><vh>&lt;&lt; define fileMenuTop2Table &gt;&gt;</vh></v>
<v t="ekr.20040809071510.224"><vh>&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.225"><vh>&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.226"><vh>&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.227"><vh>&lt;&lt; define fileMenuImportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.228"><vh>&lt;&lt; define fileMenuExportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.229"><vh>&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.230"><vh>&lt;&lt; define outline menu tables &gt;&gt;</vh>
<v t="ekr.20040809071510.231"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.232"><vh>&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.233"><vh>&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.234"><vh>&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.235"><vh>&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040809071510.236"><vh>&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.237"><vh>&lt;&lt; define window menu tables &gt;&gt;</vh></v>
<v t="ekr.20040809071510.238"><vh>&lt;&lt; define help menu tables &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.239"><vh>Check Outline submenu...</vh>
<v t="ekr.20040809071510.42"><vh>c.checkOutline</vh>
<v t="ekr.20040809071510.43"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040809071510.44"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040809071510.45"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040809071510.46"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040809071510.47"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040809071510.48"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040809071510.49"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040809071510.50"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040809071510.51"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040809071510.52"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040809071510.53"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040809071510.54"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040809071510.55"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.240"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040809071510.241"><vh>checkAllPythonCode</vh>
<v t="ekr.20040809071510.242"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.243"><vh>checkPythonCode</vh>
<v t="ekr.20040809071510.244"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.245"><vh>checkPythonNode</vh></v>
<v t="ekr.20040809071510.246"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20040809071510.247"><vh>c.dumpOutline</vh></v>
<v t="ekr.20040809071510.248"><vh>Pretty Print commands</vh>
<v t="ekr.20040809071510.249"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20040809071510.250"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20040809071510.251"><vh>class prettyPrinter</vh>
<v t="ekr.20040809071510.252"><vh>__init__</vh></v>
<v t="ekr.20040809071510.253"><vh>clear</vh></v>
<v t="ekr.20040809071510.254"><vh>dumpLines</vh></v>
<v t="ekr.20040809071510.255"><vh>dumpToken</vh></v>
<v t="ekr.20040809071510.256"><vh>get</vh></v>
<v t="ekr.20040809071510.257"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040809071510.258"><vh>put</vh></v>
<v t="ekr.20040809071510.259"><vh>putNormalToken</vh></v>
<v t="ekr.20040809071510.260"><vh>putOperator</vh></v>
<v t="ekr.20040809071510.261"><vh>putToken</vh></v>
<v t="ekr.20040809071510.262"><vh>replaceBody</vh></v>
<v t="ekr.20040809071510.263"><vh>endUndo</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040809071510.264"><vh>(Fixed MAJOR bug in p.isAncestorOf)</vh>
<v t="ekr.20040809071510.265"><vh>Notes</vh></v>
<v t="ekr.20040809071510.266"><vh>Traceback</vh></v>
<v t="ekr.20040809071510.267"><vh>p.isAncestorOf</vh></v>
</v>
<v t="ekr.20040809071510.268"><vh>Examined possible compatibility problems using old-style scripts: NO PROBLEM)</vh>
<v t="ekr.20040809071510.269"><vh>Notes</vh></v>
</v>
<v t="ekr.20040809071510.270"><vh>(Examined find.selectNextVnode)</vh>
<v t="ekr.20040809071510.271"><vh>Notes</vh></v>
<v t="ekr.20040809071510.272"><vh>selectNextVnode</vh></v>
<v t="ekr.20040809071510.273"><vh>findNextMatch</vh></v>
</v>
<v t="ekr.20040809071510.274"><vh>(Fixed bug in putTnodes)</vh>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.275"><vh>putTnodes</vh>
<v t="ekr.20040809071510.276"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.277"><vh>(Perfect Import)</vh>
<v t="ekr.20040809071510.278"><vh>What I did</vh></v>
<v t="ekr.20040809071510.279"><vh>(Fixed bugs with handling @nonl)</vh>
<v t="ekr.20040809071510.280"><vh>removeSentinelsFromFile/Lines</vh>
<v t="ekr.20040809071510.281"><vh>&lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.282"><vh>create_mapping</vh></v>
</v>
<v t="ekr.20040809071510.283"><vh>From atFile...</vh>
<v t="ekr.20040809071510.284"><vh>Reading (4.x)</vh>
<v t="ekr.20040809071510.285"><vh>createThinChild (4.2: @thin only)</vh></v>
<v t="ekr.20040809071510.286"><vh>new_df.readOpenFile</vh></v>
<v t="ekr.20040809071510.112"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040809071510.113"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.287"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20040809071510.288"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20040809071510.289"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20040809071510.290"><vh>readNormalLine</vh>
<v t="ekr.20040809071510.291"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20040809071510.292"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.293"><vh>start sentinels</vh>
<v t="ekr.20040809071510.294"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20040809071510.295"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20040809071510.296"><vh>readStartLeo</vh></v>
<v t="ekr.20040809071510.297"><vh>readStartMiddle</vh></v>
<v t="ekr.20040809071510.298"><vh>readStartNode (4.x)</vh>
<v t="ekr.20040809071510.299"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20040809071510.300"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20040809071510.301"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.302"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20040809071510.303"><vh>end sentinels</vh>
<v t="ekr.20040809071510.304"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20040809071510.305"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20040809071510.306"><vh>readEndLeo</vh></v>
<v t="ekr.20040809071510.307"><vh>readEndMiddle</vh></v>
<v t="ekr.20040809071510.308"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040809071510.309"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.310"><vh>readEndOthers</vh></v>
<v t="ekr.20040809071510.311"><vh>readLastDocLine</vh>
<v t="ekr.20040809071510.312"><vh>&lt;&lt; new code &gt;&gt;</vh></v>
<v t="ekr.20040809071510.313"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.314"><vh>Unpaired sentinels</vh>
<v t="ekr.20040809071510.315"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20040809071510.316"><vh>readAfterRef</vh></v>
<v t="ekr.20040809071510.317"><vh>readClone</vh></v>
<v t="ekr.20040809071510.318"><vh>readComment</vh></v>
<v t="ekr.20040809071510.319"><vh>readDelims</vh></v>
<v t="ekr.20040809071510.320"><vh>readDirective</vh>
<v t="ekr.20040809071510.321"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20040809071510.322"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.323"><vh>readNl</vh></v>
<v t="ekr.20040809071510.324"><vh>readNonl</vh></v>
<v t="ekr.20040809071510.325"><vh>readRef</vh></v>
<v t="ekr.20040809071510.326"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20040809071510.327"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
</v>
<v t="ekr.20040809071510.103" a="M"><vh>new_df.write</vh>
<v t="ekr.20040809071510.104"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.105"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.286"><vh>new_df.readOpenFile</vh></v>
<v t="ekr.20040809071510.308"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040809071510.309"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.328"><vh>From leoGlobals...</vh>
<v t="ekr.20040809071510.329"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20040809071510.330"><vh>g.fileLikeObject</vh></v>
<v t="ekr.20040809071510.331"><vh>g.is_sentinel</vh>
<v t="ekr.20040809071510.332"><vh>&lt;&lt; is_sentinel doc tests &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.333"><vh>class mulderUpdateAlgorithm (leoGlobals)</vh>
<v t="ekr.20040809071510.334"><vh>__init__</vh></v>
<v t="ekr.20040809071510.335"><vh>copy_sentinels</vh></v>
<v t="ekr.20040809071510.336"><vh>copy_time</vh></v>
<v t="ekr.20040809071510.282"><vh>create_mapping</vh></v>
<v t="ekr.20040809071510.337"><vh>Get or remove sentinel lines</vh>
<v t="ekr.20040809071510.338"><vh>separateSentinelsFromFile/Lines</vh></v>
<v t="ekr.20040809071510.280"><vh>removeSentinelsFromFile/Lines</vh>
<v t="ekr.20040809071510.281"><vh>&lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.339"><vh>getSentinelsFromFile/Lines</vh></v>
</v>
<v t="ekr.20040809071510.340"><vh>propagateDiffsToSentinelsFile</vh>
<v t="ekr.20040809071510.341"><vh>&lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;</vh></v>
<v t="ekr.20040809071510.342"><vh>&lt;&lt;paranoia check&gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.343"><vh>propagateDiffsToSentinelsLines (called from perfect import)</vh>
<v t="ekr.20040809071510.344"><vh>&lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;</vh></v>
<v t="ekr.20040809071510.345"><vh>&lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;</vh></v>
<v t="ekr.20040809071510.346"><vh>&lt;&lt; update and check the loop invariant&gt;&gt;</vh></v>
<v t="ekr.20040809071510.347"><vh>&lt;&lt; handle 'equal' tag &gt;&gt;</vh></v>
<v t="ekr.20040809071510.348"><vh>&lt;&lt; handle 'replace' tag &gt;&gt;</vh></v>
<v t="ekr.20040809071510.349"><vh>&lt;&lt; handle 'delete' tag &gt;&gt;</vh></v>
<v t="ekr.20040809071510.350"><vh>&lt;&lt; handle 'insert' tag &gt;&gt;</vh></v>
<v t="ekr.20040809071510.351"><vh>&lt;&lt; copy the sentinels at the end of the file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.352"><vh>report_mismatch</vh></v>
<v t="ekr.20040809071510.353"><vh>stripWhitespaceFromBlankLines(before_lines)</vh></v>
<v t="ekr.20040809071510.354"><vh>write_if_changed</vh>
<v t="ekr.20040809071510.355"><vh>&lt;&lt; make backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.93"><vh>importFilesCommand</vh>
<v t="ekr.20040809071510.94"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.356"><vh>perfectImport</vh>
<v t="ekr.20040809071510.357"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20040809071510.358"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.359"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20040809071510.360"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20040809071510.361"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20040809071510.362"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20040809071510.363"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20040809071510.364"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.365"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20040809071510.366"><vh>(Investigated write logic to see how it handles whitespace)</vh>
<v t="ekr.20040809071510.367"><vh>Notes</vh></v>
<v t="ekr.20040809071510.177"><vh>putCodeLine</vh></v>
</v>
<v t="ekr.20040809071510.368"><vh>(Fixed new bug in p.setBodyStringOrPane)</vh>
<v t="ekr.20040809071510.369"><vh>Notes</vh></v>
<v t="ekr.20040809071510.128"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040809071510.130"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20040809071510.370"><vh>(Created g.stripBlankLines and regularizeTrailingNewlines)</vh>
<v t="ekr.20040809071510.371"><vh>stripBlankLines</vh></v>
<v t="ekr.20040809071510.372"><vh>regularizeTrailingNewlines</vh></v>
</v>
<v t="ekr.20040809071510.373"><vh>(Improved and simplified Syntax Checking commands)</vh>
<v t="ekr.20040809071510.239"><vh>Check Outline submenu...</vh>
<v t="ekr.20040809071510.42"><vh>c.checkOutline</vh>
<v t="ekr.20040809071510.43"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040809071510.44"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040809071510.45"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040809071510.46"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040809071510.47"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040809071510.48"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040809071510.49"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040809071510.50"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040809071510.51"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040809071510.52"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040809071510.53"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040809071510.54"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040809071510.55"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.240"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040809071510.241"><vh>checkAllPythonCode</vh>
<v t="ekr.20040809071510.242"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.243"><vh>checkPythonCode</vh>
<v t="ekr.20040809071510.244"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.245"><vh>checkPythonNode</vh></v>
<v t="ekr.20040809071510.246"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20040809071510.247"><vh>c.dumpOutline</vh></v>
<v t="ekr.20040809071510.248"><vh>Pretty Print commands</vh>
<v t="ekr.20040809071510.249"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20040809071510.250"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20040809071510.251"><vh>class prettyPrinter</vh>
<v t="ekr.20040809071510.252"><vh>__init__</vh></v>
<v t="ekr.20040809071510.253"><vh>clear</vh></v>
<v t="ekr.20040809071510.254"><vh>dumpLines</vh></v>
<v t="ekr.20040809071510.255"><vh>dumpToken</vh></v>
<v t="ekr.20040809071510.256"><vh>get</vh></v>
<v t="ekr.20040809071510.257"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040809071510.258"><vh>put</vh></v>
<v t="ekr.20040809071510.259"><vh>putNormalToken</vh></v>
<v t="ekr.20040809071510.260"><vh>putOperator</vh></v>
<v t="ekr.20040809071510.261"><vh>putToken</vh></v>
<v t="ekr.20040809071510.262"><vh>replaceBody</vh></v>
<v t="ekr.20040809071510.263"><vh>endUndo</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040809071510.374"><vh>(Simplified edit_text)</vh>
<v t="ekr.20040809071510.375"><vh>Notes</vh></v>
</v>
<v t="ekr.20040809071510.376"><vh>(Fixed big performance bug in the read code)</vh>
<v t="ekr.20040809071510.377"><vh>Notes: </vh></v>
<v t="ekr.20040809071510.378"><vh>g.doHook</vh></v>
<v t="ekr.20040809071510.379"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20040809071510.380"><vh>getLeoFile</vh>
<v t="ekr.20040809071510.381"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20040809071510.382"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20040809071510.383"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="ekr.20040809071510.384"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.385"><vh>(Fixed undo headline problem)</vh>
<v t="ekr.20040809071510.386"><vh>redoChangeHeadline</vh></v>
<v t="ekr.20040809071510.387"><vh>undoChangeHeadline</vh></v>
<v t="ekr.20040809071510.388"><vh>p.setHeadStringOrHeadline</vh></v>
</v>
<v t="ekr.20040809071510.389"><vh>(Fixed bug: @thin badDirectory/name caused too much traceback)</vh>
<v t="ekr.20040809071510.390"><vh>Traceback &amp; Notes</vh></v>
<v t="ekr.20040809071510.391"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
<v t="ekr.20040809071510.392"><vh>writeError</vh></v>
</v>
<v t="ekr.20040809071510.393"><vh>(Allow collapsed xml tags in .leo files)</vh>
<v t="ekr.20040809071510.394"><vh>Request</vh></v>
<v t="ekr.20040809071510.395"><vh>Notes</vh></v>
<v t="ekr.20040809071510.396"><vh>getOpenTag</vh></v>
<v t="ekr.20040809071510.397"><vh>getCloneWindows</vh></v>
<v t="ekr.20040809071510.398"><vh>getFindPanelSettings</vh>
<v t="ekr.20040809071510.399"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.400"><vh>getGlobals</vh></v>
<v t="ekr.20040809071510.401"><vh>getPrefs</vh>
<v t="ekr.20040809071510.402"><vh>getTargetLanguage</vh></v>
</v>
</v>
<v t="ekr.20040809071510.403"><vh>Fixed bug: new outline code wasn't updating cloned and joined headlines.</vh></v>
<v t="ekr.20040809071510.404"><vh>Check outline now checks that p.edit_text.get matches p.headString()</vh>
<v t="ekr.20040809071510.42"><vh>c.checkOutline</vh>
<v t="ekr.20040809071510.43"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040809071510.44"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040809071510.45"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040809071510.46"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040809071510.47"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040809071510.48"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040809071510.49"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040809071510.50"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040809071510.51"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040809071510.52"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040809071510.53"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040809071510.54"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040809071510.55"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.405"><vh>(Fixed problems with confirm save box)</vh>
<v t="ekr.20040809071510.406"><vh>What I did</vh></v>
<v t="ekr.20040809071510.407"><vh>Report</vh></v>
<v t="ekr.20040809071510.408"><vh> class leoTkinterDialog</vh>
<v t="ekr.20040809071510.409"><vh>__init__ (leoDialog)</vh></v>
<v t="ekr.20040809071510.410"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="ekr.20040809071510.411"><vh>center</vh></v>
<v t="ekr.20040809071510.412"><vh>createButtons</vh></v>
<v t="ekr.20040809071510.413"><vh>createMessageFrame</vh></v>
<v t="ekr.20040809071510.414"><vh>createTopFrame</vh></v>
<v t="ekr.20040809071510.415"><vh>onClose</vh></v>
<v t="ekr.20040809071510.416"><vh>run</vh></v>
</v>
<v t="ekr.20040809071510.18"><vh>app.closeLeoWindow</vh></v>
</v>
<v t="ekr.20040809071510.417"><vh>(Fixed a recent change bug: empty change text was converted to &lt;)</vh>
<v t="ekr.20040809071510.396"><vh>getOpenTag</vh></v>
<v t="ekr.20040809071510.398"><vh>getFindPanelSettings</vh>
<v t="ekr.20040809071510.399"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.418"><vh>(Improved how es_exception gets line number of errors)</vh>
<v t="ekr.20040809071510.419"><vh>Notes</vh></v>
<v t="ekr.20040809071510.147"><vh>es_exception</vh>
<v t="ekr.20040809071510.148"><vh>&lt;&lt; look for lines containing a specific message &gt;&gt;</vh>
<v t="ekr.20040809071510.149"><vh>&lt;&lt; compute n from the line &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.420"><vh>(Fixed MAJOR bug: changing headline now marks subnodes dirty)</vh>
<v t="ekr.20040809071510.421"><vh>Report</vh></v>
<v t="ekr.20040809071510.422"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20040809071510.423"><vh>(Ignore @all nodes in Go To Line Number command)</vh>
<v t="ekr.20040809071510.424"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20040809071510.425" a="M"><vh>&lt;&lt; set root to the nearest ancestor @file node &gt;&gt;</vh></v>
<v t="ekr.20040809071510.426"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20040809071510.427"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20040809071510.428"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20040809071510.429"><vh>&lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;</vh>
<v t="ekr.20040809071510.430"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20040809071510.431"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20040809071510.432"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20040809071510.433"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20040809071510.434"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.435"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.436"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20040809071510.437"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20040809071510.438"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20040809071510.439"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20040809071510.440"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20040809071510.441"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.442"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.443"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="ekr.20040809071510.444"><vh>Test...These exist in leoProjects.txt: we should not go there</vh>
<v t="ekr.20040809071510.445"><vh>(Key handlers) </vh>
<v t="ekr.20040809071510.446"><vh>body key handlers</vh>
<v t="ekr.20040809071510.447"><vh>idle_body_key</vh>
<v t="ekr.20040809071510.448"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20040809071510.449"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20040809071510.450"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20040809071510.451"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="ekr.20040809071510.452"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20040809071510.453"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20040809071510.454"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20040809071510.455"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.456"><vh>onBodyChanged (called from core)</vh></v>
<v t="ekr.20040809071510.457"><vh>onBodyKey</vh>
<v t="ekr.20040809071510.458"><vh>handleStatusLineKey</vh>
<v t="ekr.20040809071510.459"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.460"><vh>onBodyWillChange</vh></v>
</v>
<v t="ekr.20040809071510.461"><vh>idle_head_key</vh>
<v t="ekr.20040809071510.462"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040809071510.463"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040809071510.464"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040809071510.465"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20040809071510.466"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20040809071510.467"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040809071510.468"><vh>Integrated new outline code into core</vh></v>
<v t="ekr.20040809071510.469"><vh>(Give update warning only once per derived file)</vh>
<v t="ekr.20040809071510.288"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20040809071510.308"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040809071510.309"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.470"><vh>(Made sure tnodeList is updated properly in all situations)</vh>
<v t="ekr.20040809071510.471"><vh>What I did: putVnode deletes unneeded tnodeLists!</vh>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.472"><vh>Notes</vh></v>
<v t="ekr.20040809071510.42"><vh>c.checkOutline</vh>
<v t="ekr.20040809071510.43"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040809071510.44"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040809071510.45"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040809071510.46"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040809071510.47"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040809071510.48"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040809071510.49"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040809071510.50"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040809071510.51"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040809071510.52"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040809071510.53"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040809071510.54"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040809071510.55"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.473"><vh>From atFile...</vh>
<v t="ekr.20040809071510.298"><vh>readStartNode (4.x)</vh>
<v t="ekr.20040809071510.299"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20040809071510.300"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20040809071510.301"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.285"><vh>createThinChild (4.2: @thin only)</vh></v>
<v t="ekr.20040809071510.112"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040809071510.113"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.474"><vh>old_df.write</vh>
<v t="ekr.20040809071510.475"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="ekr.20040809071510.476"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.477"><vh>&lt;&lt; write then entire @file tree &gt;&gt; (3.x)</vh>
<v t="ekr.20040809071510.478"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (3.x)</vh></v>
<v t="ekr.20040809071510.479"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="ekr.20040809071510.480"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (3.x)</vh></v>
</v>
<v t="ekr.20040809071510.481"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.103" a="M"><vh>new_df.write</vh>
<v t="ekr.20040809071510.104"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20040809071510.105"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.482"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="ekr.20040809071510.157"><vh>new_df.writeOpenFile</vh>
<v t="ekr.20040809071510.158"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20040809071510.159"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20040809071510.160"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20040809071510.161"><vh>new_df.norefWrite</vh>
<v t="ekr.20040809071510.162"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20040809071510.163"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20040809071510.164"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20040809071510.165"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20040809071510.166"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040809071510.483"><vh>From leoFileCommands...</vh>
<v t="ekr.20040809071510.484"><vh>getTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20040809071510.485"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20040809071510.486"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20040809071510.487"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20040809071510.488"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.489"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.490"><vh>top_df.writeAll</vh>
<v t="ekr.20040809071510.491"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.492"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20040809071510.493"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.494"><vh>writeAtFileNodes</vh></v>
<v t="ekr.20040809071510.495"><vh>writeDirtyAtFileNodes</vh></v>
<v t="ekr.20040809071510.496"><vh>writeMissingAtFileNodes</vh></v>
</v>
</v>
<v t="ekr.20040809071510.497"><vh>(Created isCurrent, isRoot methods in commands and positions classes</vh>
<v t="ekr.20040809071510.498"><vh>Notes</vh></v>
<v t="ekr.20040809071510.499"><vh>p.equal &amp; isEqual</vh></v>
<v t="ekr.20040809071510.500"><vh>c.is...Position</vh>
<v t="ekr.20040809071510.501"><vh>c.currentPositionIsRootPosition</vh></v>
<v t="ekr.20040809071510.502"><vh>c.currentPositionHasNext</vh></v>
<v t="ekr.20040809071510.503"><vh>c.isCurrentPosition</vh></v>
<v t="ekr.20040809071510.504"><vh>c.isRootPosition</vh></v>
</v>
<v t="ekr.20040809071510.505"><vh>c.currentPosition &amp; c.setCurrentPosition</vh>
<v t="ekr.20040809071510.506"><vh>currentPosition</vh></v>
<v t="ekr.20040809071510.507"><vh>setCurrentPosition</vh></v>
</v>
<v t="ekr.20040809071510.508"><vh>c.rootPosition &amp; c.setRootPosition</vh>
<v t="ekr.20040809071510.509"><vh>rootPosition</vh></v>
<v t="ekr.20040809071510.510"><vh>setRootPosition</vh></v>
</v>
<v t="ekr.20040809071510.511"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040809071510.512"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040809071510.513"><vh>isRootPosition</vh></v>
</v>
</v>
<v t="ekr.20040809071510.514"><vh>(Fixed several big leaks of positions)</vh>
<v t="ekr.20040809071510.515"><vh>Notes</vh></v>
<v t="ekr.20040809071510.516"><vh>app.__init__</vh>
<v t="ekr.20040809071510.517"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20040809071510.365"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20040809071510.518"><vh>p.__init__</vh></v>
<v t="ekr.20040809071510.519"><vh>p.copy</vh></v>
<v t="ekr.20040809071510.520"><vh>canHoist &amp; canDehoist</vh></v>
<v t="ekr.20040809071510.521"><vh>idleTimeHookHandler</vh></v>
<v t="ekr.20040809071510.378"><vh>g.doHook</vh></v>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.522"><vh>(Removed leak of positions from putVnode)</vh>
<v t="ekr.20040809071510.523"><vh>putVnodes</vh></v>
<v t="ekr.20040809071510.201" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20040809071510.202"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20040809071510.203"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040809071510.204"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040809071510.205"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20040809071510.206"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040809071510.524"><vh>Fixed hang in unit tests when run under Python 2.2</vh></v>
<v t="ekr.20040809071510.525"><vh>(Fixed checks so they work with Python 2.2)</vh>
<v t="ekr.20040809071510.240"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040809071510.241"><vh>checkAllPythonCode</vh>
<v t="ekr.20040809071510.242"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.243"><vh>checkPythonCode</vh>
<v t="ekr.20040809071510.244"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040809071510.245"><vh>checkPythonNode</vh></v>
<v t="ekr.20040809071510.246"><vh>tabNannyNode</vh></v>
</v>
</v>
<v t="ekr.20040809071510.526"><vh>(Fixed problems with unknown __del__ methods in Python 2.2)</vh>
<v t="ekr.20040809071510.527"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251" a="TV"><vh>4.3 projects</vh>
<v t="ekr.20050712070251.1"><vh>4.3 a1 projects</vh>
<v t="ekr.20050712070251.2" a="E"><vh>Bug fixes...</vh>
<v t="ekr.20050712070251.3" a="E"><vh>Code</vh>
<v t="ekr.20050712070251.4"><vh>(g.import wrappers return module if it is in sys.modules)</vh>
<v t="ekr.20050712070251.5"><vh>import wrappers</vh>
<v t="ekr.20050712070251.6"><vh>g.cantImport</vh></v>
<v t="ekr.20050712070251.7"><vh>g.importModule</vh></v>
<v t="ekr.20050712070251.8"><vh>g.importExtension</vh></v>
<v t="ekr.20050712070251.9"><vh>g.importFromPath</vh></v>
</v>
</v>
<v t="ekr.20050712070251.10" a="E"><vh>(Put the scrollWheel workaround in createTkTreeCanvas)</vh>
<v t="ekr.20050712070251.11"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050712070251.12"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20050712070251.13"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.14"><vh>Commands</vh>
<v t="ekr.20050712070251.15"><vh>(Fixed hyperlink bug)</vh>
<v t="ekr.20050712070251.16"><vh>Report</vh></v>
<v t="ekr.20050712070251.17"><vh>OnHyperLinkControlClick</vh></v>
</v>
<v t="ekr.20050712070251.18"><vh>(Fixed problems with spawnv option of openWith)</vh>
<v t="ekr.20050712070251.19"><vh>Report</vh></v>
<v t="ekr.20050712070251.20"><vh>createOpenWithMenuFromTable</vh></v>
<v t="ekr.20050712070251.21"><vh>openWith and allies</vh>
<v t="ekr.20050712070251.22"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.23"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20050712070251.24"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20050712070251.25"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20050712070251.26"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.27"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20050712070251.28"><vh>createOpenWithTempFile</vh>
<v t="ekr.20050712070251.29"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.30"><vh>c.openWithTempFilePath</vh></v>
</v>
</v>
<v t="ekr.20050712070251.31"><vh>(Fixed bug in  Remove Sentinels command)</vh>
<v t="ekr.20050712070251.32"><vh>Report</vh></v>
<v t="ekr.20050712070251.33"><vh>app.gui.Tkinter file dialogs</vh></v>
<v t="ekr.20050712070251.34"><vh>removeSentinels</vh></v>
<v t="ekr.20050712070251.35"><vh>removeSentinelsCommand</vh>
<v t="ekr.20050712070251.36"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.37"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.38"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.39"><vh>(Fixed bug re Paste Retaining Clones)</vh>
<v t="ekr.20050712070251.40"><vh>Report</vh></v>
<v t="ekr.20050712070251.41"><vh>What I did</vh></v>
<v t="ekr.20050712070251.42"><vh>pasteOutlineRetainingClones</vh></v>
<v t="ekr.20050712070251.43"><vh>pasteOutline</vh>
<v t="ekr.20050712070251.44"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050712070251.45"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.46"><vh>getLeoOutline (from clipboard)</vh>
<v t="ekr.20050712070251.47"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.48"><vh>getVnodes</vh>
<v t="ekr.20050712070251.49"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.50"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20050712070251.51"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.52"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.53"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.54"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.55"><vh>(Fixed Pretty Printer code for Python 2.4)</vh>
<v t="ekr.20050712070251.56"><vh>Pretty Print commands</vh>
<v t="ekr.20050712070251.57"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20050712070251.58"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20050712070251.59"><vh>class prettyPrinter</vh>
<v t="ekr.20050712070251.60"><vh>__init__</vh>
<v t="ekr.20050712070251.61"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.62"><vh>clear</vh></v>
<v t="ekr.20050712070251.63"><vh>dumpLines</vh></v>
<v t="ekr.20050712070251.64"><vh>dumpToken</vh></v>
<v t="ekr.20050712070251.65"><vh>endUndo</vh></v>
<v t="ekr.20050712070251.66"><vh>get</vh></v>
<v t="ekr.20050712070251.67"><vh>prettyPrintNode</vh></v>
<v t="ekr.20050712070251.68"><vh>put</vh></v>
<v t="ekr.20050712070251.69"><vh>putArray</vh></v>
<v t="ekr.20050712070251.70"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20050712070251.71"><vh>doEndMarker</vh></v>
<v t="ekr.20050712070251.72"><vh>doErrorToken</vh></v>
<v t="ekr.20050712070251.73"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20050712070251.74"><vh>doMultiLine</vh></v>
<v t="ekr.20050712070251.75"><vh>doName</vh></v>
<v t="ekr.20050712070251.76"><vh>doNewline</vh></v>
<v t="ekr.20050712070251.77"><vh>doNumber</vh></v>
<v t="ekr.20050712070251.78"><vh>doOp</vh></v>
<v t="ekr.20050712070251.79"><vh>doStartLine</vh></v>
<v t="ekr.20050712070251.80"><vh>oops</vh></v>
<v t="ekr.20050712070251.81"><vh>trace</vh></v>
</v>
<v t="ekr.20050712070251.82"><vh>putToken</vh></v>
<v t="ekr.20050712070251.83"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.84"><vh>(Fixed crasher in Import Derived Files command)</vh>
<v t="ekr.20050712070251.85"><vh>Report</vh></v>
<v t="ekr.20050712070251.86"><vh>Fix</vh></v>
<v t="ekr.20050712070251.87"><vh>readLine</vh></v>
<v t="ekr.20050712070251.88"><vh>scanHeaderForThin</vh></v>
<v t="ekr.20050712070251.89"><vh>scanHeader  (3.x and 4.x)</vh>
<v t="ekr.20050712070251.90"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.91"><vh>importDerivedFiles</vh>
<v t="ekr.20050712070251.92"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.93"><vh>(Fixed bug in the code that executes Open With command with spawnv)</vh>
<v t="ekr.20050712070251.27"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.94"><vh>(Fix buged: search in hoisted outline can stop outside the hoisted area)</vh>
<v t="ekr.20050712070251.95"><vh>Report</vh></v>
<v t="ekr.20050712070251.96"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20050712070251.97"><vh>selectNextVnode</vh></v>
</v>
<v t="ekr.20050712070251.98"><vh>(Fixed bugs handling @language &amp; @comment in atFile.scanAllDirectives &amp; g.scanDirectives)</vh>
<v t="ekr.20050712070251.99"><vh>Report</vh></v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.114"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20050712070251.115"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.116"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.117"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.118"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.119"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20050712070251.120"><vh>&lt;&lt; Test for @path &gt;&gt; in tangleScanAllDirectives</vh>
<v t="ekr.20050712070251.121"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.122"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.123"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.124"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20050712070251.125"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.126"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.127"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20050712070251.128"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.129"><vh>scanDirectives (utils)</vh>
<v t="ekr.20050712070251.130"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.131"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.132"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.133"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.134"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.135"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.136"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.137"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.138"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.139"><vh>Distribution</vh>
<v t="ekr.20050712070251.140"><vh>(Fixed file association in leoDist.leo)</vh></v>
</v>
<v t="ekr.20050712070251.141"><vh>Menus</vh>
<v t="ekr.20050712070251.142"><vh>(Fixed problems with Control-E)</vh>
<v t="ekr.20050712070251.143"><vh> Report</vh></v>
<v t="ekr.20050712070251.144"><vh> What I did</vh></v>
<v t="ekr.20050712070251.145"><vh>class nullMenu</vh>
<v t="ekr.20050712070251.146"><vh>ctor</vh></v>
<v t="ekr.20050712070251.147"><vh>oops</vh></v>
<v t="ekr.20050712070251.148"><vh>Gui-independent menu routines</vh></v>
<v t="ekr.20050712070251.149"><vh>Gui-independent menu enablers</vh></v>
</v>
<v t="ekr.20050712070251.150"><vh>resizePanesToRatio</vh>
<v t="ekr.20050712070251.151"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.152"><vh>defineMenuTables</vh>
<v t="ekr.20050712070251.153"><vh>&lt;&lt; define edit menu tables &gt;&gt;</vh>
<v t="ekr.20050712070251.154"><vh>&lt;&lt; define editMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.155"><vh>&lt;&lt; define editMenuEditCursorTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.156"><vh>&lt;&lt; define editMenuEditBodyTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.157"><vh>&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.158"><vh>&lt;&lt; define editMenuFindMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.159"><vh>&lt;&lt; define editMenuTop2Table &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.160"><vh>&lt;&lt; define file menu tables &gt;&gt;</vh>
<v t="ekr.20050712070251.161"><vh>&lt;&lt; define fileMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.162"><vh>&lt;&lt; define fileMenuTop2Table &gt;&gt;</vh></v>
<v t="ekr.20050712070251.163"><vh>&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.164"><vh>&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.165"><vh>&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.166"><vh>&lt;&lt; define fileMenuImportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.167"><vh>&lt;&lt; define fileMenuExportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.168"><vh>&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.169" a="E"><vh>&lt;&lt; define outline menu tables &gt;&gt;</vh>
<v t="ekr.20050712070251.170"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.171"><vh>&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.172"><vh>&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.173"><vh>&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.174"><vh>&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.175" a="M"><vh>&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.176"><vh>&lt;&lt; define window menu tables &gt;&gt;</vh></v>
<v t="ekr.20050712070251.177"><vh>&lt;&lt; define help menu tables &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.178"><vh>Gui-independent menu routines</vh>
<v t="ekr.20050712070251.179"><vh>get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="ekr.20050712070251.180"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20050712070251.181"><vh>canonicalizeShortcut</vh>
<v t="ekr.20050712070251.182"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20050712070251.183"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20050712070251.184"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20050712070251.185"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.186"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.187"><vh>createMenuEntries</vh>
<v t="ekr.20050712070251.188"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="ekr.20050712070251.189"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="ekr.20050712070251.190"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="ekr.20050712070251.191"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="ekr.20050712070251.192"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="ekr.20050712070251.193"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.194"><vh>createMenuItemsFromTable</vh></v>
<v t="ekr.20050712070251.195"><vh>createMenusFromTables</vh>
<v t="ekr.20050712070251.196"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="ekr.20050712070251.197"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.198"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.199"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.200"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.201"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.202"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.203"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="ekr.20050712070251.204"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.205"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.206"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.207"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="ekr.20050712070251.208"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.209"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.210"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.211"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.212"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.213"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.214"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.215"><vh>createNewMenu</vh></v>
<v t="ekr.20050712070251.216"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
<v t="ekr.20050712070251.217"><vh>deleteMenu</vh></v>
<v t="ekr.20050712070251.218"><vh>deleteMenuItem</vh></v>
<v t="ekr.20050712070251.219"><vh>getMenu, setMenu, destroyMenu</vh></v>
</v>
<v t="ekr.20050712070251.220"><vh>clearAccel</vh></v>
</v>
</v>
<v t="ekr.20050712070251.221"><vh>Nodes</vh>
<v t="ekr.20050712070251.222"><vh>(Fixed crash after cutting an imported node</vh>
<v t="ekr.20050712070251.223"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.224"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
</v>
<v t="ekr.20050712070251.225"><vh>(Removed invalid assert in lastVisible)</vh>
<v t="ekr.20050712070251.226"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
</v>
</v>
<v t="ekr.20050712070251.227"><vh>Files</vh>
<v t="ekr.20050712070251.228"><vh>(Disabled changes to comment delims in @@language and @@comment sentinels)</vh>
<v t="ekr.20050712070251.229"><vh>This file wasn't being read correctly</vh></v>
<v t="ekr.20050712070251.230"><vh>Posting re POSSIBLE fix</vh></v>
<v t="ekr.20050712070251.231"><vh>readDirective (@@)</vh>
<v t="ekr.20050712070251.232"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.233"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.234"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20050712070251.235"><vh>(Added better messages from g.cantImport)</vh>
<v t="ekr.20050712070251.236"><vh>what I did</vh></v>
<v t="ekr.20050712070251.6"><vh>g.cantImport</vh></v>
</v>
<v t="ekr.20050712070251.237"><vh>(Made sure files that differ only in line ending get written if @lineending is in effect)</vh>
<v t="ekr.20050712070251.238"><vh>What I did</vh></v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.239"><vh>compareFiles</vh></v>
<v t="ekr.20050712070251.240"><vh>replaceTargetFileIfDifferent</vh>
<v t="ekr.20050712070251.241"><vh>&lt;&lt; files are identical &gt;&gt;</vh></v>
<v t="ekr.20050712070251.242"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.243"><vh>(Fixed bug:  @nosent writes sentinels!)</vh>
<v t="ekr.20050712070251.244"><vh>Report</vh></v>
<v t="ekr.20050712070251.245"><vh>write</vh>
<v t="ekr.20050712070251.246"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.247"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.248"><vh>class atFile</vh>
<v t="ekr.20050712070251.249"><vh>&lt;&lt; define class constants &gt;&gt;</vh></v>
<v t="ekr.20050712070251.250"><vh>&lt;&lt; define sentinelDict &gt;&gt;</vh></v>
<v t="ekr.20050712070251.251"><vh>Birth &amp; init</vh>
<v t="ekr.20050712070251.252"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20050712070251.253"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.254"><vh>initCommonIvars</vh>
<v t="ekr.20050712070251.255"><vh>&lt;&lt; set defaults for arguments and options &gt;&gt;</vh></v>
<v t="ekr.20050712070251.256"><vh>&lt;&lt; init common ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.257"><vh>initReadIvars</vh>
<v t="ekr.20050712070251.258"><vh>&lt;&lt; init ivars for reading &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.259"><vh>initWriteIvars</vh>
<v t="ekr.20050712070251.260"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.261"><vh>Reading...</vh>
<v t="ekr.20050712070251.262"><vh>Reading (top level)</vh>
<v t="ekr.20050712070251.263"><vh>openFileForReading</vh>
<v t="ekr.20050712070251.264"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.265"><vh>read</vh>
<v t="ekr.20050712070251.266"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.267"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.268"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.269"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.270"><vh>readAll</vh></v>
<v t="ekr.20050712070251.271"><vh>readOpenFile</vh>
<v t="ekr.20050712070251.272"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.273"><vh>openForRead</vh></v>
<v t="ekr.20050712070251.274"><vh>openForWrite</vh></v>
<v t="ekr.20050712070251.88"><vh>scanHeaderForThin</vh></v>
</v>
<v t="ekr.20050712070251.275"><vh>Reading (3.x)</vh>
<v t="ekr.20050712070251.276"><vh>createNthChild3</vh>
<v t="ekr.20050712070251.277"><vh>&lt;&lt; check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.278"><vh>handleLinesFollowingSentinel</vh>
<v t="ekr.20050712070251.279"><vh>&lt;&lt; remove the comment delims from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.280"><vh>readLinesToNextSentinel</vh></v>
<v t="ekr.20050712070251.281"><vh>scanDoc3</vh>
<v t="ekr.20050712070251.282"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="ekr.20050712070251.283"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="ekr.20050712070251.284"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="ekr.20050712070251.285"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20050712070251.286"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="ekr.20050712070251.287"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.288"><vh>scanText3</vh>
<v t="ekr.20050712070251.289"><vh>&lt;&lt; put the next line into s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.290"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="ekr.20050712070251.291"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="ekr.20050712070251.292"><vh>&lt;&lt; handle the line in s &gt;&gt;</vh>
<v t="ekr.20050712070251.293"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.294"><vh>&lt;&lt; handle common sentinels &gt;&gt;</vh>
<v t="ekr.20050712070251.295"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="ekr.20050712070251.296"><vh>&lt;&lt; scan @+body &gt;&gt; 3.x</vh></v>
<v t="ekr.20050712070251.297"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="ekr.20050712070251.298"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20050712070251.299"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="ekr.20050712070251.300"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="ekr.20050712070251.301"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="ekr.20050712070251.302"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.303"><vh>&lt;&lt; scan old ref &gt;&gt; (3.0)</vh></v>
<v t="ekr.20050712070251.304"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="ekr.20050712070251.305"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="ekr.20050712070251.306"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.307"><vh>&lt;&lt; handle rare sentinels &gt;&gt;</vh>
<v t="ekr.20050712070251.308"><vh>&lt;&lt; scan @comment &gt;&gt;</vh></v>
<v t="ekr.20050712070251.309"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="ekr.20050712070251.310"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
<v t="ekr.20050712070251.311"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="ekr.20050712070251.312"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.313"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.314"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.315"><vh>sentinelKind3</vh></v>
<v t="ekr.20050712070251.316"><vh>skipSentinelStart3</vh></v>
</v>
<v t="ekr.20050712070251.317"><vh>Reading (4.x)</vh>
<v t="ekr.20050712070251.318"><vh>createThinChild4</vh></v>
<v t="ekr.20050712070251.319"><vh>findChild4</vh></v>
<v t="ekr.20050712070251.320"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20050712070251.321"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20050712070251.322"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.323"><vh>readNormalLine</vh>
<v t="ekr.20050712070251.324"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20050712070251.325"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.326"><vh>start sentinels</vh>
<v t="ekr.20050712070251.327"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20050712070251.328"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20050712070251.329"><vh>readStartLeo</vh></v>
<v t="ekr.20050712070251.330"><vh>readStartMiddle</vh></v>
<v t="ekr.20050712070251.331"><vh>readStartNode (4.x)</vh>
<v t="ekr.20050712070251.332"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20050712070251.333"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20050712070251.334"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.335"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20050712070251.336"><vh>end sentinels</vh>
<v t="ekr.20050712070251.337"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20050712070251.338"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20050712070251.339"><vh>readEndLeo</vh></v>
<v t="ekr.20050712070251.340"><vh>readEndMiddle</vh></v>
<v t="ekr.20050712070251.341"><vh>readEndNode (4.x)</vh>
<v t="ekr.20050712070251.342"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20050712070251.343"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.344"><vh>readEndOthers</vh></v>
<v t="ekr.20050712070251.234"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20050712070251.345"><vh>Unpaired sentinels</vh>
<v t="ekr.20050712070251.346"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20050712070251.347"><vh>readAfterRef</vh></v>
<v t="ekr.20050712070251.348"><vh>readClone</vh></v>
<v t="ekr.20050712070251.349"><vh>readComment</vh></v>
<v t="ekr.20050712070251.350"><vh>readDelims</vh></v>
<v t="ekr.20050712070251.231"><vh>readDirective (@@)</vh>
<v t="ekr.20050712070251.232"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.233"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.351"><vh>readNl</vh></v>
<v t="ekr.20050712070251.352"><vh>readNonl</vh></v>
<v t="ekr.20050712070251.353"><vh>readRef</vh></v>
<v t="ekr.20050712070251.354"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20050712070251.355"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20050712070251.356"><vh>sentinelKind4</vh></v>
<v t="ekr.20050712070251.357"><vh>skipSentinelStart4</vh></v>
</v>
<v t="ekr.20050712070251.358"><vh>Reading utils...</vh>
<v t="ekr.20050712070251.359"><vh>completeFirstDirectives</vh></v>
<v t="ekr.20050712070251.360"><vh>completeLastDirectives</vh></v>
<v t="ekr.20050712070251.361"><vh>copyAllTempBodyStringsToTnodes</vh></v>
<v t="ekr.20050712070251.362"><vh>createImportedNode</vh></v>
<v t="ekr.20050712070251.363"><vh>parseLeoSentinel</vh>
<v t="ekr.20050712070251.364"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20050712070251.365"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20050712070251.366"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.367"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.368"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.369"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
<v t="ekr.20050712070251.370"><vh>test_parseLeoSentinel</vh></v>
</v>
<v t="ekr.20050712070251.371"><vh>readError</vh></v>
<v t="ekr.20050712070251.87"><vh>readLine</vh></v>
<v t="ekr.20050712070251.89"><vh>scanHeader  (3.x and 4.x)</vh>
<v t="ekr.20050712070251.90"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.372"><vh>skipIndent</vh></v>
</v>
</v>
<v t="ekr.20050712070251.373"><vh>Writing...</vh>
<v t="ekr.20050712070251.374"><vh>Writing (top level)</vh>
<v t="ekr.20050712070251.375"><vh>Don't override in plugins</vh>
<v t="ekr.20050712070251.376"><vh>closeWriteFile</vh></v>
<v t="ekr.20050712070251.377"><vh>norefWrite</vh>
<v t="ekr.20050712070251.378"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20050712070251.379"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20050712070251.380"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20050712070251.381"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.382"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.383"><vh>openFileForWriting &amp; openFileForWritingHelper</vh>
<v t="ekr.20050712070251.384"><vh>openFileForWritingHelper</vh></v>
</v>
<v t="ekr.20050712070251.245"><vh>write</vh>
<v t="ekr.20050712070251.246"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.247"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.385"><vh>writeFromString (new in 4.3 beta2)</vh></v>
<v t="ekr.20050712070251.386"><vh>writeAll</vh>
<v t="ekr.20050712070251.387"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.388"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20050712070251.389"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.390"><vh>writeMissing</vh>
<v t="ekr.20050712070251.391"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.392"><vh>Override in plugins...</vh>
<v t="ekr.20050712070251.393"><vh>asisWrite</vh>
<v t="ekr.20050712070251.394"><vh>&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="ekr.20050712070251.395"><vh>&lt;&lt; Write p's body &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.396"><vh>writeOpenFile</vh></v>
</v>
</v>
<v t="ekr.20050712070251.397"><vh>Writing 4.x</vh>
<v t="ekr.20050712070251.398"><vh>putBody</vh>
<v t="ekr.20050712070251.399"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.400"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.401"><vh>writing code lines...</vh>
<v t="ekr.20050712070251.402"><vh>@all</vh>
<v t="ekr.20050712070251.403"><vh>putAtAllLine</vh></v>
<v t="ekr.20050712070251.404"><vh>putatAllBody</vh>
<v t="ekr.20050712070251.405"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.406"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20050712070251.407"><vh>@others</vh>
<v t="ekr.20050712070251.408"><vh>inAtOthers</vh></v>
<v t="ekr.20050712070251.409"><vh>putAtOthersChild</vh></v>
<v t="ekr.20050712070251.410"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20050712070251.411"><vh>putCodeLine</vh></v>
<v t="ekr.20050712070251.412"><vh>putRefLine &amp; allies</vh>
<v t="ekr.20050712070251.413"><vh>putRefLine</vh></v>
<v t="ekr.20050712070251.414"><vh>putRefAt</vh></v>
<v t="ekr.20050712070251.415"><vh>putAfterLastRef</vh></v>
<v t="ekr.20050712070251.416"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20050712070251.417"><vh>writing doc lines...</vh>
<v t="ekr.20050712070251.418"><vh>putBlankDocLine</vh></v>
<v t="ekr.20050712070251.419"><vh>putStartDocLine</vh></v>
<v t="ekr.20050712070251.420"><vh>putDocLine</vh>
<v t="ekr.20050712070251.421"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.422"><vh>putEndDocLine</vh></v>
<v t="ekr.20050712070251.423"><vh>putPending</vh></v>
</v>
</v>
<v t="ekr.20050712070251.424"><vh>Writing 4,x sentinels...</vh>
<v t="ekr.20050712070251.425"><vh>nodeSentinelText 4.x</vh>
<v t="ekr.20050712070251.426"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.427"><vh>putLeadInSentinel 4.x</vh></v>
<v t="ekr.20050712070251.428"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20050712070251.429"><vh>putOpenLeoSentinel 4.x</vh></v>
<v t="ekr.20050712070251.430"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="ekr.20050712070251.431"><vh>putSentinel (applies cweb hack) 4.x</vh>
<v t="ekr.20050712070251.432"><vh>&lt;&lt; apply the cweb hack to s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.433"><vh>Writing 4.x utils...</vh>
<v t="ekr.20050712070251.239"><vh>compareFiles</vh></v>
<v t="ekr.20050712070251.434"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20050712070251.435"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20050712070251.436"><vh>hasSectionName</vh></v>
<v t="ekr.20050712070251.437"><vh>isSectionName</vh></v>
<v t="ekr.20050712070251.438"><vh>os and allies</vh>
<v t="ekr.20050712070251.439"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="ekr.20050712070251.440"><vh>onl &amp; onl_sent</vh></v>
<v t="ekr.20050712070251.441"><vh>os</vh></v>
</v>
<v t="ekr.20050712070251.442"><vh>outputStringWithLineEndings</vh></v>
<v t="ekr.20050712070251.443"><vh>putAtFirstLines (new in 4.3 b2)</vh></v>
<v t="ekr.20050712070251.444"><vh>putAtLastLines (new in 4.3 b2)</vh></v>
<v t="ekr.20050712070251.445"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20050712070251.446"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="ekr.20050712070251.447"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.448"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.449"><vh>putIndent</vh></v>
<v t="ekr.20050712070251.450"><vh>putInitialComment</vh></v>
<v t="ekr.20050712070251.240"><vh>replaceTargetFileIfDifferent</vh>
<v t="ekr.20050712070251.241"><vh>&lt;&lt; files are identical &gt;&gt;</vh></v>
<v t="ekr.20050712070251.242"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.451"><vh>warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20050712070251.452"><vh>writeError</vh></v>
<v t="ekr.20050712070251.453"><vh>writeException</vh></v>
</v>
</v>
<v t="ekr.20050712070251.454"><vh>Uilites... (atFile)</vh>
<v t="ekr.20050712070251.455"><vh>file operations...</vh>
<v t="ekr.20050712070251.456"><vh>chmod</vh></v>
<v t="ekr.20050712070251.457"><vh>rename &amp; test</vh>
<v t="ekr.20050712070251.458"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20050712070251.459"><vh>test_atFile_rename</vh></v>
</v>
<v t="ekr.20050712070251.460"><vh>remove &amp; test</vh>
<v t="ekr.20050712070251.461"><vh>test_atFile_remove</vh></v>
</v>
<v t="ekr.20050712070251.462"><vh>stat</vh></v>
</v>
<v t="ekr.20050712070251.463"><vh>atFile.error</vh></v>
<v t="ekr.20050712070251.464"><vh>atFile.printError &amp; test</vh></v>
<v t="ekr.20050712070251.465"><vh>exception</vh></v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.466"><vh>scanDefaultDirectory</vh>
<v t="ekr.20050712070251.467"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
<v t="ekr.20050712070251.468"><vh>&lt;&lt; handle @path &gt;&gt; in df.scanDeafaultDirectory in leoAtFile.py</vh>
<v t="ekr.20050712070251.469"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.470"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.471"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.472"><vh>scanForClonedSibs (reading &amp; writing)</vh></v>
<v t="ekr.20050712070251.473"><vh>sentinelName</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.474"><vh>(Fixed bug in replaceTargetFileIfDifferent)</vh>
<v t="ekr.20050712070251.475"><vh>What I did</vh></v>
<v t="ekr.20050712070251.240"><vh>replaceTargetFileIfDifferent</vh>
<v t="ekr.20050712070251.241"><vh>&lt;&lt; files are identical &gt;&gt;</vh></v>
<v t="ekr.20050712070251.242"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.476"><vh>(Made sure that @ignore forces writing of inner @thin trees)</vh>
<v t="ekr.20050712070251.477"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20050712070251.478"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20050712070251.479"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.480"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.481"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20050712070251.482"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.483"><vh>(Fixed crasher with invalid path)</vh>
<v t="ekr.20050712070251.259"><vh>initWriteIvars</vh>
<v t="ekr.20050712070251.260"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.484"><vh>(Fixed double doc part bug)</vh>
<v t="ekr.20050712070251.485"><vh>Notes</vh></v>
<v t="ekr.20050712070251.398"><vh>putBody</vh>
<v t="ekr.20050712070251.399"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.400"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.486"><vh>(Fixed deprecation warning when saving .leo files)</vh>
<v t="ekr.20050712070251.487"><vh>@url http://docs.python.org/lib/module-pickle.html</vh></v>
<v t="ekr.20050712070251.488"><vh>putUnknownAttributes</vh></v>
<v t="ekr.20050712070251.489"><vh>getUa (changed for 4.3)</vh></v>
</v>
<v t="ekr.20050712070251.490"><vh>(Fixed bug in how Leo writes thin derived files)</vh>
<v t="ekr.20050712070251.491"><vh>Report</vh></v>
<v t="ekr.20050712070251.414"><vh>putRefAt</vh></v>
</v>
</v>
<v t="ekr.20050712070251.492"><vh>Script bugs</vh>
<v t="ekr.20050712070251.493"><vh>(Fixed unbounded recursion with --script)</vh>
<v t="ekr.20050712070251.494"><vh>Report</vh></v>
<v t="ekr.20050712070251.495"><vh>What I did</vh></v>
<v t="ekr.20050712070251.496"><vh>redirecting stderr and stdout</vh>
<v t="ekr.20050712070251.497"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh>
<v t="ekr.20050712070251.498"><vh>redirectClass.__init__</vh></v>
<v t="ekr.20050712070251.499"><vh>isRedirected</vh></v>
<v t="ekr.20050712070251.500"><vh>flush</vh></v>
<v t="ekr.20050712070251.501"><vh>rawPrint</vh></v>
<v t="ekr.20050712070251.502"><vh>redirect</vh></v>
<v t="ekr.20050712070251.503"><vh>undirect</vh></v>
<v t="ekr.20050712070251.504"><vh>write</vh></v>
</v>
<v t="ekr.20050712070251.505"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh>
<v t="ekr.20050712070251.506"><vh>redirectStderr &amp; redirectStdout</vh></v>
<v t="ekr.20050712070251.507"><vh>restoreStderr &amp; restoreStdout</vh></v>
<v t="ekr.20050712070251.508"><vh>stdErrIsRedirected &amp; stdOutIsRedirected</vh></v>
<v t="ekr.20050712070251.509"><vh>rawPrint</vh></v>
</v>
<v t="ekr.20050712070251.510"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.511"><vh>leoLog.__init__</vh></v>
<v t="ekr.20050712070251.512"><vh>class nullLog</vh>
<v t="ekr.20050712070251.513"><vh>nullLog.__init__</vh></v>
<v t="ekr.20050712070251.514"><vh>createControl</vh></v>
<v t="ekr.20050712070251.515"><vh>oops</vh></v>
<v t="ekr.20050712070251.516"><vh>put and putnl (nullLog)</vh></v>
<v t="ekr.20050712070251.517"><vh>setColorFromConfig &amp; setFontFromConfig</vh></v>
</v>
<v t="ekr.20050712070251.518"><vh>class nullFrame</vh>
<v t="ekr.20050712070251.519"><vh> ctor</vh></v>
<v t="ekr.20050712070251.520"><vh>deiconfy, lift, update</vh></v>
<v t="ekr.20050712070251.521"><vh>destroySelf</vh></v>
<v t="ekr.20050712070251.522"><vh>finishCreate</vh></v>
<v t="ekr.20050712070251.523"><vh>get_window_info</vh></v>
<v t="ekr.20050712070251.524"><vh>lift</vh></v>
<v t="ekr.20050712070251.525"><vh>oops</vh></v>
<v t="ekr.20050712070251.526"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20050712070251.527"><vh>setTopGeometry</vh></v>
</v>
</v>
<v t="ekr.20050712070251.528"><vh>(Use entire script when executing script buttons)</vh>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20050712070251.536"><vh>(Fixed error reporting in executeScript when the error happens outside the script)</vh>
<v t="ekr.20050712070251.537"><vh>Report from e</vh></v>
<v t="ekr.20050712070251.538"><vh>Report 2 from e</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.539"><vh>getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20050712070251.540"><vh>es_exception &amp; test</vh>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20050712070251.542"><vh>goToScriptLineNumber</vh></v>
</v>
</v>
<v t="ekr.20050712070251.543"><vh>Startup</vh>
<v t="ekr.20050712070251.544"><vh>(Fixed bug re non-existent filename on command line)</vh>
<v t="ekr.20050712070251.545"><vh>Report</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
</v>
<v t="ekr.20050712070251.547"><vh>(Better handling of duplicate menu shortcuts)</vh>
<v t="ekr.20050712070251.220"><vh>clearAccel</vh></v>
<v t="ekr.20050712070251.187"><vh>createMenuEntries</vh>
<v t="ekr.20050712070251.188"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="ekr.20050712070251.189"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="ekr.20050712070251.190"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="ekr.20050712070251.191"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="ekr.20050712070251.192"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="ekr.20050712070251.193"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.548"><vh>(Fixed configuration bug)</vh>
<v t="ekr.20050712070251.549"><vh>Report</vh></v>
<v t="ekr.20050712070251.550"><vh>getOutputNewline</vh></v>
</v>
<v t="ekr.20050712070251.551"><vh>(Investigated Control-Q binding)</vh></v>
</v>
<v t="ekr.20050712070251.552"><vh>(Simplified and improved shift-click scrolling code)</vh>
<v t="ekr.20050712070251.553"><vh>Notes</vh></v>
<v t="ekr.20050712070251.13"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.554"><vh>Cleanup...</vh>
<v t="ekr.20050712070251.555"><vh>(Cleaned up code in runOpenFileDialog)</vh>
<v t="ekr.20050712070251.33"><vh>app.gui.Tkinter file dialogs</vh></v>
</v>
<v t="ekr.20050712070251.556"><vh>Removed use_gnx</vh></v>
<v t="ekr.20050712070251.557"><vh>Removed write_old_format_derived_files</vh>
<v t="ekr.20050712070251.558"><vh>top_df.writeOld/NewDerivedFiles (no longer used)</vh></v>
<v t="ekr.20050712070251.559"><vh>writeNew/OldDerivedFiles (no longer used)</vh></v>
</v>
<v t="ekr.20050712070251.560"><vh>(Converted to new leoAtFile code)</vh>
<v t="ekr.20050712070251.561"><vh>What I did</vh></v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050712070251.259"><vh>initWriteIvars</vh>
<v t="ekr.20050712070251.260"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.562"><vh>(Improved and repacked pretty printing)</vh>
<v t="ekr.20050712070251.563"><vh>Notes</vh></v>
<v t="ekr.20050712070251.56"><vh>Pretty Print commands</vh>
<v t="ekr.20050712070251.57"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20050712070251.58"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20050712070251.59"><vh>class prettyPrinter</vh>
<v t="ekr.20050712070251.60"><vh>__init__</vh>
<v t="ekr.20050712070251.61"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.62"><vh>clear</vh></v>
<v t="ekr.20050712070251.63"><vh>dumpLines</vh></v>
<v t="ekr.20050712070251.64"><vh>dumpToken</vh></v>
<v t="ekr.20050712070251.65"><vh>endUndo</vh></v>
<v t="ekr.20050712070251.66"><vh>get</vh></v>
<v t="ekr.20050712070251.67"><vh>prettyPrintNode</vh></v>
<v t="ekr.20050712070251.68"><vh>put</vh></v>
<v t="ekr.20050712070251.69"><vh>putArray</vh></v>
<v t="ekr.20050712070251.70"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20050712070251.71"><vh>doEndMarker</vh></v>
<v t="ekr.20050712070251.72"><vh>doErrorToken</vh></v>
<v t="ekr.20050712070251.73"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20050712070251.74"><vh>doMultiLine</vh></v>
<v t="ekr.20050712070251.75"><vh>doName</vh></v>
<v t="ekr.20050712070251.76"><vh>doNewline</vh></v>
<v t="ekr.20050712070251.77"><vh>doNumber</vh></v>
<v t="ekr.20050712070251.78"><vh>doOp</vh></v>
<v t="ekr.20050712070251.79"><vh>doStartLine</vh></v>
<v t="ekr.20050712070251.80"><vh>oops</vh></v>
<v t="ekr.20050712070251.81"><vh>trace</vh></v>
</v>
<v t="ekr.20050712070251.82"><vh>putToken</vh></v>
<v t="ekr.20050712070251.83"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.564"><vh>(Removed g.os_path_norm and g.os_path_normabs)</vh>
<v t="ekr.20050712070251.565"><vh>Traceback</vh></v>
</v>
<v t="ekr.20050712070251.566"><vh>(Fixed shawdow warnings)</vh>
<v t="ekr.20050712070251.567"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20050712070251.568"><vh>leoApp (done)</vh></v>
<v t="ekr.20050712070251.569"><vh>leoPlugins (done)</vh></v>
<v t="ekr.20050712070251.570"><vh>leoColor (done)</vh></v>
<v t="ekr.20050712070251.571"><vh>leoNodes (done)</vh></v>
<v t="ekr.20050712070251.572"><vh>leoCompare (done)</vh></v>
<v t="ekr.20050712070251.573"><vh>leoFind (done)</vh></v>
<v t="ekr.20050712070251.574"><vh>leoMenu (done)</vh></v>
<v t="ekr.20050712070251.575"><vh>leoTkinterTree (done)</vh></v>
<v t="ekr.20050712070251.576"><vh>leoTkinterFrame (done)</vh></v>
<v t="ekr.20050712070251.577"><vh>leoTkinterPrefs (done)</vh></v>
<v t="ekr.20050712070251.578"><vh>leoTkinterGui (done)</vh></v>
<v t="ekr.20050712070251.579"><vh>leoAtFile (done)</vh></v>
<v t="ekr.20050712070251.580"><vh>leoFileCommands (done)</vh></v>
<v t="ekr.20050712070251.581"><vh>leoImport (done)</vh></v>
<v t="ekr.20050712070251.582"><vh>leoTangle (done)</vh></v>
<v t="ekr.20050712070251.583"><vh>leoCommands (done)</vh></v>
</v>
<v t="ekr.20050712070251.584"><vh>(Always use os.rename in utils_rename)</vh>
<v t="ekr.20050712070251.585"><vh>Notes</vh></v>
<v t="ekr.20050712070251.586"><vh>Used by tangle code &amp; leoFileCommands</vh>
<v t="ekr.20050712070251.587"><vh>g.update_file_if_changed</vh></v>
<v t="ekr.20050712070251.588"><vh>g.utils_remove &amp; test</vh>
<v t="ekr.20050712070251.589"><vh>test_g_utils_remove</vh></v>
</v>
<v t="ekr.20050712070251.590"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20050712070251.591"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20050712070251.592"><vh>test_g_utils_rename</vh></v>
</v>
<v t="ekr.20050712070251.593"><vh>g.utils_chmod</vh></v>
<v t="ekr.20050712070251.594"><vh>g.utils_stat</vh></v>
</v>
<v t="ekr.20050712070251.595"><vh>write_Leo_file</vh>
<v t="ekr.20050712070251.596"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.597"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050712070251.598"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.599"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.600"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.601"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.602"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.240"><vh>replaceTargetFileIfDifferent</vh>
<v t="ekr.20050712070251.241"><vh>&lt;&lt; files are identical &gt;&gt;</vh></v>
<v t="ekr.20050712070251.242"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.452"><vh>writeError</vh></v>
<v t="ekr.20050712070251.463"><vh>atFile.error</vh></v>
<v t="ekr.20050712070251.454"><vh>Uilites... (atFile)</vh>
<v t="ekr.20050712070251.455"><vh>file operations...</vh>
<v t="ekr.20050712070251.456"><vh>chmod</vh></v>
<v t="ekr.20050712070251.457"><vh>rename &amp; test</vh>
<v t="ekr.20050712070251.458"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20050712070251.459"><vh>test_atFile_rename</vh></v>
</v>
<v t="ekr.20050712070251.460"><vh>remove &amp; test</vh>
<v t="ekr.20050712070251.461"><vh>test_atFile_remove</vh></v>
</v>
<v t="ekr.20050712070251.462"><vh>stat</vh></v>
</v>
<v t="ekr.20050712070251.463"><vh>atFile.error</vh></v>
<v t="ekr.20050712070251.464"><vh>atFile.printError &amp; test</vh></v>
<v t="ekr.20050712070251.465"><vh>exception</vh></v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.466"><vh>scanDefaultDirectory</vh>
<v t="ekr.20050712070251.467"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
<v t="ekr.20050712070251.468"><vh>&lt;&lt; handle @path &gt;&gt; in df.scanDeafaultDirectory in leoAtFile.py</vh>
<v t="ekr.20050712070251.469"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.470"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.471"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.472"><vh>scanForClonedSibs (reading &amp; writing)</vh></v>
<v t="ekr.20050712070251.473"><vh>sentinelName</vh></v>
</v>
</v>
<v t="ekr.20050712070251.603"><vh>(Fixed Pychecker warnings)</vh>
<v t="ekr.20050712070251.604"><vh>Real bugs in leoConfig.py</vh></v>
<v t="ekr.20050712070251.605"><vh>Warnings</vh></v>
<v t="ekr.20050712070251.567"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.606"><vh>Config...</vh>
<v t="ekr.20050712070251.607"><vh> What I did</vh></v>
<v t="ekr.20050712070251.608"><vh>Diary</vh>
<v t="ekr.20050712070251.609"><vh>11/17 Prepared for new code</vh></v>
<v t="ekr.20050712070251.610"><vh>11/18 Modified core for new code</vh>
<v t="ekr.20050712070251.611"><vh>Removed old spellings of config getters</vh></v>
</v>
<v t="ekr.20050712070251.612"><vh>11/19 Wrote first draft of new code</vh></v>
<v t="ekr.20050712070251.613"><vh>11/20 Connected the new code</vh>
<v t="ekr.20050712070251.614"><vh>Added gui param to fram</vh></v>
<v t="ekr.20050712070251.615"><vh>Added destroySelf method to nullFram</vh></v>
<v t="ekr.20050712070251.616"><vh>Changed g.app.config.use_psyco to g.app.use_psyco</vh></v>
<v t="ekr.20050712070251.617"><vh>created g.app.nodeIndices before initing config class</vh></v>
<v t="ekr.20050712070251.618"><vh>Removed use_psycho option</vh></v>
<v t="ekr.20050712070251.619"><vh>Removed config_encoding ivar</vh></v>
</v>
<v t="ekr.20050712070251.620"><vh>11/21 Multiple find panels</vh></v>
<v t="ekr.20050712070251.621"><vh>11/24 Improved how names get munged</vh></v>
<v t="ekr.20050712070251.622"><vh>(11/17 to 11/4)</vh>
<v t="ekr.20050712070251.623"><vh>(Translating types)</vh>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
<v t="ekr.20050712070251.628"><vh>getFontFromParams (config)</vh></v>
</v>
<v t="ekr.20050712070251.629"><vh>(Suppressed over-ride message when loading a leoSettings.leo file)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
</v>
<v t="ekr.20050712070251.630"><vh>(Syntax checker ignores @settings nodes)</vh>
<v t="ekr.20050712070251.631"><vh>checkAllPythonCode</vh>
<v t="ekr.20050712070251.632"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.633"><vh>g.scanForAtSettings</vh></v>
</v>
<v t="ekr.20050712070251.634"><vh>(Update recent files in local .leo file when opening another file)</vh>
<v t="ekr.20050712070251.635"><vh>What I did</vh></v>
<v t="ekr.20050712070251.636"><vh>c.updateRecentFiles</vh></v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.638"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20050712070251.639"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.640"><vh>class configSettings</vh>
<v t="ekr.20050712070251.641"><vh>configSettings.__init__</vh>
<v t="ekr.20050712070251.642"><vh>initIvar</vh></v>
<v t="ekr.20050712070251.643"><vh>initEncoding</vh></v>
</v>
<v t="ekr.20050712070251.644"><vh>Getters</vh></v>
<v t="ekr.20050712070251.645"><vh>Setters...</vh>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.647"><vh>set &amp; setString</vh></v>
</v>
</v>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
</v>
<v t="ekr.20050712070251.648"><vh>(Problems overriding defaults)</vh>
<v t="ekr.20050712070251.649"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20050712070251.650"><vh>openSettingsFile</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050712070251.652"><vh>readSettings</vh></v>
</v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.653"><vh>run &amp; allies</vh>
<v t="ekr.20050712070251.654"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20050712070251.655"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20050712070251.656"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20050712070251.657"><vh>isValidPython</vh></v>
<v t="ekr.20050712070251.658"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20050712070251.659"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20050712070251.660"><vh>getBatchScript</vh></v>
<v t="ekr.20050712070251.661"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20050712070251.662"><vh>open</vh>
<v t="ekr.20050712070251.663"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.664"><vh>getLeoFile</vh>
<v t="ekr.20050712070251.665"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20050712070251.666"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20050712070251.667"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="ekr.20050712070251.668"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.669"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.670"><vh>(Don't munge window title, make sure to munge when comparing c.mFileName)</vh>
<v t="ekr.20050712070251.658"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
</v>
<v t="ekr.20050712070251.671"><vh>(Create Tix dialog)</vh>
<v t="ekr.20050712070251.672"><vh>createRootWindow &amp; allies</vh>
<v t="ekr.20050712070251.673"><vh>setDefaultIcon</vh></v>
<v t="ekr.20050712070251.674"><vh>tkGui.getDefaultConfigFont</vh></v>
<v t="ekr.20050712070251.675"><vh>&lt;&lt; fix problems with menus (XP) &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.676"><vh>(Problems importing Pmw files)</vh>
<v t="ekr.20050712070251.677"><vh>import.__init__</vh></v>
<v t="ekr.20050712070251.129"><vh>scanDirectives (utils)</vh>
<v t="ekr.20050712070251.130"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.131"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.132"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.133"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.134"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.135"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.136"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.137"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.138"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.678"><vh>Python scanners</vh>
<v t="ekr.20050712070251.679"><vh>scanPythonClass</vh>
<v t="ekr.20050712070251.680"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="ekr.20050712070251.681"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.682"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="ekr.20050712070251.683"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.684"><vh>&lt;&lt; append any other class material &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.685"><vh>scanPythonDef</vh>
<v t="ekr.20050712070251.686"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="ekr.20050712070251.687"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="ekr.20050712070251.688"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.689"><vh>scanPythonDecls</vh>
<v t="ekr.20050712070251.690"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="ekr.20050712070251.691"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.692"><vh>scanPythonText</vh>
<v t="ekr.20050712070251.693"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="ekr.20050712070251.694"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.695"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.696"><vh>(Eliminated alarming warning message)</vh>
<v t="ekr.20050712070251.668"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.697"><vh>putDescendentAttributes</vh></v>
<v t="ekr.20050712070251.488"><vh>putUnknownAttributes</vh></v>
</v>
<v t="ekr.20050712070251.698"><vh>(Don't call plugins for null gui's)</vh>
<v t="ekr.20050712070251.699"><vh>g.doHook</vh></v>
</v>
<v t="ekr.20050712070251.700"><vh>(Mods to drawTopTree)</vh>
<v t="ekr.20050712070251.701"><vh>drawTopTree</vh></v>
<v t="ekr.20050712070251.702"><vh>drawTree</vh></v>
<v t="ekr.20050712070251.703"><vh>p.Iterators</vh>
<v t="ekr.20050712070251.704"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="ekr.20050712070251.705"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20050712070251.706"><vh>p.allNodes_iter</vh>
<v t="ekr.20050712070251.707"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.708"><vh>next</vh></v>
</v>
<v t="ekr.20050712070251.709"><vh>p.subtree_iter</vh>
<v t="ekr.20050712070251.710"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.711"><vh>next</vh></v>
</v>
<v t="ekr.20050712070251.712"><vh>p.children_iter</vh>
<v t="ekr.20050712070251.713"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.714"><vh>next</vh></v>
</v>
<v t="ekr.20050712070251.715"><vh>p.parents_iter</vh>
<v t="ekr.20050712070251.716"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.717"><vh>next</vh></v>
</v>
<v t="ekr.20050712070251.718"><vh>p.siblings_iter</vh>
<v t="ekr.20050712070251.719"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.720"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20050712070251.721"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20050712070251.722"><vh>(Problems writing to a file with a nullFrame)</vh>
<v t="ekr.20050712070251.518"><vh>class nullFrame</vh>
<v t="ekr.20050712070251.519"><vh> ctor</vh></v>
<v t="ekr.20050712070251.520"><vh>deiconfy, lift, update</vh></v>
<v t="ekr.20050712070251.521"><vh>destroySelf</vh></v>
<v t="ekr.20050712070251.522"><vh>finishCreate</vh></v>
<v t="ekr.20050712070251.523"><vh>get_window_info</vh></v>
<v t="ekr.20050712070251.524"><vh>lift</vh></v>
<v t="ekr.20050712070251.525"><vh>oops</vh></v>
<v t="ekr.20050712070251.526"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20050712070251.527"><vh>setTopGeometry</vh></v>
</v>
</v>
<v t="ekr.20050712070251.723"><vh>(Finished g.app.config.set)</vh>
<v t="ekr.20050712070251.724"><vh> c.Birth &amp; death</vh>
<v t="ekr.20050712070251.725"><vh>c.__init__</vh></v>
<v t="ekr.20050712070251.726"><vh>c.initIvars</vh>
<v t="ekr.20050712070251.727"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.728"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20050712070251.729"><vh>c.hash</vh></v>
</v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
</v>
<v t="ekr.20050712070251.730"><vh>(Updated recent files properly)</vh>
<v t="ekr.20050712070251.731"><vh>What I did</vh></v>
<v t="ekr.20050712070251.640"><vh>class configSettings</vh>
<v t="ekr.20050712070251.641"><vh>configSettings.__init__</vh>
<v t="ekr.20050712070251.642"><vh>initIvar</vh></v>
<v t="ekr.20050712070251.643"><vh>initEncoding</vh></v>
</v>
<v t="ekr.20050712070251.644"><vh>Getters</vh></v>
<v t="ekr.20050712070251.645"><vh>Setters...</vh>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.647"><vh>set &amp; setString</vh></v>
</v>
</v>
<v t="ekr.20050712070251.732"><vh>Notes</vh></v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.733"><vh>config.findSettingsPosition</vh></v>
<v t="ekr.20050712070251.734"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
</v>
</v>
<v t="ekr.20050712070251.735"><vh>12/11</vh>
<v t="ekr.20050712070251.736"><vh>(Fixed minor bugs in spelling plugin)</vh></v>
</v>
<v t="ekr.20050712070251.737"><vh>12/17</vh>
<v t="ekr.20050712070251.738"><vh>(Fix problems with c.ivars)</vh>
<v t="ekr.20050712070251.739"><vh>From 4.2</vh>
<v t="ekr.20050712070251.740"><vh>defaultsDict</vh></v>
<v t="ekr.20050712070251.741"><vh>initialize ivars that may be set by config options</vh></v>
<v t="ekr.20050712070251.742"><vh>set in c.__init__</vh></v>
</v>
<v t="ekr.20050712070251.743"><vh>ivarsDict</vh></v>
<v t="ekr.20050712070251.649"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20050712070251.650"><vh>openSettingsFile</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050712070251.652"><vh>readSettings</vh></v>
</v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
</v>
<v t="ekr.20050712070251.744"><vh>(Support for @font)</vh>
<v t="ekr.20050712070251.745"><vh>parseFont</vh></v>
<v t="ekr.20050712070251.746"><vh>parseFontLine</vh></v>
<v t="ekr.20050712070251.747"><vh>doFont</vh></v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
</v>
<v t="ekr.20050712070251.748"><vh>(Fixed long-standing problem with clashing fonts)</vh>
<v t="ekr.20050712070251.749"><vh>tkLog.setFontFromConfig</vh></v>
<v t="ekr.20050712070251.750"><vh>tkBody.setFontFromConfig</vh></v>
<v t="ekr.20050712070251.751"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="ekr.20050712070251.628"><vh>getFontFromParams (config)</vh></v>
<v t="ekr.20050712070251.752"><vh>tkGui.getFontFromParams</vh></v>
<v t="ekr.20050712070251.674"><vh>tkGui.getDefaultConfigFont</vh></v>
<v t="ekr.20050712070251.753"><vh>setFontFromConfig</vh></v>
<v t="ekr.20050712070251.754"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20050712070251.755"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.756"><vh>(Changed lookup: added localOptionsList</vh>
<v t="ekr.20050712070251.729"><vh>c.hash</vh></v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
</v>
<v t="ekr.20050712070251.757"><vh>(Update all colors immediately)</vh>
<v t="ekr.20050712070251.758"><vh>tkBody.setColorFromConfig</vh></v>
<v t="ekr.20050712070251.759"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20050712070251.760"><vh>tkTree.setColorFromConfig</vh></v>
</v>
</v>
<v t="ekr.20050712070251.761"><vh>12/18</vh>
<v t="ekr.20050712070251.762"><vh>(Used Bunch to clarify config code)</vh>
<v t="ekr.20050712070251.763"><vh>class Bunch (object)</vh></v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.764"><vh>&lt;&lt; update recent files from d &gt;&gt;</vh></v>
<v t="ekr.20050712070251.641"><vh>configSettings.__init__</vh>
<v t="ekr.20050712070251.642"><vh>initIvar</vh></v>
<v t="ekr.20050712070251.643"><vh>initEncoding</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.765"><vh>(New leoTkinterFrame projects)</vh>
<v t="ekr.20050712070251.766"><vh>(Pane sizes)</vh>
<v t="ekr.20050712070251.767"><vh>onPmwResizeSplitter1/2</vh></v>
<v t="ekr.20050712070251.150"><vh>resizePanesToRatio</vh>
<v t="ekr.20050712070251.151"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.768"><vh>equalSizedPanes</vh></v>
<v t="ekr.20050712070251.769"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20050712070251.770"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20050712070251.771"><vh>Pmw...</vh>
<v t="ekr.20050712070251.772"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20050712070251.150"><vh>resizePanesToRatio</vh>
<v t="ekr.20050712070251.151"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.767"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20050712070251.773"><vh>Tk...</vh>
<v t="ekr.20050712070251.774"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20050712070251.775"><vh>bindBar</vh></v>
<v t="ekr.20050712070251.776"><vh>divideAnySplitter</vh></v>
<v t="ekr.20050712070251.777"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20050712070251.778"><vh>onDrag...</vh></v>
<v t="ekr.20050712070251.779"><vh>placeSplitter</vh></v>
<v t="ekr.20050712070251.780"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.788"><vh>initialRatios</vh></v>
</v>
<v t="ekr.20050712070251.789"><vh>(Tried using place to show widgets)</vh>
<v t="ekr.20050712070251.790"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20050712070251.791"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20050712070251.11"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050712070251.12"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20050712070251.13"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.792"><vh>(Replacing body pane)</vh>
<v t="ekr.20050712070251.793"><vh>class componentBaseClass</vh>
<v t="ekr.20050712070251.794"><vh> ctor</vh></v>
<v t="ekr.20050712070251.795"><vh>__repr__</vh></v>
<v t="ekr.20050712070251.796"><vh>oops</vh></v>
<v t="ekr.20050712070251.797"><vh>getters</vh></v>
<v t="ekr.20050712070251.798"><vh>must be defined in subclasses</vh></v>
<v t="ekr.20050712070251.799"><vh>show &amp; hide, pack &amp; unpack</vh></v>
</v>
<v t="ekr.20050712070251.800"><vh>class componentClass (componentBaseClass)</vh>
<v t="ekr.20050712070251.801"><vh> ctor</vh></v>
<v t="ekr.20050712070251.802"><vh>__repr__</vh></v>
<v t="ekr.20050712070251.803"><vh>destroy</vh></v>
<v t="ekr.20050712070251.804"><vh>getters &amp; setters</vh></v>
<v t="ekr.20050712070251.805"><vh>pack &amp; unpack</vh></v>
</v>
<v t="ekr.20050712070251.806"><vh>tkFrame.unpack/repack...</vh>
<v t="ekr.20050712070251.807"><vh>pane packers</vh></v>
<v t="ekr.20050712070251.808"><vh>pane replacers</vh>
<v t="ekr.20050712070251.809"><vh>replaceBodyPaneWithComponent</vh></v>
<v t="ekr.20050712070251.810"><vh>replaceLogPaneWithComponent</vh></v>
<v t="ekr.20050712070251.811"><vh>replaceTreePaneWithComponent</vh></v>
</v>
<v t="ekr.20050712070251.812"><vh>pane unpackers</vh></v>
<v t="ekr.20050712070251.813"><vh>pack/unpackComponent</vh></v>
<v t="ekr.20050712070251.814"><vh>show/hideComponent</vh></v>
</v>
<v t="ekr.20050712070251.815"><vh>class statusLineClass</vh>
<v t="ekr.20050712070251.816"><vh> ctor</vh></v>
<v t="ekr.20050712070251.817"><vh>clear</vh></v>
<v t="ekr.20050712070251.818"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20050712070251.819"><vh>get</vh></v>
<v t="ekr.20050712070251.820"><vh>getFrame</vh></v>
<v t="ekr.20050712070251.821"><vh>onActivate</vh></v>
<v t="ekr.20050712070251.822"><vh>pack &amp; show</vh></v>
<v t="ekr.20050712070251.823"><vh>put (leoTkinterFrame)</vh></v>
<v t="ekr.20050712070251.824"><vh>setFocus</vh></v>
<v t="ekr.20050712070251.825"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20050712070251.826"><vh>update</vh></v>
</v>
<v t="ekr.20050712070251.827"><vh>Icon area methods (compatibility)</vh></v>
<v t="ekr.20050712070251.828"><vh>Status line methods (compatibility)</vh></v>
<v t="ekr.20050712070251.829"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20050712070251.830"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20050712070251.831"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.832"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20050712070251.833"><vh>f.component &amp; components</vh></v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.790"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20050712070251.791"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20050712070251.11"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050712070251.12"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20050712070251.13"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.769"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20050712070251.770"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20050712070251.771"><vh>Pmw...</vh>
<v t="ekr.20050712070251.772"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20050712070251.150"><vh>resizePanesToRatio</vh>
<v t="ekr.20050712070251.151"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.767"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20050712070251.773"><vh>Tk...</vh>
<v t="ekr.20050712070251.774"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20050712070251.775"><vh>bindBar</vh></v>
<v t="ekr.20050712070251.776"><vh>divideAnySplitter</vh></v>
<v t="ekr.20050712070251.777"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20050712070251.778"><vh>onDrag...</vh></v>
<v t="ekr.20050712070251.779"><vh>placeSplitter</vh></v>
<v t="ekr.20050712070251.780"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.834"><vh>Destroying the frame</vh>
<v t="ekr.20050712070251.835"><vh>destroyAllObjects</vh>
<v t="ekr.20050712070251.836"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.837"><vh>destroyAllPanels</vh></v>
<v t="ekr.20050712070251.838"><vh>destroySelf</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.839"><vh>12/28</vh>
<v t="ekr.20050712070251.840"><vh>(Made shortcuts functional)</vh>
<v t="ekr.20050712070251.180"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20050712070251.841"><vh>&lt;&lt;  class data &gt;&gt;</vh>
<v t="ekr.20050712070251.842"><vh>defaultsDict</vh></v>
<v t="ekr.20050712070251.843"><vh>define encodingIvarsDict</vh></v>
<v t="ekr.20050712070251.743"><vh>ivarsDict</vh></v>
</v>
<v t="ekr.20050712070251.640"><vh>class configSettings</vh>
<v t="ekr.20050712070251.641"><vh>configSettings.__init__</vh>
<v t="ekr.20050712070251.642"><vh>initIvar</vh></v>
<v t="ekr.20050712070251.643"><vh>initEncoding</vh></v>
</v>
<v t="ekr.20050712070251.644"><vh>Getters</vh></v>
<v t="ekr.20050712070251.645"><vh>Setters...</vh>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.647"><vh>set &amp; setString</vh></v>
</v>
</v>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20050712070251.844"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20050712070251.845"><vh>doShortcut</vh></v>
<v t="ekr.20050712070251.846"><vh>doShortcuts</vh></v>
<v t="ekr.20050712070251.847"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20050712070251.848"><vh>(Made ivars functional)</vh>
<v t="ekr.20050712070251.849"><vh>What I did</vh></v>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.850"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20050712070251.726"><vh>c.initIvars</vh>
<v t="ekr.20050712070251.727"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.851"><vh>(Added scrollbars to settings outline pane)</vh>
<v t="ekr.20050712070251.852"><vh>When replacing body &amp; tree panes...</vh></v>
</v>
<v t="ekr.20050712070251.853"><vh>(Improved appearance of settings panel)</vh>
<v t="ekr.20050712070251.854"><vh>What I did</vh></v>
</v>
<v t="ekr.20050712070251.855"><vh>(Clear Recent Files now updates @recent_files node properly)</vh>
<v t="ekr.20050712070251.856"><vh>What I did</vh></v>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.857"><vh>clearRecentFiles</vh></v>
</v>
<v t="ekr.20050712070251.858"><vh>(Made sure recent files have correct capitalization)</vh>
<v t="ekr.20050712070251.859"><vh>What I did</vh></v>
<v t="ekr.20050712070251.636"><vh>c.updateRecentFiles</vh></v>
</v>
<v t="ekr.20050712070251.860"><vh>(Print setting changes to log)</vh>
<v t="ekr.20050712070251.861"><vh>writeChangedVars &amp; helpers</vh>
<v t="ekr.20050712070251.862"><vh>updateConfig</vh></v>
<v t="ekr.20050712070251.863"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20050712070251.864"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20050712070251.865"><vh>writeChangedList</vh>
<v t="ekr.20050712070251.866"><vh>&lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.867"><vh>writeChangesToFile</vh></v>
</v>
</v>
<v t="ekr.20050712070251.868"><vh>(Disabled all commands while in settings dialog)</vh>
<v t="ekr.20050712070251.869" a="M"><vh> doCommand</vh></v>
<v t="ekr.20050712070251.870"><vh>onAnyButton</vh></v>
</v>
</v>
<v t="ekr.20050712070251.871"><vh>New features...</vh>
<v t="ekr.20050712070251.872"><vh>(Added new expand/contract or go commands)</vh>
<v t="ekr.20050712070251.172"><vh>&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.873"><vh>&lt;&lt; enable expand/Contract submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.874"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20050712070251.875"><vh>expandNodeOrGoToFirstChild</vh></v>
</v>
<v t="ekr.20050712070251.876"><vh>(Added support for readFromString to fileLikeObject)</vh>
<v t="ekr.20050712070251.877"><vh>g.fileLikeObject</vh>
<v t="ekr.20050712070251.878"><vh> ctor</vh></v>
<v t="ekr.20050712070251.879"><vh>clear</vh></v>
<v t="ekr.20050712070251.880"><vh>close</vh></v>
<v t="ekr.20050712070251.881"><vh>flush</vh></v>
<v t="ekr.20050712070251.882"><vh>get &amp; getvalue</vh></v>
<v t="ekr.20050712070251.883"><vh>readline</vh></v>
<v t="ekr.20050712070251.884"><vh>write</vh></v>
</v>
</v>
<v t="ekr.20050712070251.885"><vh>(Bernhard Mulder: Added support for Ada)</vh>
<v t="ekr.20050712070251.886"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20050712070251.887"><vh>ada keywords</vh></v>
<v t="ekr.20050712070251.888"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="ekr.20050712070251.889"><vh>(Added keyboard shortcuts to find panel)</vh>
<v t="ekr.20050712070251.890"><vh>What I did</vh></v>
<v t="ekr.20050712070251.891"><vh>class underlinedTkButton</vh>
<v t="ekr.20050712070251.892"><vh>__init__</vh>
<v t="ekr.20050712070251.893"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.894"><vh>bindHotKey</vh></v>
<v t="ekr.20050712070251.895"><vh>callback</vh></v>
</v>
<v t="ekr.20050712070251.896"><vh>Birth &amp; death</vh>
<v t="ekr.20050712070251.897"><vh>__init__</vh>
<v t="ekr.20050712070251.898"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.899"><vh>destroySelf</vh></v>
<v t="ekr.20050712070251.900"><vh>find.createFrame</vh>
<v t="ekr.20050712070251.901"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20050712070251.902"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.903"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.904"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.905"><vh>find.init</vh>
<v t="ekr.20050712070251.906"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20050712070251.907"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.908"><vh>(Investigated Initing Pmw &amp; Tk)</vh>
<v t="ekr.20050712070251.672"><vh>createRootWindow &amp; allies</vh>
<v t="ekr.20050712070251.673"><vh>setDefaultIcon</vh></v>
<v t="ekr.20050712070251.674"><vh>tkGui.getDefaultConfigFont</vh></v>
<v t="ekr.20050712070251.675"><vh>&lt;&lt; fix problems with menus (XP) &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.909"><vh>(Added support for g.app.debugSwitch in es_exception)</vh>
<v t="ekr.20050712070251.540"><vh>es_exception &amp; test</vh>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.910"><vh>(Added support for Forth)</vh>
<v t="ekr.20050712070251.911"><vh>In leoApp.py</vh>
<v t="ekr.20050712070251.886"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20050712070251.912"><vh>In leoColor.py</vh>
<v t="ekr.20050712070251.913"><vh>forth keywords</vh></v>
<v t="ekr.20050712070251.914"><vh>&lt;&lt; extend forth words from files &gt;&gt;</vh></v>
<v t="ekr.20050712070251.888"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
<v t="ekr.20050712070251.915"><vh>doNormalState</vh>
<v t="ekr.20050712070251.916"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20050712070251.917"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20050712070251.918"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20050712070251.919"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20050712070251.920"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20050712070251.921"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.922"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20050712070251.923"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20050712070251.924"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.925"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20050712070251.926"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20050712070251.927"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.928"><vh>Vaid only in latex mode</vh>
<v t="ekr.20050712070251.929"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.930"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20050712070251.931"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20050712070251.932"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.933"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20050712070251.934"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20050712070251.935"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20050712070251.936"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.937"><vh>In leoImport.py</vh>
<v t="ekr.20050712070251.938"><vh>createOutline</vh>
<v t="ekr.20050712070251.939"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.940"><vh>scanForthText</vh></v>
</v>
</v>
<v t="ekr.20050712070251.941"><vh>(Improved Go To Line Number and Execute Script commands)</vh>
<v t="ekr.20050712070251.942"><vh>Notes</vh></v>
<v t="ekr.20050712070251.540"><vh>es_exception &amp; test</vh>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050712070251.542"><vh>goToScriptLineNumber</vh></v>
<v t="ekr.20050712070251.943"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20050712070251.944"><vh>&lt;&lt; set root &gt;&gt;</vh></v>
<v t="ekr.20050712070251.945"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20050712070251.946"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20050712070251.947"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20050712070251.948"><vh>&lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;</vh>
<v t="ekr.20050712070251.949"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="ekr.20050712070251.950"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20050712070251.951"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20050712070251.952"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20050712070251.953"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20050712070251.954"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.955"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.956"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20050712070251.957"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.958"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20050712070251.959"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.960"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20050712070251.961"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.962"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.963"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
</v>
<v t="ekr.20050712070251.964"><vh>(Restored drawing/event hooks)</vh>
<v t="ekr.20050712070251.965"><vh>What I did</vh></v>
<v t="ekr.20050712070251.966"><vh>New plugins code</vh>
<v t="ekr.20050712070251.967"><vh>getHandlersForTag</vh></v>
<v t="ekr.20050712070251.968"><vh>unregisterHandler</vh></v>
</v>
<v t="ekr.20050712070251.969"><vh>Changed code</vh>
<v t="ekr.20050712070251.970"><vh>Dragging</vh>
<v t="ekr.20050712070251.971"><vh>endDrag</vh>
<v t="ekr.20050712070251.972"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20050712070251.973"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.974"><vh>startDrag</vh></v>
<v t="ekr.20050712070251.975"><vh>onContinueDrag</vh>
<v t="ekr.20050712070251.976"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.977"><vh>onDrag</vh></v>
<v t="ekr.20050712070251.978"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20050712070251.979"><vh>onClickBoxClick</vh></v>
<v t="ekr.20050712070251.980"><vh>Icon Box...</vh>
<v t="ekr.20050712070251.981"><vh>onIconBoxClick</vh></v>
<v t="ekr.20050712070251.982"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20050712070251.983"><vh>onIconBoxDoubleClick</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.984"><vh>Added p=p param to all hooks containing v=v</vh></v>
<v t="ekr.20050712070251.985"><vh>(Eliminated global find panel, inited from @settings)</vh>
<v t="ekr.20050712070251.986"><vh>What I did</vh></v>
<v t="ekr.20050712070251.905"><vh>find.init</vh>
<v t="ekr.20050712070251.906"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20050712070251.907"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.987"><vh>find.update_ivars</vh></v>
<v t="ekr.20050712070251.988"><vh>getFindPanelSettings</vh></v>
</v>
<v t="ekr.20050712070251.989"><vh>(added a 3rd party extension mechanism)</vh>
<v t="ekr.20050712070251.990"><vh>Notes</vh></v>
<v t="ekr.20050712070251.5"><vh>import wrappers</vh>
<v t="ekr.20050712070251.6"><vh>g.cantImport</vh></v>
<v t="ekr.20050712070251.7"><vh>g.importModule</vh></v>
<v t="ekr.20050712070251.8"><vh>g.importExtension</vh></v>
<v t="ekr.20050712070251.9"><vh>g.importFromPath</vh></v>
</v>
<v t="ekr.20050712070251.653"><vh>run &amp; allies</vh>
<v t="ekr.20050712070251.654"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20050712070251.655"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20050712070251.656"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20050712070251.657"><vh>isValidPython</vh></v>
<v t="ekr.20050712070251.658"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20050712070251.659"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20050712070251.660"><vh>getBatchScript</vh></v>
<v t="ekr.20050712070251.661"><vh>reportDirectories</vh></v>
</v>
</v>
<v t="ekr.20050712070251.991"><vh>(Patched computeHomeDir to handle references to other vars)</vh>
<v t="ekr.20050712070251.992"><vh>Original posting</vh></v>
<v t="ekr.20050712070251.993"><vh>computeHomeDir</vh></v>
</v>
<v t="ekr.20050712070251.994"><vh>(Changes to plugin handling)</vh>
<v t="ekr.20050712070251.995"><vh>What I did</vh></v>
<v t="ekr.20050712070251.996"><vh>Bugs fixed</vh></v>
<v t="ekr.20050712070251.997"><vh>g.plugin_signon</vh></v>
<v t="ekr.20050712070251.6"><vh>g.cantImport</vh></v>
<v t="ekr.20050712070251.998"><vh>registerHandler</vh></v>
</v>
<v t="ekr.20050712070251.999"><vh>(Added support for Leo-relative files)</vh>
<v t="ekr.20050712070251.1000"><vh>@url file:.\..\doc\LeoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo</vh></v>
<v t="ekr.20050712070251.1001"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1002"><vh>os_path_join</vh></v>
<v t="ekr.20050712070251.1003"><vh>Directive utils...</vh>
<v t="ekr.20050712070251.1004"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20050712070251.1005"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20050712070251.1006"><vh>set_delims_from_language</vh></v>
<v t="ekr.20050712070251.1007"><vh>set_delims_from_string</vh></v>
<v t="ekr.20050712070251.1008"><vh>set_language</vh></v>
</v>
<v t="ekr.20050712070251.1009"><vh>findReference</vh></v>
<v t="ekr.20050712070251.1010"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20050712070251.1011"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1012"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.550"><vh>getOutputNewline</vh></v>
<v t="ekr.20050712070251.1013"><vh>scanAtEncodingDirective</vh></v>
<v t="ekr.20050712070251.1014"><vh>scanAtLineendingDirective</vh></v>
<v t="ekr.20050712070251.1015"><vh>scanAtPagewidthDirective</vh></v>
<v t="ekr.20050712070251.1016"><vh>scanAtTabwidthDirective</vh></v>
<v t="ekr.20050712070251.1017"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20050712070251.633"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20050712070251.1018"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20050712070251.129"><vh>scanDirectives (utils)</vh>
<v t="ekr.20050712070251.130"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.131"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.132"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.133"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.134"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.135"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.136"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.137"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.138"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1019"><vh>getBaseDirectory</vh></v>
<v t="ekr.20050712070251.1020"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20050712070251.1021"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1022"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1023"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20050712070251.1024"><vh>(Implemented 'Undo Clear Recent Files')</vh>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
</v>
<v t="ekr.20050712070251.1025"><vh>(Implemented delayed focus scheme)</vh>
<v t="ekr.20050712070251.1026"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1027"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20050712070251.1028"><vh>Activation methods</vh>
<v t="ekr.20050712070251.1029"><vh>OnActivate (tkTree)</vh>
<v t="ekr.20050712070251.1030"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1031"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20050712070251.1032"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="ekr.20050712070251.1033"><vh>OnActivateTree</vh></v>
<v t="ekr.20050712070251.1034"><vh>tkLog.onActivateLog</vh></v>
</v>
<v t="ekr.20050712070251.1035"><vh>tree.select</vh>
<v t="ekr.20050712070251.1036"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20050712070251.1037"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1038"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1039"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1040"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1041"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20050712070251.1042"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050712070251.1043"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20050712070251.815"><vh>class statusLineClass</vh>
<v t="ekr.20050712070251.816"><vh> ctor</vh></v>
<v t="ekr.20050712070251.817"><vh>clear</vh></v>
<v t="ekr.20050712070251.818"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20050712070251.819"><vh>get</vh></v>
<v t="ekr.20050712070251.820"><vh>getFrame</vh></v>
<v t="ekr.20050712070251.821"><vh>onActivate</vh></v>
<v t="ekr.20050712070251.822"><vh>pack &amp; show</vh></v>
<v t="ekr.20050712070251.823"><vh>put (leoTkinterFrame)</vh></v>
<v t="ekr.20050712070251.824"><vh>setFocus</vh></v>
<v t="ekr.20050712070251.825"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20050712070251.826"><vh>update</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1044"><vh>Plugins...</vh>
<v t="ekr.20050712070251.1045"><vh>(Improved status line plugin)</vh>
<v t="ekr.20050712070251.1046"><vh>What I did</vh></v>
<v t="ekr.20050712070251.829"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20050712070251.830"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20050712070251.831"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.832"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20050712070251.833"><vh>f.component &amp; components</vh></v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.790"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20050712070251.791"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20050712070251.11"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050712070251.12"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20050712070251.13"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.769"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20050712070251.770"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20050712070251.771"><vh>Pmw...</vh>
<v t="ekr.20050712070251.772"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20050712070251.150"><vh>resizePanesToRatio</vh>
<v t="ekr.20050712070251.151"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.767"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20050712070251.773"><vh>Tk...</vh>
<v t="ekr.20050712070251.774"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20050712070251.775"><vh>bindBar</vh></v>
<v t="ekr.20050712070251.776"><vh>divideAnySplitter</vh></v>
<v t="ekr.20050712070251.777"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20050712070251.778"><vh>onDrag...</vh></v>
<v t="ekr.20050712070251.779"><vh>placeSplitter</vh></v>
<v t="ekr.20050712070251.780"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.834"><vh>Destroying the frame</vh>
<v t="ekr.20050712070251.835"><vh>destroyAllObjects</vh>
<v t="ekr.20050712070251.836"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.837"><vh>destroyAllPanels</vh></v>
<v t="ekr.20050712070251.838"><vh>destroySelf</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1047"><vh>(More flexible plugin manager)</vh>
<v t="ekr.20050712070251.1048"><vh>getPluginModule</vh></v>
<v t="ekr.20050712070251.1049"><vh>loadOnePlugin</vh></v>
</v>
<v t="ekr.20050712070251.1050"><vh>(Fixed problems loading plugins)</vh>
<v t="ekr.20050712070251.1051"><vh>What I did</vh></v>
<v t="ekr.20050712070251.5"><vh>import wrappers</vh>
<v t="ekr.20050712070251.6"><vh>g.cantImport</vh></v>
<v t="ekr.20050712070251.7"><vh>g.importModule</vh></v>
<v t="ekr.20050712070251.8"><vh>g.importExtension</vh></v>
<v t="ekr.20050712070251.9"><vh>g.importFromPath</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1052"><vh>(Fixed problem with destroyed ivars)</vh>
<v t="ekr.20050712070251.1053"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1054"><vh>callTagHandler</vh></v>
<v t="ekr.20050712070251.1055"><vh>doHandlersForTag</vh></v>
<v t="ekr.20050712070251.1056"><vh>doPlugins</vh></v>
<v t="ekr.20050712070251.699"><vh>g.doHook</vh></v>
</v>
<v t="ekr.20050712070251.1057"><vh>(Fixed several plugin bugs)</vh>
<v t="ekr.20050712070251.1058"><vh>Report</vh></v>
<v t="ekr.20050712070251.1059"><vh>Fixes</vh></v>
<v t="ekr.20050712070251.699"><vh>g.doHook</vh></v>
<v t="ekr.20050712070251.1060"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20050712070251.1061"><vh>idle time functions (leoGlobals)</vh>
<v t="ekr.20050712070251.1062"><vh>enableIdleTimeHook</vh></v>
<v t="ekr.20050712070251.1063"><vh>disableIdleTimeHook</vh></v>
<v t="ekr.20050712070251.1064"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20050712070251.1054"><vh>callTagHandler</vh></v>
<v t="ekr.20050712070251.1056"><vh>doPlugins</vh></v>
<v t="ekr.20050712070251.1055"><vh>doHandlersForTag</vh></v>
<v t="ekr.20050712070251.998"><vh>registerHandler</vh></v>
</v>
<v t="ekr.20050712070251.1065"><vh>Fixed bug in Plugins Manager plugin: only triple-double quotes work in docstrings</vh></v>
<v t="ekr.20050712070251.1066"><vh>(Fixed conflict between settings panel conflicts and chapters plugin)</vh>
<v t="ekr.20050712070251.1067"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1068"><vh>&lt;&lt; replace tree pane with settings tree &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1069"><vh>4.3 a2 projects</vh>
<v t="ekr.20050712070251.1070"><vh> (Removed unused files)</vh></v>
<v t="ekr.20050712070251.1071"><vh>Bugs</vh>
<v t="ekr.20050712070251.1072"><vh>(Fixed very old bug in Undo Insert Node )</vh>
<v t="ekr.20050712070251.1073"><vh>Report</vh></v>
<v t="ekr.20050712070251.1074"><vh>c.insertHeadline</vh></v>
<v t="ekr.20050712070251.1075"><vh>undoInsertNodes</vh></v>
</v>
<v t="ekr.20050712070251.1076"><vh>(Made sure to remove duplicates from recent files)</vh>
<v t="ekr.20050712070251.734"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20050712070251.636"><vh>c.updateRecentFiles</vh></v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20050712070251.1077"><vh>Fixed indentation problems in leoTkinterFind.py</vh></v>
<v t="ekr.20050712070251.1078"><vh>(Changed Help menu &amp; related code to handle leoSettings.leo instead of leoConfig.leo)</vh>
<v t="ekr.20050712070251.1079"><vh>leoConfig</vh></v>
</v>
<v t="ekr.20050712070251.1080"><vh>(Investigated recent files problems)</vh>
<v t="ekr.20050712070251.1081"><vh>Report</vh></v>
<v t="ekr.20050712070251.1082"><vh>Added to @recentfile documentation</vh></v>
<v t="ekr.20050712070251.1083"><vh>Setters (g.app.config)</vh>
<v t="ekr.20050712070251.625"><vh>set (g.app.config)</vh></v>
<v t="ekr.20050712070251.1084"><vh>setString</vh></v>
<v t="ekr.20050712070251.850"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20050712070251.734"><vh>appendToRecentFiles (g.app.config)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1085"><vh>(Improved queuing of log messages)</vh>
<v t="ekr.20050712070251.1086"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1087"><vh>es &amp; related logic...</vh>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.1088"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="ekr.20050712070251.1089"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1090"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1091"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1092"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20050712070251.1094"><vh>es, enl, ecnl</vh></v>
<v t="ekr.20050712070251.1095"><vh>app.writeWaitingLog</vh></v>
</v>
<v t="ekr.20050712070251.1096"><vh>Added silent keyword to severl methods</vh>
<v t="ekr.20050712070251.662"><vh>open</vh>
<v t="ekr.20050712070251.663"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.664"><vh>getLeoFile</vh>
<v t="ekr.20050712070251.665"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20050712070251.666"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20050712070251.667"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="ekr.20050712070251.668"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.669"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1097"><vh>(Fixed crasher in Change All command)</vh></v>
<v t="ekr.20050712070251.1098"><vh>(Fixed crasher in script button)</vh>
<v t="ekr.20050712070251.1099"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.430"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
</v>
<v t="ekr.20050712070251.1100"><vh>(Fixed print problems on the Mac)</vh>
<v t="ekr.20050712070251.1101"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1102"><vh>(g.es called print on the Mac)</vh>
<v t="ekr.20050712070251.1094"><vh>es, enl, ecnl</vh></v>
<v t="ekr.20050712070251.823"><vh>put (leoTkinterFrame)</vh></v>
<v t="ekr.20050712070251.516"><vh>put and putnl (nullLog)</vh></v>
<v t="ekr.20050712070251.1103"><vh>class logClass</vh>
<v t="ekr.20050712070251.1104"><vh>&lt;&lt; put s to w &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1088"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="ekr.20050712070251.1089"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1090"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1091"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1092"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1105"><vh>leoTest.runTests now makes copies of all positions</vh></v>
<v t="ekr.20050712070251.1106"><vh>Fixed problems with unit test file paths</vh></v>
<v t="ekr.20050712070251.1107"><vh>(Made local config settings work again)</vh>
<v t="ekr.20050712070251.1108"><vh>Notes</vh></v>
<v t="ekr.20050712070251.841"><vh>&lt;&lt;  class data &gt;&gt;</vh>
<v t="ekr.20050712070251.842"><vh>defaultsDict</vh></v>
<v t="ekr.20050712070251.843"><vh>define encodingIvarsDict</vh></v>
<v t="ekr.20050712070251.743"><vh>ivarsDict</vh></v>
</v>
<v t="ekr.20050712070251.626"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20050712070251.627"><vh>getValFromDict</vh></v>
</v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.496"><vh>redirecting stderr and stdout</vh>
<v t="ekr.20050712070251.497"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh>
<v t="ekr.20050712070251.498"><vh>redirectClass.__init__</vh></v>
<v t="ekr.20050712070251.499"><vh>isRedirected</vh></v>
<v t="ekr.20050712070251.500"><vh>flush</vh></v>
<v t="ekr.20050712070251.501"><vh>rawPrint</vh></v>
<v t="ekr.20050712070251.502"><vh>redirect</vh></v>
<v t="ekr.20050712070251.503"><vh>undirect</vh></v>
<v t="ekr.20050712070251.504"><vh>write</vh></v>
</v>
<v t="ekr.20050712070251.505"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh>
<v t="ekr.20050712070251.506"><vh>redirectStderr &amp; redirectStdout</vh></v>
<v t="ekr.20050712070251.507"><vh>restoreStderr &amp; restoreStdout</vh></v>
<v t="ekr.20050712070251.508"><vh>stdErrIsRedirected &amp; stdOutIsRedirected</vh></v>
<v t="ekr.20050712070251.509"><vh>rawPrint</vh></v>
</v>
<v t="ekr.20050712070251.510"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.640"><vh>class configSettings</vh>
<v t="ekr.20050712070251.641"><vh>configSettings.__init__</vh>
<v t="ekr.20050712070251.642"><vh>initIvar</vh></v>
<v t="ekr.20050712070251.643"><vh>initEncoding</vh></v>
</v>
<v t="ekr.20050712070251.644"><vh>Getters</vh></v>
<v t="ekr.20050712070251.645"><vh>Setters...</vh>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.647"><vh>set &amp; setString</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1109"><vh>(Investigated redirection from scripts.  All appears well.)</vh>
<v t="ekr.20050712070251.496"><vh>redirecting stderr and stdout</vh>
<v t="ekr.20050712070251.497"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh>
<v t="ekr.20050712070251.498"><vh>redirectClass.__init__</vh></v>
<v t="ekr.20050712070251.499"><vh>isRedirected</vh></v>
<v t="ekr.20050712070251.500"><vh>flush</vh></v>
<v t="ekr.20050712070251.501"><vh>rawPrint</vh></v>
<v t="ekr.20050712070251.502"><vh>redirect</vh></v>
<v t="ekr.20050712070251.503"><vh>undirect</vh></v>
<v t="ekr.20050712070251.504"><vh>write</vh></v>
</v>
<v t="ekr.20050712070251.505"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh>
<v t="ekr.20050712070251.506"><vh>redirectStderr &amp; redirectStdout</vh></v>
<v t="ekr.20050712070251.507"><vh>restoreStderr &amp; restoreStdout</vh></v>
<v t="ekr.20050712070251.508"><vh>stdErrIsRedirected &amp; stdOutIsRedirected</vh></v>
<v t="ekr.20050712070251.509"><vh>rawPrint</vh></v>
</v>
<v t="ekr.20050712070251.510"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1110"><vh>(Fix url problems)</vh>
<v t="ekr.20050712070251.1111"><vh>Note: it just ran slowly &amp; silently</vh></v>
<v t="ekr.20050712070251.1020"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20050712070251.1021"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1022"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1023"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1112"><vh>findAllButton</vh></v>
<v t="ekr.20050712070251.1113"><vh>findAll</vh></v>
<v t="ekr.20050712070251.1114"><vh>findNextMatch</vh></v>
<v t="ekr.20050712070251.97"><vh>selectNextVnode</vh></v>
<v t="ekr.20050712070251.1088"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="ekr.20050712070251.1089"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1090"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1091"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1092"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1115"><vh>Buttons no longer work in toolbars when settings dialog is open</vh></v>
<v t="ekr.20050712070251.1116"><vh>(Fixed bug: Focus shifted from body to headline</vh>
<v t="ekr.20050712070251.1117"><vh>Report</vh></v>
<v t="ekr.20050712070251.1043"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20050712070251.1118"><vh>(Made sure Leo asks for leoID at most once)</vh>
<v t="ekr.20050712070251.1119"><vh>Report2</vh></v>
<v t="ekr.20050712070251.1120"><vh>Report</vh></v>
<v t="ekr.20050712070251.1121"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1122"><vh>app.setLeoID</vh>
<v t="ekr.20050712070251.1123"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1124"><vh>&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1125"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1126"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1127"><vh>(Leo now prints unicode characters properly in the log pane)</vh>
<v t="ekr.20050712070251.1094"><vh>es, enl, ecnl</vh></v>
<v t="ekr.20050712070251.1088"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="ekr.20050712070251.1089"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1090"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1091"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1092"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1128"><vh>(Fixed various problems with Unicode filenames)</vh>
<v t="ekr.20050712070251.1129"><vh>Report</vh></v>
<v t="ekr.20050712070251.464"><vh>atFile.printError &amp; test</vh></v>
<v t="ekr.20050712070251.1130"><vh>Unicode utils...</vh>
<v t="ekr.20050712070251.1131"><vh>isUnicode</vh></v>
<v t="ekr.20050712070251.1132"><vh>isValidEncoding</vh></v>
<v t="ekr.20050712070251.1133"><vh>reportBadChars</vh></v>
<v t="ekr.20050712070251.1134"><vh>toUnicode &amp; toEncodedString (and tests)</vh>
<v t="ekr.20050712070251.1135"><vh>toEncodedString</vh></v>
<v t="ekr.20050712070251.1136"><vh>toEncodedStringWithErrorCode</vh></v>
<v t="ekr.20050712070251.1137"><vh>toUnicode</vh></v>
<v t="ekr.20050712070251.1138"><vh>toUnicodeWithErrorCode</vh></v>
<v t="ekr.20050712070251.1139"><vh>test_round_trip_toUnicode_toEncodedString</vh></v>
<v t="ekr.20050712070251.1140"><vh>test_failure_with_ascii_encodings</vh></v>
</v>
<v t="ekr.20050712070251.1141"><vh>getpreferredencoding from 2.3a2</vh>
<v t="ekr.20050712070251.1142"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1143"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1144"><vh>os.path wrappers (leoGlobals.py)</vh>
<v t="ekr.20050712070251.1145"><vh>os_path_abspath</vh></v>
<v t="ekr.20050712070251.1146"><vh>os_path_basename</vh></v>
<v t="ekr.20050712070251.1147"><vh>os_path_dirname</vh></v>
<v t="ekr.20050712070251.1148"><vh>os_path_exists</vh></v>
<v t="ekr.20050712070251.1149"><vh>os_path_getmtime</vh></v>
<v t="ekr.20050712070251.1150"><vh>os_path_isabs</vh></v>
<v t="ekr.20050712070251.1151"><vh>os_path_isdir</vh></v>
<v t="ekr.20050712070251.1152"><vh>os_path_isfile</vh></v>
<v t="ekr.20050712070251.1002"><vh>os_path_join</vh></v>
<v t="ekr.20050712070251.1153"><vh>os_path_norm NOT USED</vh></v>
<v t="ekr.20050712070251.1154"><vh>os_path_normabs NOT USED</vh></v>
<v t="ekr.20050712070251.1155"><vh>os_path_normcase</vh></v>
<v t="ekr.20050712070251.1156"><vh>os_path_normpath</vh></v>
<v t="ekr.20050712070251.1157"><vh>os_path_split</vh></v>
<v t="ekr.20050712070251.1158"><vh>os_path_splitext</vh></v>
<v t="ekr.20050712070251.1159"><vh>toUnicodeFileEncoding</vh></v>
</v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.1160"><vh>app.setEncoding</vh></v>
</v>
<v t="ekr.20050712070251.1161"><vh>(Fixed unicode problems on the Mac)</vh>
<v t="ekr.20050712070251.1088"><vh>tkLog.put &amp; putnl &amp; forceLogUpdate</vh>
<v t="ekr.20050712070251.1089"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1090"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1091"><vh>&lt;&lt; put newline to log control &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1092"><vh>&lt;&lt; put newline to logWaiting and print newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1162"><vh>(Made sure Go To Line Number dialog is brought to the front)</vh>
<v t="ekr.20050712070251.1163"><vh>Report</vh></v>
<v t="ekr.20050712070251.1164"><vh>Added c to all dialog ctors!</vh>
<v t="ekr.20050712070251.1165"><vh>app.gui dialogs</vh></v>
<v t="ekr.20050712070251.1166"><vh>dialogs (unitTestGui)</vh></v>
<v t="ekr.20050712070251.1167"><vh>app.gui.Tkinter dialogs</vh></v>
</v>
<v t="ekr.20050712070251.943"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20050712070251.944"><vh>&lt;&lt; set root &gt;&gt;</vh></v>
<v t="ekr.20050712070251.945"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20050712070251.946"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20050712070251.947"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20050712070251.948"><vh>&lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;</vh>
<v t="ekr.20050712070251.949"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="ekr.20050712070251.950"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20050712070251.951"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20050712070251.952"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20050712070251.953"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20050712070251.954"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.955"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.956"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20050712070251.957"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.958"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20050712070251.959"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.960"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20050712070251.961"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.962"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.963"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="ekr.20050712070251.1168"><vh>run (tkDialog)</vh></v>
<v t="ekr.20050712070251.1169"><vh>widget_wants_focus (tk.gui)</vh></v>
<v t="ekr.20050712070251.1041"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20050712070251.1042"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050712070251.1043"><vh>set_focus (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1170"><vh>(Fixed newline bug in g.getScript)</vh>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1171"><vh>(Fixed bug involving encoding field in derived files)</vh>
<v t="ekr.20050712070251.363"><vh>parseLeoSentinel</vh>
<v t="ekr.20050712070251.364"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20050712070251.365"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20050712070251.366"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.367"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.368"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20050712070251.369"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
<v t="ekr.20050712070251.370"><vh>test_parseLeoSentinel</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1172"><vh>Fixed problems found by pychecker</vh></v>
<v t="ekr.20050712070251.1173"><vh>Rewrote ctor of settingsController to eliminate pychecker warnings</vh></v>
<v t="ekr.20050712070251.1174"><vh>(Fixed can't happen message in updateOneNode)</vh>
<v t="ekr.20050712070251.1175"><vh>What I did</vh></v>
<v t="ekr.20050712070251.863"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20050712070251.864"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20050712070251.1176"><vh>findCorrespondingNode</vh></v>
</v>
<v t="ekr.20050712070251.1177"><vh>(Note: local setting for use_plugins can not overriding global setting)</vh>
<v t="ekr.20050712070251.624"><vh>set (parseBaseClass)</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1178"><vh>New features...</vh>
<v t="ekr.20050712070251.1179"><vh>(Added new undo granularities &amp; undo_granularity setting)</vh>
<v t="ekr.20050712070251.1180"><vh>Notes</vh></v>
</v>
<v t="ekr.20050712070251.1181"><vh>(Plugins manager attempts to call init functions in plugins)</vh>
<v t="ekr.20050712070251.1182"><vh>Request</vh></v>
<v t="ekr.20050712070251.1183"><vh>Ahas</vh></v>
<v t="ekr.20050712070251.1184"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1049"><vh>loadOnePlugin</vh></v>
</v>
<v t="ekr.20050712070251.1185"><vh>(Changed name of Paste Retaining Clones to Paste Node As Clone)</vh>
<v t="ekr.20050712070251.170"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1186"><vh>&lt;&lt; enable top level outline menu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1187"><vh>(Added leoPlugins.leo to Help menu)</vh></v>
<v t="ekr.20050712070251.1188"><vh>Script buttons can request to be removed</vh></v>
<v t="ekr.20050712070251.1189"><vh>Improved documentation in leoSettings.leo</vh></v>
<v t="ekr.20050712070251.1190"><vh>(Added define_g=True param in executeScript)</vh>
<v t="ekr.20050712070251.1191"><vh>g.app did not exist during scripts!</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1192"><vh>Changed Preferences to Settings in menu, leoSettings.leo &amp; documentation</vh></v>
<v t="ekr.20050712070251.1193"><vh>Removed definitions of c, g &amp; p from all test routines</vh></v>
<v t="ekr.20050712070251.1194"><vh>(Several scripting improvements)</vh>
<v t="ekr.20050712070251.1195"><vh>What I did</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050712070251.1196"><vh>g.removeExtraLws &amp; tests</vh>
<v t="ekr.20050712070251.1197"><vh>test_g_removeExtraLws</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1198"><vh>(Give better error message when loading an enabled plugin fails)</vh>
<v t="ekr.20050712070251.1049"><vh>loadOnePlugin</vh></v>
<v t="ekr.20050712070251.9"><vh>g.importFromPath</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1199"><vh>4.3 a3 projects</vh>
<v t="ekr.20050712070251.1200"><vh>Bugs</vh>
<v t="ekr.20050712070251.1201"><vh>(Fixed crash in Tangle)</vh>
<v t="ekr.20050712070251.1202"><vh>Report &amp; notes</vh></v>
<v t="ekr.20050712070251.1203"><vh>tangle.put_all_roots</vh>
<v t="ekr.20050712070251.1204"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1205"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1206"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1207"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1208"><vh>create_temp_file &amp; test</vh>
<v t="ekr.20050712070251.1209"><vh>test_g_create_temp_file</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1210"><vh>Applied patch to rst2 plugin</vh>
<v t="ekr.20050712070251.1211"><vh>Report</vh></v>
</v>
<v t="ekr.20050712070251.1212"><vh>Revised searchbox.py so it works with Leo 4.3</vh></v>
<v t="ekr.20050712070251.1213"><vh>(xemacs plugin goes crazy)</vh>
<v t="ekr.20050712070251.21"><vh>openWith and allies</vh>
<v t="ekr.20050712070251.22"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.23"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20050712070251.24"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20050712070251.25"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20050712070251.26"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.27"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20050712070251.28"><vh>createOpenWithTempFile</vh>
<v t="ekr.20050712070251.29"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.30"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20050712070251.20"><vh>createOpenWithMenuFromTable</vh></v>
</v>
<v t="ekr.20050712070251.1214"><vh>(Fixed bugs in nav_buttons and nodenavigator plugins)</vh>
<v t="ekr.20050712070251.1215"><vh>Report</vh></v>
<v t="ekr.20050712070251.1216"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1217"><vh>Mark...</vh>
<v t="ekr.20050712070251.1218"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20050712070251.1219"><vh>markChangedRoots</vh></v>
<v t="ekr.20050712070251.1220"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20050712070251.1221"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20050712070251.1222"><vh>markClones</vh></v>
<v t="ekr.20050712070251.1223"><vh>markHeadline</vh></v>
<v t="ekr.20050712070251.1224"><vh>markSubheads</vh></v>
<v t="ekr.20050712070251.1225"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20050712070251.1226"><vh>v.clearMarked</vh></v>
<v t="ekr.20050712070251.1227"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20050712070251.1228"><vh> Status bits (position)</vh></v>
<v t="ekr.20050712070251.699"><vh>g.doHook</vh></v>
<v t="ekr.20050712070251.1055"><vh>doHandlersForTag</vh></v>
</v>
<v t="ekr.20050712070251.1118"><vh>(Made sure Leo asks for leoID at most once)</vh>
<v t="ekr.20050712070251.1119"><vh>Report2</vh></v>
<v t="ekr.20050712070251.1120"><vh>Report</vh></v>
<v t="ekr.20050712070251.1121"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1122"><vh>app.setLeoID</vh>
<v t="ekr.20050712070251.1123"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1124"><vh>&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1125"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1126"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1229"><vh>(Fixed botch in g.pdb)</vh>
<v t="ekr.20050712070251.1230"><vh>g.pdb &amp; test</vh>
<v t="ekr.20050712070251.1231"><vh>test_g_pdb</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1232"><vh>(Fixed bug in Execute Script in new window)</vh>
<v t="ekr.20050712070251.1233"><vh>Report</vh></v>
<v t="ekr.20050712070251.1234"><vh>What I did</vh></v>
<v t="ekr.20050712070251.550"><vh>getOutputNewline</vh></v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1235"><vh>New features</vh>
<v t="ekr.20050712070251.1236"><vh>Added sets.py to distribution</vh></v>
<v t="ekr.20050712070251.1237"><vh>(Added test for g.exception &amp; added color='suppress' hack to g.es)</vh>
<v t="ekr.20050712070251.540"><vh>es_exception &amp; test</vh>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1238"><vh>4.3 a4 projects</vh>
<v t="ekr.20050712070251.1239"><vh>Bugs</vh>
<v t="ekr.20050712070251.1240"><vh>(Investigated disappearing node body text)</vh>
<v t="ekr.20050712070251.1241"><vh>Original posting: (not correct!)</vh></v>
<v t="ekr.20050712070251.1242"><vh>What I did</vh></v>
<v t="ekr.20050712070251.265"><vh>read</vh>
<v t="ekr.20050712070251.266"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.267"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.268"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.269"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.341"><vh>readEndNode (4.x)</vh>
<v t="ekr.20050712070251.342"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20050712070251.343"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.318"><vh>createThinChild4</vh></v>
<v t="ekr.20050712070251.320"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20050712070251.321"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20050712070251.322"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.323"><vh>readNormalLine</vh>
<v t="ekr.20050712070251.324"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20050712070251.325"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.326"><vh>start sentinels</vh>
<v t="ekr.20050712070251.327"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20050712070251.328"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20050712070251.329"><vh>readStartLeo</vh></v>
<v t="ekr.20050712070251.330"><vh>readStartMiddle</vh></v>
<v t="ekr.20050712070251.331"><vh>readStartNode (4.x)</vh>
<v t="ekr.20050712070251.332"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20050712070251.333"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20050712070251.334"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.335"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20050712070251.336"><vh>end sentinels</vh>
<v t="ekr.20050712070251.337"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20050712070251.338"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20050712070251.339"><vh>readEndLeo</vh></v>
<v t="ekr.20050712070251.340"><vh>readEndMiddle</vh></v>
<v t="ekr.20050712070251.341"><vh>readEndNode (4.x)</vh>
<v t="ekr.20050712070251.342"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20050712070251.343"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.344"><vh>readEndOthers</vh></v>
<v t="ekr.20050712070251.234"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20050712070251.345"><vh>Unpaired sentinels</vh>
<v t="ekr.20050712070251.346"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20050712070251.347"><vh>readAfterRef</vh></v>
<v t="ekr.20050712070251.348"><vh>readClone</vh></v>
<v t="ekr.20050712070251.349"><vh>readComment</vh></v>
<v t="ekr.20050712070251.350"><vh>readDelims</vh></v>
<v t="ekr.20050712070251.231"><vh>readDirective (@@)</vh>
<v t="ekr.20050712070251.232"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.233"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.351"><vh>readNl</vh></v>
<v t="ekr.20050712070251.352"><vh>readNonl</vh></v>
<v t="ekr.20050712070251.353"><vh>readRef</vh></v>
<v t="ekr.20050712070251.354"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20050712070251.355"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1243"><vh>(Further problems specifying .leoID.txt)</vh>
<v t="ekr.20050712070251.1122"><vh>app.setLeoID</vh>
<v t="ekr.20050712070251.1123"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1124"><vh>&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1125"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1126"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1244"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20050712070251.1245"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20050712070251.993"><vh>computeHomeDir</vh></v>
<v t="ekr.20050712070251.1246"><vh>computeLoadDir</vh></v>
<v t="ekr.20050712070251.1247"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20050712070251.1248"><vh>startupEncoding</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1249"><vh>(Fixed crasher in atFile read logic when mod_labels plugin not enabled!)</vh>
<v t="ekr.20050712070251.1250"><vh>Report</vh></v>
<v t="ekr.20050712070251.361"><vh>copyAllTempBodyStringsToTnodes</vh></v>
</v>
<v t="ekr.20050712070251.1251"><vh>(Fix colorizer bug for initial @nocolor in @root nodes)</vh>
<v t="ekr.20050712070251.1252"><vh>Report</vh></v>
<v t="ekr.20050712070251.1253"><vh>continueDocPart</vh>
<v t="ekr.20050712070251.1254"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1255"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1256"><vh>(Fixed @wrap bug)</vh>
<v t="ekr.20050712070251.1257"><vh>Report</vh></v>
<v t="ekr.20050712070251.1258"><vh>f.setWrap</vh></v>
</v>
<v t="ekr.20050712070251.1259"><vh>(Fixed two change-all bugs)</vh>
<v t="ekr.20050712070251.1260"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1261"><vh>Report</vh></v>
<v t="ekr.20050712070251.1262"><vh>Report 2</vh></v>
<v t="ekr.20050712070251.1263"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20050712070251.1264"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1265"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1266"><vh>changeAll (sets end of change-all group)</vh></v>
<v t="ekr.20050712070251.1267"><vh>redraw_now</vh></v>
<v t="ekr.20050712070251.1093"><vh>forceLogUpdate</vh></v>
<v t="ekr.20050712070251.1268"><vh>c.endUpdate</vh></v>
<v t="ekr.20050712070251.1269"><vh>tree.endUpdate</vh></v>
<v t="ekr.20050712070251.1270"><vh>tree.redraw</vh></v>
<v t="ekr.20050712070251.1271"><vh>idle_redraw</vh>
<v t="ekr.20050712070251.1272"><vh>&lt;&lt; return if disabled, or quitting or dragging &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1218"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20050712070251.1219"><vh>markChangedRoots</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1273"><vh>Features</vh>
<v t="ekr.20050712070251.1274"><vh>removed all reloads from test.leo</vh></v>
<v t="ekr.20050712070251.1275"><vh>deprecated new_c key in hooks, added c key</vh></v>
<v t="ekr.20050712070251.1276"><vh>(Added Add/Delete Comments commands)</vh>
<v t="ekr.20050712070251.156"><vh>&lt;&lt; define editMenuEditBodyTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1277"><vh>insert/removeComments</vh>
<v t="ekr.20050712070251.1278"><vh>addComments</vh></v>
<v t="ekr.20050712070251.1279"><vh>deleteComments</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1280"><vh>Plugins &amp; hooks</vh>
<v t="ekr.20050712070251.1281"><vh>(Made sure file names get sanitized correctly)</vh>
<v t="ekr.20050712070251.1282"><vh>Report</vh></v>
<v t="ekr.20050712070251.1283"><vh>Notes</vh></v>
<v t="ekr.20050712070251.30"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20050712070251.1284"><vh>(Added support for mod_labels plugin)</vh>
<v t="ekr.20050712070251.361"><vh>copyAllTempBodyStringsToTnodes</vh></v>
</v>
<v t="ekr.20050712070251.1285"><vh>(Converted cleo.py to 4.3 code base)</vh>
<v t="ekr.20050712070251.1286"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20050712070251.1287"><vh>g.funcToMethod</vh></v>
<v t="ekr.20050712070251.701"><vh>drawTopTree</vh></v>
<v t="ekr.20050712070251.1288"><vh>tree.set...LabelState</vh>
<v t="ekr.20050712070251.1289"><vh>setNormalLabelState</vh></v>
<v t="ekr.20050712070251.1290"><vh>setDisabledLabelState</vh></v>
<v t="ekr.20050712070251.1291"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20050712070251.1292"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20050712070251.1293"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20050712070251.1294"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20050712070251.1295"><vh>setUnselectedHeadlineColors</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1296"><vh>(Changes to hooks)</vh>
<v t="ekr.20050712070251.1297"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1298"><vh>new</vh></v>
<v t="ekr.20050712070251.637"><vh>g.openWithFileName</vh></v>
<v t="ekr.20050712070251.638"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20050712070251.639"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.195"><vh>createMenusFromTables</vh>
<v t="ekr.20050712070251.196"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="ekr.20050712070251.197"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.198"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.199"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.200"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.201"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.202"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.203"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="ekr.20050712070251.204"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.205"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.206"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.207"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="ekr.20050712070251.208"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.209"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.210"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.211"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.212"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.213"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.214"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1299"><vh>(Changed 'onCreate' hook to 'before-create-leo-frame')</vh>
<v t="ekr.20050712070251.638"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20050712070251.639"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1300"><vh>(Fixed 2 problems in mod_scripting plugin)</vh>
<v t="ekr.20050712070251.1301"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.1302"><vh>Report: buttons installed twice</vh></v>
</v>
<v t="ekr.20050712070251.1303"><vh>Fixed problem in templates.py</vh></v>
<v t="ekr.20050712070251.1304"><vh>Removed new_c from all plugins</vh></v>
<v t="ekr.20050712070251.1305"><vh>Removed 'start2' hook</vh></v>
<v t="ekr.20050712070251.1306"><vh>Fixed crash in autocompleter(leoNodes) during unit test</vh></v>
<v t="ekr.20050712070251.1307"><vh>(Fixed emacs &amp; vim plugins)</vh>
<v t="ekr.20050712070251.1308"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1309"><vh>Docs</vh>
<v t="ekr.20050712070251.1310"><vh>Documentation of tnodeLists &amp; potential problems</vh>
<v t="ekr.20050712070251.1311"><vh>The basic design</vh></v>
<v t="ekr.20050712070251.319"><vh>findChild4</vh></v>
<v t="ekr.20050712070251.245"><vh>write</vh>
<v t="ekr.20050712070251.246"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.247"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.430"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
</v>
<v t="ekr.20050712070251.1312"><vh>Revised scripting chapter (on web and in LeoDocs.leo) to use predefined g, c, p</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1313"><vh>4.3 b1 projects</vh>
<v t="ekr.20050712070251.1314"><vh>Bugs...</vh>
<v t="ekr.20050712070251.1315"><vh>(Made sure NameErrors are reported with tracebacks in scripts)</vh>
<v t="ekr.20050712070251.1316"><vh>Report</vh></v>
<v t="ekr.20050712070251.1317"><vh>What I did</vh></v>
<v t="ekr.20050712070251.542"><vh>goToScriptLineNumber</vh></v>
<v t="ekr.20050712070251.1318"><vh>g.executeScript</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1319"><vh>Dumps</vh>
<v t="ekr.20050712070251.1320"><vh>dump</vh></v>
<v t="ekr.20050712070251.1321"><vh>es_error</vh></v>
<v t="ekr.20050712070251.1322"><vh>es_event_exception</vh></v>
<v t="ekr.20050712070251.540"><vh>es_exception &amp; test</vh>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20050712070251.539"><vh>getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20050712070251.1323"><vh>printBindings</vh></v>
<v t="ekr.20050712070251.1324"><vh>printGlobals</vh></v>
<v t="ekr.20050712070251.1325"><vh>printLeoModules</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1326"><vh>(Finally! fixed .leoID problem!)</vh>
<v t="ekr.20050712070251.1327"><vh>Report</vh></v>
<v t="ekr.20050712070251.1328"><vh>What I did</vh></v>
<v t="ekr.20050712070251.993"><vh>computeHomeDir</vh></v>
<v t="ekr.20050712070251.1122"><vh>app.setLeoID</vh>
<v t="ekr.20050712070251.1123"><vh>&lt;&lt; return if we can set self.leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1124"><vh>&lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1125"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1126"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1329"><vh>(Investigated problem with LeoPluginsRef.leo)</vh>
<v t="ekr.20050712070251.1330"><vh>Report</vh></v>
<v t="ekr.20050712070251.1331"><vh>Log message</vh></v>
<v t="ekr.20050712070251.1310"><vh>Documentation of tnodeLists &amp; potential problems</vh>
<v t="ekr.20050712070251.1311"><vh>The basic design</vh></v>
<v t="ekr.20050712070251.319"><vh>findChild4</vh></v>
<v t="ekr.20050712070251.245"><vh>write</vh>
<v t="ekr.20050712070251.246"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.247"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.430"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1332"><vh>Fixed conflicts in menu shortcuts</vh>
<v t="ekr.20050712070251.195"><vh>createMenusFromTables</vh>
<v t="ekr.20050712070251.196"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="ekr.20050712070251.197"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.198"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.199"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.200"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.201"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.202"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.203"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="ekr.20050712070251.204"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.205"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.206"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.207"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="ekr.20050712070251.208"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.209"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.210"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.211"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.212"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.213"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="ekr.20050712070251.214"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.169"><vh>&lt;&lt; define outline menu tables &gt;&gt;</vh>
<v t="ekr.20050712070251.170"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.171"><vh>&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.172"><vh>&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.173"><vh>&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.174"><vh>&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;</vh></v>
<v t="ekr.20050712070251.175" a="M"><vh>&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1333"><vh>(Debugged @if-platform, @if-gui, @ints &amp; @strings)</vh>
<v t="ekr.20050712070251.1334"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1335"><vh>visitNode (settingsDialogParserClass)</vh></v>
<v t="ekr.20050712070251.1336"><vh>visitNode (settingsTreeParser)</vh></v>
<v t="ekr.20050712070251.1337"><vh>traverse (parserBaseClass)</vh></v>
<v t="ekr.20050712070251.1338"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20050712070251.1339"><vh>kind handlers (parserBaseClass)</vh>
<v t="ekr.20050712070251.1340"><vh>doBool</vh></v>
<v t="ekr.20050712070251.1341"><vh>doColor</vh></v>
<v t="ekr.20050712070251.1342"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20050712070251.1343"><vh>doFloat</vh></v>
<v t="ekr.20050712070251.747"><vh>doFont</vh></v>
<v t="ekr.20050712070251.1344"><vh>doIf</vh></v>
<v t="ekr.20050712070251.1345"><vh>doIfGui</vh></v>
<v t="ekr.20050712070251.1346"><vh>doIfPlatform</vh></v>
<v t="ekr.20050712070251.1347"><vh>doIgnore</vh></v>
<v t="ekr.20050712070251.1348"><vh>doInt</vh></v>
<v t="ekr.20050712070251.1349"><vh>doInts</vh></v>
<v t="ekr.20050712070251.1350"><vh>doPage</vh></v>
<v t="ekr.20050712070251.1351"><vh>doRatio</vh></v>
<v t="ekr.20050712070251.845"><vh>doShortcut</vh></v>
<v t="ekr.20050712070251.846"><vh>doShortcuts</vh></v>
<v t="ekr.20050712070251.1352"><vh>doString</vh></v>
<v t="ekr.20050712070251.1353"><vh>doStrings</vh></v>
</v>
<v t="ekr.20050712070251.1354"><vh>valueError</vh></v>
</v>
<v t="ekr.20050712070251.1355"><vh>(Reloaded settings files when opening the settings dialog)</vh>
<v t="ekr.20050712070251.1356"><vh>Notes</vh></v>
<v t="ekr.20050712070251.653"><vh>run &amp; allies</vh>
<v t="ekr.20050712070251.654"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20050712070251.655"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20050712070251.656"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20050712070251.657"><vh>isValidPython</vh></v>
<v t="ekr.20050712070251.658"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20050712070251.659"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20050712070251.660"><vh>getBatchScript</vh></v>
<v t="ekr.20050712070251.661"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20050712070251.861"><vh>writeChangedVars &amp; helpers</vh>
<v t="ekr.20050712070251.862"><vh>updateConfig</vh></v>
<v t="ekr.20050712070251.863"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20050712070251.864"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20050712070251.865"><vh>writeChangedList</vh>
<v t="ekr.20050712070251.866"><vh>&lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.867"><vh>writeChangesToFile</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1357"><vh>Fixed bug in p.initStatus caught by pychecker</vh></v>
<v t="ekr.20050712070251.1358"><vh>(Fixed Crasher in undo)</vh>
<v t="ekr.20050712070251.1359"><vh>undoDeleteNode</vh></v>
</v>
<v t="ekr.20050712070251.1360"><vh>(Fixed crasher in import logic (leoAtFile)</vh>
<v t="ekr.20050712070251.252"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20050712070251.253"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.88"><vh>scanHeaderForThin</vh></v>
</v>
<v t="ekr.20050712070251.1361"><vh>(Put in protections against unbounded recursion in idle_scrollTo)</vh>
<v t="ekr.20050712070251.1362"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.1363"><vh>idle_scrollTo</vh>
<v t="ekr.20050712070251.1364"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1365"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1366"><vh>scrollTo</vh></v>
<v t="ekr.20050712070251.1367"><vh>yoffset</vh></v>
<v t="ekr.20050712070251.718"><vh>p.siblings_iter</vh>
<v t="ekr.20050712070251.719"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20050712070251.720"><vh>next</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1368"><vh>Features...</vh>
<v t="ekr.20050712070251.1369"><vh>(Created stand-alone leoGlobals.py module)</vh>
<v t="ekr.20050712070251.1370"><vh>What I did</vh></v>
<v t="ekr.20050712070251.653"><vh>run &amp; allies</vh>
<v t="ekr.20050712070251.654"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20050712070251.655"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20050712070251.656"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20050712070251.657"><vh>isValidPython</vh></v>
<v t="ekr.20050712070251.658"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20050712070251.659"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20050712070251.660"><vh>getBatchScript</vh></v>
<v t="ekr.20050712070251.661"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20050712070251.1371"><vh>g.createStandAloneApp</vh></v>
<v t="ekr.20050712070251.1244"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20050712070251.1245"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20050712070251.993"><vh>computeHomeDir</vh></v>
<v t="ekr.20050712070251.1246"><vh>computeLoadDir</vh></v>
<v t="ekr.20050712070251.1247"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20050712070251.1248"><vh>startupEncoding</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1372"><vh>(Ignore problems opening settings file for chapters plugin)</vh>
<v t="ekr.20050712070251.1373"><vh>What I did</vh></v>
<v t="ekr.20050712070251.649"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20050712070251.650"><vh>openSettingsFile</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050712070251.652"><vh>readSettings</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1374"><vh>(Improved write logic)</vh>
<v t="ekr.20050712070251.1375"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1376"><vh>From leoGlobals</vh>
<v t="ekr.20050712070251.877"><vh>g.fileLikeObject</vh>
<v t="ekr.20050712070251.878"><vh> ctor</vh></v>
<v t="ekr.20050712070251.879"><vh>clear</vh></v>
<v t="ekr.20050712070251.880"><vh>close</vh></v>
<v t="ekr.20050712070251.881"><vh>flush</vh></v>
<v t="ekr.20050712070251.882"><vh>get &amp; getvalue</vh></v>
<v t="ekr.20050712070251.883"><vh>readline</vh></v>
<v t="ekr.20050712070251.884"><vh>write</vh></v>
</v>
<v t="ekr.20050712070251.590"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20050712070251.591"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20050712070251.592"><vh>test_g_utils_rename</vh></v>
</v>
<v t="ekr.20050712070251.1135"><vh>toEncodedString</vh></v>
</v>
<v t="ekr.20050712070251.1377"><vh>From leoFileCommands</vh>
<v t="ekr.20050712070251.595"><vh>write_Leo_file</vh>
<v t="ekr.20050712070251.596"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.597"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050712070251.598"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.599"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.600"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.601"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.602"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1378"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="ekr.20050712070251.1379"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="ekr.20050712070251.1380"><vh>deleteFileWithMessage</vh>
<v t="ekr.20050712070251.1381"><vh>test_fc_deleteFileWithMessage</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1382"><vh>(Finished new undo)</vh>
<v t="ekr.20050712070251.1383"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1384"><vh>Calls to undoer methods</vh>
<v t="ekr.20050712070251.1385"><vh>From Commands...</vh>
<v t="ekr.20050712070251.1386"><vh> Top Level... (Commands)</vh>
<v t="ekr.20050712070251.1387"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20050712070251.1388"><vh>cutOutline</vh></v>
<v t="ekr.20050712070251.1389"><vh>copyOutline</vh></v>
<v t="ekr.20050712070251.43"><vh>pasteOutline</vh>
<v t="ekr.20050712070251.44"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050712070251.45"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.42"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20050712070251.96"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20050712070251.1390"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20050712070251.1391"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20050712070251.1392"><vh>c.deleteOutline</vh></v>
<v t="ekr.20050712070251.1074"><vh>c.insertHeadline</vh></v>
<v t="ekr.20050712070251.1393"><vh>c.clone</vh></v>
<v t="ekr.20050712070251.1394"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20050712070251.1395"><vh>c.sortChildren</vh></v>
<v t="ekr.20050712070251.1396"><vh>c.sortChildrenHelper</vh></v>
<v t="ekr.20050712070251.1397"><vh>c.sortSiblings</vh></v>
<v t="ekr.20050712070251.1398"><vh>c.sortTopLevel</vh></v>
</v>
<v t="ekr.20050712070251.1399"><vh>Edit Body submenu</vh>
<v t="ekr.20050712070251.1400"><vh>convertAllBlanks</vh></v>
<v t="ekr.20050712070251.1401"><vh>convertAllTabs</vh></v>
<v t="ekr.20050712070251.1402"><vh>convertBlanks</vh></v>
<v t="ekr.20050712070251.1403"><vh>convertTabs</vh></v>
<v t="ekr.20050712070251.1404"><vh>createLastChildNode</vh></v>
<v t="ekr.20050712070251.1405"><vh>dedentBody</vh></v>
<v t="ekr.20050712070251.1406"><vh>extract</vh></v>
<v t="ekr.20050712070251.1407"><vh>extractSection</vh>
<v t="ekr.20050712070251.1408"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1409"><vh>extractSectionNames</vh>
<v t="ekr.20050712070251.1410"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1411"><vh>findBoundParagraph</vh>
<v t="ekr.20050712070251.1412"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1413"><vh>findMatchingBracket</vh>
<v t="ekr.20050712070251.1414"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20050712070251.1415"><vh>getBodyLines</vh></v>
<v t="ekr.20050712070251.1416"><vh>indentBody</vh></v>
<v t="ekr.20050712070251.1417"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20050712070251.1418"><vh>getTime</vh></v>
</v>
<v t="ekr.20050712070251.1277"><vh>insert/removeComments</vh>
<v t="ekr.20050712070251.1278"><vh>addComments</vh></v>
<v t="ekr.20050712070251.1279"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20050712070251.1419"><vh>reformatParagraph</vh>
<v t="ekr.20050712070251.1420"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1421"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1422"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1423"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1424"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20050712070251.59"><vh>class prettyPrinter</vh>
<v t="ekr.20050712070251.60"><vh>__init__</vh>
<v t="ekr.20050712070251.61"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.62"><vh>clear</vh></v>
<v t="ekr.20050712070251.63"><vh>dumpLines</vh></v>
<v t="ekr.20050712070251.64"><vh>dumpToken</vh></v>
<v t="ekr.20050712070251.65"><vh>endUndo</vh></v>
<v t="ekr.20050712070251.66"><vh>get</vh></v>
<v t="ekr.20050712070251.67"><vh>prettyPrintNode</vh></v>
<v t="ekr.20050712070251.68"><vh>put</vh></v>
<v t="ekr.20050712070251.69"><vh>putArray</vh></v>
<v t="ekr.20050712070251.70"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20050712070251.71"><vh>doEndMarker</vh></v>
<v t="ekr.20050712070251.72"><vh>doErrorToken</vh></v>
<v t="ekr.20050712070251.73"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20050712070251.74"><vh>doMultiLine</vh></v>
<v t="ekr.20050712070251.75"><vh>doName</vh></v>
<v t="ekr.20050712070251.76"><vh>doNewline</vh></v>
<v t="ekr.20050712070251.77"><vh>doNumber</vh></v>
<v t="ekr.20050712070251.78"><vh>doOp</vh></v>
<v t="ekr.20050712070251.79"><vh>doStartLine</vh></v>
<v t="ekr.20050712070251.80"><vh>oops</vh></v>
<v t="ekr.20050712070251.81"><vh>trace</vh></v>
</v>
<v t="ekr.20050712070251.82"><vh>putToken</vh></v>
<v t="ekr.20050712070251.83"><vh>replaceBody</vh></v>
</v>
<v t="ekr.20050712070251.1425"><vh>Move... (Commands)</vh>
<v t="ekr.20050712070251.1426"><vh>demote</vh></v>
<v t="ekr.20050712070251.1427"><vh>moveOutlineDown</vh>
<v t="ekr.20050712070251.1428"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1429"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20050712070251.1430"><vh>moveOutlineRight</vh></v>
<v t="ekr.20050712070251.1431"><vh>moveOutlineUp</vh>
<v t="ekr.20050712070251.1432"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1433"><vh>promote</vh></v>
</v>
<v t="ekr.20050712070251.1434"><vh>Dragging (commands)</vh>
<v t="ekr.20050712070251.1435"><vh>c.dragAfter</vh></v>
<v t="ekr.20050712070251.1436"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20050712070251.1437"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20050712070251.1438"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="ekr.20050712070251.1439"><vh>readAtFileNodes (commands)</vh></v>
</v>
<v t="ekr.20050712070251.1440"><vh>From Find</vh>
<v t="ekr.20050712070251.1266"><vh>changeAll (sets end of change-all group)</vh></v>
<v t="ekr.20050712070251.1263"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20050712070251.1264"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1265"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1441"><vh>From Import...</vh>
<v t="ekr.20050712070251.938"><vh>createOutline</vh>
<v t="ekr.20050712070251.939"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.91"><vh>importDerivedFiles</vh>
<v t="ekr.20050712070251.92"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1442"><vh>importFlattenedOutline</vh>
<v t="ekr.20050712070251.1443"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1444"><vh>createOutlineFromWeb</vh></v>
</v>
<v t="ekr.20050712070251.1445"><vh>From tkTree</vh>
<v t="ekr.20050712070251.1446"><vh>idle_head_key</vh>
<v t="ekr.20050712070251.1447"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1448"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1449"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1450"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1451"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1452"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1453"><vh>(Implemented undo/redo for Paste Retaining clones)</vh>
<v t="ekr.20050712070251.1454"><vh>Notes</vh>
<v t="ekr.20050712070251.1455"><vh>Report</vh></v>
<v t="ekr.20050712070251.1456"><vh>Responses</vh></v>
</v>
<v t="ekr.20050712070251.1457"><vh>fc.read logic</vh>
<v t="ekr.20050712070251.46"><vh>getLeoOutline (from clipboard)</vh>
<v t="ekr.20050712070251.47"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1458"><vh>getTnode</vh>
<v t="ekr.20050712070251.1459"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.50"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20050712070251.51"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.52"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.53"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.54"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1460"><vh>getExistingVnode</vh></v>
<v t="ekr.20050712070251.1461"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20050712070251.1462"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1463"><vh>fc.write logic</vh>
<v t="ekr.20050712070251.1379"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="ekr.20050712070251.1464"><vh>putTnode</vh></v>
<v t="ekr.20050712070251.477"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20050712070251.478"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20050712070251.479"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.480"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.481"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20050712070251.482"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1465"><vh>From undo</vh>
<v t="ekr.20050712070251.1466"><vh>beforeInsertNode</vh></v>
<v t="ekr.20050712070251.1467"><vh>afterInsertNode</vh></v>
<v t="ekr.20050712070251.1468"><vh>undoInsertNode</vh></v>
<v t="ekr.20050712070251.1469"><vh>redoInsertNode</vh></v>
</v>
<v t="ekr.20050712070251.1387"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20050712070251.1388"><vh>cutOutline</vh></v>
<v t="ekr.20050712070251.1389"><vh>copyOutline</vh></v>
<v t="ekr.20050712070251.43"><vh>pasteOutline</vh>
<v t="ekr.20050712070251.44"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050712070251.45"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.42"><vh>pasteOutlineRetainingClones</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1470"><vh>(Added support for 'str_' uA's</vh>
<v t="ekr.20050712070251.1471"><vh>Posting</vh></v>
<v t="ekr.20050712070251.1472"><vh>From leoTkinterTree...</vh>
<v t="ekr.20050712070251.1473"><vh>Design for drawUserIcons (use dict instead of tuples) (finished)</vh></v>
<v t="ekr.20050712070251.1474"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20050712070251.1475"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20050712070251.1476"><vh>drawUserIcons</vh></v>
<v t="ekr.20050712070251.1477"><vh>drawUserIcon</vh>
<v t="ekr.20050712070251.1478"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1479"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1480"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1481"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1482"><vh>From docs...</vh>
<v t="ekr.20050712070251.1483"><vh>Adding attributes to nodes and .leo files</vh>
<v t="ekr.20050712070251.1484"><vh>Extending the format of .leo files</vh></v>
<v t="ekr.20050712070251.1485"><vh>Attaching temporary attributes to vnodes and tnodes</vh></v>
<v t="ekr.20050712070251.1486"><vh>Recommended conventions for plugins</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1487"><vh>From leoFileCommands...</vh>
<v t="ekr.20050712070251.1488"><vh>read...</vh>
<v t="ekr.20050712070251.1489"><vh>getDescendentAttributes</vh></v>
<v t="ekr.20050712070251.1490"><vh>getDescendentUnknownAttributes</vh></v>
<v t="ekr.20050712070251.1461"><vh>createVnode (changed for 4.2) sets skip</vh>
<v t="ekr.20050712070251.1462"><vh>&lt;&lt; handle unknown vnode attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.664"><vh>getLeoFile</vh>
<v t="ekr.20050712070251.665"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20050712070251.666"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20050712070251.667"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="ekr.20050712070251.668"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.669"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1458"><vh>getTnode</vh>
<v t="ekr.20050712070251.1459"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.50"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20050712070251.51"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.52"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.53"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.54"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.489"><vh>getUa (changed for 4.3)</vh></v>
</v>
<v t="ekr.20050712070251.1491"><vh>write...</vh>
<v t="ekr.20050712070251.1492"><vh>putDescendentUnknownAttributes</vh></v>
<v t="ekr.20050712070251.1464"><vh>putTnode</vh></v>
<v t="ekr.20050712070251.488"><vh>putUnknownAttributes</vh></v>
<v t="ekr.20050712070251.1493"><vh>putUa (new in 4.3) (changed for 4.3)</vh></v>
<v t="ekr.20050712070251.477"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20050712070251.478"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20050712070251.479"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20050712070251.480"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.481"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20050712070251.482"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1494"><vh>Removed unused params from leoAtFile.py</vh></v>
<v t="ekr.20050712070251.1495"><vh>(Added u.before/afterClearRecentFiles</vh>
<v t="ekr.20050712070251.857"><vh>clearRecentFiles</vh></v>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.1496"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20050712070251.1497"><vh>undoClearRecentFiles</vh></v>
</v>
<v t="ekr.20050712070251.1498"><vh>(Read and write .leoRecentFiles.txt)</vh>
<v t="ekr.20050712070251.1499"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1500"><vh>New plan</vh></v>
<v t="ekr.20050712070251.595"><vh>write_Leo_file</vh>
<v t="ekr.20050712070251.596"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.597"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050712070251.598"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.599"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050712070251.600"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.601"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.602"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.649"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20050712070251.650"><vh>openSettingsFile</vh></v>
<v t="ekr.20050712070251.651"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050712070251.652"><vh>readSettings</vh></v>
</v>
<v t="ekr.20050712070251.646"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050712070251.734"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20050712070251.857"><vh>clearRecentFiles</vh></v>
<v t="ekr.20050712070251.1501"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20050712070251.1502"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20050712070251.1503"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20050712070251.1504"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1505"><vh>(Added support for read-only as the first line of .leoRecentFiles.txt)</vh>
<v t="ekr.20050712070251.1501"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20050712070251.1502"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20050712070251.1503"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20050712070251.1504"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1506"><vh>(Copied expansion state when writing @settings trees)</vh>
<v t="ekr.20050712070251.1507"><vh>copyExpansionState</vh></v>
<v t="ekr.20050712070251.1508"><vh>createSettingsTree &amp; helpers</vh>
<v t="ekr.20050712070251.1509"><vh>&lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;</vh>
<v t="ekr.20050712070251.1510"><vh>&lt;&lt; add entry for p to filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1511"><vh>rootNodeComments</vh></v>
</v>
<v t="ekr.20050712070251.861"><vh>writeChangedVars &amp; helpers</vh>
<v t="ekr.20050712070251.862"><vh>updateConfig</vh></v>
<v t="ekr.20050712070251.863"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20050712070251.864"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20050712070251.865"><vh>writeChangedList</vh>
<v t="ekr.20050712070251.866"><vh>&lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.867"><vh>writeChangesToFile</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1512"><vh>(Added support for UNL's in settings pane)</vh>
<v t="ekr.20050712070251.1513"><vh>tree.select</vh></v>
<v t="ekr.20050712070251.1363"><vh>idle_scrollTo</vh>
<v t="ekr.20050712070251.1364"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1365"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1514"><vh> ctor (settingsController)</vh>
<v t="ekr.20050712070251.1515"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1516"><vh>&lt;&lt; define Tk color names &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1517"><vh>&lt;&lt; set background color for widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.828"><vh>Status line methods (compatibility)</vh></v>
</v>
<v t="ekr.20050712070251.1518"><vh>(Added Paul Paterson's Tangle patch)</vh>
<v t="ekr.20050712070251.1519"><vh>email</vh></v>
<v t="ekr.20050712070251.1520"><vh>patch</vh></v>
<v t="ekr.20050712070251.1521"><vh>tangle</vh></v>
<v t="ekr.20050712070251.1010"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20050712070251.1011"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1012"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1522"><vh>Plugins</vh>
<v t="ekr.20050712070251.1523"><vh>(Read @file Nodes v Import Derived Files)</vh>
<v t="ekr.20050712070251.1439"><vh>readAtFileNodes (commands)</vh></v>
<v t="ekr.20050712070251.1524"><vh>readAtFileNodes (leoAtFile)</vh></v>
<v t="ekr.20050712070251.1525"><vh>importDerivedFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1526"><vh>4.3 b2 projects</vh>
<v t="ekr.20050712070251.1527"><vh>Bugs</vh>
<v t="ekr.20050712070251.1528"><vh>(Investigated problems with os.spwawnv in openWith</vh>
<v t="ekr.20050712070251.1529"><vh>Report</vh></v>
<v t="ekr.20050712070251.1530"><vh>Suggested fix</vh></v>
<v t="ekr.20050712070251.1531"><vh>Not really a problem</vh></v>
<v t="ekr.20050712070251.21"><vh>openWith and allies</vh>
<v t="ekr.20050712070251.22"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.23"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20050712070251.24"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20050712070251.25"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20050712070251.26"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.27"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20050712070251.28"><vh>createOpenWithTempFile</vh>
<v t="ekr.20050712070251.29"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.30"><vh>c.openWithTempFilePath</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1532"><vh>(Fixed nodenavagator bug)</vh></v>
<v t="ekr.20050712070251.1533"><vh>(Fixed LaTex Coloring bug)</vh>
<v t="ekr.20050712070251.1534"><vh>Report</vh></v>
<v t="ekr.20050712070251.1535"><vh>Notes</vh></v>
<v t="ekr.20050712070251.918"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1536"><vh>latex keywords</vh></v>
</v>
<v t="ekr.20050712070251.1537"><vh>(Unredirected output only after all script processing is complete)</vh>
<v t="ekr.20050712070251.1538"><vh>Report</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.541"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20050712070251.1539"><vh>(Fixed Crasher in nav_buttons)</vh>
<v t="ekr.20050712070251.1540"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1541"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.1054"><vh>callTagHandler</vh></v>
<v t="ekr.20050712070251.1035"><vh>tree.select</vh>
<v t="ekr.20050712070251.1036"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20050712070251.1037"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1038"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1039"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1040"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1542"><vh>(Investigated disappearing scrollbar  when autocompleter plugin is enabled)</vh>
<v t="ekr.20050712070251.1543"><vh>Report</vh></v>
</v>
<v t="ekr.20050712070251.1544"><vh>(Tested chapters plugin)</vh>
<v t="ekr.20050712070251.1545"><vh>Problem: crasher (no problem now)</vh>
<v t="ekr.20050712070251.1546"><vh>Report</vh></v>
<v t="ekr.20050712070251.664"><vh>getLeoFile</vh>
<v t="ekr.20050712070251.665"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20050712070251.666"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20050712070251.667"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="ekr.20050712070251.668"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.669"><vh>&lt;&lt; set current and top positions &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1547"><vh>Problem: disappearing chapters (I don't see this)</vh>
<v t="ekr.20050712070251.1035"><vh>tree.select</vh>
<v t="ekr.20050712070251.1036"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20050712070251.1037"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1038"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1039"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1040"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1548"><vh>Report 1</vh></v>
<v t="ekr.20050712070251.1549"><vh>Report 2</vh></v>
</v>
<v t="ekr.20050712070251.1550"><vh>Problem: c.exists may return False in chapters</vh>
<v t="ekr.20050712070251.1363"><vh>idle_scrollTo</vh>
<v t="ekr.20050712070251.1364"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1365"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1551"><vh>(Fixed crasher in yoffsetTree)</vh>
<v t="ekr.20050712070251.1552"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.1367"><vh>yoffset</vh></v>
</v>
<v t="ekr.20050712070251.1553"><vh>(Fixed crasher in undo)</vh>
<v t="ekr.20050712070251.1554"><vh>Report</vh></v>
<v t="ekr.20050712070251.1424"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20050712070251.1555"><vh>setSelectionAreas (tkinterBody)</vh></v>
<v t="ekr.20050712070251.1556"><vh>idle_body_key &amp; helpers</vh>
<v t="ekr.20050712070251.1557"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1558"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1559"><vh>&lt;&lt; handle special characters &gt;&gt;</vh>
<v t="ekr.20050712070251.1560"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1561"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1562"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1563"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1564"><vh>doAutoIndent (David McNab)</vh></v>
<v t="ekr.20050712070251.1565"><vh>convertBlanksToTabs</vh>
<v t="ekr.20050712070251.1566"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1567"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1568"><vh>setUndoTypingParams</vh>
<v t="ekr.20050712070251.1569"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1570"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1571"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1572"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1573"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1574"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20050712070251.1575"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20050712070251.1576"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1577"><vh>(Fix indentation problems with Extract and Extract Section)</vh>
<v t="ekr.20050712070251.1578"><vh>Report</vh></v>
<v t="ekr.20050712070251.1407"><vh>extractSection</vh>
<v t="ekr.20050712070251.1408"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1406"><vh>extract</vh></v>
</v>
<v t="ekr.20050712070251.1579"><vh>(Fixed undo problems with Extract and Extract Section)</vh>
<v t="ekr.20050712070251.1580"><vh>Report</vh></v>
<v t="ekr.20050712070251.1581"><vh>redoTyping</vh></v>
<v t="ekr.20050712070251.1582"><vh>undoTyping</vh></v>
</v>
<v t="ekr.20050712070251.1583"><vh>(Fixed bug with Delete in headlines)</vh>
<v t="ekr.20050712070251.1584"><vh>Report</vh></v>
<v t="ekr.20050712070251.1585"><vh>delete</vh></v>
</v>
<v t="ekr.20050712070251.1586"><vh>(Fixed crasher in nav_buttons)</vh>
<v t="ekr.20050712070251.1587"><vh>Report</vh></v>
<v t="ekr.20050712070251.1588"><vh>go</vh></v>
</v>
<v t="ekr.20050712070251.1589"><vh>(Marking any node sets the outline changed)</vh>
<v t="ekr.20050712070251.1590"><vh>Notes</vh></v>
<v t="ekr.20050712070251.1591"><vh> v.Status bits</vh>
<v t="ekr.20050712070251.1592"><vh>clearClonedBit</vh></v>
<v t="ekr.20050712070251.1593"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="ekr.20050712070251.1226"><vh>v.clearMarked</vh></v>
<v t="ekr.20050712070251.1594"><vh>clearOrphan</vh></v>
<v t="ekr.20050712070251.1595"><vh>clearVisited</vh></v>
<v t="ekr.20050712070251.1596"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20050712070251.1597"><vh>initStatus</vh></v>
<v t="ekr.20050712070251.1598"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="ekr.20050712070251.1227"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20050712070251.1599"><vh>setOrphan</vh></v>
<v t="ekr.20050712070251.1600"><vh>setSelected (vnode)</vh></v>
<v t="ekr.20050712070251.1601"><vh>t.setVisited</vh></v>
</v>
<v t="ekr.20050712070251.1602"><vh>p.Dirty bits</vh>
<v t="ekr.20050712070251.1603"><vh>p.clearDirty</vh></v>
<v t="ekr.20050712070251.1604"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20050712070251.1605"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20050712070251.1606"><vh>p.setDirty</vh></v>
<v t="ekr.20050712070251.1607"><vh>p.inAtIgnoreRange</vh></v>
</v>
<v t="ekr.20050712070251.1217"><vh>Mark...</vh>
<v t="ekr.20050712070251.1218"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20050712070251.1219"><vh>markChangedRoots</vh></v>
<v t="ekr.20050712070251.1220"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20050712070251.1221"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20050712070251.1222"><vh>markClones</vh></v>
<v t="ekr.20050712070251.1223"><vh>markHeadline</vh></v>
<v t="ekr.20050712070251.1224"><vh>markSubheads</vh></v>
<v t="ekr.20050712070251.1225"><vh>unmarkAll</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1608"><vh>(Fixed bugs re initial_splitter_orientation &amp; @strings &amp; @ints generally)</vh>
<v t="ekr.20050712070251.1609"><vh>Report</vh></v>
<v t="ekr.20050712070251.1610"><vh>What I did</vh></v>
<v t="ekr.20050712070251.781"><vh>f.finishCreate</vh>
<v t="ekr.20050712070251.782"><vh>&lt;&lt; create the toplevel and outer frames &gt;&gt;</vh></v>
<v t="ekr.20050712070251.783"><vh>&lt;&lt; create the icon bar &gt;&gt;</vh></v>
<v t="ekr.20050712070251.784"><vh>&lt;&lt; create the splitters and their subframes &gt;&gt;</vh></v>
<v t="ekr.20050712070251.785"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
<v t="ekr.20050712070251.786"><vh>&lt;&lt; create the status line &gt;&gt;</vh></v>
<v t="ekr.20050712070251.787"><vh>&lt;&lt; create the menu bar &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.788"><vh>initialRatios</vh></v>
<v t="ekr.20050712070251.1353"><vh>doStrings</vh></v>
<v t="ekr.20050712070251.1349"><vh>doInts</vh></v>
</v>
<v t="ekr.20050712070251.1611"><vh>(Fixed bug with hoist + insert)</vh>
<v t="ekr.20050712070251.1612"><vh>Report</vh></v>
<v t="ekr.20050712070251.1613"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1074"><vh>c.insertHeadline</vh></v>
<v t="ekr.20050712070251.96"><vh>Hoist &amp; dehoist</vh></v>
</v>
<v t="ekr.20050712070251.1614"><vh>(Fixed problem with settings dialog position when panes split horizontally)</vh>
<v t="ekr.20050712070251.1615"><vh>Report</vh></v>
<v t="ekr.20050712070251.1616"><vh>What I did</vh></v>
<v t="ekr.20050712070251.546"><vh>createFrame (leo.py)</vh></v>
</v>
<v t="ekr.20050712070251.1617"><vh>(Fixed problem changing shortcut &amp; redid shortcuts widget)</vh>
<v t="ekr.20050712070251.1618"><vh>Report</vh></v>
<v t="ekr.20050712070251.1619"><vh>What I did</vh></v>
<v t="ekr.20050712070251.1620"><vh>updateSetter</vh></v>
<v t="ekr.20050712070251.1621"><vh>createWidgets &amp; helpers</vh>
<v t="ekr.20050712070251.1622"><vh>&lt;&lt; define creatorDispatchDict &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1623"><vh>createBool</vh></v>
<v t="ekr.20050712070251.1624"><vh>createColor</vh>
<v t="ekr.20050712070251.1625"><vh>&lt;&lt; munge val and add val to colorNamesList &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1626"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1627"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1628"><vh>createComments</vh></v>
<v t="ekr.20050712070251.1629"><vh>createOnlyComments</vh></v>
<v t="ekr.20050712070251.1630"><vh>createDirectory</vh></v>
<v t="ekr.20050712070251.1631"><vh>createFloat</vh></v>
<v t="ekr.20050712070251.1632"><vh>createFont</vh>
<v t="ekr.20050712070251.1633"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1634"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1635"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1636"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20050712070251.1637"><vh>&lt;&lt; define fontCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1638"><vh>createInt</vh></v>
<v t="ekr.20050712070251.1639"><vh>createInts</vh></v>
<v t="ekr.20050712070251.1640"><vh>createPath</vh></v>
<v t="ekr.20050712070251.1641"><vh>createRatio</vh></v>
<v t="ekr.20050712070251.1642"><vh>createShortcut</vh></v>
<v t="ekr.20050712070251.1643"><vh>createShortcuts</vh></v>
<v t="ekr.20050712070251.1644"><vh>createSpacerFrame</vh></v>
<v t="ekr.20050712070251.1645"><vh>createString</vh></v>
<v t="ekr.20050712070251.1646"><vh>createStrings</vh></v>
<v t="ekr.20050712070251.1647"><vh>createText</vh></v>
</v>
<v t="ekr.20050712070251.1648"><vh>doShortcuts</vh></v>
<v t="ekr.20050712070251.861"><vh>writeChangedVars &amp; helpers</vh>
<v t="ekr.20050712070251.862"><vh>updateConfig</vh></v>
<v t="ekr.20050712070251.863"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20050712070251.864"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20050712070251.865"><vh>writeChangedList</vh>
<v t="ekr.20050712070251.866"><vh>&lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.867"><vh>writeChangesToFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1649"><vh>Features</vh>
<v t="ekr.20050712070251.1650"><vh>(Allow quoted urls in  @urls nodes)</vh>
<v t="ekr.20050712070251.1651"><vh>Request</vh></v>
<v t="ekr.20050712070251.1020"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20050712070251.1021"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1022"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20050712070251.1023"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1652"><vh>(Moved executeFile into core)</vh>
<v t="ekr.20050712070251.1653"><vh>g.executeFile</vh>
<v t="ekr.20050712070251.1654"><vh>&lt;&lt; define subprocess_wrapper &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1655"><vh>(Rewrote g.getScript using at.writeFromString)</vh>
<v t="ekr.20050712070251.1656"><vh>What I did</vh></v>
<v t="ekr.20050712070251.100"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20050712070251.101"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20050712070251.102"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20050712070251.103"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20050712070251.104"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20050712070251.105"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.106"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20050712070251.107"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20050712070251.108"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20050712070251.109"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20050712070251.110"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.111"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20050712070251.112"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20050712070251.113"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.534"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050712070251.535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050712070251.259"><vh>initWriteIvars</vh>
<v t="ekr.20050712070251.260"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.398"><vh>putBody</vh>
<v t="ekr.20050712070251.399"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20050712070251.400"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.443"><vh>putAtFirstLines (new in 4.3 b2)</vh></v>
<v t="ekr.20050712070251.444"><vh>putAtLastLines (new in 4.3 b2)</vh></v>
<v t="ekr.20050712070251.383"><vh>openFileForWriting &amp; openFileForWritingHelper</vh>
<v t="ekr.20050712070251.384"><vh>openFileForWritingHelper</vh></v>
</v>
<v t="ekr.20050712070251.245"><vh>write</vh>
<v t="ekr.20050712070251.246"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20050712070251.247"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.396"><vh>writeOpenFile</vh></v>
<v t="ekr.20050712070251.385"><vh>writeFromString (new in 4.3 beta2)</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050712070251.1657"><vh>notes</vh></v>
<v t="ekr.20050712070251.1658"><vh>e post 1</vh></v>
<v t="ekr.20050712070251.1659"><vh>e post 2</vh></v>
<v t="ekr.20050712070251.1660"><vh>iPython support (more powerful execute script)</vh></v>
</v>
<v t="ekr.20050712070251.1661"><vh>(Added define_name arg to c.executeScript)</vh>
<v t="ekr.20050712070251.1662"><vh>Posting</vh></v>
<v t="ekr.20050712070251.529"><vh>c.executeScript</vh>
<v t="ekr.20050712070251.530"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.531"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="ekr.20050712070251.532"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20050712070251.533"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1663"><vh>Commands for jumping between words: temacs &amp; usetemacs</vh>
<v t="ekr.20050712070251.1664"><vh>Request</vh></v>
<v t="ekr.20050712070251.1665"><vh>Reply</vh></v>
<v t="ekr.20050712070251.1666"><vh>From Tk docs</vh></v>
</v>
</v>
</v>
<v t="ekr.20050712070251.1667"><vh>4.3 final projects</vh>
<v t="ekr.20050712070251.1668"><vh>(Fixed crasher when pie-menu plugin enabled)</vh>
<v t="ekr.20050712070251.1669"><vh>Report</vh></v>
<v t="ekr.20050712070251.1670"><vh>Traceback</vh></v>
</v>
<v t="ekr.20050712070251.1671"><vh>(Fixed crasher in Extract Section Command)</vh>
<v t="ekr.20050712070251.1672"><vh>Traceback</vh></v>
<v t="ekr.20050712070251.1407"><vh>extractSection</vh>
<v t="ekr.20050712070251.1408"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20050712070251.1406"><vh>extract</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040422091601.1"></t>
<t tx="EKR.20040422101256"></t>
<t tx="EKR.20040422101256.1"></t>
<t tx="EKR.20040422130619">def resizeToScreen (self):
    
    top = self.top
    
    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()
    
    geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)

    top.geometry(geom)</t>
<t tx="EKR.20040422130619.1"></t>
<t tx="EKR.20040422131023">Make sure beginUpdate inhibits redraw!</t>
<t tx="EKR.20040422131742">@nocolor

What I did:
	
- Put frame around find/change text areas:  added relief setting.
- Reduced height and width of find/change text areas.
- Reduced padding around buttons and checkboxes.
- It turns out that _clover_ v and p work in checkboxes.
- Bring outline to front after sucessful search.

@color</t>
<t tx="EKR.20040422131742.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2355852
By: rodrigo_b

On Linux, if you copy some leo headline or body text, and try to paste it in
the Find/Change panel (as a string to search), it does not work.

I suspect the problem is due that Ctrl+V (paste) is not define in the Find panel.

RodrigoB.</t>
<t tx="EKR.20040422131742.2">@nocolor

By: dthein ( Dave Hein ) 
 BUG: double-paste in searchbox.py plugin   
2004-02-06 16:59  

 Leo 4.1 rc4, build 1.76 , February 3, 2004
Python 2.3.3, Tk 8.4.2, linux2

When I Ctrl-C copy a string from a body and Ctlr-V paste it into the searchbox it gets pasted twice (e.g. the string "image" gets pasted as "imageimage").

I'll try to track this down, but if anyone has a clue right away, please post the solution.

--
Dave Hein  
</t>
<t tx="EKR.20040422132037.1"></t>
<t tx="EKR.20040422132037.8">@nocolor

By: Bill Drissel - drissel
2004-04-13 19:43  

Xserver (XFree86 under Cygwin) on PC (W2000); controlling Linux Red Hat;
buncha windows up including one Leo window and many xterms and Xemacs.

A: means action, R: means result

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; locate mouse symbol in text
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; up arrow to locate Ibeam in text
R: Joy! colorizes, marks headline and saves!

A: hilite headline text; type on KB
R: keystrokes replace hilited text

A: hilite text in Xemacs window; hilite headline; middle click
R: hilited text appended to headline rather than replacing

This last anomaly seems to persist regardless of how the headline is hilited and regardless of pasting method (middle click or Control-V)</t>
<t tx="EKR.20040423082910">if type(s) == type(u""): # 3/18/03
    s = g.toEncodedString(s,g.app.tkEncoding)
    
if sys.platform == "darwin":
    print s,

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate()</t>
<t tx="EKR.20040423082910.1">g.app.logWaiting.append((s,color),)

print "Null tkinter log"
if type(s) == type(u""): # 3/18/03
    s = g.toEncodedString(s,"ascii")
print s</t>
<t tx="EKR.20040423082910.2">if sys.platform == "darwin":
    print
    
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")

self.frame.tree.disableRedraw = True
self.logCtrl.update_idletasks()
#self.frame.outerFrame.update_idletasks() # 4/23/04
#self.frame.top.update_idletasks()
self.frame.tree.disableRedraw = False</t>
<t tx="EKR.20040423082910.3">g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print</t>
<t tx="EKR.20040424085407"># This routine is needed to handle cvs stupidities.

def compareFilesIgnoringLineEndings (self,path1,path2):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        f1 = open(path1) ; f2 = open(path2)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except:
        return False</t>
<t tx="EKR.20040424091902"></t>
<t tx="EKR.20040424151409"></t>
<t tx="EKR.20040424153344">def disableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="disabled",background="gray")
    
def enableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="normal",background="pink")
        t.focus_set()
        
def statusLineIsEnabled(self):
    t = self.statusText
    if t:
        state = t.cget("state")
        return state == "normal"
    else:
        return False</t>
<t tx="EKR.20040424154804">def setFocusStatusLine (self):
    
    t = self.statusText
    if t:
        t.focus_set()</t>
<t tx="EKR.20040425130443"></t>
<t tx="EKR.20040427073852"></t>
<t tx="EKR.20040427074150"></t>
<t tx="EKR.20040427075250"></t>
<t tx="EKR.20040427095028">def putCloseNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    at = self
    
    s = self.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)</t>
<t tx="EKR.20040427105350"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="EKR.20040427134616">at.dispatch_dict = {
    # Plain line.
    noSentinel: at.readNormalLine,
    # Starting sentinels...
    startAll:    at.readStartAll,
    startAt:     at.readStartAt,
    startDoc:    at.readStartDoc,
    startLeo:    at.readStartLeo,
    startMiddle: at.readStartMiddle,
    startNode:   at.readStartNode,
    startOthers: at.readStartOthers,
    # Ending sentinels...
    endAll:    at.readEndAll,
    endAt:     at.readEndAt,
    endDoc:    at.readEndDoc,
    endLeo:    at.readEndLeo,
    endMiddle: at.readEndMiddle,
    endNode:   at.readEndNode,
    endOthers: at.readEndOthers,
    # Non-paired sentinels.
    startAfterRef:  at.readAfterRef,
    startClone:     at.readClone,
    startComment:   at.readComment,
    startDelims:    at.readDelims,
    startDirective: at.readDirective,
    startNl:        at.readNl,
    startNonl:      at.readNonl,
    startRef:       at.readRef,
    startVerbatim:  at.readVerbatim,
    # Ignored 3.x sentinels
    endBody:               at.ignoreOldSentinel,
    startBody:             at.ignoreOldSentinel,
    startVerbatimAfterRef: at.ignoreOldSentinel }</t>
<t tx="EKR.20040427145035">@nocolor

Recognizers

- Added vnode recognizers for @file-thin option.
- Added position proxies for vnode recognizers.

Directives &amp; sentinels
- Added support for @all.

Writing

- Added top-level atFile code to write @file-thin tree.
- DO write @file-thin vnodes if there was an error writing the derived file.
	- No autosave for @file-thin.
 	- Leo writes @file nodes first, so this is not a problem.
	- putVnode checks orphan bit, which gets set if there was an error.
- Don't write vnodes (or related tnodes) for @file-thin trees. (fileCommands).
- Do write empty nodes in @thin trees.
- Don't generate close node sentinels until all children have been generated.

Reading

- Set at.thinFile when reading thin files.
- Suppressed changed message and related items for thin files.
- Modified scanText4 and allies to read thin derived files.
	- Don't look for tnodeList for thin files.
	- Initially, at.lastThinNode is at.root.v
	- readStartNode calls createThinChild
	- createThinChild makes a child of at.lastThinNode if needed and sets at.lastThinNode.
- Updated fc.tnodesDict in at.createThinChild.
	Otherwise clones existing only in two thin files won't be linked properly.</t>
<t tx="EKR.20040427180451"></t>
<t tx="EKR.20040428060432">@nocolor

- Existing fileCommands.write logic assigns tnode indices (gnx's) for all nodes to be written.
- New atFile.write logic writes tnode gnx's in all node headers.
- Existing fileCommands.read logic creates fc.tnodeList dictionary associating gnx's with tnodes.
	- The atFile.read logic can use this to associate newly created vnodes with shared tnodes.</t>
<t tx="EKR.20040429080901.1"></t>
<t tx="EKR.20040429081306"></t>
<t tx="EKR.20040429081306.1"></t>
<t tx="EKR.20040429082121"></t>
<t tx="EKR.20040429083147.3"></t>
<t tx="EKR.20040429084140"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="EKR.20040430080943.1">def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta</t>
<t tx="EKR.20040430080943.2">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)</t>
<t tx="EKR.20040430081109">def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
</t>
<t tx="EKR.20040430081109.1"></t>
<t tx="EKR.20040430081109.2"></t>
<t tx="EKR.20040430081719">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(endAll)</t>
<t tx="EKR.20040430081719.1">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(endAll)</t>
<t tx="EKR.20040430104717">def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="EKR.20040430104717.1"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="EKR.20040430152000">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="EKR.20040502120243">@nocolor

The fix was to set v.t.vnodeList in p.linkAsRoot and v.linkAsRoot.
While I was at it, I made c.setRootPosition more robust.


Open Discussion
http://sourceforge.net/forum/forum.php?thread_id=1058570&amp;forum_id=10226

By: Maxim Krikun - tws5
 4.2a1 problems   
2004-04-16 07:16  

 I'm using this alpha for two days, and had experienced certain strange behaviour. Probably this is related to the warning above. Anyway, here is a report:

(1) Focus switch instead of moving node when moving clones

Create the following tree (all nodes empty):

ROOT
..clone (1)
..A
	clone (2)
..B
	clone (3)

If i sit in clone(3) and press Ctrl+U, the focus goes to clone(2). Next Ctrl+U sets focus to clone (1).

If i sit in clone(1) and press Ctrl+D, i get (surprising)

ROOT
..clone
..clone

(2) _parent lost somewhere:

in a new file, create 'ROOT' root node
insert 'SUB' node (Ctrl+I)
move right (Ctri+R)
at this point ROOT collapses
trying to move 'SUB' left (Ctrl+L) raises an exception:

exception executing command
Traceback (most recent call last):
File "C:\maxim\leo\leo-4.2-a1\src\leoCommands.py", line 140, in doCommand
command()
File "C:\maxim\leo\leo-4.2-a1\src\leoCommands.py", line 3353, in moveOutlineLeft
p.moveAfter(parent)
File "C:\maxim\leo\leo-4.2-a1\src\leoNodes.py", line 2493, in moveAfter
p.linkAfter(a)
File "C:\maxim\leo\leo-4.2-a1\src\leoNodes.py", line 2987, in linkAfter
p.v._parent = after.v._parent
AttributeError: 'NoneType' object has no attribute '_parent'

Also when sitting at "SUB" cannot move up with 'Alt+Up'  
</t>
<t tx="EKR.20040502123721"></t>
<t tx="EKR.20040503064147.2"></t>
<t tx="EKR.20040503070514">def handleUserClick (self,p):
    
    """Reset suboutline-only search when the user clicks a headline."""
    
    try:
        if self.c and self.c.suboutline_only_flag:
            # g.trace(p)
            self.onlyVnode = p.copy() # Bug fix: 7/26/04
    except: pass</t>
<t tx="EKR.20040503071007">@nocolor

After a match, the find-next command searched only in the suboutline where the first match occured.
To fix this, we call g.app.findFrame.handleUserClick in various Tk event handlers.
This was a long-standing problem.

The call to g.app.findFrame.handleUserClick(p) probably should be in a base class.  How to do this?</t>
<t tx="EKR.20040503072338.1"></t>
<t tx="EKR.20040503090928.1"></t>
<t tx="EKR.20040503093407.1">@nocolor

Ooops.  p.v.t.visitedBit was used for two purposes:

- To mark the nodes to be written.
- To mark nodes that are not orphan.

What I did:

- Added t.is/set/clearWriteBit.
- Call t.setWriteBit in putVnode unless we are in a thin node.
- putTnodes tests for t.writeBit rather than t.visitedBit.</t>
<t tx="EKR.20040503105354">if g.match(s,i,thin_tag):
    i += len(tag)</t>
<t tx="EKR.20040503105740"></t>
<t tx="EKR.20040504145804.1">def propagateDiffsToSentinelsLines (self,
    i_lines,j_lines,fat_lines,mapping):
    
    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    &lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;
    &lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        &lt;&lt; update and check the loop invariant &gt;&gt;
        if tag == 'equal':
            &lt;&lt; handle 'equal' tag &gt;&gt;
        elif tag == 'replace':
            &lt;&lt; handle 'replace' tag &gt;&gt;
        elif tag == 'delete':
            &lt;&lt; handle 'delete' tag &gt;&gt;
        elif tag == 'insert':
            &lt;&lt; handle 'insert' tag &gt;&gt;
        else: assert 0,"bad tag"
    &lt;&lt; copy the sentinels at the end of the file &gt;&gt;
    return write_lines</t>
<t tx="EKR.20040504145804.2"># Indices into i_lines, j_lines &amp; fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose</t>
<t tx="EKR.20040504145804.3">while fat_pos &lt; mapping[0]:

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "copy initial line",fat_pos,line,
    fat_pos += 1
</t>
<t tx="EKR.20040504145804.4"># We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, delims)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], delims)[1]</t>
<t tx="EKR.20040504145804.5"># Copy the lines, including sentinels.
while fat_pos &lt;= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)</t>
<t tx="EKR.20040504145804.6">@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line =&gt; orignal line.
@c

while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="EKR.20040504145804.7">if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="EKR.20040504145804.8">while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.</t>
<t tx="EKR.20040504145804.9">while fat_pos &lt; len(fat_lines):

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "Append last line",line
    fat_pos += 1
</t>
<t tx="EKR.20040504150046">import difflib,shutil

class mulderUpdateAlgorithm:
    
    """A class to update derived files using
    diffs in files without sentinels.
    """
    
    @others
    
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

    mu = mulderUpdateAlgorithm()

    mu.pull_source(sourcefilename,targetfilename)
    mu.copy_time(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504150046.3">def __init__ (self,testing=False,verbose=False):
    
    self.testing = testing
    self.verbose = False
    self.do_backups = False</t>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None</t>
<t tx="EKR.20040504150046.5">def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    print '='*20
    print message
    
    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,
         
        print '='*20
    
        print lines2_message
        print '-'*20
        for line in lines2:
            print line,</t>
<t tx="EKR.20040504150046.6">def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """
    
    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)
    
    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping</t>
<t tx="EKR.20040504150046.9">@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """
    
    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i &lt;= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos &lt; j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos</t>
<t tx="EKR.20040504150046.10">def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
    
    &lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;
    
    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)
        
    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        &lt;&lt; paranoia check&gt;&gt;</t>
<t tx="EKR.20040504150046.11"># Get the sentinel comment delims.
delims = self.comment_delims_from_extension(sourcefilename)
if not delims:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)
    
    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.
    
    i_lines,mapping = self.create_mapping(fat_lines,delims)
    
    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return</t>
<t tx="EKR.20040504150046.12"># Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,delims)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")</t>
<t tx="EKR.20040504155109">def copy_time(self,sourcefilename,targetfilename):
    
    """
    Set the target file's modification time to
    that of the source file.
    """

    st = os.stat(sourcefilename)

    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")</t>
<t tx="EKR.20040504160820">def write_if_changed(self,lines,sourcefilename,targetfilename):
    """
    
    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.
    
    Optionally backs up the overwritten file.

    """
    
    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
        
    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            &lt;&lt; make backup file &gt;&gt;
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
</t>
<t tx="EKR.20040504160820.1">if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if testing:
        print "backup file in ", backupname</t>
<t tx="EKR.20040505080156"># These routines originally were part of push_filter &amp; push_filter_lines.</t>
<t tx="EKR.20040505080156.2">def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return removeSentinelsFromLines(lines,delims)
    
def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""
    
    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    &lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;
    return result</t>
<t tx="EKR.20040505080156.3">def getSentinelsFromFile (self,filename,delims):
    
    """Returns all sentinels lines in a file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return getSentinelsFromLines(lines,delims)
    
def getSentinelsFromLines (self,lines,delims):
    
    """Returns all sentinels lines in lines."""
    
    return [line for line in lines if g.is_sentinel(line,delims)]</t>
<t tx="EKR.20040505081121">def separateSentinelsFromFile (self,filename):
    
    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return self.separateSentinelsFromLines(lines,delims)
    
def separateSentinelsFromLines (self,lines,delims):
    
    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""
    
    strippedLines = self.removeSentinelsFromLines(lines,delims)
    sentinelLines = self.getSentinelsFromLines(lines,delims)
    
    return strippedLines,sentinelLines</t>
<t tx="EKR.20040506075328">def writeOpenFile(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    at = self ; c = at.c
    
    &lt;&lt; init atFile ivars for writing &gt;&gt;
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    &lt;&lt; put all @first lines in root &gt;&gt;

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    &lt;&lt; put all @last lines in root &gt;&gt;
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()</t>
<t tx="EKR.20040506075328.1"># Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.raw = False
assert(at.toStringFlag == toString) # Must have been set earlier.

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.</t>
<t tx="EKR.20040506075328.2">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    &lt;&lt; about this algorithm &gt;&gt;
    c = p.c ; root = p.copy()
    at = c.atFileCommands
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</t>
<t tx="EKR.20040507093503"></t>
<t tx="EKR.20040512081330.1"></t>
<t tx="EKR.20040512084726">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2556550
By: bwmulder

The 4.1 documentation of unknownAttributes says:

&gt; Each plugin should create its own dictionary _inside_ any tempAttributes or
unknownAttributes dictionaries that it intends to create or modify.

This does not seem to work since the write code tries to call 'replace' on the
value of those attributes. It seems that unknownAttributes can only contain
string / string key / value pairs.

For now, I am trying to use the pickle module to convert my dictionary into
a string.

-------------

Follow up:

http://sourceforge.net/forum/message.php?msg_id=2558114
By: bwmulder

No, pickling is also not the answer: the pickled string can not contain a double
quote.

Pickling and hexlifying should do the trick, though.</t>
<t tx="EKR.20040517084551"></t>
<t tx="EKR.20040519073926.1"># putVnode must test for self.usingClipboard in two places.</t>
<t tx="EKR.20040519080820"></t>
<t tx="EKR.20040519083814"># The comment delim is ';', and it is not being recognized</t>
<t tx="EKR.20040520075421.4"># While I was at it, I added @asis, @noref, @nosent.</t>
<t tx="EKR.20040520075421.5"></t>
<t tx="EKR.20040520080309"># putCodeLine converts all directives to verbatim directives.
# This is exactly what we need to do for @all.</t>
<t tx="EKR.20040520092739"></t>
<t tx="EKR.20040520093903">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="EKR.20040521084602">@nocolor</t>
<t tx="EKR.20040523104815">def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex</t>
<t tx="EKR.20040523193958"></t>
<t tx="EKR.20040524050229"></t>
<t tx="EKR.20040524053657">@nocolor

I made these changes:

- Generate open/close middle sentinels in putRefAt for all intermediate (inBetween) nodes.

- An earlier version just hacked readEndNode not to replace text, but this was wrong: sentinels should mean what they say.  Moreover, we don't want to confuse @+-node with @+-middle sentinels when trying to handle differences between cloned text.</t>
<t tx="EKR.20040524053657.1"></t>
<t tx="EKR.20040524070500">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="EKR.20040524071414">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="EKR.20040524152405"></t>
<t tx="EKR.20040524164424">@nocolor

1. It took me some time to realize that Leo uses plain Text widgets in the tree, _not_ canvas text widgets.

2. The fix therefore was to make redraw_now cancel any pending redraw so that the selection doesn't get destroyed by another redraw.</t>
<t tx="EKR.20040525084847">@nocolor

This happens after write errors such as orphan nodes.

The error persists even after the error is corrected.j

The fix was to do: root.clearOrphan() in atFile.openWriteFile.  This method is used by both old and new style files.</t>
<t tx="EKR.20040525135323"></t>
<t tx="EKR.20040526072519">u.redoDispatchDict = {
    "Change":             u.redoTyping,
    "Change All":         u.redoChangeAll,
    "Change Headline":    u.redoChangeHeadline,
    "Clone Node":         u.redoClone,
    "Convert All Blanks": u.redoReplaceNodesContents,
    "Convert All Tabs":   u.redoReplaceNodesContents,
    "Convert Blanks":     u.redoTyping,
    "Convert Tabs":       u.redoTyping,
    "Cut":                u.redoTyping,
    "Cut Node":           u.redoDeleteNode,
    "De-Hoist":           u.redoDehoist,
    "Delete":             u.redoTyping,
    "Delete Node":        u.redoDeleteNode,
    "Demote":             u.redoDemote,
    "Drag":               u.redoMoveNode,
    "Drag &amp; Clone":       u.redoClone,
    "Extract":            u.redoReplaceNodes,
    "Extract Names":      u.redoReplaceNodes,
    "Extract Section":    u.redoReplaceNodes,
    "Hoist":              u.redoHoist,
    "Import":             u.redoInsertNodes,
    "Indent":             u.redoTyping,
    "Insert Node":        u.redoInsertNodes,
    "Move Down":          u.redoMoveNode,
    "Move Left":          u.redoMoveNode,
    "Move Right":         u.redoMoveNode,
    "Move Up":            u.redoMoveNode,
    "Paste":              u.redoTyping,
    "Paste Node":         u.redoInsertNodes,
    "Pretty Print":       u.redoChangeAll,
    "Promote":            u.redoPromote,
    "Read @file Nodes":   u.redoReplaceNodes,
    "Reformat Paragraph": u.redoTyping,
    "Sort Children":      u.redoSortChildren,
    "Sort Siblings":      u.redoSortSiblings,
    "Sort Top Level":     u.redoSortTopLevel,
    "Typing":             u.redoTyping,
    "Undent":             u.redoTyping }</t>
<t tx="EKR.20040526072519.1">def redoClone (self):
    
    u = self ; c = u.c
    
    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)

    c.selectVnode(u.p)</t>
<t tx="EKR.20040526072519.2">def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectVnode(u.p)
    c.deleteOutline()</t>
<t tx="EKR.20040526072519.3">def redoHoist (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.hoist()
    u.updateSetChangedFlag = False
    
def redoDehoist (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.dehoist()
    u.updateSetChangedFlag = False</t>
<t tx="EKR.20040526072519.4">def redoInsertNodes (self):
    
    u = self ; c = u.c

    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    c.selectVnode(u.p)</t>
<t tx="EKR.20040526072519.5"></t>
<t tx="EKR.20040526075238">u.undoDispatchDict = {
    "Change":             u.undoTyping,
    "Change All":         u.undoChangeAll,
    "Change Headline":    u.undoChangeHeadline,
    "Clone Node":         u.undoClone,
    "Convert All Blanks": u.undoReplaceNodesContents,
    "Convert All Tabs":   u.undoReplaceNodesContents,
    "Convert Blanks":     u.undoTyping,
    "Convert Tabs":       u.undoTyping,
    "Cut":                u.undoTyping,
    "Cut Node":           u.undoDeleteNode,
    "De-Hoist":           u.undoDehoist,
    "Delete":             u.undoTyping,
    "Delete Node":        u.undoDeleteNode,
    "Demote":             u.undoDemote,
    "Drag":               u.undoMoveNode,
    "Drag &amp; Clone":       u.undoDragClone, # redo uses redoClone.
    "Extract":            u.undoReplaceNodes,
    "Extract Names":      u.undoReplaceNodes,
    "Extract Section":    u.undoReplaceNodes,
    "Hoist":              u.undoHoist,
    "Import":             u.undoInsertNodes,
    "Indent":             u.undoTyping,
    "Insert Node":        u.undoInsertNodes,
    "Move Down":          u.undoMoveNode,
    "Move Left":          u.undoMoveNode,
    "Move Right":         u.undoMoveNode,
    "Move Up":            u.undoMoveNode,
    "Paste":              u.undoTyping,
    "Paste Node":         u.undoInsertNodes,
    "Pretty Print":       u.undoChangeAll,
    "Promote":            u.undoPromote,
    "Read @file Nodes":   u.undoReplaceNodes,
    "Reformat Paragraph": u.undoTyping,
    "Sort Children":      u.undoSortChildren,
    "Sort Siblings":      u.undoSortSiblings,
    "Sort Top Level":     u.undoSortTopLevel,
    "Typing":             u.undoTyping,
    "Undent":             u.undoTyping }</t>
<t tx="EKR.20040526075238.1">def redoMoveNode (self):
    
    u = self ; c = u.c

    # g.trace(u.p)
    if u.parent:
        u.p.moveToNthChildOf(u.parent,u.n)
    elif u.back:
        u.p.moveAfter(u.back)
    else:
        oldRoot = c.rootPosition() # Bug fix: 4/9/04
        u.p.moveToRoot(oldRoot)

    c.selectVnode(u.p)</t>
<t tx="EKR.20040526075238.2">def redoDemote (self):
    
    u = self ; c = u.c

    c.selectVnode(u.p)
    c.demote()
    
def redoPromote (self):
    
    u = self ; c = u.c

    c.selectVnode(u.p)
    c.promote()</t>
<t tx="EKR.20040526075238.3">def redoReplaceNodes (self):
    
    """Redo replacement of multiple nodes."""
    
    u = self ; c = u.c

    u.p = self.undoReplace(u.p,u.oldTree,u.newTree)
    c.selectVnode(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
        
def redoReplaceNodesContents (self):
    
    """Redo replacement of body text of multiple nodes."""
    
    u = self
    u.redoReplaceNodes()
    u.redrawFlag = False
</t>
<t tx="EKR.20040526075238.4">def redoSortChildren (self):
    
    u = self ; c = u.c

    c.selectVnode(u.p)
    c.sortChildren()

def redoSortSiblings (self):
    
    u = self ; c = u.c

    c.selectVnode(u.p)
    c.sortSiblings()
    
def redoSortTopLevel (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.sortTopLevel()
    u.p = None # don't mark u.p dirty</t>
<t tx="EKR.20040526075238.5">def redoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()

    # selectVnode causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectVnode(u.p)
    elif u.undoType in ("Cut","Paste"):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
        
    u.redrawFlag = (current != u.p)</t>
<t tx="EKR.20040526083847">def undoClone (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.deleteOutline()
    c.selectVnode(u.back)

def undoDragClone (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.deleteOutline()
    c.selectVnode(u.oldV)</t>
<t tx="EKR.20040526083847.1">@ Deleting a clone is _not_ the same as undoing a clone:
the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    c.selectVnode(u.p)</t>
<t tx="EKR.20040526083847.2">def undoHoist (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.dehoist()
    u.updateSetChangedFlag = False

def undoDehoist (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.hoist()
    u.updateSetChangedFlag = False
</t>
<t tx="EKR.20040526084140">def undoInsertNodes (self):
    
    u = self ; c = u.c
    
    c.selectVnode(u.p)
    c.deleteOutline()
    if u.select:
        c.selectVnode(u.select)</t>
<t tx="EKR.20040526084140.1">def undoMoveNode (self):
    
    u = self ; c = u.c

    # g.trace("oldParent",u.oldParent)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition() # Bug fix: 4/9/04
        u.p.moveToRoot(oldRoot)

    c.selectVnode(u.p)</t>
<t tx="EKR.20040526090701.1">def redoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        # g.trace(u.undoType,u.p,u.newText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.v.setTnodeText(u.newText)
            u.p.setDirty()
            count += 1
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.newText)
            count += 1
        else: assert(False)

    g.es("redo %d instances" % count)</t>
<t tx="EKR.20040526090701.2">def redoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.newText)
    
    u.p.setHeadStringOrHeadline(u.newText)
    
    c.selectVnode(u.p)</t>
<t tx="EKR.20040526090701.3">def undoReplaceNodes (self):
    
    u = self ; c = u.c

    u.p = self.undoReplace(u.p,u.newTree,u.oldTree)
    c.selectVnode(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
    
def undoReplaceNodesContents (self):
    
    u = self ; c = u.c
    
    u.undoReplaceNodes()
    u.redrawFlag = False</t>
<t tx="EKR.20040526090701.4">def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()

    # g.trace(u.undoType,u.p)
    # selectVnode causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectVnode(u.p)
    elif u.undoType in ("Cut","Paste"):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
        
    u.redrawFlag = (current != u.p)</t>
<t tx="EKR.20040526090701.5">def undoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        # g.trace(u.undoType,u.p,u.oldText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.setTnodeText(u.oldText)
            count += 1
            u.p.setDirty()
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.oldText)
            count += 1
        else: assert False, "bad undo type:" % u.undoType

    g.es("undo %d instances" % count)</t>
<t tx="EKR.20040526090701.6">def undoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.oldText)
    
    u.p.setHeadStringOrHeadline(u.oldText)
    
    c.selectVnode(u.p)

    </t>
<t tx="EKR.20040526094429">def registerUndoHandlers (self,undoName,undoFunc,redoFunc,verbose=False):
    
    """Public method to set undo &amp; redo handlers for a new command."""
    
    u = self
    u.registerHandler(undoName,redoFunc,"Redo",u.redoDispatchDict,verbose)
    u.registerHandler(undoName,undoFunc,"Undo",u.undoDispatchDict,verbose)
    
    
def registerHandler (self,undoName,func,kind,dict,verbose=False):
    
    """Private helper method for registerUndoHandlers."""
    
    u = self

    try:
        g.funcToMethod(func,undoer)
        assert(hasattr(u,func.__name__))
    except (AttributeError, AssertionError):
        s = "Bad %s handler for %s: %s" % (kind,undoName,repr(func))
        g.trace(s) ; g.es(s, color="red")
        return
    try:
        dict[undoName] = getattr(u,func.__name__) # Get the method, not the function.
        if verbose:
            print "%s registered as %s handler for %s" % (func.__name__,kind,undoName)
    except KeyError:
        s = "Bad key: %s for %s: %s" % (kind,undoName,repr(func))
        g.trace(s) ; g.es(s, color="red")</t>
<t tx="EKR.20040526150818">def getBead (self,n):
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    d = u.beads[n]
    # g.trace(n,len(u.beads),d)
    self.clearIvars()
    u.p = d["v"]
    u.undoType = d["undoType"]

    for ivar in u.optionalIvars:
        val = d.get(ivar,None)
        setattr(u,ivar,val)

    if not u.new_undo: # Recreate an "oldText" entry if necessary.
        if u.undoType == "Typing" and u.oldText == None:
            assert(n &gt; 0)
            old_d = u.beads[n-1]
            # The user will lose data if these asserts fail.
            assert(old_d["undoType"] == "Typing")
            assert(old_d["v"] == u.p)
            u.oldText = old_d["newText"]
            # g.trace(u.oldText)
    return d</t>
<t tx="EKR.20040526150818.1">def peekBead (self,n):
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    d = u.beads[n]
    # g.trace(n,len(u.beads),d)
    return d</t>
<t tx="EKR.20040526150818.2">def setBead (self,n,keywords=None):

    u = self ; d = {}
    d["undoType"]=u.undoType
    d["v"]=u.p
    # Only enter significant entries into the dictionary.
    # This is an important space optimization for typing.
    for ivar in u.optionalIvars:
        if getattr(u,ivar) != None:
            d[ivar] = getattr(u,ivar)
    # copy all significant keywords to d.
    if keywords:
        for key in keywords.keys():
            if keywords[key] != None:
                d[key] = keywords[key]
    # Clear the "oldText" entry if the previous entry was a "Typing" entry.
    # This optimization halves the space needed for Undo/Redo Typing.
    if not u.new_undo:
        if u.undoType == "Typing" and n &gt; 0:
            old_d = u.beads[n-1]
            if old_d["undoType"] == "Typing" and old_d["v"] == u.p:
                del d["oldText"] # We can recreate this entry from old_d["newText"]
                # g.trace(u.oldText)
    # g.trace(d)
    return d</t>
<t tx="EKR.20040526202501">def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)

        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")</t>
<t tx="EKR.20040526204036">def getUnknownTag(self):
    
    self.skipWsAndNl() # guarantees at least one more character.
    tag = self.getStringToTag('=')
    if not tag:
        print "getUnknownTag failed"
        raise BadLeoFile("unknown tag not followed by '='")

    self.fileIndex += 1
    val = self.getDqString()
    # g.trace(tag,val)
    return tag,val</t>
<t tx="EKR.20040526204036.1">def getUnknownAttribute(self,nodeType):
    
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
    
    try:
        bin = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
        val2 = pickle.loads(bin)
        return attr,val2

    except (TypeError,pickle.UnpicklingError,ImportError):
        # Assume that Leo 4.1 wrote the attribute.
        return attr,val</t>
<t tx="EKR.20040526210456">@nocolor

By: Bernhard Mulder - bwmulder
 unknownAttributes   
2004-05-06 00:32  

 The 4.1 documentation of unknownAttributes says:

&gt; Each plugin should create its own dictionary _inside_ any tempAttributes or unknownAttributes dictionaries that it intends to create or modify.

This does not seem to work since the write code tries to call 'replace' on the value of those attributes. It seems that unknownAttributes can only contain string / string key / value pairs.

For now, I am trying to use the pickle module to convert my dictionary into a string.</t>
<t tx="EKR.20040528070309.2"></t>
<t tx="EKR.20040528075307">def saveTree (self,p,treeInfo=None):
    
    """Create all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="EKR.20040528111420.1">def swapIntoTree (self,v2):
	
	"""Link a vnode into the tree in place of v2."""
	
	v1 = self

	# Set the links in v1.
	v1._next = v2._next
	v1._back = v2._back 
	v1._parent = v2._parent
	
	# Set links in other nodes to v1.
	if v1._next: v1._next._back = v1
	if v1._back: v1._back._next = v1
	if v1._parent and v2 == v1._parent.t._firstChild:
		v1._parent.t._firstChild = v1

def swapLinks (self,v2): # not used.
	
	"""Swap the next/back links of two vnodes."""
	
	v1 = self
	
	v1._next,   v2._next   = v2._next,  v1._next
	v1._back,   v2._back   = v2._back,  v1._back
	v1._parent, v2._parent = v2._parent,v1._parent</t>
<t tx="EKR.20040528151551"></t>
<t tx="EKR.20040528151551.2">def subtree_iter(self):

    """Return all nodes of self's tree in outline order."""
    
    v = self

    if v:
        yield v
        child = v.t._firstChild
        while child:
            for v1 in child.subtree_iter():
                yield v1
            child = child.next()
            
self_and_subtree_iter = subtree_iter</t>
<t tx="EKR.20040528151551.3">def unique_subtree_iter(self,marks=None):

    """Return all vnodes in self's tree, discarding duplicates """
    
    v = self

    if marks == None: marks = {}

    if v and v not in marks:
        marks[v] = v
        yield v
        if v.t._firstChild:
            for v1 in v.t._firstChild.unique_subtree_iter(marks):
                yield v1
        v = v._next
        while v:
            for v in v.unique_subtree_iter(marks):
                yield v
            v = v._next
            
self_and_unique_subtree_iter = unique_subtree_iter</t>
<t tx="EKR.20040528151551.4">def updateVnodeListsFrom (self,v2):
	
	"""Update the vnodeLists in a vnode tree copied from v2.
	
	Only data in the v1 tree should change. """
	
	v1 = self
	
	# Create correspondences between elements of v1 and v2.
	nodes1 = [v for v in v1.self_and_subtree_iter()]
	nodes2 = [v for v in v2.self_and_subtree_iter()]
	assert(len(nodes1) == len(nodes2))
	
	# Doesn't handle clones properly...Or maybe it is copyTree that is the problem.
		
	# Replace in _v1_ vnodeList references to nodes in v2 by references to nodes in v1.
	for v1 in nodes1:
		vnodeList = v1.t.vnodeList
		for v in vnodeList[:]:
			try:
				n = nodes2.index(v)
				vnodeList.remove(v)
				vnodeList.append(nodes1[n])
				print "vnodeList replace",v,nodes1[n]
			except ValueError:
				pass # v not in nodes2.</t>
<t tx="EKR.20040529091232">def allNodes_iter(self,copy=False):
    
    c = self
    return c.rootPosition().allNodes_iter(copy)
    
all_positions_iter = allNodes_iter</t>
<t tx="EKR.20040529091232.1">def all_tnodes_iter(self):
    
    c = self
    for p in c.all_positions_iter():
        yield p.v.t

    # return c.rootPosition().all_tnodes_iter(all=True)</t>
<t tx="EKR.20040529091232.2">def all_unique_tnodes_iter(self):
    
    c = self ; marks = {}
    
    for p in c.all_positions_iter():
        if not p.v.t in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t</t>
<t tx="EKR.20040529091232.3">def all_vnodes_iter(self):
    
    c = self
    for p in c.all_positions_iter():
        yield p.v</t>
<t tx="EKR.20040529091232.4">def all_unique_vnodes_iter(self):
    
    c = self ; marks = {}
    for p in c.all_positions_iter():
        if not p.v in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040529103843">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040529103945">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040529124312"># p.repr must call p.cleanHeadString.</t>
<t tx="EKR.20040530114124">@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo) where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="EKR.20040530115450">def createUndoInfo (self):
    
    """Create a dict containing all info needed to recreate a vnode for undo."""
    
    v = self ; d = {}
    
    # Copy all ivars.
    d ["v"] = v
    d ["statusBits"] = v.statusBits
    d ["parent"] = v._parent
    d ["next"] = v._next
    d ["back"] = v._back
    # The tnode never changes so there is no need to save it here.
    
    try: d ["unknownAttributes"] = v.unknownAttributes
    except: pass

    return d</t>
<t tx="EKR.20040530120245">def createUndoInfo (self,copyLinks=True):
    
    """Create a dict containing all info needed to recreate a vnode."""
    
    t = self ; d = {}
    
    # Essential fields.
    d ["t"] = t
    d ["headString"] = t.headString
    d ["bodyString"] = t.bodyString
    d ["vnodeList"]  = t.vnodeList[:]
    d ["statusBits"] = t.statusBits
    d ["firstChild"] = t._firstChild

    try: d ["unknownAttributes"] = t.unknownAttributes
    except: pass
    
    if 0: # These neve change, so no need to save/restore them.
        # In fact, it would be wrong to undo changes made to them!
        d ["cloneIndex"]  = t.cloneIndex
        d ["fileIndex"]  = t.fileIndex

    if 0: # probably not needed for undo.
        d ["insertSpot"]      = t.insertSpot
        d ["scrollBarSpot"]   = t.scrollBarSpot
        d ["selectionLength"] = t.selectionLength
        d ["selectionStart"]  = t.selectionStart

    return d
</t>
<t tx="EKR.20040530121329">def restoreTree (self,treeInfo):
    
    """Use the tree info to restore all vnode and tnode data,
    including all links."""
    
    # This effectively relinks all vnodes.
    
    for v,vInfo,tInfo in treeInfo:
        v.restoreUndoInfo(vInfo)
        v.t.restoreUndoInfo(tInfo)</t>
<t tx="EKR.20040530121847">def restoreUndoInfo (self,d):
    
    """Restore all ivars saved in dict d."""
    
    v = d ["v"] ; assert(v == self)

    v.statusBits = d ["statusBits"]
    v._parent    = d ["parent"] 
    v._next      = d ["next"] 
    v._back      = d ["back"]
    
    try:
        v.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="EKR.20040530121847.2">def restoreUndoInfo (self,d):
    
    t = d ["t"] ; assert(t == self)

    t.headString  = d ["headString"]
    t.bodyString  = d ["bodyString"]
    t.vnodeList   = d ["vnodeList"]
    t.statusBits  = d ["statusBits"]
    t._firstChild = d ["firstChild"]

    try:
        t.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="EKR.20040601083927"></t>
<t tx="EKR.20040602113145">@nocolor

- Leo calls g.enableIdleTimeHook at end of startup code.
	- This means that g.idleTimeHookHandler gets called periodically, even if no hooks have been defined.
	- g.enableIdleTime hook now calls g.app.gui.setIdleTimeHook at most once.

- app.forceShutdown now calls "end1" hook before calling app.finishQuit.
	- This ensures that the "end1" hook always gets called once.
	- app.finishQuit calls doHook("end1",...) only if it hasn't been called before.
		- This isn't necessary, but it makes traces in doHook less confusing.

- idleTimeHookHandler now calls the idle-time hook for all open windows.
	- So having multiple windows open should not affect idle-time hooks.

** Warning: new convention required to workaround apparent Tk problems.
	- "idle" hooks should return if g.app.killed is True.</t>
<t tx="EKR.20040602125018">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        s = "idle-time hooks enabled"
        # print s ; g.es(s)
        g.app.idleTimeHook = True
        g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
        
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler</t>
<t tx="EKR.20040602125018.1"># Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False</t>
<t tx="EKR.20040602125018.2"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c ; v = c.currentVnode()
        g.doHook("idle",c=c,v=v)

    # Requeue this routine after 100 msec.  Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.app.idleTimeDelay,g.idleTimeHookHandler)
        # g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="EKR.20040602144908">@color

Added the following hooks:

tag argument                                               keys in keywords
(hook name)           overrides    when called           dictionary argument
---------             ---------    -----------           -------------------

"draw-outline-box"       yes   start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"      yes   start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"      yes   start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"  yes   start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"       yes   start of tree.drawTree    tree,p,v,x,y,h,level,hoistFlag (note 6)</t>
<t tx="EKR.20040602150338">
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="EKR.20040603074929"></t>
<t tx="EKR.20040603092958">@nocolor

By: billp9619 ( bill palmer ) 
 leo_header optional closetag sb valid?   
2004-03-07 01:21  

 1. &lt;leo_header ... /&gt;
vs.
2. &lt;leo_header ... &gt;&lt;/leo_header&gt;

Leo saves using style 1 and treats style 2 as invalid.

Both are equivalent and so I think leo should accept both. Some applications for comparing xml insist on style 2.</t>
<t tx="EKR.20040603103215">@nocolor

By: David McNab - davidmcnab
 Syntax Colouring Bug - html mode   
2004-04-22 07:38  

Within an HTML @file node, where I have '@language html' at the top root, I notice that on typing in a triple-double-quote ("""), the text following gets coloured green, as would be appropriate if the node were actually python.

Several fixes, all in skip_string.</t>
<t tx="EKR.20040603150347">@nocolor

- Added @language html when importing ".htm" and ".html" files.
- Added @nocolor when importing ".txt" and ".text" files
</t>
<t tx="EKR.20040603151855">@nocolor

when in headline, selectall selects the body text then delete will delete it!
obviously, these should only be operating on the headline text at that point.

The fix was to try to select all text in the pane that has focus, and pass if the select fails.

To do: support select all in other panels?</t>
<t tx="EKR.20040604083436">@nocolor

- idle_body_key must call g.scanDirectives in order to support @tab_width.
	- This must be done for tabs and newlines.

- Fixed bug in g.scanDirectives that was rejecting negative tabwidth values.
	- This bug did not exist in the other versions of scanDirectives.

- With a negative tabwidth, a backspace now computes what spaces are equivalent to a tab and delete all of those.  This is easy to do!
</t>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="EKR.20040604155223"># s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    start = s[j:i]
else:
    valid = False</t>
<t tx="EKR.20040604155223.1">def parseLeoSentinel (self,s):
    
    at = self
    new_df = False ; valid = True ; n = len(s)
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    return valid,new_df,start,end</t>
<t tx="EKR.20040604160917">@nocolor

By: Poor Yorick - pooryorick
 Bug: Remove Sentinels   
2004-05-21 09:57  

 The Remove Sentinels function also converts windows newlines into unix newlines.

Comment:  actually, everything should work properly if the output_newline option is "platform" or "crlf" rather than nl.

- Created at.parseLeoSentinel so we don't have to duplicate code.</t>
<t tx="EKR.20040605172003">@nocolor

No absolute directory specified anywhere.

By: Kent Tenney - ktenney
 'Import Derived File' error   
2004-05-06 13:38  

In my Leo file is a node with the headline;
@file c:\cygwin\home\ktenney\work\ImageWords\ImageWords.py

When I start a new Leo file and choose; File-&gt;Import-&gt;Import Derived File

and open the file derived from the first Leo file, I get a node with the headline;
Imported @file C:/Python23/Lib/site-packages/leo/plugins/run_nodes.py

.. no body.

The message pane says;
imported C:/cygwin/home/ktenney/work/ImageWords/ImageWords.py
No absolute directory specified anywhere.</t>
<t tx="EKR.20040605173101">@nocolor

This message is from top_df.scanDefaultDirectory and old_df.scanAllDirectives.

The solution is to disable this message in these routine when importing.</t>
<t tx="EKR.20040605173241"></t>
<t tx="EKR.20040605175309">@nocolor

The Import Derived File command was showing the gnx field in the headlines.

This was because top_df.read was not setting at.thinFile when importing thin files.

What I did:

- Set at.thinFile in top_df.read.&lt;&lt;copy ivars to df&gt;&gt; when importing.
- Don't pop thinNodeStack when importing in readEndNode.
	- readStartNode doesn't push this stack when importing.</t>
<t tx="EKR.20040605181231"># This is not the cause of any slowness.</t>
<t tx="EKR.20040606191836">doc\leoUsersGuide.txt
doc\leoFAQ.txt
doc\leoLeaps.txt</t>
<t tx="EKR.20040606204504"></t>
<t tx="EKR.20040606204504.1">@nocolor

atFile.scanHeader was not handling -encoding fields properly.</t>
<t tx="EKR.20040608092709"></t>
<t tx="EKR.20040608093403">@nocolor

The old code used at c.tab_width.  It should also look for @tabwidth directives.

This was not good when @tabwidth -4 was in effect.</t>
<t tx="EKR.20040608095611">&lt;!---@+leo-ver=4-encoding=iso-8859-1.---&gt;
&lt;!---@+node:@file login_process.cfm---&gt;


&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
&lt;!---@-node:@file login_process.cfm---&gt;
&lt;!---@-leo---&gt;</t>
<t tx="EKR.20040608110312"></t>
<t tx="EKR.20040609090913"></t>
<t tx="EKR.20040609090913.1">@nocolor

File "/home/ng/mob/lib/leo-4.2-a3/src/leoCommands.py", line 334, in openWith
if v.t == dict.get("v") and searchPath == dict.get("path"):

File "/home/ng/mob/lib/leo-4.2-a3/src/leoNodes.py", line 1537, in __cmp__
if p1.v != p2.v or p1.stack != p2.stack:

AttributeError: 'tnode' object has no attribute 'v'
</t>
<t tx="EKR.20040609110138">found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="EKR.20040609160237"># namespace not handled very well.</t>
<t tx="EKR.20040609160237.1">@nocolor

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 143, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 924, in importAtFile
    c.importCommands.importFilesCommand (paths,"@file")
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 148, in importFilesCommand
    v = self.createOutline(fileName,current)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 82, in createOutline
    self.scanCText(s,v)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 1502, in scanCText
    self.scanCText(s[inner_ip:],parent)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 1291, in scanCText
    i = g.skip_braces(s,i)
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 2877, in skip_braces
    assert(g.match(s,i,'{'))
AssertionError
</t>
<t tx="EKR.20040610082623">"deech_99" &lt;deech_99@yahoo.com&gt; wrote in message news:c6m6hu$ncv$1@news.fas.harvard.edu...

I coded a PHP program using noweb and have recently decided to convert it
into a Leo program. The importing, however, seems to mess up the indenting
of the latex documentation badly. In noweb format the documentation looks
like this:

%------------------------
\subsection{Title}
%------------------------
contentcontentcontentconte
ntcontent
&lt;&lt;Code Chunk&gt;&gt;=
codecodecodecode
codecodecodecode
@

whereas in Leo, I get this:
@%-----------------\subsection{Title} %---
------contentcontentcontentcontentcontent
content

Does anyone understand why this happens?</t>
<t tx="EKR.20040610082623.1">Here is what I did:

- Created a file called nowebImportTest.nw containing the code you describe.

- Used Leo's "Import noweb Files" command to import this file.

Leo seemed to do a reasonable job with the Import.
</t>
<t tx="EKR.20040610082855"></t>
<t tx="EKR.20040610082855.1">@nocolor

By: Davide Salomoni - dsalomoni
 4.2a3: traceback loading a recent file   
2004-06-09 08:08  

 I just downloaded the latest cvs code. I launched leo, opened a few files (among them leoPluginsRef.leo) and exited. Then I re-launched leo and selected File-&gt;Recent Files-&gt;leoPluginsRef.leo

The file loaded, and I got the following traceback:

Exception in Tkinter callback
Traceback (most recent call last):
File "/localstore/computer/local/lib/python2.3/lib-tk/Tkinter.py", line 1345, in __call__
return self.func(*args)
File "/localstore/computer/davides/Test/leo/leo/src/leoMenu.py", line 1128, in callback
c.openRecentFile(name)
File "/localstore/computer/davides/Test/leo/leo/src/leoCommands.py", line 676, in openRecentFile
g.doHook("recentfiles2",c=c,v=v,fileName=fileName,closeFlag=closeFlag)
File "/localstore/computer/davides/Test/leo/leo/src/leoGlobals.py", line 1790, in doHook
elif c and c.hookFunction:
AttributeError: Commands instance has no attribute 'hookFunction'

(leo cvs, python 2.3.3, tk 8.3.3, linux)

Davide

----

The fix was to set c = frame.c in openRecentFile after destroying the original commander.
</t>
<t tx="EKR.20040610094819"># Visible externally so plugins may add to the list of directives.

globalDirectiveList = [
    "color", "comment", "encoding", "header", "ignore", "killcolor",
    "language", "lineending", "nocolor", "noheader", "nowrap",
    "pagewidth", "path", "quiet", "root", "silent",
    "tabwidth", "terse", "unit", "verbose", "wrap"]</t>
<t tx="EKR.20040610102329"></t>
<t tx="EKR.20040610123559"></t>
<t tx="EKR.20040610123559.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2612319
By: nobody

When I use 'shift+ctl+g', I get the error below:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 2136, in getTime
    s = time.strftime(format,time.localtime())
NameError: global name 'time' is not defined
exception executing command
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 143, in doCommand
    command()
  File "C:\Program Files\Leo\src\leoCommands.py", line 2111, in insertBodyTime
    s = self.getTime(body=True)
  File "C:\Program Files\Leo\src\leoCommands.py", line 2139, in getTime
    s = time.strftime(default_format,time.gmtime())
NameError: global name 'time' is not defined

I inserted "import time", and while I was at it I improved the error checking.</t>
<t tx="EKR.20040610125924"></t>
<t tx="EKR.20040610125924.1">@nocolor

By: Scott Beardsley - sbeards
 install script broken in leo-4.2-a3   
2004-06-10 12:19  

Two issues with the install script...


</t>
<t tx="EKR.20040610130943">def pasteOutlineRetainingClones (self):
    
    c = self
    
    return c.pasteOutline(reassignIndices=False)</t>
<t tx="EKR.20040610131603">@nocolor

- By default, finishPaste command reassigns all indices in copied nodes.
- Created pasteOutlineRetainingClones.
- Added reassignIndices arg to pasteOutline, getLeoOutline and finishPaste.
- Added &lt;&lt; recreate tnodesDict &gt;&gt; in getLeoOutline.
- Simplified getTnode slightly: the "if t" code is the same for both kinds of reads.</t>
<t tx="EKR.20040610134756">nodeIndices = g.app.nodeIndices

for t in self.c.all_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]</t>
<t tx="EKR.20040610174603"></t>
<t tx="EKR.20040610174603.1">@nocolor

&gt; found a fatal bug in Leo headline handling.

setting breakpoints in OnPasteFromMenu and in idle_head_key,
after a large paste, control is returned to OnPasteFromMenu
before 
  w.event_generate(virtual_event_name("Paste")) 
told it to continue running,
and control is returned to  idle_head_key. told it to continue running,
and it crashes. so something in idle_head_key.

singlestepping in idle_head_key after a large paste,
it gets to here.
  s = v.edit_text().get("1.0","end")
able to singlestep thru,
then crashes here.
  s = toUnicode(s,app.tkEncoding) # 2/25/03
what was that saying about refusing the temptation to guess?

even though not a direct cause as it now appears,
a possible solution is to limit the size of the copy buffer
before the virtual paste in OnPasteFromMenu 

after the virtual paste there is this line,
  if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.

is there only the body or headline widget possible using this function?

is there anyway to determine exactly if this widget is a headline?
I gather the headline widgets don't have Tk names
as many of the other Text and Entry widgets also don't.
it would simplify automation of Leo if all widgets had names.
since they do have arbitrarily assigned Tk numbers as names anyway,
maybe when each headline is created it can be given a name.
then it would simply be a matter of testing if it was a headline widget.

this would also seem to provide a solution to the long standing bug,
where delete and selectall while editing headline
actually deletes and selectall operates on the body text.

in OnPasteFromMenu something like:
...
  w = self.getFocus()
#
  if w._name.startswith('Hl'):   #we have a headline
        g.app.gui.replaceClipboardWith(
                g.app.gui.getTextFromClipboard()[:1024]
        )
#
  w.event_generate(virtual_event_name("Paste"))
...

then again, maybe its a bug in the py2.3 unicode conversion
or in Leo's toUnicode and nothing whatever in Tk.

it still quite boggles my mind how much stuff 
goes on behind the scenes in Leo.

heres another way to run Leo I just tried
yesterday for the first time.

------cut openleo.pys
@path c:\bIn\pys\
@lineending crnl
@
w04609p09:57:19 a pys to open leo and do something.
you need the win32 extensions amn you have to enable 
the script engine. details how on google or on the win32 page.

the sendkeys method can insert any test or control codes
msdn or microsoft.com/scripting

@c
pypath = r'C:\c\py\Python233'
py =  pypath + r'\python.exe -itOO '
leosrc = r'c:\c\leo\leo4CVS233\src'
name = "blank.leo"

WshShell = WScript.CreateObject("WScript.Shell")

#look like it comes up untitled 
# if it cant find an existing leo of that name?

WshShell.Run(py + leosrc + r'\Leo.py ../' + name)
WScript.Sleep(4900) 

wname = "untitled"

WshShell.AppActivate(wname);  WScript.Sleep(2100)
WshShell.SendKeys("%Fe");   WScript.Sleep(1300);  #^Q

---end openleo.pys

I can see using WSH scripts as another way to test apps,
simulating what the user does pressing keys.
maybe I can determine exactly the size of text needed to crash.
and if it matters the content of the text.
so far I've been using copys of nodes to cause the crash. 
maybe there is something besides the size of the node.
sorry if its more questions than answers today.

</t>
<t tx="EKR.20040611081747.2"></t>
<t tx="EKR.20040612093706"># This does not happen in 4.2, only 4.1.  It hardly seems worthwhile messing with the 4.1 code base now.</t>
<t tx="EKR.20040612093706.1">@nocolor

This one has bitten me for the 2nd time now: There are situations, where 
clones are not marked as clones. Finally I found how to reproduce the behavior:

Build the following outline:

Level 1
...Level 2
    ..Clone
    ..Level 3

Now do a CLONE DRAG of 'Clone' to 'Level 3' and shift it to the right.

Your outline now looks like this:

Level 1
...Level 2
    ..Clone
    ..Level 3
        .Clone

Both clones are marked as clone. So far so good.

Now create another top level node 'Another Level 1'

CLONE DRAG the 'Level 3' node to 'Another Level 1', but leave it at top level.

Your outline now looks this way:

Level 1
...Level 2
    ..Clone
    ..Level 3
        .Clone
Another Level 1
Level 3
...Clone

Still everything's ok.

Now clone drag the only 'Level 2' node to 'Another Level 1' and shift it right.
The node is not expanded, so expand it until you see the node 'Clone'. This node is NOT
marked as clone. However, it IS a clone, as you can see, if you write into one of the 'Clone' nodes.

Your outline now looks this way:

Level 1
...Level 2 *
    ..Clone *
    ..Level 3 *
        .Clone *
Another Level 1
...Level 2 *
    ..Clone *
    ..Level 3 *
        .Clone (*)
Level 3 *
...Clone *

In the above hierarchy I have marked all clones with a '*' and the clones erratically not 
being marked as clone marked with a '(*)'.

Now, if you delete the top level 'Level 3' node, the erratically unmarked clone
becomes marked - the error has gone!

HTH
Franz GEIGER</t>
<t tx="EKR.20040612094305"></t>
<t tx="EKR.20040612112111">@nocolor

What I did:
    
- Removed from leoGlobals import true,false
- Replaced true,false with True,False
- Properly import Tkinter as follows:

try: import Tkinter as Tk
except ImportError: Tk = None

- Removed all assignments: Tk = Tkinter
- Converted leading tabs to spaces</t>
<t tx="EKR.20040612113045"></t>
<t tx="EKR.20040612121907"></t>
<t tx="EKR.20040612121907.1"></t>
<t tx="EKR.20040612121907.2"></t>
<t tx="EKR.20040612141359"></t>
<t tx="EKR.20040612152431">@nocolor

- Set removeTrailing to True unless ch is a newline.

This allows Alt-f to work properly.

- Return "break" after the "final" text has been computed if nothing has changed.

This suppresses spurious newlines.

A new idea:  Make sure the text _does_ have a newline at all times.  I'm not sure this will work...

- ALWAYS set the text in select.  This prevents some weird problems with trailling newlines.</t>
<t tx="EKR.20040612213138"></t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1</t>
<t tx="EKR.20040612223431">i += len(tag)
j = line.find(',',i)
if j &gt; i: n = line[i:j]
else:     n = line[i:].strip()
# g.trace(n)
try: n = int(n)
except (TypeError,ValueError): n = None</t>
<t tx="EKR.20040612232221">def goToScriptLineNumber (self,root,script,n):

    c = self
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n)</t>
<t tx="EKR.20040613000310">@nocolor

- The string passed to exec now includes sentinels.

goToLineNumber needs sentinels to work properly.

- es_exception now gets the error line number from the traceback.

- Added new keyword arguments to goToLineNumber.

- Created goToScriptLineNumber, which just calls goToLineNumber.</t>
<t tx="EKR.20040614071102"></t>
<t tx="EKR.20040614071102.1">def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script</t>
<t tx="EKR.20040614072333"># Hitting return in middle of a headline didn't work.</t>
<t tx="EKR.20040614075003">edit_text.delete("1.0","end")
edit_text.insert("end",head)
edit_text.mark_set("insert",index)</t>
<t tx="EKR.20040614151841.1"></t>
<t tx="EKR.20040614151841.2"># all</t>
<t tx="EKR.20040615010747"></t>
<t tx="EKR.20040615010747.1">@nocolor

By: Bernhard Mulder - bwmulder
 RE: Attributes in @thin trees: gotcha   
2004-06-15 00:48  

 In drawUserIcons:
.iconsList = t.unknownAttributes.get("icons")
.# g.trace(iconsList)

.try:
..for dict in iconsList:

Guard the try: with 'if iconsList:', otherwise, you'll get a traceback whenever some attributes are defined, but not "icons".  
</t>
<t tx="EKR.20040615105613"></t>
<t tx="EKR.20040615105613.1">@nocolor

Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=2618355
By: sbeards

I'm having a problem opening a leo file that I last used with 4.1-final. I'm
getting the following traceback from leo on cvs and 4.2a3 when attempting to
open the file:

exceptions opening: [filename].leo
Traceback (most recent call last):
  File "/usr/local/lib/leo/src/leoGlobals.py", line 670, in openWithFileName
    frame.c.fileCommands.open(file,fileName) # closes file.
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 1181, in open
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=true)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 583, in getLeoFile
    self.getVnodes()
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 987, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 924, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 924, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 924, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 924, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 891, in getVnode
    v = self.getExistingVnode(tref)
  File "/usr/local/lib/leo/src/leoFileCommands.py", line 165,
in getExistingVnode
    return t.vnodeList[0]
IndexError: list index out of range

Any ideas?</t>
<t tx="EKR.20040615105613.2"></t>
<t tx="EKR.20040615105613.3">@nocolor
https://sourceforge.net/forum/message.php?msg_id=2618807
By: nobody

From: Rich

I have a script to print headlines that runs in one node, but not another!?!
The script is:

@color

from leoGlobals import top
v = top().currentVnode() 
after = v.nodeAfterTree() 
# Don't do _this_ node
v = v.threadNext()
while v and v != after: 
# Get the header
    h = v.headString()
# Filter
    if (h.find("CR3") != -1):
        print h 
# Next! 
    v = v.threadNext()

@nocolor

and it runs fine (either Ctrl-e or dynabutton's exS) in one node, but in the
other, I get:

Unknown language: using Python comment delimiters
c.target_language:u'c'
delim1,delim2,delim3:None:None:None
exception executing script
  File "&lt;string&gt;", line 1
    from leoGlobals import top
                              ^
SyntaxError: invalid syntax

</t>
<t tx="EKR.20040616102910">@killcolor

As I reported to Scott privately, this 4.1 file was corrupted:

When I run the Check Outline command (in 4.1) Leo reports various "topology mismatches".  This error indicates that one clone has a different topology than another  A node in one clone have a different number of children from the "same" node in another clone!

Obviously Leo has messed up somehow in creating this file.  I have no idea how this happened.  This kind of error is (I think) impossible in 4.2 because in 4.2 Leo represents clones as actual shared data.  There is only one copy of the data so it can't possibly be inconsistent with itself.

I am going to see whether there is some way of having Leo recover from this error automatically in 4.2: it doesn't look easy.  In the meantime, the outline can be fixed as follows:

1. Pick one of the clones called "Latest Code", (maybe the first?) as the "proper" clone.  That is, make _sure_ the proper clone contains all the nodes in either clone.  In particular, check all the nodes that contain the topology mismatch.

2. Delete the other clone.

3. Re-clone the proper clone and drag it where the deleted clone used to be.

I did this assuming the first clone is "proper" and everything now works. In particular, the Check Outline command now is happy and Leo can now read the recreated outline.

The conclusion is that 4.2 appears to read all correct 4.1 files properly.  Again, I'll see if I can get Leo to make sense out of this improper file, but don't count on it.</t>
<t tx="EKR.20040617063225"></t>
<t tx="EKR.20040617063225.1">@killcolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2621892
By: nobody

When I start leo with no parameters, then open one file, then another,  I get
this exception:

  File "/home/ng/mob/lib/leo/leo/src/leoGlobals.py", line 508, in
openWithFileName
    c,frame = app.gui.newLeoCommanderAndFrame(fileName)
  File "/home/ng/mob/lib/leo/leo/src/leoGui.py", line 122, in
newLeoCommanderAndFrame
    frame.finishCreate(c)
  File "/home/ng/mob/lib/leo/leo/src/leoTkinterFrame.py", line 192, in
finishCreate
    c.frame.getFocus()
  File "/home/ng/mob/lib/leo/leo/src/leoTkinterFrame.py", line 1313, in
getFocus
    f = self.top.focus_displayof()
  File "/usr/lib/python2.3/lib-tk/Tkinter.py", line 413, in focus_displayof
    return self._nametowidget(name)
  File "/usr/lib/python2.3/lib-tk/Tkinter.py", line 1015, in nametowidget
    w = w.children[name]
KeyError: '#1077138060#1082735148'

This happens for some files, but not others (the .leo files distributed with
leo).

I am using the CVS version of leo.
</t>
<t tx="EKR.20040617063837"></t>
<t tx="EKR.20040617072908"></t>
<t tx="EKR.20040617072908.2">The ending ?&gt; will not exist in the derived file when multiple newlines exist after the @last directive.
Test body text:
@last ?&gt;\n\n

Test derived file output:
#@+leo-ver=4
#@+node:@file test.txt
#@@last

#@-node:@file test.txt
#@-leo</t>
<t tx="EKR.20040617072908.3">When using @last the last character in a derived file is always a newline, when
using @file or @file-nosent and I think always).

This will only be a problem in special cases when you do not want the derived
file to end in a newline (when generating binary files maybe?).
</t>
<t tx="EKR.20040617074620.2">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2618344
By: sbeards

Another minor issue:

3) leo executable will error out on files with spaces

when attempting to open a leo file that has spaces in the filename (ie leo /tmp/foobar.leo) you'll get the following error in the log pane:

File not found: /tmp/foo

To fix change line 131 in install script:

echo "python ${LEO_PREFIX}/lib/leo/src/leo.py \"\$1\"" &gt; $LEO_RUN_SCRIPT_OUTPUT

(Note: added escaped double quotes around $1)

If you don't want to reinstall just add double-quotes around the $1 in the leo
executable (defaults to /usr/local/bin/leo).

</t>
<t tx="EKR.20040617083707"></t>
<t tx="EKR.20040617103332">@nocolor

Changed getVnode so it checks for v = None after calling getExistingVnode.  Creating the node seems to work in this case: I wouldn't bet my life that it works in all cases.</t>
<t tx="EKR.20040617155244">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2612510
By: sbeards

Yes, number 3 and 4 in the previous post are still problems in 4.2a3.
</t>
<t tx="EKR.20040618071040"></t>
<t tx="EKR.20040618071040.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2623801
By: sbeards

&gt; @last ?&gt;
&gt; @last

Yes this appears to allow multiple newlines.

However, I do believe there is still a bug here. Extra newlines in the body
pane (after the @last) prevent the @last directive from insuring the parameters
were in fact the last text in the derived file.

The fix might just be to eat up extra lines after detecting the @last directive.
Or maybe force @last to be on the last line in the body pane.

Currently @last seems to just fail silently when any extra lines exist.

See below for an illustration.

[ START body contents ]
@first &lt;?php
echo "just a test";
@last ?&gt;

[ END body contents (note: 1+ newlines after the '&gt;') ]

[ START expected derived file ]
&lt;?php
#@+leo-ver=4
#@+node:@file /tmp/foo.php
#@@first
echo "just a test";
#@@last
#@-node:@file /tmp/foo.php
#@-leo
?&gt;
[ END expected derived file ]

[ START actual derived file ]
&lt;?php
#@+leo-ver=4
#@+node:@file /tmp/foo.php
#@@first
echo "just a test";
#@@last
 
#@-node:@file /tmp/foo.php
#@-leo
[ END actual derived file (note: no ending tag and the 1+ newlines shows up
after the #@@last line) ]</t>
<t tx="EKR.20040619122528"></t>
<t tx="EKR.20040620094529">def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))</t>
<t tx="EKR.20040620094529.1">def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()</t>
<t tx="EKR.20040620094529.2">def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    if s and self.outputFile:
        try:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            self.outputFile.write(s)
        except:
            g.es("exception writing:",s)
            g.es_exception(full=True)</t>
<t tx="EKR.20040620094529.4">@

- Added toString to most write methods.</t>
<t tx="EKR.20040621080839"></t>
<t tx="EKR.20040621081709">@killcolor

- Allow indented @all.
    - Changed to g.is_special
    - Changed leoColor.doAtKeyword
    
- Fixed bug in is_special that broke p.isAtAllNode.</t>
<t tx="EKR.20040622060649.1"></t>
<t tx="EKR.20040622083920"></t>
<t tx="EKR.20040622104344"></t>
<t tx="EKR.20040623090054">case_insensitiveLanguages = []</t>
<t tx="EKR.20040623090054.1"></t>
<t tx="EKR.20040623101617"></t>
<t tx="EKR.20040623101617.1">@killcolor

https://sourceforge.net/forum/message.php?msg_id=2631282
By: nobody

traceback causes double print of line number
with redirect script io to log enabled.
there is print s,; g.es(s, ...) in executeScript
in a few places.
from test.leo, executescript on
"Test of better error messages in Execute Script command"

hello
exception executing script
  File "&lt;string&gt;", line 9, in ?
NameError: name 'b' is not defined
--------------------
--------------------
line 9: c = b
line 9: c = b</t>
<t tx="EKR.20040623101617.4"></t>
<t tx="EKR.20040623102728"></t>
<t tx="EKR.20040623102728.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2631522
By: m4rkng

&gt; I thought that is what the code does. 

Thats what I thought too. ;) but it corrupts pickled objects.

This sequence of actions will reveal the problem:
0. Mark some t.leo file using cleo.  Exit leo.
1. Disable cleo, load t.leo. Leo loads it no worries. Do some random edits.
Save the file.  Exit leo.
2. Re-enable cleo, then load t.leo.  You will get exceptions about strings being
treated as objects.  All the markings done in step 0 was "corrupted" in step 1.

The cause is that cleo uses pickled objects (I was lazy ;)and leo (from the
above patch) treats the pickled objects as strings when it failed to import
cleo during the unpickling process, which causes putUnknownAttributes when saving
to pickle the already pickled data twice, hence the corruption.


Cleo can be made not use pickled objects, but I believe the problem is best
solved up a level in leo.

&gt; What changes would you suggest?

I can't find a clean and fast solution;  the vals that failed to unpickle
(ImportErrors) should be tagged so that the putUnknowAttributes knows not to
pickled them twice.

Here is the diff that fixes it.  It is a hack, but atm I can't find a better
solution.  Let me know if you refactored into something more palatable. ;)

Is there a better way to paste py diffs on SF ?

</t>
<t tx="EKR.20040623102728.2">*** leoFileCommands.py.orig     Wed Jun 23 18:43:34 2004
--- leoFileCommands.py  Wed Jun 23 18:43:50 2004

*************** getUnknownAttribute
*** 372,381 ****
          try:
              bin = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
              val2 = pickle.loads(bin)
          except (TypeError,pickle.UnpicklingError,ImportError):
              # The unknownAtrribute was written before 4.2.
              val2 = val             
          return attr,val2
      
--- 372,390 ----
          try:
              bin = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
              val2 = pickle.loads(bin)
+ 
+         # Maybe ImportError should be handled separately
          except (TypeError,pickle.UnpicklingError,ImportError):
              # The unknownAtrribute was written before 4.2.
+             print "Failed to unpickle attribute: %s" % attr
+             if not hasattr(self,"badPickles"):
+                 self.badPickles = []
+ 
+             # storing attr could cause should-be-pickled-when-saving data to
+             # not be pickled. ie: badPickles should be specific
+             self.badPickles.append(val) # hack
              val2 = val
!                         
          return attr,val2

*************** putUnknownAttribute
*** 1661,1667 ****
--- 1670,1686 ----
              
          attrs = []
          for key in attrDict.keys():
+             print "&gt; put attribute: %s" % key
              val = attrDict[key]
+             # skip badPickles
+             # XXX the changes of a picklable val being the same as as an unpickle-able
+             #   val should be quite slim. ;)
+             if hasattr(self, 'badPickles') and (val in self.badPickles):
+                 print "    Not pickling non-unpicklable attribute: %s" % key
+                 attr = ' %s="%s"' % (key,val)  # val is already hex'ed and escaped
+                 attrs.append(attr)
+                 continue
+                 
              try:
                  s = pickle.dumps(val,bin=True)
              except pickle.PicklingError:</t>
<t tx="EKR.20040624081759"></t>
<t tx="EKR.20040624081759.1">@killcolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2632977
By: nobody

Traceback (most recent call last):
  File "J:\mark\leo-4.2a4\src\leoCommands.py", line 144, in doCommand
    command()
  File "J:\mark\leo-4.2a4\src\leoFileCommands.py", line 2151,
in writeMissingAtFileNodes
    changedFiles = at.writeMissing(v)
  File "J:\mark\leo-4.2a4\src\leoAtFile.py", line 813, in writeMissing
    if at.outputFile:
AttributeError: atFile instance has no attribute 'outputFile'
</t>
<t tx="EKR.20040624091333"></t>
<t tx="EKR.20040625085548">@killcolor

This isn't real good.  The problem is that clones disappear during reading.

I personally would like to outlaw them, but even that takes work...</t>
<t tx="EKR.20040625090549"></t>
<t tx="EKR.20040625090549.1"></t>
<t tx="EKR.20040625092523"></t>
<t tx="EKR.20040625093305">@killcolor

This only happened after previous write error.

The fix was to init self.errors in openWriteFile.

The whole atFile logic is pretty gruesome.  It's got to be cleaned up.</t>
<t tx="EKR.20040625095103.1">@killcolor

There is a small hole in the format of derived files.  Leo presently assumes that comment delimiters do not change within any particular derived file.

This assumption is not necessarily true in files like leoProjects.txt.

What I did:

- putDirective and readDirective now check for @langauge and @comment, and change comment delims appropriately.

This is slightly dubious: after all, an @langauge directive in the middle of most derived files will cause havoc.  However, one could say that this is the users problem :-)

BTW, this doesn't really solve all problems in @all trees: Leo can still get mightily confused about comment delims if the user doesn't put proper @language directives in @all trees.
</t>
<t tx="EKR.20040625103148">self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")</t>
<t tx="EKR.20040625103148.1">self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")</t>
<t tx="EKR.20040625104908"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="EKR.20040625104908.1">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="EKR.20040626110541"></t>
<t tx="EKR.20040626110728">@killcolor

Leo will write only t.unknownAttributes to the .leo file when writing the &lt;v&gt; element corresponding to the root of an @thin tree.  Leo will do this by writing a new xml attribute, say descendentTnodeUnknownAttributes, in &lt;v&gt; element.

The reason that Leo will only write t.unknownAttributes and not v.unknownAttributes is that only tnodes have gnx's in thin derived files.  In effect, vnodes are anonymous.  We could attempt to get around this by identifying vnodes by their corresponding tnodes, but that's not a general solution and it is, in effect, equivalent to writing only t.unknownAttributes.  This being so, it seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using unknownAttributes is concerned.  As I've stated in the past, this won't do if, for example, a plugin is trying create an arbitrary directed graph between vnodes.  In that case, the plugin should confine itself to @file trees, or just vnodes in .leo files, for that matter.

7/1/04:

- Leo now writes "marks" and "expanded" attributes in the root &lt;v&gt; element for @thin trees.

- VERY IMPORTANT.  Leo now writes entire tree of @ignored @thin nodes.  This fixes a major bug.</t>
<t tx="EKR.20040627100424">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="EKR.20040627113418">def putDescendentUnknownAttributes (self,p):

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                tnodes.append((p,t),)    
    # g.trace(tnodes)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodes:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            for key in d.keys():
                try: pickle.dumps(d[key],bin=True)
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict"
        for key in resultDict:
            print ; print key,resultDict[key]
        
    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            s = pickle.dumps(resultDict,bin=True)
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            self.put(field)
        except pickle.PicklingError:
            g.trace("can't happen",color="red")</t>
<t tx="EKR.20040627114602">def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        return None</t>
<t tx="EKR.20040627120120">for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
    # g.trace("done")</t>
<t tx="EKR.20040628080251">1) Will not run when using non-borne shells
Install script should probably contain an @first directive.

The first three lines are currently:
#@+leo-ver=4-thin
#@+node:EKR.20040519082027.33:@file-thin ../install
#!/bin/sh

In shell scripts however the '#!/bin/sh' should *always* be on the first line. Otherwise you get messages in csh like:

%./install
LEO_PREFIX=/usr/local: Command not found.
LEO_RUN_SCRIPT_SOURCE=./scripts/install/leo-script.txt: Command not found.
LEO_PREFIX: Undefined variable.
</t>
<t tx="EKR.20040628080251.1">2) bin dir is not created (for this I modified step 2 a tad)

################################
# Step 2
# Make the directory structure
################################
if [ ! -d $LEO_LIB_DIR ]; then
...echo ""
...echo Making directory structure $LEO_LIB_DIR

...RESULTS=`mkdir -p -m755 $LEO_LIB_DIR 2&gt;&amp;1`
...if [ $? -ne 0 ]; then
    ..echo Failure making directory $LEO_LIB_DIR!
    ..exit 0;
...fi
fi

if [ ! -d $LEO_PREFIX/bin ]; then
...echo ""
...echo Making directory structure $LEO_PREFIX/bin
...RESULTS=`mkdir -p -m755 $LEO_PREFIX/bin 2&gt;&amp;1`
...if [ $? -ne 0 ]; then
    ..echo Failure making directory $LEO_PREFIX/bin!
    ..exit 0;
...fi
fi
</t>
<t tx="EKR.20040628080251.2">@ The problem was setting endSentinelComment to None instead of "" in readDirective.

The code is pretty fragile; it should handle either None or "", but in fact it requires "".</t>
<t tx="EKR.20040628084530"></t>
<t tx="ekr.20031218072017.367">@nocolor

- Add a new entries in &lt;&lt; define global data structures &gt;&gt; app

- Add a new Tk.Radiobutton in &lt;&lt;create the Target Language frame&gt;&gt;

- Add an entry to the languages list in &lt;&lt;configure language-specific settings&gt;&gt;

- Add a list of the keywords of the language to &lt;&lt; define colorizer keywords &gt;&gt;

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the &lt;preferences&gt; tag (near the top) contains an entry like this:

&lt;preferences allow_rich_text="0" defaultTargetLanguage="Python"&gt;
&lt;/preferences&gt;

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color</t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "_\\_ _(_ _)_", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20031218072017.369"># Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex"),
    ("Pascal","pascal")]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")</t>
<t tx="ekr.20031218072017.370"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","c","csharp","css","cweb","elisp","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "&lt;&lt;"
    self.rb = "&gt;&gt;"
else:
    self.lb = g.choose(self.language == "cweb","@&lt;","&lt;&lt;")
    self.rb = g.choose(self.language == "cweb","@&gt;","&gt;&gt;")</t>
<t tx="ekr.20031218072017.371">@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords</t>
<t tx="ekr.20031218072017.372">actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]</t>
<t tx="ekr.20031218072017.373">c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]</t>
<t tx="ekr.20031218072017.374"># EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]</t>
<t tx="ekr.20031218072017.375"># No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "&lt;%","%&gt;" ]</t>
<t tx="ekr.20031218072017.376">java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]</t>
<t tx="ekr.20031218072017.377">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]</t>
<t tx="ekr.20031218072017.378">pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]</t>
<t tx="ekr.20031218072017.379">perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 &amp; FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 &amp; f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]</t>
<t tx="ekr.20031218072017.380">php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="ekr.20031218072017.381">python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]</t>
<t tx="ekr.20031218072017.382">rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]</t>
<t tx="ekr.20031218072017.383">tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]</t>
<t tx="ekr.20031218072017.744"></t>
<t tx="ekr.20031218072017.836">def updateEditMenu (self):

    c = self.c ; frame = c.frame ; gui = g.app.gui
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        &lt;&lt; enable cut/paste &gt;&gt;
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        enable(menu,"Extract Section",c.canExtractSection())
        enable(menu,"Extract Names",c.canExtractSectionNames())
        enable(menu,"Extract",c.canExtract())
        enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()</t>
<t tx="ekr.20031218072017.838">def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("&lt;Button-1&gt;", frame.OnBodyClick)
    t.bind("&lt;Button-3&gt;", frame.OnBodyRClick)
    t.bind("&lt;Double-Button-1&gt;", frame.OnBodyDoubleClick)
    t.bind("&lt;Key&gt;", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)</t>
<t tx="ekr.20031218072017.839">self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &amp;U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &amp;R reserved for Redo
    ("-",None,None),
    ("Cu&amp;t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&amp;y","Ctrl+C",f.OnCopyFromMenu),
    ("&amp;Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&amp;Delete",None,c.delete),
    ("Select &amp;All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.841">def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""

    frame = self ; c = frame.c ; v = c.currentVnode()
    
    # This is probably being subverted by Tk.
    if g.app.gui.win32clipboard:
        data = frame.body.getSelectedText()
        if data:
            g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
    
    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Cut"))
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)




</t>
<t tx="ekr.20031218072017.842">def OnCopy (self,event=None):
    
    frame = self

    if g.app.gui.win32clipboard:
        data = frame.body.getSelectedText()
        if data:
            g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
def OnCopyFromMenu (self):

    frame = self
    w = frame.getFocus()
    w.event_generate(g.virtual_event_name("Copy"))

</t>
<t tx="ekr.20031218072017.843">def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
</t>
<t tx="ekr.20031218072017.853">@nocolor

readEndNode uses the existing tempBodyString attribute to determine if the body text has changed.  If so, we mark the tnode dirty.  The code in 

top_df.read.&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;

propagates the dirty marks to all ancestor @file nodes.  This can't be done in readEndNode because no positions are available at that point.</t>
<t tx="ekr.20031218072017.859"># All appears to work well at present.
# Besides, there have been no bug reports lately.</t>
<t tx="ekr.20031218072017.862"></t>
<t tx="ekr.20031218072017.893">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="ekr.20031218072017.915"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="ekr.20031218072017.928">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20031218072017.930">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="ekr.20031218072017.931">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="ekr.20031218072017.932">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="ekr.20031218072017.933">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="ekr.20031218072017.934">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="ekr.20031218072017.935">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20031218072017.936">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="ekr.20031218072017.937">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    # if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p</t>
<t tx="ekr.20031218072017.938">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="ekr.20031218072017.939">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="ekr.20031218072017.940">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="ekr.20031218072017.941">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="ekr.20031218072017.1000">def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        box_id = canvas.create_image(x,y+self.lineyoffset,image=image)
    
        id1 = canvas.tag_bind(box_id, "&lt;1&gt;", p.OnBoxClick)
        id2 = canvas.tag_bind(box_id, "&lt;Double-1&gt;", lambda x2: None)

        self.tagBindings.append((box_id,id1,"&lt;1&gt;"),)
        self.tagBindings.append((box_id,id2,"&lt;Double-1&gt;"),)
        
        return box_id</t>
<t tx="ekr.20031218072017.1002">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    tree = self ; v = p.v # Make sure the bindings refer to the _present_ position.

    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=tree,p=p,v=v,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image,tag="iconBox")
        self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.
    
        id1 = self.canvas.tag_bind(id,"&lt;1&gt;",p.OnIconClick)
        id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",p.OnIconDoubleClick)
        id3 = self.canvas.tag_bind(id,"&lt;3&gt;",p.OnIconRightClick)
        
        # Remember the bindings so deleteBindings can delete them.
        self.tagBindings.append((id,id1,"&lt;1&gt;"),)
        self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
        self.tagBindings.append((id,id3,"&lt;3&gt;"),)
    
    return 0,icon_width # dummy icon height,width</t>
<t tx="ekr.20031218072017.1004">def drawNode(self,p,x,y):

    """Draw horizontal line from vertical line to icon"""
    
    tree = self ; v = p.v
    
    data = g.doHook("draw-outline-node",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data
    
    # g.trace(p)
    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
        
    self.canvas.create_line(x,y+7+self.lineyoffset,
        x+box_width,y+7+self.lineyoffset,
        tag="lines",fill="gray50") # stipple="gray25")

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20031218072017.1005">def drawText(self,p,x,y,box_id=None):
    
    """draw text for v at nominal coordinates x,y."""

    tree = self ; c = self.c ; v = p.v
    h = self.line_height
    x += text_indent
    
    data = g.doHook("draw-outline-text-box",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data

    self.lastText = t = Tk.Text(self.canvas,
        font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

    # New in 4.2: entries are pairs (p,t) indexed by v.
    # Remember which text widget belongs to v.
    d = self.edit_text_dict
    val = d.get(v,[])
    val.append((p,t),)
    d[v] = val
    # g.trace("entry",d[p.v])

    # Remember the widget so deleteBindings can delete it.
    self.widgets.append(t) # Fixes a _huge_ memory leak.

    t.insert("end", v.headString())
    &lt;&lt; configure the text depending on state &gt;&gt;

    if 1: # use bind here, else use bind_tag in drawTopTree.
        # Use vnode or postion callbacks.
        id1 = t.bind("&lt;1&gt;",p.OnHeadlineClick)
        id2 = t.bind("&lt;3&gt;",p.OnHeadlineRightClick)
        id3 = t.bind("&lt;Key&gt;", p.OnHeadlineKey)
        id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
            # 10/16/02: Stamp out the erroneous control-t binding.
        # Remember the bindings so deleteBindings can delete them.
        self.bindings.append((t,id1,"&lt;1&gt;"),)
        self.bindings.append((t,id2,"&lt;3&gt;"),)
        self.bindings.append((t,id3,"&lt;Key&gt;"),)
        self.bindings.append((t,id4,"&lt;Control-t&gt;"),)
    
    if 0: # I like underlining only when the cursor is outside the text widget.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
        
    id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t,tag="textBox")
    self.canvas.tag_lower(id)
    
    # This doesn't work: must call update_idletasks first, and that's hard here.
    # g.trace(t,t.winfo_height(),t.winfo_width())
    
    return self.line_height</t>
<t tx="ekr.20031218072017.1006">if p and p == c.currentPosition():
    if p == self.editPosition():
        self.setNormalLabelState(p)
    else:
        self.setDisabledLabelState(p) # selected, disabled
else:
    self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20031218072017.1008">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; v = p.v
    yfirst = ylast = y
    if level==0: yfirst += 10
    w = 0
    
    # We must make copies for drawText and drawBox and drawIcon,
    # So making copies here actually reduces the total number of copies.
    ### This will change for incremental redraw.
    p = p.copy()
    
    data = g.doHook("draw-sub-outline",tree=tree,p=p,v=v,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        h,w = self.drawNode(p,x,y)
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
            x += w2 ; w += w2
        if hoistFlag: break
        else:         p = p.next()
    &lt;&lt; draw vertical line &gt;&gt;
    return y,w</t>
<t tx="ekr.20031218072017.1009">id = self.canvas.create_line(
    x, yfirst-hline_y,
    x, ylast+hline_y-h,
    fill="gray50", # stipple="gray50"
    tag="lines")

# self.canvas.tag_lower(id)</t>
<t tx="ekr.20031218072017.1010">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20031218072017.1011"></t>
<t tx="ekr.20031218072017.1012"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    # g.trace(self.updateCount,self.redrawScheduled)
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20031218072017.1013"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
    
    # g.trace(self.redrawScheduled)
    # import traceback ; traceback.print_stack()

    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20031218072017.1014"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # g.trace()
    
    # Bug fix: 4/24/04: cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.
    self.disableRedraw = True
    self.canvas.update_idletasks()
    self.disableRedraw = False
        
    # Now do the actual redraw.
    self.idle_redraw(scroll=scroll)</t>
<t tx="ekr.20031218072017.1015">def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    &lt;&lt; return if disabled, or quitting or dragging &gt;&gt;

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=self.c):
        self.allocatedNodes = 0
        &lt;&lt; Erase and redraw the entire tree &gt;&gt;
        if self.trace:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
    g.doHook("after-redraw-outline",c=self.c)

    self.canvas['cursor'] = oldcursor
    
    # g.collectGarbage()
    g.printGc()
    # import gc ; print len(gc.get_referents(frame))
    # g.printGcRefs(verbose=False)
    # g.trace("positions",g.app.positions)
</t>
<t tx="ekr.20031218072017.1016">def idle_second_redraw (self):
    
    c = self.c
    
    g.trace()
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    self.deleteBindings()
    self.canvas.delete("all")
    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes</t>
<t tx="ekr.20031218072017.1017">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas

    # Miscellaneous info.
    self.iconimages = {} # Image cache set by getIconImage().
    self.active = False # True if tree is active
    self._editPosition = None # returned by leoTree.editPosition()
    self.lineyoffset = 0 # y offset for this headline.
    self.disableRedraw = False # True: reschedule a redraw for later.
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    # Set self.font and self.fontName.
    self.setFontFromConfig()
    
    # Recycling bindings.
    self.bindings = [] # List of bindings to be unbound when redrawing.
    self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
    self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
    self.widgets = [] # Widgets that must be destroyed when redrawing.
    
    # Drag and drop
    self.drag_p = None
    self.controlDrag = False # True: control was down when drag started.
    self.drag_id = None # To reset bindings after drag
    
    # 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
    #                     behavior better on Linux
    # Context menu
    self.popupMenu = None
    
    # Incremental redraws:
    self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
    self.trace = False # True enabling of various traces.
    self.prevMoveToFrac = None
    self.visibleArea = None
    self.expandedVisibleArea = None
    
    self.allocatedNodes = 0 # A crucial statistic.
        # Incremental drawing allocates visible nodes at most twice.
        # Non-incremetal drawing allocates all visible nodes once.
        
    if self.allocateOnlyVisibleNodes:
        self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)
    
    if not leoTkinterTree.callbacksInjected: # Class var.
        leoTkinterTree.callbacksInjected = True
        self.injectCallbacks()</t>
<t tx="ekr.20031218072017.1018">def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that v is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition() # 4/8/04.
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
    except:
        g.es_exception()</t>
<t tx="ekr.20031218072017.1019"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=True):

    if not p: return
    
    &lt;&lt; define vars and stop editing &gt;&gt;
    
    # g.trace(p)
    # g.printGc()

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20031218072017.1020">c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)</t>
<t tx="ekr.20031218072017.1021"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    # g.trace("different node")
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20031218072017.1022">frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
body.delete("1.0","end")
body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")</t>
<t tx="ekr.20031218072017.1023">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p)
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20031218072017.1024"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20031218072017.1025">self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20031218072017.1131"></t>
<t tx="ekr.20031218072017.1132">@nocolor

This works in the log and body panes, and not in the outline pane.

proc mscroll {bindtag} {
      bind $bindtag &lt;Button-5&gt; [list %W yview scroll 5 units]
      bind $bindtag &lt;Button-4&gt; [list %W yview scroll -5 units]
      bind $bindtag &lt;Shift-Button-5&gt; [list %W yview scroll 1 units]
      bind $bindtag &lt;Shift-Button-4&gt; [list %W yview scroll -1 units]
      bind $bindtag &lt;Control-Button-5&gt; [list %W yview scroll 1 pages]
      bind $bindtag &lt;Control-Button-4&gt; [list %W yview scroll -1 pages]

from Tkinter import *

def roll(event):
    print event.delta

frame = Frame(width=200, height=200)
frame.pack()
frame.focus_set() # wheel events goes to focussed window
frame.bind("&lt;MouseWheel&gt;", roll)</t>
<t tx="ekr.20031218072017.1135"></t>
<t tx="ekr.20031218072017.1136"></t>
<t tx="ekr.20031218072017.1137">@nocolor
Here is the above code in a function, with definitions for missing functions min/max and with missing function lset replaced with calls to scan. The code has also been modified to correctly handle more than a screenful of text. This code still lacks the feature found in the default tkTextUpDownLine where the original column is maintained across repeated operations even though some lines passed through don't have enough columns -- Brian Theado:
@color
@language tcltk

 proc min args {lindex [lsort -real $args] 0}
 proc max args {lindex [lsort -real $args] end}
 
 proc moveUpDown {textWidget upOrDown} {
     # Make the insertion cursor visible so bbox doesn't return empty list
     $textWidget see insert

     # Find the coordinates of the cursor and set the new height
     # manually. Note: errors rounding off, since
     # coordinates don't match character positions exactly.
     scan [$textWidget index insert] {%d.%d} lines char
     scan [$textWidget bbox [$textWidget index insert]] {%d %d %d %d} x y textWidth textHeight
     scan [$textWidget bbox @[winfo width $textWidget],[winfo height $textWidget]] {%*d %d %*d %*d} maxy
     # When updating position, make sure y is within text boundaries
     switch -- $upOrDown {
       "up" {
           if {$y &lt;= $textHeight} {
               $textWidget yview scroll -1 units
           } else {
               set y [max [expr $y-$textHeight] 0]
           }
       }
       "down" {
           if {$y &gt;= $maxy} {
                $textWidget yview scroll 1 units
           } else {
                set y [min [expr $y+$textHeight] $maxy]
           }
       }
     }
     scan [$textWidget bbox [$textWidget index @$x,$y]] {%d %d %d %*d} newx newy width

     # Test on which side of the character
     # we should position the cursor
     if {$x&gt;[expr $newx+$width/2]} {
       set x [expr $newx+$width+1]
     }
     return [$textWidget index @$x,$y]
 }

 # Replace the default Text widget bindings to try it out
 bind Text &lt;Up&gt; {
    tkTextSetCursor %W [moveUpDown %W up]
 }
 bind Text &lt;Down&gt; {
    tkTextSetCursor %W [moveUpDown %W down]
 }</t>
<t tx="ekr.20031218072017.1138">@nocolor

&gt;Drat. There is some interaction between the new moveUpDown code and previous bindings... 

Note the code at http://wiki.tcl.tk/3082 is passing the result of moveUpDown to the function tkTextSetCursor, which both moves the insertion cursor and removes the selection (see lib/tk8.3/text.tcl in the Tcl/Tk distribution for the definition of this function). I notice in the leo code just moves the insertion cursor. 

Also, I just realized that Shift-Up and Shift-Down should probably rebound to use the new up/down code so stroking the selection is consistent with moving up and down. I updated the above referenced web page with this change. 

In Python the Shift-Up and Shift-Down is probably harder to incorporate in Python because it uses tkTextKeySelect which does more than tkTextSetCursor (have a look at text.tcl). I guess either more transliteration of Tcl ("greek") would be needed or maybe the tkTextKeySelect can be called from Python. 

Brian Theado </t>
<t tx="ekr.20031218072017.1139">@nocolor

https://sourceforge.net/forum/message.php?msg_id=1796317
By: nobody

I am a newbie to Leo, and not a programmer.
I intend to use it to write plain text, not code. I believe Leo is an ideal
writer's tool as well.

But there is one behaviour of the TkText widget that I find hard to swallow:
not to be able to move through a paragraph of text with the cursor keys.

To quote from the Leo documentation: 
"Line movement is by text lines terminated by hard returns (newlines), not by
displayed lines; if a text line is long and wraps across more than one display
line, then the Up and Down movement will skip the extra wrapped display lines."

This is probably fine for programming where a code line is usually shorter than
a screen line and so all lines are terminated by hard returns. But for plain
text in ordinary writing, most paragraphs are longer than a screen line. So
I am forced to use the mouse for every movement in the text. Unless I want to
go back word-by-word through the whole paragraph. Not very effective for writers
who mostly prefer the keyboard over the mouse.

If this cannot be changed, I would like to see MORE's 'hoist' command implemented:
hoisting the body pane text to a separate, preferrably full screen editor window
with a more navigable editor.
Actually I would like to see a 'hoist' command anyway. Working on my text on
the full screen is just nicer. But being able to bring the body pane size up
to full screen height with one command would be enough (if I could use cursor
keys for movement across screen lines...).

Ulrich
</t>
<t tx="ekr.20031218072017.1140">1 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
2 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
3 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk













4 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
5 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
6 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk</t>
<t tx="ekr.20031218072017.1141">def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if upOrDown == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2:
        x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    # g.trace("entry:  %s.%s" % (lines,char))
    # g.trace("result:",result)
    # g.trace("insert:",body.index("insert"))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20031218072017.1147">def flattenOutline (self,fileName):

    c = self.c ; nl = self.output_newline
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    try:
        # 10/14/02: support for output_newline setting.
        mode = g.app.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        file = open(fileName,mode)
        
        for p in p.self_and_subtree_iter():
            head = p.moreHead(firstLevel)
            head = g.toEncodedString(head,self.encoding,reportErrors=True)
            file.write(head + nl)
            body = p.moreBody() # Inserts escapes.
            if len(body) &gt; 0:
                body = g.toEncodedString(body,self.encoding,reportErrors=True)
                file.write(body + nl)
        file.close()
    except:
        g.es("exception while flattening outline")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.1149">try:
    mode = g.app.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    file = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    file.write(s)
    file.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()</t>
<t tx="ekr.20031218072017.1193">def deleteOutline (self,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; p = c.currentPosition()
    if not p: return
    # If vBack is NULL we are at the top level,
    # the next node should be v.next(), _not_ v.visNext();
    if p.hasVisBack(): newNode = p.visBack()
    else:              newNode = p.next()
    if not newNode: return

    c.endEditing() # Make sure we capture the headline for Undo.
    c.beginUpdate()
    if 1: # update...
        p.setAllAncestorAtFileNodesDirty()
        c.undoer.setUndoParams(op_name,p,select=newNode)
        p.doDelete(newNode)
        c.setChanged(True)
    c.endUpdate()
    c.validateOutline()</t>
<t tx="ekr.20031218072017.1260"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set dict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return dict</t>
<t tx="ekr.20031218072017.1261">j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i</t>
<t tx="ekr.20031218072017.1262">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1319">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
</t>
<t tx="ekr.20031218072017.1320">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20031218072017.1322"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20031218072017.1325"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1329"># Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)</t>
<t tx="ekr.20031218072017.1330">def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char
    
    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)</t>
<t tx="ekr.20031218072017.1331"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20031218072017.1332">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others</t>
<t tx="ekr.20031218072017.1333">def onHeadChanged (self,p):
    
    """Handle a change to headline text."""
    
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)

</t>
<t tx="ekr.20031218072017.1334">def OnHeadlineKey (self,p,event):
    
    """Handle a key event in a headline."""

    ch = event.char
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)


</t>
<t tx="ekr.20031218072017.1335">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; v = p.v

    if not p or not p.edit_text() or p != c.currentPosition():
        return "break"
        
    edit_text = p.edit_text()
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update v and all nodes joined to v &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20031218072017.1336">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) &gt; 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20031218072017.1337">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20031218072017.1338">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    if not p.isDirty():
        p.setDirty()
    # Update v.
    v.initHeadString(s)
    edit_text.delete("1.0","end")
    edit_text.insert("end",s)
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20031218072017.1339"># Reconfigure v's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))</t>
<t tx="ekr.20031218072017.1340">if done:
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # Update v immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20031218072017.1341">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.</t>
<t tx="ekr.20031218072017.1342">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	&lt;&lt; Set ivars &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="ekr.20031218072017.1343">self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app().config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="ekr.20031218072017.1344"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) &gt; 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
</t>
<t tx="ekr.20031218072017.1345"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="ekr.20031218072017.1346">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e</t>
<t tx="ekr.20031218072017.1347"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")</t>
<t tx="ekr.20031218072017.1348">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
</t>
<t tx="ekr.20031218072017.1349"># We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			&lt;&lt; handle absolute path &gt;&gt;
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="ekr.20031218072017.1350">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)</t>
<t tx="ekr.20031218072017.1351"># path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
</t>
<t tx="ekr.20031218072017.1352">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=True)
	if w and w &gt; 0:
		self.page_width = w</t>
<t tx="ekr.20031218072017.1353">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=True)
	if w and w != 0:
		self.tab_width = w

</t>
<t tx="ekr.20031218072017.1354"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""</t>
<t tx="ekr.20031218072017.1355"># Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""</t>
<t tx="ekr.20031218072017.1356"># Called by __init__

def init_ivars(self):

    c = self.c
    &lt;&lt; init tangle ivars &gt;&gt;
    &lt;&lt; init untangle ivars &gt;&gt;
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    &lt;&lt; init directive ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1357"># Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "&lt;unknown file name&gt;"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline()</t>
<t tx="ekr.20031218072017.1358">@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.</t>
<t tx="ekr.20031218072017.1359">if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = g.app.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="ekr.20031218072017.1360">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        &lt;&lt; Collect @first attributes &gt;&gt;
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        dict = g.get_directives_dict(s)
        # g.trace("dict:",dict,p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for print modes directives &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @root &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        old.update(dict)
    &lt;&lt; Set self.tangle_directory &gt;&gt;</t>
<t tx="ekr.20031218072017.1361">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

</t>
<t tx="ekr.20031218072017.1362">if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif dict.has_key("comment"):

    i = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif dict.has_key("language"):

    i = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="ekr.20031218072017.1363">if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20031218072017.1364">if not old.has_key("lineending") and dict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,dict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20031218072017.1365">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if dict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
</t>
<t tx="ekr.20031218072017.1366">if require_path_flag and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    &lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
    if len(dir) &gt; 0:
        base = g.getBaseDirectory() # May return "".
        if dir and len(dir) &gt; 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir):
                &lt;&lt; handle absolute @path &gt;&gt;
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + dir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20031218072017.1367">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

dir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    dir = g.os_path_join(g.app.loadDir,dir)

# g.trace("dir: " + dir)</t>
<t tx="ekr.20031218072017.1368">if g.os_path_exists(dir):
    self.tangle_directory = dir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(dir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + dir)
            if base and len(base) &gt; 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) &gt; 0:
                g.es("relative path in @path directive: " + relative_path)</t>
<t tx="ekr.20031218072017.1369">if not old.has_key("pagewidth") and dict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict,issue_error_flag)
    if w and w &gt; 0:
        self.page_width = w</t>
<t tx="ekr.20031218072017.1370">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and dict.has_key("root"):

    i = dict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)</t>
<t tx="ekr.20031218072017.1371">if not old.has_key("tabwidth") and dict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20031218072017.1372">if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif dict.has_key("header") and dict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif dict.has_key("header"):
    self.use_header_flag = True

elif dict.has_key("noheader"):
    self.use_header_flag = False
</t>
<t tx="ekr.20031218072017.1373">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) &gt; 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory() # May return "".

    for dir2, kind in table:
        if dir2 and len(dir2) &gt; 0:
            # print "base,dir:",base,dir
            dir = g.os_path_join(base,dir2)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                &lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="ekr.20031218072017.1374">if g.os_path_exists(dir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = dir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(dir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + dir)
        if base and len(base) &gt; 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) &gt; 0:
            g.es(kind + " directory: " + dir2)
</t>
<t tx="ekr.20031218072017.1375"># Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; set w and break on @tabwidth &gt;&gt;

    c.frame.setTabWidth(w)</t>
<t tx="ekr.20031218072017.1376">if dict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break</t>
<t tx="ekr.20031218072017.1377">def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    language = c.target_language
    self.language = language # 2/2/03
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment or @language &gt;&gt;
        &lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;

    return self.language # For use by external routines.</t>
<t tx="ekr.20031218072017.1378"># 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
    k = dict["comment"]
    self.comment_string = s[k:]

if dict.has_key("language"):
    i = dict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language # 2/2/03

if dict.has_key("comment") or dict.has_key("language"):
    break</t>
<t tx="ekr.20031218072017.1379">if dict.has_key("root") and not self.rootMode:

    k = dict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = g.app.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
</t>
<t tx="ekr.20031218072017.1380"></t>
<t tx="ekr.20031218072017.1381"></t>
<t tx="ekr.20031218072017.1382"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
</t>
<t tx="ekr.20031218072017.1383">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]</t>
<t tx="ekr.20031218072017.1384">def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,</t>
<t tx="ekr.20031218072017.1385">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()</t>
<t tx="ekr.20031218072017.1386">def getOutputNewline (lineending = None):
    
    """Convert the name of a line ending to the line ending itself.
    Use the output_newline configuration option if no lineending is given.
    """
    
    if lineending:
        s = lineending
    else:
        s = app.config.output_newline

    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s</t>
<t tx="ekr.20031218072017.1387">def scanAtEncodingDirective(s,dict):
    
    """Scan the @encoding directive at s[dict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = dict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None</t>
<t tx="ekr.20031218072017.1388">def scanAtLineendingDirective(s,dict):
    
    """Scan the @lineending directive at s[dict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = dict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None</t>
<t tx="ekr.20031218072017.1389">def scanAtPagewidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[dict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val &gt; 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
</t>
<t tx="ekr.20031218072017.1390">def scanAtTabwidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[dict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

</t>
<t tx="ekr.20031218072017.1391">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20031218072017.1392">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.</t>
<t tx="ekr.20031218072017.1393"># @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20031218072017.1394">if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
</t>
<t tx="ekr.20031218072017.1395">if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
</t>
<t tx="ekr.20031218072017.1396">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20031218072017.1397">if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20031218072017.1398">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20031218072017.1399">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20031218072017.1400">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20031218072017.1401">@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8</t>
<t tx="ekr.20031218072017.1402">line 1
line 2
last line (no newline)</t>
<t tx="ekr.20031218072017.1403">node 1 line 1
node 1 line 2
node 1 line 3 (newline)
</t>
<t tx="ekr.20031218072017.1404">node 2 line 1
node 2 line 2
node 2 line 3 (no newline)</t>
<t tx="ekr.20031218072017.1405">line 1
line 2
last line (no newline)</t>
<t tx="ekr.20031218072017.1406">@root c:\prog\test\tangleTest.txt

line 1 
line 2
&lt;&lt; ref &gt;&gt;
line 3</t>
<t tx="ekr.20031218072017.1407">&lt;&lt; ref &gt;&gt;=
ref line 1
ref line 2</t>
<t tx="ekr.20031218072017.1416">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.copies = 0 # Number of calls to position.copy
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.disableSave = False
    self.globalWindows = []
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.use_gnx = True # True: generate gnx's instead of tnode indices.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.findFrame = None
    self.pythonFrame = None
    
    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="ekr.20031218072017.1417">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
</t>
<t tx="ekr.20031218072017.1473"># All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    if g.app.quitting: return
    elif self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        &lt;&lt; put newline to log control &gt;&gt;
    else:
        &lt;&lt; put newline to logWaiting and print newline &gt;&gt;
        
def forceLogUpdate (self):
    if sys.platform != "darwin": # Does not work on darwin.
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        #self.frame.outerFrame.update_idletasks() # 4/23/04
        #self.frame.top.update_idletasks()
        self.frame.tree.disableRedraw = False</t>
<t tx="ekr.20031218072017.1493"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using v's body text &gt;&gt;
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            &lt;&lt; print mismatch trace &gt;&gt;
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)</t>
<t tx="ekr.20031218072017.1494"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading &gt; 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading &gt; 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))</t>
<t tx="ekr.20031218072017.1495"># Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result</t>
<t tx="ekr.20031218072017.1496">textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result</t>
<t tx="ekr.20031218072017.1497">print "undo mismatch"
print "expected:",result
print "actual  :",textResult</t>
<t tx="ekr.20031218072017.1548"></t>
<t tx="ekr.20031218072017.1549">def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()</t>
<t tx="ekr.20031218072017.1550">def copyOutline(self):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)</t>
<t tx="ekr.20031218072017.1551"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; current = c.currentPosition()
    
    s = g.app.gui.getTextFromClipboard()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)

    if isLeo:
        p = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        p = c.importCommands.convertMoreStringToOutlineAfter(s,current)
        
    if p:
        c.endEditing()
        c.beginUpdate()
        if 1: # inside update...
            c.validateOutline()
            c.selectVnode(p)
            p.setDirty()
            c.setChanged(True)
            # paste as first child if back is expanded.
            back = p.back()
            if back and back.isExpanded():
                p.moveToNthChildOf(back,0)
            c.undoer.setUndoParams("Paste Node",p)
        c.endUpdate()
        c.recolor()
    else:
        g.es("The clipboard is not a valid " + g.choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="ekr.20031218072017.1553"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=True):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    &lt;&lt; warn on read-only files &gt;&gt;
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        &lt;&lt; scan all the xml elements &gt;&gt;
    except BadLeoFile, message:
        &lt;&lt; raise an alert &gt;&gt;
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    if ok and atFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    &lt;&lt; restore attributes in descendent tnodes &gt;&gt;
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio</t>
<t tx="ekr.20031218072017.1554">try:
    self.read_only = False
    self.read_only = not os.access(fileName,os.W_OK)
    if self.read_only:
        g.es("read only: " + fileName,color="red")
except:
    if 0: # testing only: access may not exist on all platforms.
        g.es("exception getting file access")
        g.es_exception()</t>
<t tx="ekr.20031218072017.1555">self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("&lt;leo_file&gt;") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="ekr.20031218072017.1556"># All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))</t>
<t tx="ekr.20031218072017.1557">def finishPaste(self,reassignIndices=True):
    
    """Finish pasting an outline from the clipboard.
    
    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    c.beginUpdate()
    if reassignIndices:
        &lt;&lt; reassign tnode indices and clear all clone links &gt;&gt;
    c.selectVnode(current)
    c.endUpdate()
    return current</t>
<t tx="ekr.20031218072017.1558">@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        self.maxTnodeIndex += 1
        t.setFileIndex(self.maxTnodeIndex)</t>
<t tx="ekr.20031218072017.1559"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []
    
    if not reassignIndices:
        &lt;&lt; recreate tnodesDict &gt;&gt;

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("&lt;leo_file&gt;") # &lt;leo_file/&gt; is not valid.
        self.getClipboardHeader()
        self.getVnodes()
        self.getTnodes()
        self.getTag("&lt;/leo_file&gt;")
        v = self.finishPaste(reassignIndices)
    except BadLeoFile:
        v = None

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v</t>
<t tx="ekr.20031218072017.1560">def getTnodes (self):

    # A slight change: we require a tnodes element.  But Leo always writes this.
    if self.getOpenTag("&lt;tnodes&gt;"):
        return # &lt;tnodes/&gt; seen.
        
    while self.matchTag("&lt;t"):
        self.getTnode()

    self.getTag("&lt;/tnodes&gt;")
</t>
<t tx="ekr.20031218072017.1561">def getTnode (self):

    # we have already matched &lt;t.
    index = -1 ; attrDict = {}
    # New in version 1.7: attributes may appear in any order.
    while 1:	
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag("&gt;"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("tnode")
            if attr: attrDict[attr] = val
            
    if g.app.use_gnx:
        # index might be Tnnn, nnn, or gnx.
        id,time,n = g.app.nodeIndices.scanGnx(index,0)
        if time == None: # A pre-4.1 file index.
            if index[0] == "T":
                index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    # g.trace(t)
    &lt;&lt; handle unknown attributes &gt;&gt;
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("&lt;/t&gt;")
</t>
<t tx="ekr.20031218072017.1564">keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        print s ; g.es(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)</t>
<t tx="ekr.20031218072017.1565">def getVnodes (self):

    c = self.c

    if self.getOpenTag("&lt;vnodes&gt;"):
        return # &lt;vnodes/&gt; seen.
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()

    back = parent = None # This routine _must_ work on vnodes!
    
    self.currentVnodeStack = []
    self.topVnodeStack = []
    while self.matchTag("&lt;v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)
    else:
        &lt;&lt; set current and top positions &gt;&gt;

    self.getTag("&lt;/vnodes&gt;")</t>
<t tx="ekr.20031218072017.1566">def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched &lt;v.
    while 1:
        if self.matchTag("a=\""):
            &lt;&lt; Handle vnode attribute bits &gt;&gt;
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = self.getDqString()
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            dict = self.getDescendentUnknownAttributes(s)
            if dict:
                self.descendentUnknownAttributesDictList.append(dict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag("&gt;"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("&lt;vh&gt;"):
        headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    &lt;&lt; Set the remembered status bits &gt;&gt;

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("&lt;v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    &lt;&lt; Append to current or top stack &gt;&gt;

    # End this vnode.
    self.getTag("&lt;/v&gt;")
    return v</t>
<t tx="ekr.20031218072017.1567"># The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()</t>
<t tx="ekr.20031218072017.1568">if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()</t>
<t tx="ekr.20031218072017.1570">def assignFileIndices (self):
    
    """Assign a file index to all tnodes"""
    
    c = self.c ; nodeIndices = g.app.nodeIndices

    nodeIndices.setTimestamp() # This call is fairly expensive.

    if g.app.use_gnx:
        &lt;&lt; assign missing gnx's, converting ints to gnx's &gt;&gt;
    else:
        &lt;&lt; reassign all tnode indices &gt;&gt;
        
    if 0: # debugging:
        for p in c.allNodes_iter():
            g.trace(p.v.t.fileIndex)

# Indices are now immutable, so there is no longer any difference between these two routines.
compactFileIndices = assignFileIndices</t>
<t tx="ekr.20031218072017.1571"># Always assign an (immutable) index, even if the tnode is empty.

for p in c.allNodes_iter():
    try: # Will fail for None or any pre 4.1 file index.
        id,time,n = p.v.t.fileIndex
    except TypeError:
        # Don't convert to string until the actual write.
        p.v.t.fileIndex = nodeIndices.getNewIndex()</t>
<t tx="ekr.20031218072017.1572"># Clear out all indices.
for p in c.allNodes_iter():
    p.v.t.fileIndex = None
    
# Recreate integer indices.
self.maxTnodeIndex = 0

for p in c.allNodes_iter():
    if p.v.t.fileIndex == None:
        self.maxTnodeIndex += 1
        p.v.t.fileIndex = self.maxTnodeIndex</t>
<t tx="ekr.20031218072017.1575">def putTnodes (self):
    
    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("&lt;tnodes&gt;") ; self.put_nl()
    &lt;&lt; write only those tnodes that were referenced &gt;&gt;
    self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.1576">if self.usingClipboard: # write the current tree.
    iter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    iter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in iter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)</t>
<t tx="ekr.20031218072017.1577">def putTnode (self,t):

    self.put("&lt;t")
    self.put(" tx=")

    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(t.fileIndex)
        self.put_in_dquotes(gnx)
    else:
        self.put_in_dquotes("T" + str(t.fileIndex))

    if hasattr(t,"unknownAttributes"):
        self.putUnknownAttributes(t)

    self.put("&gt;")

    # g.trace(t)
    if t.bodyString:
        self.putEscapedString(t.bodyString)

    self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.1579">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;") ; self.put_nl()

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            self.putVnode(p) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.1595"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]</t>
<t tx="ekr.20031218072017.1596">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError:
        return None
    
    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
    
    if 0: # Don't use trace here!
        if tag != "idle":
            print "doHook",tag,c

    if not g.app.config.use_plugins:
        if tag == "start1":
            g.es("Plugins disabled: use_plugins is 0",color="blue")
        return None
    elif c and c.hookFunction:
        try:
            return c.hookFunction(tag,keywords)
        except:
            g.es("exception in c.hookFunction for " + c.frame.getTitle())
    elif g.app.hookFunction:
        try:
            return g.app.hookFunction(tag,keywords)
        except:
            g.es("exception in app.hookFunction")
    else:
        import leoPlugins
        try:
            g.app.hookFunction = leoPlugins.doPlugins
            return app.hookFunction(tag,keywords)
        except:
            g.app.hookFunction = None
            g.es("exception in plugin")

    # Handle all exceptions.
    g.es_exception()
    g.app.hookError = True # Supress this function.
    g.app.idleTimeHook = False # Supress idle-time hook
    return None # No return value</t>
<t tx="ekr.20031218072017.1602"># Add any newly-added user keywords.
for d in g.globalDirectiveList:
    name = '@' + d
    if name not in leoKeywords:
        leoKeywords.append(name)

# Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
s = self.body.getAllText() # 10/27/03
self.sel = sel = self.body.getInsertionPoint() # 10/27/03
start,end = self.body.convertIndexToRowColumn(sel) # 10/27/03

# g.trace(self.language)
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    self.removeAllImages()

self.redoColoring = False
self.redoingColoring = False

&lt;&lt; configure tags &gt;&gt;
&lt;&lt; configure language-specific settings &gt;&gt;

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')</t>
<t tx="ekr.20031218072017.1603">config = g.app.config
assert(config)

for name in default_colors_dict.keys(): # Python 2.1 support.
    option_name,default_color = default_colors_dict[name]
    option_color = config.getColorsPref(option_name)
    color = g.choose(option_color,option_color,default_color)
    # Must use foreground, not fg.
    try:
        self.body.tag_configure(name, foreground=color)
    except: # Recover after a user error.
        self.body.tag_configure(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    self.body.tag_configure("link",underline=1) # defined
    self.body.tag_configure("name",underline=0) # undefined
else:
    self.body.tag_configure("link",underline=0)
    if underline_undefined:
        self.body.tag_configure("name",underline=1)
    else:
        self.body.tag_configure("name",underline=0)
        
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = config.getColorsPref(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            self.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            self.body.tag_configure(name,background=default_color)
    
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    self.body.tag_configure("latexModeBackground",foreground="black")
    self.body.tag_configure("latexModeKeyword",foreground="blue")
    self.body.tag_configure("latexBackground",foreground="black")
    self.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    self.body.tag_configure("latexBackground",foreground="black",background="white")
    self.body.tag_configure("latexKeyword",foreground="blue",background="white")
    
# Tags for wiki coloring.
if self.showInvisibles:
    self.body.tag_configure("elide",background="yellow")
else:
    self.body.tag_configure("elide",elide="1")
self.body.tag_configure("bold",font=self.bold_font)
self.body.tag_configure("italic",font=self.italic_font)
self.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    self.body.tag_configure(name,foreground=name)</t>
<t tx="ekr.20031218072017.1606"># Copies of arguments.
self.p = None
self.language = None
self.flag = None
self.killFlag = False
self.line_index = 0

# Others.
self.single_comment_start = None
self.block_comment_start = None
self.block_comment_end = None
self.case_sensitiveLanguage = True
self.has_string = None
self.string_delims = ("'",'"')
self.has_pp_directives = None
self.keywords = None
self.lb = None
self.rb = None
self.rootMode = None # None, "code" or "doc"

config = g.app.config
self.latex_cweb_docs     = config.getBoolColorsPref("color_cweb_doc_parts_with_latex")
self.latex_cweb_comments = config.getBoolColorsPref("color_cweb_comments_with_latex")
# print "docs,comments",self.latex_cweb_docs,self.latex_cweb_comments</t>
<t tx="ekr.20031218072017.1612"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20031218072017.1617"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j</t>
<t tx="ekr.20031218072017.1619">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"</t>
<t tx="ekr.20031218072017.1620"># Handles non-cweb keyword.

def doAtKeyword (self,s,i):

    j = self.skip_id(s,i+1,chars="-") # to handle @root-code, @root-doc
    word = s[i:j]
    word = word.lower()
    if i != 0 and word not in ("@others","@all"):
        word = "" # can't be a Leo keyword, even if it looks like it.
    
    # 7/8/02: don't color doc parts in plain text.
    if self.language != "plain" and (word == "@" or word == "@doc"):
        # at-space is a Leo keyword.
        self.tag("leoKeyword",i,j)
        k = len(s) # Everything on the line is in the doc part.
        if not g.doHook("color-optional-markup",
            colorer=self,v=self.p,s=s,i=j,j=k,colortag="docPart"):
            self.tag("docPart",j,k)
        return k,"doc"
    elif word == "@nocolor":
        # Nothing on the line is colored.
        self.tag("leoKeyword",i,j)
        return j,"nocolor"
    elif word in leoKeywords:
        self.tag("leoKeyword",i,j)
        return j,"normal"
    else:
        return j,"normal"</t>
<t tx="ekr.20031218072017.1624">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)
    
    # Try to create a frame for the file.
    if fileName:
        fileName = g.os_path_join(os.getcwd(),fileName)
        fileName = g.os_path_normpath(fileName)
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame &amp; indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20031218072017.1655">@nocolor

- (done) Created runMainLoop function in leo.py so the call to mainloop() is in a separate function.

- (done) Added flush method to redirect class in leoGlobals.py

@color</t>
<t tx="ekr.20031218072017.1656"># To redirect stdout a class only needs to implement a write(self,s) method.
def __init__ (self):
    self.old = None
    
def isRedirected (self):
    return self.old != None
    
def flush(self, *args):
    return # 6/14/03:  For LeoN: just for compatibility.

def redirect (self,stdout=1):
    import sys
    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self

def undirect (self,stdout=1):
    import sys
    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None

def write(self,s):
    # g.trace(s)
    if self.old:
        if app.log: app.log.put(s)
        else: self.old.write(s)
    else: print s # Typically will not happen.
</t>
<t tx="ekr.20031218072017.1657">def runMainLoop(root):
	
	"""A function that runs root.mainloop()
	
	LeoN may replace this fuction entirely."""
	
	root.mainloop()
</t>
<t tx="ekr.20031218072017.1708">def extractSection(self):

    c = self ; body = c.frame.body ; current = v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Extract Section")
        return

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0] ; del lines[0]
    junk, ws = g.skip_leading_ws_with_indent(headline,0,c.tab_width)
    line1 = "\n" + headline
    # Create copy for undo.
    v_copy = c.undoer.saveTree(v)
    oldText = body.getAllText()
    oldSel = body.getTextSelection()
    &lt;&lt; Set headline for extractSection &gt;&gt;
    # Remove leading whitespace from all body lines.
    result = []
    for line in lines:
        # Remove the whitespace on the first line
        line = g.removeLeadingWhitespace(line,ws,c.tab_width)
        result.append(line)
    # Create a new node from lines.
    newBody = string.join(result,'\n')
    if head and len(head) &gt; 0:
        head = string.rstrip(head)
    c.beginUpdate()
    if 1: # update range...
        c.createLastChildNode(v,headline,newBody)
        # g.trace(v)
        undoType = None # Set undo params later.
        c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        newText = body.getAllText()
        newSel = body.getTextSelection()
        c.undoer.setUndoParams("Extract Section",v,
            select=current,oldTree=v_copy,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel)
    c.endUpdate()</t>
<t tx="ekr.20031218072017.1709">if 0: # I have no idea why this was being done.
    while len(headline) &gt; 0 and headline[0] == '/':
        headline = headline[1:]

headline = headline.strip()

if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return</t>
<t tx="ekr.20031218072017.1714">@ This routine implements undo for any kind of operation, no matter how complex.  Just do:

    v_copy = c.undoer.saveTree(v)
    ...make arbitrary changes to p's tree.
    c.undoer.setUndoParams("Op Name",p,select=current,oldTree=v_copy)
@c

def undoReplace (self,p,new_data,old_data):

    """Replace p.v and its subtree using old_data during undo."""

    u = self ; c = u.c
    if 0:
        # g.trace(u.undoType,"u.bead",u.bead)
        g.trace("new_data:",new_data)
        g.trace("old_data:",old_data)

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        d = u.beads[u.bead]
        d["newTree"] = u.saveTree(p.copy())
        u.beads[u.bead] = d

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    p.setBodyStringOrPane(p.bodyString())

    return p # Nothing really changes.</t>
<t tx="ekr.20031218072017.1723">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False):
    
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            &lt;&lt; set name to the label for doCommand &gt;&gt;
            &lt;&lt; set accel to the shortcut for name &gt;&gt;
            &lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;
            &lt;&lt; define callback function &gt;&gt;
            &lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                &lt;&lt; handle bind_shorcut &gt;&gt;</t>
<t tx="ekr.20031218072017.1724">name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
</t>
<t tx="ekr.20031218072017.1725">config = g.app.config
rawKey,accel2 = config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.</t>
<t tx="ekr.20031218072017.1726">bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("&lt;Control-c&gt;","&lt;Control-v&gt;","&lt;Control-x&gt;"):
        bind_shortcut = None</t>
<t tx="ekr.20031218072017.1727">if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)</t>
<t tx="ekr.20031218072017.1728">realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, &amp; bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&amp;")
if amp_index == -1:
    amp_index = realLabel.find("&amp;")

realLabel = realLabel.replace("&amp;","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""</t>
<t tx="ekr.20031218072017.1729">if bind_shortcut in self.menuShortcuts:
    if not g.app.menuWarningsGiven:
        g.es("duplicate shortcut:", accel, bind_shortcut, label,color="red")
        print "duplicate shortcut:", accel, bind_shortcut, label
else:
    self.menuShortcuts.append(bind_shortcut)
    try:
        self.frame.body.bind(bind_shortcut,callback)
        self.bind(bind_shortcut,callback)
    except: # could be a user error
        if not g.app.menuWarningsGiven:
            print "exception binding menu shortcut..."
            print bind_shortcut
            g.es_exception()
            g.app.menuWarningsGive = True</t>
<t tx="ekr.20031218072017.1732">def finishQuit(self):
    
    # forceShutdown may already have fired the "end1" hook.
    if not g.app.killed:
        g.doHook("end1")

    self.destroyAllGlobalWindows()
    self.destroyAllOpenWithFiles()
    
    if g.app.gui:
        g.app.gui.destroySelf()
        
    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called even after the following code.

    if 0: # Do not use g.trace here!
        print "finishQuit",g.app.killed
        
    if g.app.afterHandler:
        # TK bug: This appears to have no effect, at least on Windows.
        # print "finishQuit: cancelling",g.app.afterHandler
        if g.app.gui and g.app.gui.guiName() == "tkinter":
            self.root.after_cancel(g.app.afterHandler)
        g.app.afterHandler = None</t>
<t tx="ekr.20031218072017.1733">def updateStatusRowCol (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
    gui = g.app.gui
    if not lab: return
    
    # New for Python 2.3: may be called during shutdown.
    if g.app.killed:
        return

    if 0: # New code
        index = c.frame.body.getInsertionPoint()
        row,col = c.frame.body.indexToRowColumn(index)
        index1 = c.frame.body.rowColumnToIndex(row,0)
    else:
        index = body.index("insert")
        row,col = gui.getindex(body,index)
    
    if col &gt; 0:
        if 0: # new code
            s = c.frame.body.getRange(index1,index2)
        else:
            s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
        col = g.computeWidth (s,self.tab_width)

    if row != self.lastStatusRow or col != self.lastStatusCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastStatusRow = row
        self.lastStatusCol = col
        
    # Reschedule this routine 100 ms. later.
    # Don't use after_idle: it hangs Leo.
    self.statusFrame.after(100,self.updateStatusRowCol)</t>
<t tx="ekr.20031218072017.1745"></t>
<t tx="ekr.20031218072017.1746">def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()</t>
<t tx="ekr.20031218072017.1747">def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == docDirective,"@+doc","@+at")
    directive = g.choose(kind == docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)</t>
<t tx="ekr.20031218072017.1748">def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20031218072017.1749">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)</t>
<t tx="ekr.20031218072017.1750">def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)</t>
<t tx="ekr.20031218072017.1751">def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()</t>
<t tx="ekr.20031218072017.1752">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endDoc)
    
def skipToEndSentinel(self,s,i):
    end = self.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20031218072017.1753">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20031218072017.1754">if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(s) # The tag has already been removed.
at.docOut = []</t>
<t tx="ekr.20031218072017.1755"># Remove the @doc or @space.  We'll add it back at the end.
if g.match(s,0,tag):
    s = s[len(tag):]
else:
    at.readError("Missing start of doc part")
    return

if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(tag + s)
at.docOut = []</t>
<t tx="ekr.20031218072017.1760">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
    
    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True</t>
<t tx="ekr.20031218072017.1761"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Node"):

    c = self ; p = c.currentPosition()
    hasChildren = p.hasChildren()
    isExpanded  = p.isExpanded()
    if not p: return

    c.beginUpdate()
    if 1: # inside update...
        if (
            # 1/31/04: Make sure new node is visible when hoisting.
            (hasChildren and isExpanded) or
            (c.hoistStack and p == c.hoistStack[-1][0])
        ):
            p = p.insertAsNthChild(0)
        else:
            p = p.insertAfter()
        c.undoer.setUndoParams(op_name,p,select=p)
        c.selectVnode(p)
        c.editPosition(p)
        p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
    c.endUpdate()</t>
<t tx="ekr.20031218072017.1762">def clone (self):

    c = self
    p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    if 1: # update...
        clone = p.clone(p)
        clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            c.selectVnode(clone)
            c.undoer.setUndoParams("Clone Node",clone)
    c.endUpdate() # updates all icons</t>
<t tx="ekr.20031218072017.1765"># Makes sure all nodes are valid.

def validateOutline (self):

    c = self
    
    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True</t>
<t tx="ekr.20031218072017.1766"></t>
<t tx="ekr.20031218072017.1767">def demote(self):

    c = self ; p = c.currentPosition()
    if not p or not p.hasNext(): return

    last = p.lastChild()
    # Make sure all the moves will be valid.
    for child in p.children_iter():
        if not c.checkMoveWithParentWithWarning(child,p,True):
            return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            child.moveToNthChildOf(p,p.numberOfChildren())
        p.expand()
        c.selectVnode(p)
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
    c.endUpdate()
    c.undoer.setUndoParams("Demote",p,lastChild=last)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1768">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

    c = self ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move v down &gt;&gt;
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            p.setAllAncestorAtFileNodesDirty()
        c.selectVnode(p)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20031218072017.1769"># Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()

if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    if c.checkMoveWithParentWithWarning(p,next,True):
        p.moveToNthChildOf(next,0)
        c.undoer.setUndoParams("Move Down",p,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
    # Attempt to move p after next.
    if c.checkMoveWithParentWithWarning(p,next.parent(),True):
        p.moveAfter(next)
        c.undoer.setUndoParams("Move Down",p,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="ekr.20031218072017.1770">def moveOutlineLeft(self):
    
    c = self ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    
    if not p.hasParent(): return
    # Remember both the before state and the after state for undo/redo
    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    oldBack = p.back()
    oldParent = p.parent()
    oldN = p.childIndex()
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        c.undoer.setUndoParams("Move Left",p,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            p.setAllAncestorAtFileNodesDirty()
        c.selectVnode(p)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1771">def moveOutlineRight(self):
    
    c = self ; p = c.currentPosition()
    if not p: return
    
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    # Remember both the before state and the after state for undo/redo
    oldBack = back
    oldParent = p.parent()
    oldN = p.childIndex()
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        c.undoer.setUndoParams("Move Right",p,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        # Moving an outline right can never bring it outside the range of @ignore.
        p.setAllAncestorAtFileNodesDirty()
        c.selectVnode(p)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20031218072017.1772">def moveOutlineUp(self):

    c = self ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineUp(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    # A weird special case: just select back2.
    if back2 and p.v in back2.v.t.vnodeList:
        # g.trace('-'*20,"no move, selecting visBack")
        c.selectVnode(back2)
        return
    c = self
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move v up &gt;&gt;
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            p.setAllAncestorAtFileNodesDirty()
        c.selectVnode(p)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20031218072017.1773"># Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
    # p will be the new root node
    p.moveToRoot(c.rootVnode())
    c.undoer.setUndoParams("Move Up",p,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        p.moveToNthChildOf(back2,0)
        c.undoer.setUndoParams("Move Up",p,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(p,back2.parent(),True):
    # Insert after back2.
    p.moveAfter(back2)
    c.undoer.setUndoParams("Move Up",p,
        oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="ekr.20031218072017.1774">def promote(self):

    c = self ; p = c.currentPosition()
    if not p or not p.hasChildren(): return

    last = p.lastChild()
    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            child.moveAfter(after)
            after = child
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        c.selectVnode(p)
    c.endUpdate()
    c.undoer.setUndoParams("Promote",p,lastChild=last)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20031218072017.1776"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,p,event):

    # Note: "drag" hooks handled by vnode callback routine.

    c = self.c ; v = p.v
    assert(p == self.drag_p)

    if not event:
        return

    if not self.dragging():
        windowPref = g.app.config.getBoolWindowPref
        # Only do this once: greatly speeds drags.
        self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
        self.setDragging(True)
        if windowPref("allow_clone_drags"):
            self.controlDrag = c.frame.controlKeyIsDown
            if windowPref("look_for_control_drag_on_mouse_down"):
                if windowPref("enable_drag_messages"):
                    if self.controlDrag:
                        g.es("dragged node will be cloned")
                    else:
                        g.es("dragged node will be moved")
        else: self.controlDrag = False
        self.canvas['cursor'] = "hand2" # "center_ptr"

    self.OnContinueDrag(p,event)</t>
<t tx="ekr.20031218072017.1777">def OnEndDrag(self,p,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    v = p.v
    
    # 7/10/03: Make sure we are still dragging.
    if not self.drag_p:
        return

    assert(p == self.drag_p)
    c = self.c ; canvas = self.canvas ; config = g.app.config

    if event:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if config.getBoolWindowPref("allow_clone_drags"):
            if not config.getBoolWindowPref("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown

        if vdrag and vdrag.v.t != p.v.t: # 6/22/04: Disallow drag to joined node.
            if self.controlDrag: # Clone p and move the clone.
                if childFlag:
                    c.dragCloneToNthChildOf(p,vdrag,0)
                else:
                    c.dragCloneAfter(p,vdrag)
            else: # Just drag p.
                if childFlag:
                    c.dragToNthChildOf(p,vdrag,0)
                else:
                    c.dragAfter(p,vdrag)
        else:
            if p and self.dragging():
                pass # g.es("not dragged: " + p.headString())
            if 0: # Don't undo the scrolling we just did!
                self.idle_scrollTo(p)
    
    # 1216/02: Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"

    if self.drag_id:
        canvas.tag_unbind(self.drag_id,"&lt;B1-Motion&gt;")
        canvas.tag_unbind(self.drag_id,"&lt;Any-ButtonRelease-1&gt;")
        self.drag_id = None
        
    self.setDragging(False)
    self.drag_p = None</t>
<t tx="ekr.20031218072017.1778">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
# id = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20031218072017.1809">def importDerivedFile (self):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; frame = c.frame ; v = c.currentVnode()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(v,names)</t>
<t tx="ekr.20031218072017.1810">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; at = c.atFileCommands
    current = c.currentVnode()
    
    c.beginUpdate()
    
    for fileName in paths:
        v = parent.insertAfter()
        v.initHeadString("Imported @file " + fileName)
        c.undoer.setUndoParams("Import",v,select=current)
        at.read(v,importFileName=fileName)
        c.selectVnode(v)
        v.expand()

    c.endUpdate()</t>
<t tx="ekr.20031218072017.1812"># The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False):
    
    """Common read logic for any derived file."""
    
    at = self ; c = at.c
    at.errors = 0
    importing = importFileName is not None
    &lt;&lt; set fileName from root and importFileName &gt;&gt;
    &lt;&lt; open file or return False &gt;&gt;
    g.es("reading: " + root.headString())
    firstLines,read_new = at.scanHeader(file,fileName)
    df = g.choose(read_new,at.new_df,at.old_df)
    # g.trace(g.choose(df==at.new_df,"new","old"))
    &lt;&lt; copy ivars to df &gt;&gt;
    root.clearVisitedInTree()
    try:
        # 1/28/04: Don't set comment delims when importing.
        # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
        importing = importFileName is not None
        df.scanAllDirectives(root,importing=importing,reading=True)
        df.readOpenFile(root,file,firstLines)
    except:
        at.error("Unexpected exception while reading derived file")
        g.es_exception()
    file.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    &lt;&lt; warn about non-empty unvisited nodes &gt;&gt;
    if df.errors == 0:
        if not df.importing:
            &lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;
    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return df.errors == 0</t>
<t tx="ekr.20031218072017.1813">at.scanDefaultDirectory(root,importing=importing)
if at.errors: return

if importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False</t>
<t tx="ekr.20031218072017.1814">fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
    # 11/4/03: open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    file = open(fn,'rb')
    if file:
        &lt;&lt; warn on read-only file &gt;&gt;
    else: return False
except:
    at.error("Can not open: " + '"@file ' + fn + '"')
    root.setDirty()
    return False</t>
<t tx="ekr.20031218072017.1815">try:
    read_only = not os.access(fn,os.W_OK)
    if read_only:
        g.es("read only: " + fn,color="red")
except:
    pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20031218072017.1816"># Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = False
if importing and df == at.new_df:
    thinFile = True
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.importRootSeen = False
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = False
df.perfectImportRoot = None # Set only in readOpenFile.</t>
<t tx="ekr.20031218072017.1817">for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.</t>
<t tx="ekr.20031218072017.1818">for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()</t>
<t tx="ekr.20031218072017.1819">for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")</t>
<t tx="ekr.20031218072017.1823">def createLastChildNode (self,parent,headline,body):
    
    c = self
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""
    v = parent.insertAsLastChild()
    v.initHeadString(headline)
    v.setTnodeText(body)
    v.setDirty()
    c.validateOutline()</t>
<t tx="ekr.20031218072017.1824">def dedentBody (self):
    
    c = self ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Unindent")
        return

    d = g.scanDirectives(c,p) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Undent",oldSel,oldYview)</t>
<t tx="ekr.20031218072017.1830">def indentBody (self):

    c = self ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Indent")
        return

    d = g.scanDirectives(c,p) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)
    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,"Indent",oldSel,oldYview)</t>
<t tx="ekr.20031218072017.1832">def getTime (self,body=True):

    config = g.app.config
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = config.getWindowPref("body_time_format_string")
        gmt = config.getBoolWindowPref("body_gmt_time")
    else:
        format = config.getWindowPref("headline_time_format_string")
        gmt = config.getBoolWindowPref("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20031218072017.1860">def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t: t = self.newTnode(tref)
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(c,t)
        v.moveToRoot()

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) &gt; 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    &lt;&lt; handle unknown vnode attributes &gt;&gt;
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip</t>
<t tx="ekr.20031218072017.1861">keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        print s ; g.es(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)</t>
<t tx="ekr.20031218072017.1863">def putVnode (self,p):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("&lt;v")
    &lt;&lt; Put tnode index &gt;&gt;
    &lt;&lt; Put attribute bits &gt;&gt;
    &lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;
    fc.put("&gt;")
    &lt;&lt; Write the head text &gt;&gt;

    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="ekr.20031218072017.1864">if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")</t>
<t tx="ekr.20031218072017.1865">attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)</t>
<t tx="ekr.20031218072017.1866">headString = p.v.headString()

if headString:
    fc.put("&lt;vh&gt;")
    fc.putEscapedString(headString)
    fc.put("&lt;/vh&gt;")</t>
<t tx="ekr.20031218072017.1880">def colorizeAnyLanguage (self,p,leading=None,trailing=None):
    
    """Color the body pane either incrementally or non-incrementally"""
    
    # g.trace("incremental",self.incremental,p)
    if self.killFlag:
        self.removeAllTags()
        return
    try:
        &lt;&lt; initialize ivars &amp; tags &gt;&gt;
        g.doHook("init-color-markup",colorer=self,v=self.p)
        self.color_pass = 0
        if self.incremental and (
            &lt;&lt; all state ivars match &gt;&gt; ):
            &lt;&lt; incrementally color the text &gt;&gt;
        else:
            &lt;&lt; non-incrementally color the text &gt;&gt;
        if self.redoColoring:
            &lt;&lt; completely recolor in two passes &gt;&gt;
        &lt;&lt; update state ivars &gt;&gt;
        return "ok" # for testing.
    except:
        &lt;&lt; set state ivars to "unknown" &gt;&gt;
        if self.c:
            g.es_exception()
        else:
            import traceback ; traceback.print_exc()
        return "error" # for unit testing.</t>
<t tx="ekr.20031218072017.1881">self.flag == self.last_flag and
self.last_language == self.language and
self.comment_string == self.last_comment and
self.markup_string == self.last_markup</t>
<t tx="ekr.20031218072017.1882">@  Each line has a starting state.  The starting state for the first line is always "normal".

We need remember only self.lines and self.states between colorizing.  It is not necessary to know where the text comes from, only what the previous text was!  We must always colorize everything when changing nodes, even if all lines match, because the context may be different.

We compute the range of lines to be recolored by comparing leading lines and trailing lines of old and new text.  All other lines (the middle lines) must be colorized, as well as any trailing lines whose states may have changed as the result of changes to the middle lines.
@c

# g.trace("incremental")

# 6/30/03: make a copies of everything
old_lines = self.lines[:]
old_states = self.states[:]
new_lines = lines[:]
new_states = []

new_len = len(new_lines)
old_len = len(old_lines)

if new_len == 0:
    self.states = []
    self.lines = []
    return

# Bug fix: 11/21/02: must test against None.
if leading != None and trailing != None:
    # print "leading,trailing:",leading,trailing
    leading_lines = leading
    trailing_lines = trailing
else:
    &lt;&lt; compute leading, middle &amp; trailing lines &gt;&gt;
    
middle_lines = new_len - leading_lines - trailing_lines
# print "middle lines", middle_lines

&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;
&lt;&lt; initialize new states &gt;&gt;
&lt;&lt; colorize until the states match &gt;&gt;</t>
<t tx="ekr.20031218072017.1883">@ The leading lines are the leading matching lines.  The trailing lines are the trailing matching lines.  The middle lines are all other new lines.  We will color at least all the middle lines.  There may be no middle lines if we delete lines.
@c

min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading_lines = i

if leading_lines == new_len:
    # All lines match, and we must color _everything_.
    # (several routine delete, then insert the text again,
    # deleting all tags in the process).
    # print "recolor all"
    leading_lines = trailing_lines = 0
else:
    i = 0
    while i &lt; min_len - leading_lines:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing_lines = i
</t>
<t tx="ekr.20031218072017.1884">@ 11/19/02: Changing @color or @nocolor directives requires we recolor all leading states as well.
@c

if trailing_lines == 0:
    m1 = new_lines[leading_lines:]
    m2 = old_lines[leading_lines:]
else:
    m1 = new_lines[leading_lines:-trailing_lines]
    m2 = old_lines[leading_lines:-trailing_lines]
m1.extend(m2) # m1 now contains all old and new middle lines.
if m1:
    for s in m1:
        s = g.toUnicode(s,g.app.tkEncoding) # 10/28/03
        i = g.skip_ws(s,0)
        if g.match_word(s,i,"@color") or g.match_word(s,i,"@nocolor"):
            leading_lines = 0
            break
</t>
<t tx="ekr.20031218072017.1885"># Copy the leading states from the old to the new lines.
i = 0
while i &lt; leading_lines and i &lt; old_len: # 12/8/02
    new_states.append(old_states[i])
    i += 1
    
# We know the starting state of the first middle line!
if middle_lines &gt; 0 and i &lt; old_len:
    new_states.append(old_states[i])
    i += 1
    
# Set the state of all other middle lines to "unknown".
first_trailing_line = max(0,new_len - trailing_lines)
while i &lt; first_trailing_line:
    new_states.append("unknown")
    i += 1

# Copy the trailing states from the old to the new lines.
i = max(0,old_len - trailing_lines)
while i &lt; old_len and i &lt; len(old_states):
    new_states.append(old_states[i])
    i += 1

# 1/8/03: complete new_states by brute force.
while len(new_states) &lt; new_len:
    new_states.append("unknown")</t>
<t tx="ekr.20031218072017.1886"># Colorize until the states match.
# All middle lines have "unknown" state, so they will all be colored.

# Start in the state _after_ the last leading line, which may be unknown.
i = leading_lines
while i &gt; 0:
    if i &lt; old_len and i &lt; new_len:
        state = new_states[i]
        # assert(state!="unknown") # This can fail.
        break
    else:
        i -= 1

if i == 0:
    # Color plain text unless we are under the control of @nocolor.
    # state = g.choose(self.flag,"normal","nocolor")
    state = self.setFirstLineState()
    new_states[0] = state

# The new_states[] will be "unknown" unless the lines match,
# so we do not need to compare lines here.
while i &lt; new_len:
    self.line_index = i + 1
    state = self.colorizeLine(new_lines[i],state)
    i += 1
    # Set the state of the _next_ line.
    if i &lt; new_len and state != new_states[i]:
        new_states[i] = state
    else: break
    
# Update the ivars
self.states = new_states
self.lines = new_lines</t>
<t tx="ekr.20031218072017.1887"># g.trace("non-incremental",self.language)

self.line_index = 1 # The Tk line number for indices, as in n.i
for s in lines:
    state = self.colorizeLine(s,state)
    self.line_index += 1
</t>
<t tx="ekr.20031218072017.1888">self.last_flag = self.flag
self.last_language = self.language
self.last_comment = self.comment_string
self.last_markup = self.markup_string</t>
<t tx="ekr.20031218072017.1889">self.last_flag = "unknown"
self.last_language = "unknown"
self.last_comment = "unknown"</t>
<t tx="ekr.20031218072017.1890"># This code is executed only if graphics characters will be inserted by user markup code.

# Pass 1:  Insert all graphics characters.

self.removeAllImages()
s = self.body.getAllText() # 10/27/03
lines = s.split('\n')

self.color_pass = 1
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
    state = self.colorizeLine(s,state)
    self.line_index += 1

# Pass 2: Insert one blank for each previously inserted graphic.

self.color_pass = 2
self.line_index = 1
state = self.setFirstLineState()
for s in lines:
    &lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;
    state = self.colorizeLine(s,state)
    self.line_index += 1
</t>
<t tx="ekr.20031218072017.1891">@ A spectacular kludge.

Images take up a real index, yet the get routine does not return any character for them!
In order to keep the colorer in synch, we must insert dummy blanks in s at the positions corresponding to each image.
@c

inserted = 0

for photo,image,line_index,i in self.image_references:
    if self.line_index == line_index:
        n = i+inserted ; 	inserted += 1
        s = s[:n] + ' ' + s[n:]
</t>
<t tx="ekr.20031218072017.1896">## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state</t>
<t tx="ekr.20031218072017.1897"></t>
<t tx="ekr.20031218072017.1898">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j</t>
<t tx="ekr.20031218072017.1899">if g.match(s,i,"\\"):
    j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.</t>
<t tx="ekr.20031218072017.1900">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20031218072017.1901">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2</t>
<t tx="ekr.20031218072017.1902">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)</t>
<t tx="ekr.20031218072017.1903"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2</t>
<t tx="ekr.20031218072017.1904">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20031218072017.1905">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)</t>
<t tx="ekr.20031218072017.1906"></t>
<t tx="ekr.20031218072017.1907">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1</t>
<t tx="ekr.20031218072017.1908"></t>
<t tx="ekr.20031218072017.1909"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)</t>
<t tx="ekr.20031218072017.1910">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1

</t>
<t tx="ekr.20031218072017.1911">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1</t>
<t tx="ekr.20031218072017.1912">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1</t>
<t tx="ekr.20031218072017.1913"># self.tag("normal",i,i+1)
i += 1</t>
<t tx="ekr.20031218072017.1921">@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first &amp; @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        &lt;&lt; handle @delims &gt;&gt;
    elif g.match_word(s,k,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,k,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i</t>
<t tx="ekr.20031218072017.1922"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")</t>
<t tx="ekr.20031218072017.1924"></t>
<t tx="ekr.20031218072017.1925"></t>
<t tx="ekr.20031218072017.1926">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2257820
By: wtrenker

When I edit a Headline and select the existing text, then I paste in some other
text, the original selected text remains instead of being overwritten by the
newly pasted text.

Here's a simple, repeatable example.  Start a new Leo file.  As expected, the
new file is initialized with a single node with a headline containing the text
"NewHeadline".  The text is pre-selected, ready to edit.  Now do a copy and
then paste.  The text will now read "NewHeadlineNewHeadline".  The original
text was not overwritten.

Here's my configuration:

Leo Log Window...
Leo 4.0.3, build  1.99 , October 25, 2003
Python 2.3.2, Tk 8.3.3

Linux 2.4.19; libc.so.6 2.2.5; gcc 2.95.3
KDE: 3.0.0 Qt: 3.0.4
GNU ld version 2.13.90.0.4 20020814
GNU Make 3.80
pkg-config 0.14.0
Python 2.3.2 (#1, Oct 27 2003, 10:19:56) [GCC 2.95.3 20010315 (release)]

Regards,
Bill
</t>
<t tx="ekr.20031218072017.1934">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    if not isValidPython(): return
    # Import leoGlobals, but do NOT set g.
    import leoGlobals
    # Create the application object.
    import leoApp ; leoGlobals.app = leoApp.LeoApp()
    g = leoGlobals ; assert(g.app) # NOW we can set g.
    g.app.loadDir = computeLoadDir() # Depends on g.app.tkEncoding: uses utf-8 for now.
    import leoConfig
    g.app.config = leoConfig.config()
    g.app.setEncoding() # 10/20/03: do this earlier
    script = getBatchScript()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    else:
        &lt;&lt; print encoding info &gt;&gt;
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui()
    if g.app.use_gnx:
        if not g.app.leoID: g.app.setLeoID() # Forces the user to set g.app.leoID.
        import leoNodes
        g.app.nodeIndices = leoNodes.nodeIndices()
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    &lt;&lt; start psycho &gt;&gt;
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    v = c.currentVnode()
    g.doHook("start2",c=c,v=v,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20031218072017.1935">g.es("leoConfig.txt encoding: " + g.app.config.config_encoding, color="blue")

if 0: # This is just confusing for users.
    g.es("Text encoding: " + g.app.tkEncoding, color="blue")</t>
<t tx="ekr.20031218072017.1936">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except:
        print message
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            g.app.gui.runAskOkDialog("Python version error",message=message,text="Exit")
        return ok
    except:
        print "exception getting Python version"
        import traceback ; traceback.print_exc()
        return False</t>
<t tx="ekr.20031218072017.1937">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding)
    
    try:
        import leo
        path = g.os_path_abspath(leo.__file__)

        if sys.platform=="win32": # "mbcs" exists only on Windows.
            path = g.toUnicode(path,"mbcs")
        elif sys.platform=="dawwin":
            path = g.toUnicode(path,"utf-8")
        else:
            path = g.toUnicode(path,g.app.tkEncoding)

        if path:
            loadDir = g.os_path_dirname(path)
        else:
            loadDir = None
        if not loadDir:
            loadDir = g.os_path_abspath(os.getcwd())
            print "Using emergency loadDir:",repr(loadDir)

        encoding = g.choose(sys.platform=="dawwin","utf-8",g.app.tkEncoding) # 11/18/03
        loadDir = g.toUnicode(loadDir,encoding) # 10/20/03
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None</t>
<t tx="ekr.20031218072017.1938">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20031218072017.1939">def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name: return None	
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script</t>
<t tx="ekr.20031218072017.1954">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(endDoc)
    at.inCode = True</t>
<t tx="ekr.20031218072017.1956">def injectCallbacks(self):
    
    import leoNodes
    
    &lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;

    for f in (
        OnBoxClick,OnDrag,OnEndDrag,
        OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
        OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
        OnIconClick,OnIconDoubleClick,OnIconRightClick):
        
        g.funcToMethod(f,leoNodes.position)</t>
<t tx="ekr.20031218072017.1957"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others</t>
<t tx="ekr.20031218072017.1958"># Called when the box is clicked.

def OnBoxClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("boxclick1",c=c,p=p,event=event):
            c.frame.tree.OnBoxClick(p)
        g.doHook("boxclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("boxclick")</t>
<t tx="ekr.20031218072017.1959">def OnDrag(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if c.frame.tree.dragging():
            if not g.doHook("dragging1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("dragging2",c=c,p=p,event=event)
        else:
            if not g.doHook("drag1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("drag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("drag")</t>
<t tx="ekr.20031218072017.1960">def OnEndDrag(self,event=None):
    
    """Callback injected into vnode or position class."""
    
    # g.trace()

    try:
        p = self ; c = p.c
        # 7/10/03: Always call frame.OnEndDrag, regardless of state.
        if not g.doHook("enddrag1",c=c,p=p,event=event):
            c.frame.tree.OnEndDrag(p,event)
        g.doHook("enddrag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("enddrag")</t>
<t tx="ekr.20031218072017.1961">def OnHeadlineClick(self,event=None):
    """Callback injected into vnode or position class."""
    try:
        p = self ; c = p.c
        if not g.doHook("headclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
        g.doHook("headclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headclick")
    
def OnHeadlineRightClick(self,event=None):

    """Callback injected into vnode or position class."""

    #g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("headrclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
            c.frame.tree.OnPopup(self,event)
        g.doHook("headrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headrclick")</t>
<t tx="ekr.20031218072017.1962">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into vnode or position class."""

    # g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,event=event):
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hypercclick")</t>
<t tx="ekr.20031218072017.1963">def OnHeadlineKey (self,event=None):

    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("headkey1",c=c,p=p,event=event):
            c.frame.tree.OnHeadlineKey(p,event)
        g.doHook("headkey2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headkey")</t>
<t tx="ekr.20031218072017.1964">def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperenter")</t>
<t tx="ekr.20031218072017.1965">def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperleave")</t>
<t tx="ekr.20031218072017.1966">def OnIconClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconClick(p,event)
        g.doHook("iconclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconclick")
    
def OnIconRightClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconrclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconRightClick(p,event)
        g.doHook("iconrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconrclick")
</t>
<t tx="ekr.20031218072017.1967">def OnIconDoubleClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("icondclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconDoubleClick(self)
        g.doHook("icondclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("icondclick")
</t>
<t tx="ekr.20031218072017.1968">self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None</t>
<t tx="ekr.20031218072017.1970">def getLeoHeader (self):

    # Set defaults.
    self.maxTnodeIndex = 0
    self.numberOfTnodes = 0

    if self.getOpenTag("&lt;leo_header"):
        return # &lt;leo_header/&gt; seen.

    # New in version 1.7: attributes may appear in any order.
    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.numberOfTnodes = self.getLong() ; self.getDquote()
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.maxTnodeIndex = self.getLong() ; self.getDquote()
            # g.trace("max_tnode_index:",self.maxTnodeIndex)
        elif self.matchTag("clone_windows="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
        elif self.matchTag("&gt;&lt;/leo_header&gt;"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/&gt;")
            break</t>
<t tx="ekr.20031218072017.1979"># This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if not g.app.batchMode:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None</t>
<t tx="ekr.20031218072017.1999">def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    id,t,n = index

    if removeDefaultId and id == self.defaultId:
        id = ""

    if not n: # None or ""
        return "%s.%s" % (id,t)
    else:
        return "%s.%s.%d" % (id,t,n)</t>
<t tx="ekr.20031218072017.2001">def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)
    
    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        at.root.v.t.tnodeList.append(p.v.t)</t>
<t tx="ekr.20031218072017.2002">def putTnodeList (self,v):
    
    """Put the tnodeList attribute of a tnode."""
    
    # g.trace(v)
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        fc.put(" tnodeList=") ; fc.put_dquote()
        if g.app.use_gnx:
            for t in tnodeList:
                try: # Will fail for None or any pre 4.1 file index.
                    id,time,n = t.fileIndex
                except:
                    g.trace("assigning gnx for ",v,t)
                    gnx = nodeIndices.getNewIndex()
                    v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
            s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        else:
            s = ','.join([str(t.fileIndex) for t in tnodeList])
        fc.put(s) ; fc.put_dquote()</t>
<t tx="ekr.20031218072017.2004">def canonicalTnodeIndex(self,index):
    
    """Convert Tnnn to nnn, leaving gnx's unchanged."""

    # index might be Tnnn, nnn, or gnx.
    id,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    return index</t>
<t tx="ekr.20031218072017.2007">def findChild (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
    
    if 0: # Old code:
        &lt;&lt; Check the headlines &gt;&gt;</t>
<t tx="ekr.20031218072017.2008">def getTnodeList (self,s):

    """Parse a list of tnode indices in string s."""
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    
    fc = self ; 

    indexList = s.split(',') # The list never ends in a comma.
    tnodeList = []
    for index in indexList:
        index = self.canonicalTnodeIndex(index)
        t = fc.tnodesDict.get(index)
        if not t:
            # Not an error: create a new tnode and put it in fc.tnodesDict.
            # g.trace("not allocated: %s" % index)
            t = self.newTnode(index)
        tnodeList.append(t)
        
    # if tnodeList: g.trace(len(tnodeList))
    return tnodeList
</t>
<t tx="ekr.20031218072017.2015">def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave</t>
<t tx="ekr.20031218072017.2016">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()</t>
<t tx="ekr.20031218072017.2017">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    df.fileChangedFlag = False # 1/9/04
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True</t>
<t tx="ekr.20031218072017.2018">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")</t>
<t tx="ekr.20031218072017.2019">def writeMissing(self,p,toString=False):

    at = self

    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            missing = False ; valid = True
            df.targetFileName = p.anyAtFileNodeName()
            &lt;&lt; set missing if the file does not exist &gt;&gt;
            if valid and missing:
                &lt;&lt; create df.outputFile &gt;&gt;
                if df.outputFile:
                    &lt;&lt; write the @file node &gt;&gt;
                    df.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles &gt; 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.</t>
<t tx="ekr.20031218072017.2020"># This is similar, but not the same as, the logic in openWriteFile.

valid = df.targetFileName and len(df.targetFileName) &gt; 0

if valid:
    try:
        # Creates missing directives if option is enabled.
        df.scanAllDirectives(p)
        valid = df.errors == 0
    except:
        g.es("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False

if valid:
    try:
        fn = df.targetFileName
        df.shortFileName = fn # name to use in status messages.
        df.targetFileName = g.os_path_join(df.default_directory,fn)
        df.targetFileName = g.os_path_normpath(df.targetFileName)

        path = df.targetFileName # Look for the full name, not just the directory.
        valid = path and len(path) &gt; 0
        if valid:
            missing = not g.os_path_exists(path)
    except:
        g.es("exception creating path:" + fn)
        g.es_exception()
        valid = False</t>
<t tx="ekr.20031218072017.2021">if toString:
    df.outputFileName = "&lt;string: %s&gt;" % df.targetFileName
    df.outputFile = g.fileLikeObject()
else:
    try:
        df.outputFileName = df.targetFileName
        df.outputFile = open(df.outputFileName,'wb')
        if df.outputFile is None:
            g.es("can not open " + df.outputFileName)
    except IOError:
        g.es("Can not open " + df.outputFileName)
        g.es_exception()
        df.outputFile = None</t>
<t tx="ekr.20031218072017.2022">if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if df.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True</t>
<t tx="ekr.20031218072017.2023">def replaceTargetFileIfDifferent (self):
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    if g.os_path_exists(self.targetFileName):
        if self.compareFilesIgnoringLineEndings(
            self.outputFileName,self.targetFileName):
            &lt;&lt; delete the output file &gt;&gt;
        else:
            &lt;&lt; replace the target file with the output file &gt;&gt;
    else:
        &lt;&lt; rename the output file to be the target file &gt;&gt;</t>
<t tx="ekr.20031218072017.2024">try: # Just delete the temp file.
    os.remove(self.outputFileName)
except:
    g.es("exception deleting:" + self.outputFileName)
    g.es_exception()

g.es("unchanged: " + self.shortFileName)</t>
<t tx="ekr.20031218072017.2025">try:
    # 10/6/02: retain the access mode of the previous file,
    # removing any setuid, setgid, and sticky bits.
    mode = (os.stat(self.targetFileName))[0] &amp; 0777
except:
    mode = None

try: # Replace target file with temp file.
    os.remove(self.targetFileName)
    try:
        g.utils_rename(self.outputFileName,self.targetFileName)
        if mode != None: # 10/3/02: retain the access mode of the previous file.
            try:
                os.chmod(self.targetFileName,mode)
            except:
                g.es("exception in os.chmod(%s)" % (self.targetFileName))
        g.es("writing: " + self.shortFileName)
        self.fileChangedFlag = True
    except:
        # 6/28/03
        self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
        g.es_exception()
except:
    self.writeError("exception removing:" + self.targetFileName)
    g.es_exception()
    try: # Delete the temp file when the deleting the target file fails.
        os.remove(self.outputFileName)
    except:
        g.es("exception deleting:" + self.outputFileName)
        g.es_exception()</t>
<t tx="ekr.20031218072017.2026">try:
    g.utils_rename(self.outputFileName,self.targetFileName)
    g.es("creating: " + self.targetFileName)
    self.fileChangedFlag = True
except:
    self.writeError("exception renaming:" + self.outputFileName +
        " to " + self.targetFileName)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2028">def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        c.undoer.setUndoParams("De-Hoist",p)
        h,expanded = c.hoistStack.pop()
        if expanded: p.expand()
        else:        p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            p,junk = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + p.headString())
        else:
            c.frame.putStatusLine("No hoist")

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        c.undoer.setUndoParams("Hoist",p)
        # New in 4.2: remember expansion state.
        c.hoistStack.append((p,p.isExpanded()),)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())</t>
<t tx="ekr.20031218072017.2029">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount)
    # import traceback ; traceback.print_stack()
    
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    if c.hoistStack:
        p,junk = c.hoistStack[-1]
        self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),root_left,root_top,0,0)
        
    canvas.lower("lines")
    canvas.lower("colorBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox")
    
    if 0:
        &lt;&lt; define callbacks &gt;&gt;
        # Use vnode or postion callbacks.
        canvas.tag_bind("textBox","&lt;1&gt;",onHeadlineClickCallback)
        canvas.tag_bind("textBox","&lt;3&gt;",onHeadlineRightClickCallback)
        canvas.tag_bind("textBox","&lt;Key&gt;", onHeadlineKeyCallback)
        canvas.tag_bind("textBox","&lt;Control-t&gt;",self.OnControlT)
            # Stamp out erroneous control-t binding.</t>
<t tx="ekr.20031218072017.2030">def redo (self):

    u = self ; c = u.c
    if not u.canRedo(): return
    if not u.getBead(u.bead+1): return
    if not  c.currentPosition(): return
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))

    u.redoing = True 
    u.redrawFlag = True
    u.updateSetChangedFlag = True
    
    c.beginUpdate()
    if 1: # update...
        try:
            func = u.redoDispatchDict[u.undoType]
        except KeyError:
            s = "Unknown redo key: %s" % u.undoType
            g.trace(s) ; g.es(s, color="red")
            func = None
        if func:
            func()
            if u.updateSetChangedFlag:
                c.setChanged(True)
                if u.p: u.p.setDirty(setDescendentsDirty=False)
    c.endUpdate(u.redrawFlag)

    u.redoing = False
    u.bead += 1
    u.setUndoTypes()</t>
<t tx="ekr.20031218072017.2034">elif redoType in ["Import","Insert Node","Paste Node"]:

	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)</t>
<t tx="ekr.20031218072017.2035">elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	# g.trace(u.p)
	if u.parent:
		u.p.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.p.moveAfter(u.back)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)
	
elif redoType == "Drag":

	u.p.moveToNthChildOf(u.parent,u.n)
	c.selectVnode(u.p)</t>
<t tx="ekr.20031218072017.2039">def undo (self):

    """Undo the operation described by the undo parmaters."""
    
    u = self ; c = u.c
    if not u.canUndo(): return
    if not u.getBead(u.bead): return
    if not c.currentPosition(): return
    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))

    c.endEditing()# Make sure we capture the headline for a redo.
    u.undoing = True
    u.redrawFlag = True
    u.updateSetChangedFlag = True

    c.beginUpdate()
    if 1: # update...
        try:
            func = u.undoDispatchDict[u.undoType]
        except KeyError:
            s = "Unknown undo key: %s" % u.undoType
            g.trace(s) ; g.es(s, color="red")
            func = None
        if func:
            func()
            if u.updateSetChangedFlag:
                c.setChanged(True)
                if u.p: u.p.setDirty(setDescendentsDirty=False)
    c.endUpdate(u.redrawFlag)

    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()</t>
<t tx="ekr.20031218072017.2041">@ Deleting a clone is _not_ the same as undoing a clone:
the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Node" or undoType == "Cut Node":
	
	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)</t>
<t tx="ekr.20031218072017.2044">elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	# g.trace("oldParent",u.oldParent)

	if u.oldParent:
		u.p.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.p.moveAfter(u.oldBack)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,enableLog=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    # g.trace(fileName)
    assert(app.config)

    if not fileName or len(fileName) == 0:
        return False, None

    # Create a full normalized path name.
    # Display the file name with case intact.
    fileName = g.os_path_join(os.getcwd(), fileName)
    fileName = g.os_path_normpath(fileName)
    oldFileName = fileName 
    fileName = g.os_path_normcase(fileName)

    # If the file is already open just bring its window to the front.
    list = app.windowList
    for frame in list:
        fn = g.os_path_normcase(frame.c.mFileName)
        fn = g.os_path_normpath(fn)
        if fileName == fn:
            frame.deiconify()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
            
    fileName = oldFileName # Use the idiosyncratic file name.

    try:
        # 11/4/03: open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        file = open(fileName,'rb')
        if file:
            c,frame = app.gui.newLeoCommanderAndFrame(fileName)
            frame.log.enable(enableLog)
            if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
                app.setLog(frame.log,"openWithFileName")
                app.lockLog()
                frame.c.fileCommands.open(file,fileName) # closes file.
                app.unlockLog()
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
            return True, frame
        else:
            g.es("can not open: " + fileName,color="red")
            return False, None
    except IOError:
        g.es("can not open: " + fileName, color="blue")
        return False, None
    except:
        if 1:
            print "exceptions opening:", fileName
            traceback.print_exc()
        else:
            g.es("exceptions opening: " + fileName,color="red")
            g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2062">def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("&lt;preferences"):
        return # &lt;preferences/&gt; seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/&gt;"):
                done = True ; break
            if self.matchTag("&gt;"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done: # 8/31/04
        while 1:
            if self.matchTag("&lt;defaultDirectory&gt;"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("&lt;/defaultDirectory&gt;")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:" + c.tangle_directory)
            elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
                self.getEscapedString() # ignored
                self.getTag("&lt;/TSyntaxMemo_options&gt;")
            else: break
        self.getTag("&lt;/preferences&gt;")

    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)</t>
<t tx="ekr.20031218072017.2063">def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default</t>
<t tx="ekr.20031218072017.2072">def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    &lt;&lt; assert equivalence of lastVisible methods &gt;&gt;
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors</t>
<t tx="ekr.20031218072017.2081">def openRecentFile(self,name=None):
    
    if not name: return

    c = self ; v = c.currentVnode()
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
    
    fileName = name
    if not g.doHook("recentfiles1",c=c,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame) # 12/12/03
            g.app.setLog(frame.log,"openRecentFile") # Sets the log stream for g.es()
            c = frame.c # 6/10/04: Switch to the new commander so the "recentfiles2" hook doesn't crash.

    g.doHook("recentfiles2",c=c,v=v,fileName=fileName,closeFlag=closeFlag)
</t>
<t tx="ekr.20031218072017.2082">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow==True and # The window was open on startup
    c.changed==False and c.frame.saved==False and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20031218072017.2098">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20031218072017.2099">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20031218072017.2100"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20031218072017.2101"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="ekr.20031218072017.2102">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20031218072017.2103">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20031218072017.2106"></t>
<t tx="ekr.20031218072017.2107">def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        if not at.perfectImportRoot: # A kludge: we shouldn't be importing derived files here!
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta</t>
<t tx="ekr.20031218072017.2108">def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta</t>
<t tx="ekr.20031218072017.2109">def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta</t>
<t tx="ekr.20031218072017.2111"></t>
<t tx="ekr.20031218072017.2112"></t>
<t tx="ekr.20031218072017.2113"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self
    if at.outputFile:
        at.outputFile.flush()
        if self.toStringFlag:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None</t>
<t tx="ekr.20031218072017.2114"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    &lt;&lt; open the file; return on error &gt;&gt;
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.</t>
<t tx="ekr.20031218072017.2116">if toString:
    at.targetFileName = "&lt;new_df.write string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return</t>
<t tx="ekr.20031218072017.2118">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    self.os(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2119">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        self.os(line[i:])</t>
<t tx="ekr.20031218072017.2121"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20031218072017.2122">def norefWrite(self,root,toString=False):

    at = self

    c = at.c ; at.root = root
    at.errors = 0
    at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
    at.sentinels = True # 10/1/03
    at.thinFile = False # 5/17/04
    c.endEditing() # Capture the current headline.
    try:
        at.targetFileName = root.atNorefFileNodeName()
        ok = at.openWriteFile(root,toString)
        if not ok: return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.handleWriteException(root)
        
rawWrite = norefWrite
</t>
<t tx="ekr.20031218072017.2123">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="ekr.20031218072017.2124">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2125">s2 = g.app.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20031218072017.2126">at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) &gt; 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20031218072017.2127">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()</t>
<t tx="ekr.20031218072017.2128">def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20031218072017.2129">if kind == noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
    assert(not at.pending)
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (cDirective,codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.</t>
<t tx="ekr.20031218072017.2130"></t>
<t tx="ekr.20031218072017.2131">def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True</t>
<t tx="ekr.20031218072017.2132">def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20031218072017.2133">def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta</t>
<t tx="ekr.20031218072017.2134">def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)</t>
<t tx="ekr.20031218072017.2135"></t>
<t tx="ekr.20031218072017.2136"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return othersDirective
        elif g.match_word(s,j,"@all"):
            return allDirective
        else:
            return noDirective

    table = (
        ("@all",allDirective),
        ("@c",cDirective),
        ("@code",codeDirective),
        ("@doc",docDirective),
        ("@end_raw",endRawDirective),
        ("@others",othersDirective),
        ("@raw",rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 &gt;= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            noDirective,atDirective)

    # 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1&gt;= n or s[i+1] not in string.ascii_letters):
        return noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # 10/14/02: return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return miscDirective

    return noDirective</t>
<t tx="ekr.20031218072017.2137">def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    return -1 &lt; n1 &lt; n2, n1, n2</t>
<t tx="ekr.20031218072017.2138"># Note:  self.outputFile may be either a fileLikeObject or a real file.

</t>
<t tx="ekr.20031218072017.2140">def executeScript(self,p=None,script=None,useSelectedText=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            &lt;&lt; unredirect output &gt;&gt;
            if not script1:
                g.es("end of script",color="purple")
        except:
            &lt;&lt; unredirect output &gt;&gt;
            g.es("exception executing script")
            fileName,n = g.es_exception(full=False,c=c)
            g.trace(fileName)
            if n is not None:
                &lt;&lt; dump the lines near the error &gt;&gt;
                if p and not script1 and not fileName:
                    c.goToScriptLineNumber(p,script,n)
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        &lt;&lt; unredirect output &gt;&gt;
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() </t>
<t tx="ekr.20031218072017.2143">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20031218072017.2177">frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("&lt;Button-1&gt;", frame.OnActivateLeoEvent)

frame.top.bind("&lt;Activate&gt;", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("&lt;Deactivate&gt;", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("&lt;Control-KeyPress&gt;",frame.OnControlKeyDown)
frame.top.bind("&lt;Control-KeyRelease&gt;",frame.OnControlKeyUp)</t>
<t tx="ekr.20031218072017.2188">def newLeoCommanderAndFrame(self,fileName):
    
    """Create a commander and its view frame for the Leo main window."""
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = g.app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    # Finish creating the frame
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    c.updateRecentFiles(fileName) # 12/01/03
    
    g.doHook("after-create-leo-frame",c=c)
    return c,frame</t>
<t tx="ekr.20031218072017.2189"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

</t>
<t tx="ekr.20031218072017.2222">class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    @others</t>
<t tx="ekr.20031218072017.2249">def createPopupMenu (self,event):
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createMenuEntries(menu,g.app.openWithTable,openWith=1)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # 11/27/03: Don't actually set binding: it would conflict with previous.
    frame.menu.createMenuEntries(menu,table,dontBind=True)</t>
<t tx="ekr.20031218072017.2250">table = (
    ("&amp;Read @file Nodes",None,c.readAtFileNodes),
    ("&amp;Write @file Nodes",None,c.fileCommands.writeAtFileNodes),
    ("-",None,None),
    ("&amp;Tangle","Shift+Ctrl+T",c.tangle),
    ("&amp;Untangle","Shift+Ctrl+U",c.untangle),
    ("-",None,None),
    # 2/16/04: Remove shortcut for Toggle Angle Brackets command.
    ("Toggle Angle &amp;Brackets",None,c.toggleAngleBrackets),
    ("-",None,None),
    ("Cut Node","Shift+Ctrl+X",c.cutOutline),
    ("Copy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort C&amp;hildren",None,c.sortChildren),
    ("&amp;Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("Contract Parent","Alt+0",c.contractParent))</t>
<t tx="ekr.20031218072017.2256"></t>
<t tx="ekr.20031218072017.2257">def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace(g.get_line(s,i))
    classIndent = self.getLeadingIndent(s,i)
    &lt;&lt; set classname and headline, or return i &gt;&gt;
    i = g.skip_line(s,i) # Skip the class line.
    &lt;&lt; create class_vnode &gt;&gt;
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=True)
    &lt;&lt; create nodes for all defs of the class &gt;&gt;
    &lt;&lt; append any other class material &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20031218072017.2258"># Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    classname = s[j:i]
    headline = "class " + classname
else:
    return i</t>
<t tx="ekr.20031218072017.2259"># Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# i points just after the class line.

# Add a docstring to the class node.
docStringSeen = False
j = g.skip_ws_and_nl(s,i)
if g.match(s,j,'"""') or g.match(s,j,"'''"):
    j = g.skip_python_string(s,j)
    if j != len(s): # No scanning error.
        i = j ; docStringSeen = True

body = s[start:i]
body = self.undentBody(body)
if docStringSeen: body = body + '\n'
class_vnode = self.createHeadline(parent,prefix + body,headline)</t>
<t tx="ekr.20031218072017.2260">indent =  self.getLeadingIndent(s,i)
start = i = g.skip_blank_lines(s,i)
parent_vnode = None # 7/6/02
while i &lt; len(s) and indent &gt; classIndent:
    progress = i
    if g.is_nl(s,i):
        backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
        j = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,j)
            if indent &gt; classIndent: i = j
            else: break
        else: i = j
    elif g.match_c_word(s,i,"def"):
        if not parent_vnode:
            &lt;&lt; create parent_vnode &gt;&gt;
        i = start = self.scanPythonDef(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif g.match_c_word(s,i,"class"):
        if not parent_vnode:
            &lt;&lt; create parent_vnode &gt;&gt;
        i = start = self.scanPythonClass(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
    elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress &lt; i)</t>
<t tx="ekr.20031218072017.2261"># This must be done after the declaration reference is generated.
if self.treeType == "@file":
    class_vnode.appendStringToBody("\t@others\n")
else:
    ref = g.angleBrackets(" class " + classname + " methods ")
    class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode</t>
<t tx="ekr.20031218072017.2262">s2 = s[start:i]
if s2:
    class_vnode.appendStringToBody(s2)</t>
<t tx="ekr.20031218072017.2263">def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    &lt;&lt; set headline or return i &gt;&gt;
    &lt;&lt; skip the Python def &gt;&gt;
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    &lt;&lt; Create def node &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20031218072017.2264">i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i</t>
<t tx="ekr.20031218072017.2265"># Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = g.skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
while i &lt; len(s) and indent &gt; defIndent:
    progress = i
    ch = s[i]
    if g.is_nl(s,i):
        backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
        i = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,i)
            if indent &lt;= defIndent:
                break
    elif ch == '#':
        i = g.skip_to_end_of_line(s,i) # 7/29/02
    elif ch == '"' or ch == '\'':
        i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress &lt; i)</t>
<t tx="ekr.20031218072017.2266"># Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20031218072017.2267">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    done = False ; start = i
    while not done and i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent &lt;= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; break on def or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j &lt; i:
        &lt;&lt; Create a child node for declarations &gt;&gt;
    return i</t>
<t tx="ekr.20031218072017.2268">if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)</t>
<t tx="ekr.20031218072017.2269">headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)</t>
<t tx="ekr.20031218072017.2270"># See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; handle possible Python function or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    if not decls_seen: # 2/17/03
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
    &lt;&lt; Append a reference to the methods of this file &gt;&gt;
    &lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="ekr.20031218072017.2271">if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file": # 7/29/02
            parent.appendStringToBody("@others\n") # 7/29/02
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)</t>
<t tx="ekr.20031218072017.2272">if self.treeType == "@root" and self.methodsSeen:
    parent.appendStringToBody(
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")</t>
<t tx="ekr.20031218072017.2273"># Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i &lt; len(s):
    parent.appendStringToBody(s[start:])</t>
<t tx="ekr.20031218072017.2287">def canExtract (self):

    c = self ; body = c.frame.body
    return body and body.hasTextSelection()
    
canExtractSectionNames = canExtract
        
def canExtractSection (self):
    
    __pychecker__ = '--no-implicitreturns' # Suppress bad warning.

    c = self ; body = c.frame.body
    if not body: return False
    
    s = body.getSelectedText()
    if not s: return False

    line = g.get_line(s,0)
    i1 = line.find("&lt;&lt;")
    j1 = line.find("&gt;&gt;")
    i2 = line.find("@&lt;")
    j2 = line.find("@&gt;")
    return -1 &lt; i1 &lt; j1 or -1 &lt; i2 &lt; j2</t>
<t tx="ekr.20031218072017.2322"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    if thinFile:
        self.error("@file-thin not supported before 4.2")
        return
    
    # Remove any old tnodeList.
    if hasattr(root.v.t,"tnodeList"):
        # g.trace("removing tnodeList for ",root)
        delattr(root.v.t,"tnodeList")

    c = self.c
    &lt;&lt; initialize &gt;&gt;
    try:
        &lt;&lt; open the file; return on error &gt;&gt;
        root.clearAllVisitedInTree() # 1/28/04: clear both vnode and tnode bits.
        &lt;&lt; write then entire @file tree &gt;&gt;
        self.closeWriteFile()
        if not nosentinels:
            self.warnAboutOrphandAndIgnoredNodes()
        &lt;&lt; finish writing &gt;&gt;
    except:
        self.handleWriteException()
</t>
<t tx="ekr.20031218072017.2323">self.sentinels = not nosentinels
self.raw = False

self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
c.endEditing() # Capture the current headline.</t>
<t tx="ekr.20031218072017.2324">if nosentinels:
    self.targetFileName = root.atNoSentFileNodeName()
else:
    self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root,toString)
if not ok: return</t>
<t tx="ekr.20031218072017.2325">next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="ekr.20031218072017.2326">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # 21-SEP-2002 DTHEIN: write @first line, whether empty or not
    line = s[j:i]
    self.putBuffered(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2327">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="ekr.20031218072017.2328">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="ekr.20031218072017.2330">@ We set the orphan and dirty flags if there are problems writing the file to force write_Leo_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
    root.setOrphan()
    root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
    os.remove(self.outputFileName) # Delete the temp file.
    g.es("Not written: " + self.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    self.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20031218072017.2336">@ Important note: most hooks are created in the vnode callback routines, _not_ here.
</t>
<t tx="ekr.20031218072017.2337">def OnActivate (self,p,event=None):

    try:
        c = self.c ; gui = g.app.gui
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20031218072017.2338">current = c.currentPosition()

if p == current:
    if self.active:
        self.editLabel(p)
    else:
        self.undimEditLabel()
        gui.set_focus(c,self.canvas) # Essential for proper editing.
else:
    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    if p.v.t.insertSpot != None: # 9/1/02
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
    gui.set_focus(c,c.frame.bodyCtrl)

self.active = True</t>
<t tx="ekr.20031218072017.2339"># Called on click in box and double-click in headline.

def OnBoxClick (self,p):
    
    # g.trace(p)

    # Note: "boxclick" hooks handled by vnode callback routine.
    c = self.c ; gui = g.app.gui

    if p.isExpanded(): p.contract()
    else:              p.expand()

    self.active = True
    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
    self.redraw()</t>
<t tx="ekr.20031218072017.2340">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Bug fix: 7/13/03: Only do this as needed.
    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        try:
            # g.trace(focus)
            tree.endEditLabel()
            tree.dimEditLabel()
        except:
            g.es_event_exception("deactivate tree")</t>
<t tx="ekr.20031218072017.2341">def findVnodeWithIconId (self,id):
    
    # Due to an old bug, id may be a tuple.
    try:
        return self.icon_id_dict.get(id[0])
    except:
        return self.icon_id_dict.get(id)</t>
<t tx="ekr.20031218072017.2342">def OnContinueDrag(self,p,event):

    try:
        &lt;&lt; continue dragging &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20031218072017.2343"># g.trace(p)
assert(p == self.drag_p)

canvas = self.canvas
frame = self.c.frame

if event:
    x,y = event.x,event.y
else:
    x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
    if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

if 0: # no longer used.
    canvas_x = canvas.canvasx(x)
    canvas_y = canvas.canvasy(y)
    id = self.canvas.find_closest(canvas_x,canvas_y)
    # id = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
    &lt;&lt; scroll the canvas as needed &gt;&gt;</t>
<t tx="ekr.20031218072017.2344"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.OnContinueDrag,p,None) # Don't propagate the event.</t>
<t tx="ekr.20031218072017.2345"># This works around an apparent Tk bug.

def OnControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20031218072017.2346">def OnIconClick (self,p,event):
    
    # g.trace(p)
    
    p = p.copy() # Make sure callbacks use the _present_ position.

    tree = self ; canvas = tree.canvas
    if event:
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        id = canvas.find_closest(canvas_x,canvas_y)
        # id = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if id != None:
            try: id = id[0]
            except: pass
            self.drag_p = p
            self.drag_id = id
            
            # Create the bindings.
            id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", p.OnDrag)
            id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", p.OnEndDrag)
            
            # Remember the bindings so deleteBindings can delete them.
            self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
            self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)
    tree.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.
    
def OnIconRightClick (self,p,event):

    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20031218072017.2348">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        if not g.doHook("create-popup-menu",c=c,p=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20031218072017.2349">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    self.popupMenu.unpost()
    
</t>
<t tx="ekr.20031218072017.2350">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20031218072017.2351">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20031218072017.2352">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu ; gui = g.app.gui

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Make certain we have focus so we know when we lose it.
    # I think this is OK for all OSes.
    gui.set_focus(c,menu)</t>
<t tx="ekr.20031218072017.2353">def dragAfter(self,v,after):

    c = self
    if not c.checkMoveWithParentWithWarning(v,after.parent(),True): return
    # Remember both the before state and the after state for undo/redo
    inAtIgnoreRange = v.inAtIgnoreRange()
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        # v.setDirty()
        v.setAllAncestorAtFileNodesDirty() # 1/12/04
        v.moveAfter(after)
        c.undoer.setUndoParams("Drag",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        if inAtIgnoreRange and not v.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            v.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            v.setAllAncestorAtFileNodesDirty()
        c.selectVnode(v)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="ekr.20031218072017.2355">def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
</t>
<t tx="ekr.20031218072017.2387">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(dict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;</t>
<t tx="ekr.20031218072017.2388">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="ekr.20031218072017.2389"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) &gt; 0 and g.os_path_isabs(dir):
    if g.os_path_exists(dir):
        self.default_directory = dir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(dir)
        if not self.default_directory:
            self.error("Directory \"" + dir + "\" does not exist")</t>
<t tx="ekr.20031218072017.2390"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    # 11/14/02: Similar to fix below.
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    # 11/14/02: Fix bug reported by J.M.Gilligan.
    self.language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20031218072017.2391">if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        self.encoding = e</t>
<t tx="ekr.20031218072017.2392"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")</t>
<t tx="ekr.20031218072017.2393">if not old.has_key("lineending") and dict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,dict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20031218072017.2394"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")</t>
<t tx="ekr.20031218072017.2395">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)</t>
<t tx="ekr.20031218072017.2396"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
</t>
<t tx="ekr.20031218072017.2397">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w</t>
<t tx="ekr.20031218072017.2398">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

</t>
<t tx="ekr.20031218072017.2399"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory() # returns "" on error.
    for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if dir and len(dir) &gt; 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                if g.os_path_exists(dir):
                    self.default_directory = dir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(dir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20031218072017.2400">if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))</t>
<t tx="ekr.20031218072017.2611">def destroyAllGlobalWindows (self):
    
    for w in self.globalWindows:
        w.destroySelf()
        
    self.globalWindows = []
    
    self.findFrame = None
    self.pythonFrame = None
</t>
<t tx="ekr.20031218072017.2616">def forceShutdown (self):
    
    """Forces an immediate shutdown of Leo at any time.
    
    In particular, may be called from plugins during startup."""
    
    # Wait until everything is quiet before really quitting.
    g.doHook("end1")
    
    self.log = None # Disable writeWaitingLog
    self.killed = True # Disable all further hooks.
    
    for w in self.windowList[:]:
        self.destroyWindow(w)

    self.finishQuit()</t>
<t tx="ekr.20031218072017.2621"># These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	  =  5 # @code
cDirective		    =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
endAt			 = 21 # @-at
endBody			 = 22 # @-body
# not used   = 23
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @&lt; &lt; ... &gt; &gt;
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)
    
sentinelDict = {
    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,
    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,
    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,
    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,
    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers }</t>
<t tx="ekr.20031218072017.2626">def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    at.initIvars()
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            if partialFlag:
                # We are forcing the read.
                at.read(p)
            else:
                # if p is an orphan, we don't expect to see a derived file,
                # and we shall read a derived file if it exists.
                wasOrphan = p.isOrphan()
                ok = at.read(p)
                if wasOrphan and not ok:
                    # Remind the user to fix the problem.
                    p.setDirty()
                    c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")</t>
<t tx="ekr.20031218072017.2627">def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        if dict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""</t>
<t tx="ekr.20031218072017.2628"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
dir = g.choose(name,g.os_path_dirname(name),None)

if dir and g.os_path_isabs(dir):
    if g.os_path_exists(dir):
        at.default_directory = dir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(dir)
        if not at.default_directory:
            at.error("Directory \"" + dir + "\" does not exist")</t>
<t tx="ekr.20031218072017.2629"># We set the current director to a path so future writes will go to that directory.

k = dict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path and len(path) &gt; 0:
    base = g.getBaseDirectory() # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: " + path)
else:
    at.error("ignoring empty @path")

</t>
<t tx="ekr.20031218072017.2630">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()</t>
<t tx="ekr.20031218072017.2631"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: " + path)</t>
<t tx="ekr.20031218072017.2632"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory() # returns "" on error.
    for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if dir and len(dir) &gt; 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                if g.os_path_exists(dir):
                    at.default_directory = dir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(dir)
</t>
<t tx="ekr.20031218072017.2633">def scanHeader(self,file,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in " + fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines, new_df</t>
<t tx="ekr.20031218072017.2634">@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(file)
    
n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20031218072017.2635">@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False</t>
<t tx="ekr.20031218072017.2636">new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i &lt; len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j &lt; i:
        pass # version = s[j:i]
    else:
        valid = False
</t>
<t tx="ekr.20031218072017.2637"># Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j &gt; -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 1 # 6/8/04
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j &gt; -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
</t>
<t tx="ekr.20031218072017.2638"># The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]</t>
<t tx="ekr.20031218072017.2641">def norefWrite (self,p,toString=False):
    at = self
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    try:    df.norefWrite(p,toString=toString)
    except: at.writeException(p)
    
rawWrite = norefWrite # Compatibility with old scripts.
    
def asisWrite (self,p,toString=False):
    at = self
    try: at.old_df.asisWrite(p,toString=toString) # No new_df.asisWrite method.
    except: at.writeException(p)
    
selentWrite = asisWrite # Compatibility with old scripts.
    
def write (self,p,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    at = self
    write_new = thinFile or not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile,toString=toString,oneNodeOnly=oneNodeOnly)
    except: at.writeException(p)</t>
<t tx="ekr.20031218072017.2642">def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old</t>
<t tx="ekr.20031218072017.2645"># errors is the number of errors seen while reading and writing.
self.errors = 0

# Initialized by atFile.scanAllDirectives.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c
self.shortFileName = "" # short version of file name used for messages.
self.targetFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFile = None # The temporary output file.
self.toStringFlag = False # True if output eventually gets put in self.stringOutput
self.stringOutput = None

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing the at-node directive and restore the old value when the
expansion is complete.
@c
self.indent = 0  # The unit of indentation is spaces, not tabs.

# The root of tree being written.
self.root = None

# Ivars used to suppress newlines between sentinels.
self.suppress_newlines = True # True: enable suppression of newlines.
self.newline_pending = False # True: newline is pending on read or write.

# Support of output_newline option
self.output_newline = g.getOutputNewline()

# Support of @raw
self.raw = False # True: in @raw mode
self.sentinels = True # True: output sentinels while expanding refs.

# The encoding used to convert from unicode to a byte stream.
self.encoding = g.app.config.default_derived_file_encoding

# For interface between 3.x and 4.x read code.
self.file = None
self.importing = False
self.importRootSeen = False

# Set when a file has actually been updated.
self.fileChangedFlag = False</t>
<t tx="ekr.20031218072017.2695"># This method is the same as putSentinel except we don't put an opening newline and leading whitespace.

def putOpenLeoSentinel(self,s):
    
    """Put a +leo sentinel containing s."""
    
    if not self.sentinels:
        return # Handle @nosentinelsfile.

    self.os(self.startSentinelComment)
    self.os(s)
    encoding = self.encoding.lower()
    if encoding != "utf-8":
        self.os("-encoding=")
        self.os(encoding)
        # New in 4.2: encoding fields end in ",."
        # However, there is no point in changing things here.
        # We want to be as compatible as possible with the old versions of Leo.
        self.os(".")
    self.os(self.endSentinelComment)
    if self.suppress_newlines: # 9/27/02
        self.newline_pending = True # Schedule a newline.
    else:
        self.onl() # End of sentinel.
</t>
<t tx="ekr.20031218072017.2718">def closeWriteFile (self):
    
    if not self.outputFile: return

    if self.suppress_newlines and self.newline_pending:
        self.newline_pending = False
        self.onl() # Make sure file ends with a newline.

    self.outputFile.flush()
    self.outputFile.close()
    self.outputFile = None</t>
<t tx="ekr.20031218072017.2720"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root,toString):
    
    self.toStringFlag = toString
    self.errors = 0 # Bug fix: 6/25/04.
    self.root = root # Bug fix: 7/30/04: needed by error logic.

    try:
        self.scanAllDirectives(root)
        valid = self.errors == 0
    except:
        self.writeError("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False
        
    if valid and toString:
        self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
        self.outputFile = g.fileLikeObject()
        self.stringOutput = ""
        return valid

    if valid:
        try:
            fn = self.targetFileName
            self.shortFileName = fn # name to use in status messages.
            self.targetFileName = g.os_path_join(self.default_directory,fn)
            self.targetFileName = g.os_path_normpath(self.targetFileName)
            path = g.os_path_dirname(self.targetFileName)
            if not path or not g.os_path_exists(path):
                self.writeError("path does not exist: " + path)
                valid = False
        except:
            self.writeError("exception creating path:" + fn)
            g.es_exception()
            valid = False

    if valid and g.os_path_exists(self.targetFileName):
        try:
            if not os.access(self.targetFileName,os.W_OK):
                self.writeError("can not create: read only: " + self.targetFileName)
                valid = False
        except:
            pass # os.access() may not exist on all platforms.
        
    if valid:
        try:
            root.clearOrphan() # Bug fix: 5/25/04.
            self.outputFileName = self.targetFileName + ".tmp"
            self.outputFile = open(self.outputFileName,'wb')
            if self.outputFile is None:
                self.writeError("can not create " + self.outputFileName)
                valid = False
        except:
            g.es("exception creating:" + self.outputFileName)
            g.es_exception()
            valid = False
            self.outputFile = None # 3/22/04

    if not valid:
        root.setOrphan()
        root.setDirty()
        self.outputFile = None # 1/29/04
    
    return valid</t>
<t tx="ekr.20031218072017.2755">def __init__(self,c):
    
    """Ctor for 4.x atFile class."""
    
    at = self

    # Initialize the base class.
    oldDerivedFile.__init__(self,c) 

    # For 4.x reading &amp; writing...
    at.inCode = True
    at.thinFile = False
    at.cloneSibCount = 0 # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel

    # For 4.x writing...
    at.docKind = None
    at.pending = [] # Doc part that remains to be written.

    # For 4.x reading...
    at.docOut = [] # The doc part being accumulated.
    at.done = False # True when @-leo seen.
    at.endSentinelStack = []
    at.importing = False
    at.indent = 0 ; at.indentStack = []
    at.lastLines = [] # The lines after @-leo
    at.leadingWs = ""
    at.out = None ; at.outStack = []
    at.root_seen = False # True: root vnode has been handled in this file.
    at.tnodeList = [] ; at.tnodeListIndex = 0
    at.t = None ; at.tStack = []
    
    # For reading thin derived files.
    at.lastThinNode = None ; at.thinNodeStack = [] # Used by createThinChild.
    at.perfectImportRoot = None # The root of the perfect import command.

    &lt;&lt; Create the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20031218072017.2757">def readOpenFile(self,root,file,firstLines,perfectImportRoot=None):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self
    
    # This is safe (just barely) because only this method calls scanText4&gt;
    at.perfectImportRoot = perfectImportRoot

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s</t>
<t tx="ekr.20031218072017.2758">def scanText4 (self,file,p):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(file)
        if len(s) == 0: break
        kind = at.sentinelKind(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20031218072017.2759"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20031218072017.2760">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20031218072017.2761">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20031218072017.2762">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20031218072017.2763">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20031218072017.2764"></t>
<t tx="ekr.20031218072017.2765">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20031218072017.2766">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild(headline)
    
    at.endSentinelStack.append(endNode)</t>
<t tx="ekr.20031218072017.2767"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20031218072017.2768">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20031218072017.2769">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(endOthers)</t>
<t tx="ekr.20031218072017.2770"></t>
<t tx="ekr.20031218072017.2771">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.file)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20031218072017.2772">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)</t>
<t tx="ekr.20031218072017.2773">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(endOthers)</t>
<t tx="ekr.20031218072017.2774"></t>
<t tx="ekr.20031218072017.2775">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20031218072017.2776">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.file)
    at.out.append(s)</t>
<t tx="ekr.20031218072017.2777">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20031218072017.2778">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20031218072017.2779">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
    
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if g.match_word(s,i,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,i,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20031218072017.2780">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20031218072017.2781">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20031218072017.2782">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20031218072017.2783">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.file) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20031218072017.2784">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    at.readError("Ignoring %s sentinel.  Expecting %s" %
        (at.sentinelName(at.endSentinelStack[-1]),
         at.sentinelName(expectedKind)))
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20031218072017.2786">def nodeSentinelText(self,p):
    
    """Return the text of a @+node or @-node sentinel for p."""
    
    at = self ; h = p.headString()
    &lt;&lt; remove comment delims from h if necessary &gt;&gt;
    
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h</t>
<t tx="ekr.20031218072017.2787">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) &gt; 0:
    h = h.replace(start,"")
    h = h.replace(end,"")</t>
<t tx="ekr.20031218072017.2788">def putLeadInSentinel (self,s,i,j,delta):
    
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    
    Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.</t>
<t tx="ekr.20031218072017.2789">def putOpenLeoSentinel(self,s):
    
    """Write @+leo sentinel."""

    at = self
    
    if not at.sentinels:
        return # Handle @nosentinelsfile.
        
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    
    at.putSentinel(s)</t>
<t tx="ekr.20031218072017.2801"># The main colorizer entry point.

def colorize(self,p,incremental=False):

    if self.enabled:
        # g.trace("incremental",incremental)
        self.incremental=incremental
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p)
    else:
        return "ok" # For unit testing.
        
# Called from incremental undo code.
# Colorizes the lines between the leading and trailing lines.
        
def recolor_range(self,p,leading,trailing):
    
    if self.enabled:
        # g.trace("leading,trailing",leading,trailing)
        self.incremental=True
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p,leading=leading,trailing=trailing)
    else:
        return "ok" # For unit testing.</t>
<t tx="ekr.20031218072017.2804"># self.flag is True unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,p):

    p = p.copy()
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)
</t>
<t tx="ekr.20031218072017.2805">def useSyntaxColoring (self,p):
    
    """Return True unless p is unambiguously under the control of @nocolor."""
    
    p = p.copy() ; first = p.copy()
    val = True ; self.killFlag = False
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        no_color = dict.has_key("nocolor")
        color = dict.has_key("color")
        kill_color = dict.has_key("killcolor")
        # A killcolor anywhere disables coloring.
        if kill_color:
            val = False ; self.killFlag = True ; break
        # A color anywhere in the target enables coloring.
        if color and p == first:
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            val = False ; break
        elif color and not no_color:
            val = True ; break

    return val
</t>
<t tx="ekr.20031218072017.2809">def skip_string(self,s,i):
    
    """Skip a string literal."""
    
    first = i # for tracing.
    allow_newlines = self.language == "elisp"
    delim = s[i] ; i += 1
    continue_state = g.choose(delim=="'","singleString","doubleString")
    assert(delim == '"' or delim == "'")
    n = len(s)
    while i &lt; n and s[i] != delim and (allow_newlines or not s[i] == '\n'): # 6/3/04: newline ends most strings.
        if s[i:] == "\\": # virtual trailing newline.
            return n,continue_state
        elif s[i] == '\\': i += 2
        else: i += 1

    if i &gt;= n:
        return n, g.choose(allow_newlines,continue_state,"normal")
    if s[i] == delim:
        i += 1
    return i,"normal"</t>
<t tx="ekr.20031218072017.2817">def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()

    # A horrible kludge: set g.app.log to cover for a possibly missing activate event.
    g.app.setLog(c.frame.log,"doCommand")

    if label == "cantredo": label = "redo"
    if label == "cantundo": label = "undo"
    g.app.commandName = label

    if not g.doHook("command1",c=c,v=p,label=label):
        try:
            command()
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            c.frame.tree.redrawAfterException() # 1/26/04
    
    c = g.top() # 6/17/04: The command can change the commander.
    if c:
        p = c.currentPosition()
        g.doHook("command2",c=c,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20031218072017.2821">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)</t>
<t tx="ekr.20031218072017.2822">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow==True and # The window was open on startup
    c.changed==False and c.frame.saved==False and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20031218072017.2823">def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook."""
    
    c = self ; v = c.currentVnode()
    if not data or len(data) != 3: return # 6/22/03
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,v=v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,v=v,openType=openType,arg=arg,ext=ext)
    except:
        g.es("exception in openWith")
        g.es_exception()

    return "break"</t>
<t tx="ekr.20031218072017.2824">if not ext:
    dict = g.scanDirectives(c)
    language = dict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20031218072017.2825">dict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(v,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20031218072017.2826">searchPath = c.openWithTempFilePath(v,ext)

if g.os_path_exists(searchPath):
    for dict in g.app.openWithFiles:
        if v == dict.get("v") and searchPath == dict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20031218072017.2827">@ We test for changes in both v and the temp file:

- If only v's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = dict.get("encoding")
old_body = dict.get("body")
new_body = v.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = dict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(v,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20031218072017.2828">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20031218072017.2829">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        command  = "os.system("+arg+shortPath+")"
        os.system(arg+path)
    elif openType == "os.startfile":
        command    = "os.startfile("+arg+shortPath+")"
        os.startfile(arg+path)
    elif openType == "exec":
        command    = "exec("+arg+shortPath+")"
        exec arg+path in {} # 12/11/02
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl("+arg+","+filename+','+ shortPath+")"
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = g.os_path_basename(arg)
        command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
        apply(os.spawnl,(os.P_NOWAIT,arg,(filename,path)))
    else:
        command="bad command:"+str(openType)
    # This seems a bit redundant.
    # g.es(command)
except:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2830">def createOpenWithTempFile (self, v, ext):
    
    c = self
    path = c.openWithTempFilePath(v,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        file = open(path,"w")
        # 3/7/03: convert s to whatever encoding is in effect.
        s = v.bodyString()
        dict = g.scanDirectives(c,p=v)
        encoding = dict.get("encoding",None)
        if encoding == None:
            encoding = g.app.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        file.write(s)
        file.flush()
        file.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # 4/22/03: add body and encoding entries to dict for later comparisons.
        dict = {"body":s, "c":c, "encoding":encoding, "f":file, "path":path, "time":time, "v":v}
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt; # 4/22/03
        g.app.openWithFiles.append(dict)
        return path
    except:
        file = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.2831">for d in g.app.openWithFiles[:]: # 6/30/03
    v2 = d.get("v")
    if v.t == v2.t:
        print "removing previous entry in g.app.openWithFiles for",v
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,v,ext):
    
    """Return the path to the temp file corresponding to v and ext."""

    name = "LeoTemp_" + str(id(v.t)) + '_' + g.sanitize_filename(v.headString()) + ext
    name = g.toUnicode(name,g.app.tkEncoding) # 10/20/03

    td = g.os_path_abspath(tempfile.gettempdir())
    path = g.os_path_join(td,name)
    
    # print "openWithTempFilePath",path
    return path</t>
<t tx="ekr.20031218072017.2863">def delete(self):

    c = self ; v = c.currentVnode()
    
    # 6/11/04: Don't assume the body has focus.
    try:
        body = c.frame.body ; bodyCtrl = body.bodyCtrl
        w = bodyCtrl.focus_get()
        if w == bodyCtrl:
            oldSel = body.getTextSelection()
            body.deleteTextSelection()
            body.onBodyChanged(v,"Delete",oldSel=oldSel)
        else:
            # Assume we are changing a headline...
            # This works even if the assumption is incorrect.
            body.deleteTextSelection(w)
            c.frame.tree.onHeadChanged(v)
    except:
        # import traceback ; traceback.print_exc()
        pass</t>
<t tx="ekr.20031218072017.2864">def goToLineNumber (self,root=None,lines=None,n=None):

    c = self ; p = c.currentPosition() ; root1 = root
    if root is None:
        &lt;&lt; set root to the nearest ancestor @file node &gt;&gt;
    if lines is None:
        &lt;&lt; read the file into lines &gt;&gt;
    if n is None:
        &lt;&lt; get n, the line number, from a dialog &gt;&gt;
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        &lt;&lt; count outline lines, setting p,n2,found &gt;&gt;
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        &lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;
    &lt;&lt; select p and make it visible &gt;&gt;
    &lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="ekr.20031218072017.2865">fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                if fileName: break
        if fileName: break
    
if fileName:
    root = p.copy()
else:
    g.es("Go to line number: ancestor must be @file node", color="blue")
    return</t>
<t tx="ekr.20031218072017.2866"># 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    file=open(fileName)
    lines = file.readlines()
    file.close()
except:
    g.es("not found: " + fileName)
    return</t>
<t tx="ekr.20031218072017.2867">n = g.app.gui.runAskOkCancelNumberDialog("Enter Line Number","Line number:")
if n == -1:
    return</t>
<t tx="ekr.20031218072017.2868">p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) &gt; 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines &gt;= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)</t>
<t tx="ekr.20031218072017.2869">if gnx:
    &lt;&lt; 4.2: get node from gnx &gt;&gt;
elif childIndex == -1:
    &lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
    &lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="ekr.20031218072017.2870"># This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
    tnodeIndex = max(0,tnodeIndex)
    &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
            
if not ok:
    # Fall back to the old logic.
    &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="ekr.20031218072017.2871">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1</t>
<t tx="ekr.20031218072017.2872">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False</t>
<t tx="ekr.20031218072017.2873">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return</t>
<t tx="ekr.20031218072017.2874">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex &lt;= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20031218072017.2875">c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()</t>
<t tx="ekr.20031218072017.2876">if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()</t>
<t tx="ekr.20031218072017.2877">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    &lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
</t>
<t tx="ekr.20031218072017.2878"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
</t>
<t tx="ekr.20031218072017.2879">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1</t>
<t tx="ekr.20031218072017.2880">if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.</t>
<t tx="ekr.20031218072017.2881">if newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")</t>
<t tx="ekr.20031218072017.2882">def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n</t>
<t tx="ekr.20031218072017.2896">def sortTopLevel (self):
    
    # Create a list of position, headline tuples
    c = self ; root = c.rootPosition()
    if not root: return
    &lt;&lt; Set the undo info for sortTopLevel &gt;&gt;
    pairs = []
    for p in root.self_and_siblings_iter(copy=True):
        pairs.append((p.headString().lower(),p),)
    # Sort the list on the headlines.
    pairs.sort()
    sortedNodes = pairs
    # Move the nodes
    c.beginUpdate()
    h,p = sortedNodes[0]
    if p != root:
        p.setAllAncestorAtFileNodesDirty()
        p.moveToRoot(oldRoot=root)
        p.setAllAncestorAtFileNodesDirty()
    for h,next in sortedNodes[1:]:
        next.moveAfter(p)
        p = next
    if 0:
        g.trace("-----moving done")
        for p in c.rootPosition().self_and_siblings_iter():
            print p,p.v
    c.endUpdate()</t>
<t tx="ekr.20031218072017.2897"># Get the present list of children.
sibs = []

for sib in root.self_and_siblings_iter(copy=True):
    sibs.append(sib)
    
c.undoer.setUndoParams("Sort Top Level",root,sort=sibs)</t>
<t tx="ekr.20031218072017.2900">def contractAllHeadlines (self):

    c = self
    
    c.beginUpdate()
    if 1: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    c.endUpdate()

    c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="ekr.20031218072017.2910">def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()</t>
<t tx="ekr.20031218072017.2945"></t>
<t tx="ekr.20031218072017.2946">def dragCloneToNthChildOf (self,v,parent,n):

    c = self
    c.beginUpdate()
    if 1: # Update range...
        # g.trace("v,parent,n:",v.headString(),parent.headString(),n)
        clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete(v) # Destroys clone and makes v the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        # Remember both the before state and the after state for undo/redo
        inAtIgnoreRange = v.inAtIgnoreRange()
        oldBack = v.back()
        oldParent = v.parent()
        oldN = v.childIndex()
        c.endEditing()
        # clone.setDirty()
        clone.setAllAncestorAtFileNodesDirty() # 1/12/04
        clone.moveToNthChildOf(parent,n)
        c.undoer.setUndoParams("Drag &amp; Clone",clone,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
        if inAtIgnoreRange and not v.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            v.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            v.setAllAncestorAtFileNodesDirty()
        c.selectVnode(clone)
        c.setChanged(True)
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20031218072017.2947">def dragToNthChildOf(self,v,parent,n):

    c = self
    if not c.checkMoveWithParentWithWarning(v,parent,True): return
    # Remember both the before state and the after state for undo/redo
    inAtIgnoreRange = v.inAtIgnoreRange()
    oldBack = v.back()
    oldParent = v.parent()
    oldN = v.childIndex()
    c.beginUpdate()
    if 1: # inside update...
        c.endEditing()
        v.setAllAncestorAtFileNodesDirty()
        v.moveToNthChildOf(parent,n)
        c.undoer.setUndoParams("Drag",v,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN)
        if inAtIgnoreRange and not v.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            v.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            v.setAllAncestorAtFileNodesDirty()
        c.selectVnode(v)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="ekr.20031218072017.2948">def dragCloneAfter (self,v,after):

    c = self
    c.beginUpdate()
    if 1: # Update range...
        clone = v.clone(v) # Creates clone.  Does not set undo.
        # g.trace("v,after:",v.headString(),after.headString())
        if not c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            g.trace("invalid clone move")
            clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        # Remember both the before state and the after state for undo/redo
        inAtIgnoreRange = clone.inAtIgnoreRange()
        oldBack = v.back()
        oldParent = v.parent()
        oldN = v.childIndex()
        c.endEditing()
        clone.setAllAncestorAtFileNodesDirty()
        clone.moveAfter(after)
        c.undoer.setUndoParams("Drag &amp; Clone",clone,
            oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
        if inAtIgnoreRange and not clone.inAtIgnoreRange():
            # The moved node have just become newly unignored.
            clone.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            clone.setAllAncestorAtFileNodesDirty()
        c.selectVnode(clone)
        c.setChanged(True)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20031218072017.2955"></t>
<t tx="ekr.20031218072017.2956">def canContractAllHeadlines (self):
    
    c = self
    
    for p in c.allNodes_iter():
        if p.isExpanded():
            return True

    return False</t>
<t tx="ekr.20031218072017.2957">def canContractAllSubheads (self):

    c = self ; current = c.currentPosition()
    
    for p in current.subtree_iter():
        if p != current and p.isExpanded():
            return True

    return False</t>
<t tx="ekr.20031218072017.2958">def canContractParent (self):

    c = self
    return c.currentPosition().parent()</t>
<t tx="ekr.20031218072017.2959">def canContractSubheads (self):
    
    c = self ; current = c.currentPosition()

    for child in current.children_iter():
        if child.isExpanded():
            return True
        
    return False</t>
<t tx="ekr.20031218072017.2960">def canDeleteHeadline (self):
    
    c = self ; p = c.currentPosition()

    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline</t>
<t tx="ekr.20031218072017.2961">def canDemote (self):

    c = self
    return c.currentPosition().hasNext()</t>
<t tx="ekr.20031218072017.2962">def canExpandAllHeadlines (self):
    
    c = self
    
    for p in c.allNodes_iter():
        if not p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2963">def canExpandAllSubheads (self):

    c = self
    
    for p in c.currentPosition().subtree_iter():
        if not p.isExpanded():
            return True
        
    return False</t>
<t tx="ekr.20031218072017.2964">def canExpandSubheads (self):

    c = self ; current = c.currentPosition()
    
    for p in current.children_iter():
        if p != current and not p.isExpanded():
            return True

    return False</t>
<t tx="ekr.20031218072017.2965">def canFindMatchingBracket (self):
    
    c = self ; brackets = "()[]{}"
    c1 = c.frame.body.getCharAtInsertPoint()
    c2 = c.frame.body.getCharBeforeInsertPoint()
    return (c1 and c1 in brackets) or (c2 and c2 in brackets)</t>
<t tx="ekr.20031218072017.2966">def canGoToNextDirtyHeadline (self):
    
    c = self ; current = c.currentPosition()

    for p in c.allNodes_iter():
        if p != current and p.isDirty():
            return True
    
    return False</t>
<t tx="ekr.20031218072017.2967">def canGoToNextMarkedHeadline (self):
    
    c = self ; current = c.currentPosition()
        
    for p in c.allNodes_iter():
        if p != current and p.isMarked():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2968">def canMarkChangedHeadlines (self):
    
    c = self
    
    for p in c.allNodes_iter():
        if p.isDirty():
            return True
    
    return False</t>
<t tx="ekr.20031218072017.2969">def canMarkChangedRoots (self):
    
    c = self
    
    for p in c.allNodes_iter():
        if p.isDirty and p.isAnyAtFileNode():
            return True

    return False</t>
<t tx="ekr.20031218072017.2970">def canMoveOutlineDown (self):

    c = self ; current = c.currentPosition()
        
    p = current.visNext()
    while p and current.isAncestorOf(p):
        p.moveToVisNext()

    if c.hoistStack:
        h,junk = c.hoistStack[-1]
        return p and p != h and h.isAncestorOf(p)
    else:
        return p</t>
<t tx="ekr.20031218072017.2971">def canMoveOutlineLeft (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
        h,junk = c.hoistStack[-1]
        if p and p.hasParent():
            p.moveToParent()
            return p != h and h.isAncestorOf(p)
        else:
            return False
    else:
        return p and p.hasParent()</t>
<t tx="ekr.20031218072017.2972">def canMoveOutlineRight (self):

    c = self ; p = c.currentPosition()
    
    if c.hoistStack:
        h,junk = c.hoistStack[-1]
        return p and p.hasBack() and p != h
    else:
        return p and p.hasBack()</t>
<t tx="ekr.20031218072017.2973">def canMoveOutlineUp (self):

    c = self ; p = c.currentPosition()
    if not p: return False
    
    pback = p.visBack()
    if not pback: return False

    if c.hoistStack:
        h,junk = c.hoistStack[-1]
        return h != p and h.isAncestorOf(pback)
    else:
        return True</t>
<t tx="ekr.20031218072017.2974">def canPasteOutline (self,s=None):

    c = self
    if s == None:
        s = g.app.gui.getTextFromClipboard()
    if not s:
        return False

    # g.trace(s)
    if g.match(s,0,g.app.prolog_prefix_string):
        return True
    elif len(s) &gt; 0:
        return c.importCommands.stringIsValidMoreFile(s)
    else:
        return False</t>
<t tx="ekr.20031218072017.2975">def canPromote (self):

    c = self ; v = c.currentVnode()
    return v and v.hasChildren()</t>
<t tx="ekr.20031218072017.2976">def canRevert (self):

    # c.mFileName will be "untitled" for unsaved files.
    c = self
    return (c.frame and c.mFileName and c.isChanged())</t>
<t tx="ekr.20031218072017.2977"># 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadBack()
    
def canSelectThreadNext (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadNext()

def canSelectVisBack (self):
    c = self ; p = c.currentPosition()
    return p.hasVisBack()
    
def canSelectVisNext (self):
    c = self ; p = c.currentPosition()
    return p.hasVisNext()</t>
<t tx="ekr.20031218072017.2978">def canShiftBodyLeft (self):

    c = self ; body = c.frame.body
    return body and body.getAllText()

canShiftBodyRight = canShiftBodyLeft</t>
<t tx="ekr.20031218072017.2979">def canSortChildren (self):
    
    c = self ; p = c.currentPosition()
    return p and p.hasChildren()

def canSortSiblings (self):

    c = self ; p = c.currentPosition()
    return p and (p.hasNext() or p.hasBack())</t>
<t tx="ekr.20031218072017.2980">def canUndo (self):

    c = self
    return c.undoer.canUndo()
    
def canRedo (self):

    c = self
    return c.undoer.canRedo()</t>
<t tx="ekr.20031218072017.2981">def canUnmarkAll (self):
    
    c = self
    
    for p in c.allNodes_iter():
        if p.isMarked():
            return True

    return False</t>
<t tx="ekr.20031218072017.2983">def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    return self._currentPosition.copy() # Must make the second copy now.
    
def setCurrentPosition (self,p):
    
    """Set the presently selected position."""

    self._currentPosition = p.copy() # Must make the first copy _now_
    
# Define these for compatibiility with old scripts.
currentVnode = currentPosition
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20031218072017.2985">def clearAllVisited (self):

    c = self

    for p in c.allNodes_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()
</t>
<t tx="ekr.20031218072017.2988">def rootPosition(self):
    
    """Return the root position."""
    
    return self._rootPosition.copy()

def setRootPosition(self,p):
    
    """Set the root positioin."""

    self._rootPosition = p.copy() # Potential bug fix: 5/2/04
    
# Define these for compatibiility with old scripts.
rootVnode = rootPosition
setRootVnode = setRootPosition</t>
<t tx="ekr.20031218072017.2989">def setChanged (self,changedFlag):

    c = self
    if not c.frame: return
    
    # import traceback ; traceback.print_stack()

    # Clear all dirty bits _before_ setting the caption.
    # 9/15/01 Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        # g.trace("clearing all dirty bits")
        for p in c.allNodes_iter():
            if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
                p.clearDirty()
    # Update all derived changed markers.
    c.changed = changedFlag
    s = c.frame.getTitle()
    if len(s) &gt; 2 and not c.loading: # don't update while loading.
        if changedFlag:
            # import traceback ; traceback.print_stack()
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])</t>
<t tx="ekr.20031218072017.3019">def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame
    self.initIvars()

def initIvars(self):

    # General
    self.maxTnodeIndex = 0
    self.numberOfTnodes = 0
    self.topPosition = None
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = g.app.config.new_leo_file_encoding
    # For reading
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.fileFormatNumber = 0
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    self.fileBuffer = None ; self.fileIndex = 0
    self.currentVnodeStack = [] # A stack of vnodes giving the current position.
    self.topVnodeStack     = [] # A stack of vnodes giving the top position.
    # For writing
    self.read_only = False
    self.outputFile = None # File for normal writing
    self.outputList = None # List of strings for pasting
    self.openDirectory = None
    self.topVnode = None
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}  # keys are gnx strings as returned by canonicalTnodeIndex.</t>
<t tx="ekr.20031218072017.3022">def getClipboardHeader (self):

    if self.getOpenTag("&lt;leo_header"):
        return # &lt;leo_header&gt; or &lt;leo_header/&gt; has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("&gt;&lt;/leo_header&gt;"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/&gt;")
            break</t>
<t tx="ekr.20031218072017.3046">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c ; config = g.app.config

    self.assignFileIndices()
    if not outlineOnlyFlag:
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        &lt;&lt; create the output file &gt;&gt;
        &lt;&lt; update leoConfig.txt &gt;&gt;
        &lt;&lt; put the .leo file &gt;&gt;
    except:
        &lt;&lt; report the exception &gt;&gt;
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
    if self.outputFile:
        &lt;&lt; close the output file &gt;&gt;
        &lt;&lt; delete backup file &gt;&gt;
        return True
    else: # This probably will never happen because errors should raise exceptions.
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
        
write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20031218072017.3047"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    try:
        backupName = g.os_path_join(g.app.loadDir,fileName)
        backupName = fileName + ".bak"
        if g.os_path_exists(backupName):
            os.unlink(backupName)
        # os.rename(fileName,backupName)
        g.utils_rename(fileName,backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception creating backup file: " + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception creating backup file: " + backupName)
        g.es_exception()
        backupName = None
        return False
else:
    backupName = None</t>
<t tx="ekr.20031218072017.3048">if backupName and g.os_path_exists(backupName):
    try:
        os.unlink(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
</t>
<t tx="ekr.20031218072017.3049">g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
    try:
        os.unlink(fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting: " + fileName)
            g.es_exception()
    except:
        g.es("exception deleting: " + fileName)
        g.es_exception()
        
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    try:
        g.utils_rename(backupName, fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception renaming " + backupName + " to " + fileName)
            g.es_exception()
    except:
        g.es("exception renaming " + backupName + " to " + fileName)
        g.es_exception()</t>
<t tx="ekr.20031218072017.3069">def changeAll(self):

    c = self.c ; st = self.s_text ; gui = g.app.gui
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1:
            count += 1
            self.batchChange(pos1,pos2,count)
            line = gui.getLineContainingIndex(st,pos1)
            self.printLine(line,allFlag=True)
        else: break
    c.endUpdate()
    # Make sure the headline and body text are updated.
    v = c.currentVnode()
    c.frame.tree.onHeadChanged(v)
    c.frame.body.onBodyChanged(v,"Can't Undo")
    if count &gt; 0:
        # A change was made.  Tag the end of the Change All command.
        c.undoer.setUndoParams("Change All",v)
    g.es("changed: ",count)
    self.restore(data)</t>
<t tx="ekr.20031218072017.3082"></t>
<t tx="ekr.20031218072017.3083">def checkArgs (self):

    c = self.c
    val = True
    if not c.search_headline_flag and not c.search_body_flag:
        g.es("not searching headline or body")
        val = False
    if len(c.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val</t>
<t tx="ekr.20031218072017.3084"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = c.search_headline_flag # Search headlines first.
    self.errors = 0

    # Select the first node.
    if c.suboutline_only_flag or c.node_only_flag or c.selection_only_flag: # 11/9/03
        self.v = c.currentVnode()
        if c.selection_only_flag: self.selStart,self.selEnd = c.frame.body.getTextSelection()
        else:                     self.selStart,self.selEnd = None,None
    else:
        v = c.rootVnode()
        if c.reverse_flag:
            while v and v.next():
                v = v.next()
            v = v.lastNode()
        self.v = v

    # Set the insert point.
    self.initBatchText()</t>
<t tx="ekr.20031218072017.3085"># Returns s_text with "insert" point set properly for batch searches.
def initBatchText(self):
    v = self.v
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,v.headString(), v.bodyString())
    return self.init_s_text(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    v = self.v
    s = g.choose(self.in_headline,v.headString(), v.bodyString())
    return self.init_s_text(s)</t>
<t tx="ekr.20031218072017.3086"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; v = self.v

    if c.search_headline_flag and c.search_body_flag:
        # Do not change this line without careful thought and extensive testing!
        self.in_headline = (v == c.frame.tree.editPosition())
    else:
        self.in_headline = c.search_headline_flag</t>
<t tx="ekr.20031218072017.3087"># For incremental searches

def initInteractiveCommands(self):

    c = self.c ; v = self.v ; gui = g.app.gui

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(v)
        t = v.edit_text()
        sel = None
    else:
        t = c.frame.bodyCtrl
        sel = gui.getTextSelection(t)
    pos = gui.getInsertPoint(t)
    st = self.initNextText()
    gui.set_focus(c,t)
    gui.setInsertPoint(st,pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = c.wrap_flag
    if c.wrap_flag and self.wrapVnode == None:
        self.wrapPos = pos
        # Do not set self.wrapVnode here: that must be done after the first search.</t>
<t tx="ekr.20031218072017.3088">def printLine (self,line,allFlag=False):

    c = self.c
    both = c.search_body_flag and c.search_headline_flag
    context = c.batch_flag # "batch" now indicates context

    if allFlag and both and context:
        g.es(self.v)
        type = g.choose(self.in_headline,"head: ","body: ")
        g.es(type + line)
    elif allFlag and context and not self.v.isVisited():
        # We only need to print the context once.
        g.es(self.v)
        g.es(line)
        self.v.setVisited()
    else:
        g.es(line)</t>
<t tx="ekr.20031218072017.3089"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,v,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectVnode(v)
    if not in_headline:

        if 0: # Looks bad.
            gui.setSelectionRange(t,start,end)
        else: # Looks good and provides clear indication of failure or termination.
            gui.setSelectionRange(t,insert,insert)

        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        gui.set_focus(c,t)

    </t>
<t tx="ekr.20031218072017.3090">def save (self):

    c = self.c ; v = self.v ; gui = g.app.gui
    t = g.choose(self.in_headline,v.edit_text(),c.frame.bodyCtrl)
    insert = gui.getInsertPoint(t)
    sel = gui.getSelectionRange(t)
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,v,t,insert,start,end)</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, v.edit_text() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; v = self.v ; gui = g.app.gui
    
    # g.trace()
    c.frame.bringToFront() # Needed on the Mac

    c.beginUpdate()
    if 1: # range of update...
        c.selectVnode(v)
        c.frame.tree.redraw_now() # Redraw now so selections are not destroyed.
        # Select the found vnode again after redraw.
        if self.in_headline:
            c.editPosition(v)
            c.frame.tree.setNormalLabelState(v)
            assert(v.edit_text())
        else:
            c.selectVnode(v)
    c.endUpdate(False) # Do not draw again!

    t = g.choose(self.in_headline,v.edit_text(),c.frame.bodyCtrl)
    
    insert = g.choose(c.reverse_flag,pos,newpos)
    # g.trace(pos,newpos,t)
    gui.setInsertPoint(t,insert)
    gui.setSelectionRange(t,pos,newpos)
    gui.makeIndexVisible(t,insert)
    gui.set_focus(c,t)
    if c.wrap_flag and not self.wrapVnode:
        self.wrapVnode = self.v
</t>
<t tx="ekr.20031218072017.3112">def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()

    if full:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        
    if 1:
        n = g.getLastTracebackLineNumber()
    else:
        # old, kludgy code...
        &lt;&lt; look for lines containing a specific message &gt;&gt;

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    return n</t>
<t tx="ekr.20031218072017.3137"># pychecker bug: pychecker complains that there is no attribute time.clock

def getTime():
    return time.clock()
    
def esDiffTime(message, start):
    g.es("%s %6.3f" % (message,(time.clock()-start)))
    return time.clock()
    
def printDiffTime(message, start):
    print "%s %6.3f" % (message,(time.clock()-start))
    return time.clock()</t>
<t tx="ekr.20031218072017.3152">def scanAtFileOptions (h,err_flag=False):
    
    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        &lt;&lt; scan another @file option &gt;&gt;
        
    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)
            
    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList</t>
<t tx="ekr.20031218072017.3153">i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err &gt; -1:
    g.es("unknown option:" + h[err:i] + " in " + h)</t>
<t tx="ekr.20031218072017.3160">@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.
    
    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3179"># We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1</t>
<t tx="ekr.20031218072017.3202"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j &gt; 0:
        s = s[j:]
    return s</t>
<t tx="ekr.20031218072017.3210">def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v</t>
<t tx="ekr.20031218072017.3211">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None</t>
<t tx="ekr.20031218072017.3212">def importFilesCommand (self,files,treeType,
    perfectImport=True,testing=False,verbose=False):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)</t>
<t tx="ekr.20031218072017.3213">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)</t>
<t tx="ekr.20031218072017.3250"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

    &lt;&lt; define scanCText vars &gt;&gt;
    while i &lt; len(s):
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        # These cases skip tokens.
        if ch == '/':
            &lt;&lt; handle possible C comments &gt;&gt;
        elif ch == '"' or ch == '\'':
            i = g.skip_string(s,i)
        # These cases help determine where functions start.
        elif ch == '=':
            &lt;&lt; handle equal sign in C &gt;&gt;
        elif ch == '(':
            &lt;&lt; handle open paren in C &gt;&gt;
        elif ch == ';':
            &lt;&lt; handle semicolon in C &gt;&gt;
        # These cases and the default case can create child nodes.
        elif ch == '#':
            &lt;&lt; handle # sign &gt;&gt;
        elif ch == '{':
            &lt;&lt; handle open curly bracket in C &gt;&gt;
        elif g.is_c_id(ch):
            &lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="ekr.20031218072017.3251">c = self.c
include_seen = method_seen = False
methodKind = g.choose(self.fileType==".c","functions","methods")
lparen = None   # Non-null if '(' seen at outer level.
scan_start = function_start = 0
name = None
i = 0</t>
<t tx="ekr.20031218072017.3252"># if statements may contain function definitions.
i += 1  # Skip the '#'
if not include_seen and g.match_c_word(s,i,"include"):
    include_seen = True
    &lt;&lt; create a child node for all #include statements &gt;&gt;
else:
    j = i
    i = g.skip_pp_directive(s,i)</t>
<t tx="ekr.20031218072017.3253"># Scan back to the start of the line.
include_start = i = g.find_line_start(s,i)

# Scan to the next line that is neither blank nor and #include.
i = g.skip_pp_directive(s,i)
i = g.skip_nl(s,i)
include_end = i
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    if g.match_c_word(s,i,"#include"):
        i = g.skip_pp_directive(s,i)
        i = g.skip_nl(s,i)
        include_end = i
    elif i + 2 &lt; len(s) and s[i] == '\\':
        # Handle possible comment.
        if s[i+1] == '\\':
            i = g.skip_to_end_of_line(s,i)
        elif s[i+1] == '*':
            i = g.skip_block_comment(s,i + 2)
        else:
            i = include_end ; break
    else:
        i = include_end ; break
        

headline = g.angleBrackets(" " + self.methodName + " #includes ")
body = s[include_start:include_end]
body = self.undentBody(body)
prefix = g.choose(self.treeType == "@file","","@code\n\n")
self.createHeadline(parent,prefix + body,headline)
parent.appendStringToBody("@ignore\n" + self.rootLine + "@language c\n")

# Append any previous text to the parent's body.
save_ip = i ; i = scan_start
while i &lt; include_start and g.is_ws_or_nl(s,i):
    i += 1
if i &lt; include_start:
    parent.appendStringToBody(s[i:include_start])
scan_start = function_start = i = save_ip
# Append the headline to the parent's body.
parent.appendStringToBody(headline + "\n")</t>
<t tx="ekr.20031218072017.3254">j = i = g.skip_braces(s,i) # Skip all inner blocks.

# This may fail if #if's contain unmatched curly braces.
if (g.match(s,i,'}') and lparen and name and function_start):
    # Point i _after_ the last character of the function.
    i += 1
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
    function_end = i
    if method_seen:
        # Include everything after the last function.
        function_start = scan_start 
    else:
        &lt;&lt; create a declaration node &gt;&gt;
        &lt;&lt; append C function/method reference to parent node &gt;&gt;
    headline = name
    body = s[function_start:function_end]
    body = self.massageBody(body,"functions")
    self.createHeadline(parent,body,headline)
    
    method_seen = True
    scan_start = function_start = i # Set the start of the _next_ function.
    lparen = None
else:
    i += 1</t>
<t tx="ekr.20031218072017.3255">save_ip = i
i = scan_start
while i &lt; function_start and g.is_ws_or_nl(s,i):
    i += 1
if i &lt; function_start:
    headline = g.angleBrackets(" " + self.methodName + " declarations ")
    # Append the headline to the parent's body.
    parent.appendStringToBody(headline + "\n")
    decls = s[scan_start:function_start]
    decls = self.undentBody(decls)
    if self.treeType == "@file":
        body = decls
    else:
        body = "@code\n\n" + decls
    self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="ekr.20031218072017.3256">if self.treeType == "@file":
    parent.appendStringToBody("@others\n")
else:
    cweb = c.target_language == "cweb"
    lb = g.choose(cweb,"@&lt;","&lt;&lt;")
    rb = g.choose(cweb,"@&gt;","&gt;&gt;")
    parent.appendStringToBody(
        lb + " " + self.methodName + " " + methodKind + " " + rb + "\n")</t>
<t tx="ekr.20031218072017.3257">if g.match_c_word(s,i,"typedef"):
    i = g.skip_typedef(s,i)
    lparen = None
elif g.match_c_word(s,i,"struct"):
    i = g.skip_typedef(s,i)
    # lparen = None ;  # This can appear in an argument list.
elif g.match_c_word(s,i,"union"):
    i = g.skip_typedef(s,i)
    # lparen = None ;  # This can appear in an argument list.
elif g.match_c_word(s,i,"namespace"):
    g.trace("namespace")
    &lt;&lt; create children for the namespace &gt;&gt;
# elif g.match_c_word(s,i,"class"):
    # &lt; &lt; create children for the class &gt; &gt;
else:
    # Remember the last name before an open parenthesis.
    if lparen == None:
        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
    else:
        i = g.skip_c_id(s,i)
    &lt;&lt; test for operator keyword &gt;&gt;
</t>
<t tx="ekr.20031218072017.3258">@ Namesspaces change the self.moduleName and recursively call self function with a text covering only the range of the namespace. This effectively changes the definition line of any created child nodes. The namespace is written to the top level.
@c

# skip the "namespace" keyword.
i += len("namespace")
i = g.skip_ws_and_nl(s,i)
# Skip the namespace name.
namespace_name_start = i
namespace_name_end = None
if i &lt; len(s) and g.is_c_id(s[i]):
    i = g.skip_c_id(s,i)
    namespace_name_end = i - 1
else: namespace_name_start = None
# Skip the '{'
i = g.skip_ws_and_nl(s,i)
if g.match(s,i,'{') and namespace_name_start:
    # g.trace(s[i],s[namespace_name_start:namespace_name_end+1])
    inner_ip = i + 1
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        # Append everything so far to the body.
        if inner_ip &gt; scan_start:
            parent.appendStringToBody(s[scan_start:inner_ip])
        # Save and change self.moduleName to namespaceName
        savedMethodName = self.methodName
        namespaceName = s[namespace_name_start:namespace_name_end+1]
        self.methodName = "namespace " + namespaceName
        # Recursively call this function .
        self.scanCText(s[inner_ip:],parent)
        # Restore self.moduleName and continue scanning.
        self.methodName = savedMethodName
        scan_start = function_start = i</t>
<t tx="ekr.20031218072017.3259"># We treat a C++ a construct such as operator + as a function name.
if g.match(name,0,"operator"):
    j = i
    i = g.skip_ws(s,i) # Don't allow newline in headline.
    if (i &lt; len(s) and not g.is_c_id(s[i]) and
        s[i]!=' ' and s[i]!='\n' and s[i]!='\r'):
        while (i &lt; len(s) and not g.is_c_id(s[i]) and
            s[i]!=' ' and s[i]!='\n' and s[i] != '\r'):
            i += 1
        name = s[j:i] # extend the name.</t>
<t tx="ekr.20031218072017.3260">if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1</t>
<t tx="ekr.20031218072017.3261">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
i = g.skip_ws(s,i) # 6/9/04
if g.match(s,i,'{'):
    i = g.skip_braces(s,i)</t>
<t tx="ekr.20031218072017.3262">lparen = i
# This will skip any equal signs inside the paren.
i = g.skip_parens(s,i)
if g.match(s,i,')'):
    i += 1
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        lparen = None # not a function definition.
else: lparen = None</t>
<t tx="ekr.20031218072017.3263">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
    function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="ekr.20031218072017.3264"># Used by C, Java and Pascal parsers.
# Do nothing if only whitespace is left.

i = g.skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
    parent.appendStringToBody(s[scan_start:])</t>
<t tx="ekr.20031218072017.3300">def removeSentinelsCommand (self,paths):

    self.setEncoding()

    for fileName in paths:
        path, self.fileName = g.os_path_split(fileName) # path/fileName
        &lt;&lt; Read file into s &gt;&gt;
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = g.app.config.remove_sentinels_extension
        if ext == None or len(ext) == 0:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        # g.trace(repr(s))
        &lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="ekr.20031218072017.3301">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return</t>
<t tx="ekr.20031218072017.3302"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None</t>
<t tx="ekr.20031218072017.3303">@ Properly removes all sentinel lines in s.  Only leading single-line comments may be sentinels.

line_delim, start_delim and end_delim are the comment delimiters.
@c

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

    i = 0 ; result = [] ; nlSeen = True
    while i &lt; len(s):
        # g.trace(i,nlSeen,g.get_line_after(s,i))
        start = i # The start of the next syntax element.
        if nlSeen or g.is_nl(s,i):
            nlSeen = False
            &lt;&lt; handle possible sentinel &gt;&gt;
        if line_delim and g.match(s,i,line_delim):
            i = g.skip_to_end_of_line(s,i)
        elif start_delim and end_delim and g.match(s,i,start_delim):
            i = g.skip_matching_delims(s,i,start_delim,end_delim)
        elif g.match(s,i,"'") or g.match(s,i,'"'):
            i = g.skip_string(s,i)
        else:
            i += 1
        assert(i == 0 or start&lt;i)
        result.append(s[start:i])# 12/11/03: hugely faster than string concatenation.

    result = ''.join(result)
    return result</t>
<t tx="ekr.20031218072017.3304">if g.is_nl(s,i):
    i = g.skip_nl(s,i)
    nlSeen = True
i = g.skip_ws(s,i)
# g.trace(i,g.get_line(s,i))
if line_delim:
    if g.match(s,i,line_delim):
        j = i+len(line_delim)
        if g.match(s,j,"@"):
            i = g.skip_line(s,i)
            nlSeen = True
            continue # Remove the entire sentinel line, including the newline.
        else:
            i = g.skip_to_end_of_line(s,i)
elif start_delim:
    if g.match(s,i,start_delim):
        j = i+len(start_delim)
        i = g.skip_matching_delims(s,i,start_delim,end_delim)
        if g.match(s,j,"@"):
            continue # Remove the sentinel
elif nlSeen and start &lt; i:
    # Put the newline that was at the start of this line.
    result.append(s[start:i])
    continue</t>
<t tx="ekr.20031218072017.3319"># We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    c = self.c
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i &lt; len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,c.tab_width)
        result += line
    return result</t>
<t tx="ekr.20031218072017.3345">def __repr__ (self):
    
    if self.t:
        return "&lt;vnode %d:'%s'&gt;" % (id(self),self.cleanHeadString())
    else:
        return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="ekr.20031218072017.3346"></t>
<t tx="ekr.20031218072017.3348"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="ekr.20031218072017.3350">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="ekr.20031218072017.3352">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="ekr.20031218072017.3353">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="ekr.20031218072017.3368">def isCloned (self):
    
    return len(self.t.vnodeList) &gt; 1</t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="ekr.20031218072017.3395">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

def expand(self):

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="ekr.20031218072017.3398">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20031218072017.3401"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20031218072017.3419">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAfter(self)

    return v</t>
<t tx="ekr.20031218072017.3421">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAsNthChild(self,n)

    return v</t>
<t tx="ekr.20031218072017.3422">def moveToRoot (self,oldRoot=None):

    """Moves the receiver to the root position"""

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v</t>
<t tx="ekr.20031218072017.3424"># Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):
	
	"""Create a clone of back."""
	
	clone = self.cloneTree(back)

	# Set the clone bit in all nodes joined to back.
	# This is not nearly enough.
	clone.setClonedBit()
	back.setClonedBit()
	for v in back.t.joinList:
		v.setClonedBit()

	return clone</t>
<t tx="ekr.20031218072017.3425">def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v</t>
<t tx="ekr.20031218072017.3426">def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self ; c = v.c

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v

    newRoot = position(v,[])
    c.setRootPosition(newRoot)</t>
<t tx="ekr.20031218072017.3437">@ The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.

Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.
@c

def shouldBeClone (self):
	
	"""Returns True if the receiver should be a clone"""
	pv1 = self.parent()
	n = self.childIndex()

	for v in self.t.joinList:
		if v != self:
			vp = v.parent()
			# self and v are structurally dissimilar if...
			if( (not pv1 or not vp) or  # they are at the top level, or
				vp == pv1 or  # have the same parent, or
				pv1.t != vp.t or  # have unjoined parents, or
				(v.childIndex() != n)): # have different child indices.

				# g.trace("True",v)
				return True

	# The receiver is structurally similar to all nodes joined to it.
	# g.trace("False",v)
	return False</t>
<t tx="ekr.20031218072017.3438">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self ; c = v.c

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
    
    # Special case the root.
    if v == c.rootPosition().v: # 3/11/04
        assert(v._next)
        newRoot = position(v._next,[])
        c.setRootPosition(newRoot)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="ekr.20031218072017.3442">def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order"""

    global handlers
    
    # g.trace(g.app.killed)
    
    if g.app.killed:
        return None

    if handlers.has_key(tag):
        handle_fns = handlers[tag]
        handle_fns.sort()
        for handle_fn in handle_fns:
            ret = handle_fn(tag,keywords)
            if ret is not None:
                return ret

    if handlers.has_key("all"):
        handle_fns = handlers["all"]
        handle_fns.sort()
        for handle_fn in handle_fns:
            ret = handle_fn(tag,keywords)
            if ret is not None:
                return ret
    return None
</t>
<t tx="ekr.20031218072017.3443">def registerHandler(tags,fn):
    
    """ Register one or more handlers"""
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""

    global handlers

    existing = handlers.setdefault(tag,[])
    existing.append(fn)</t>
<t tx="ekr.20031218072017.3604"># New in 4.2: this is now an ivar, not a global, and it's a list, not a tuple.

u.optionalIvars = [
    "lastChild",
    "parent","oldParent",
    "back","oldBack",
    "n","oldN","oldV",
    "oldText","newText",
    "oldSel","newSel",
    "sort","select",
    "oldTree","newTree", # Added newTree 10/14/03
    "yview",
    # For incremental undo typing...
    "leading","trailing",
    "oldMiddleLines","newMiddleLines",
    "oldNewlines","newNewlines" ]</t>
<t tx="ekr.20031218072017.3606">def __init__ (self,c):
    
    u = self ; u.c = c
    
    # Ivars to transition to new undo scheme...
    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.
    u.new_undo = True # True: enable new debug code.

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    &lt;&lt; Define optional ivars &gt;&gt;
    &lt;&lt; define redoDispatchDict &gt;&gt;
    &lt;&lt; define undoDispatchDict &gt;&gt;
    u.updateSetChangedFlag = True
    u.redrawFlag = True</t>
<t tx="ekr.20031218072017.3607">def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.
    for ivar in u.optionalIvars:
        setattr(u,ivar,None)</t>
<t tx="ekr.20031218072017.3612"></t>
<t tx="ekr.20031218072017.3615">@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,p,**keywords):
    
    # g.trace(undo_type,p,keywords)

    u = self
    if u.redoing or u.undoing: return None
    if undo_type == None:
        return None
    if undo_type == "Can't Undo":
        u.clearUndoState()
        return None

    # Set the type: set the menu labels later.
    u.undoType = undo_type
    # Calculate the standard derived information.
    u.p = p.copy()
    u.parent = p.parent()
    u.back = p.back()
    u.n = p.childIndex()
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    d = u.setBead(u.bead,keywords)
    u.beads[u.bead:] = [d]
    # g.trace(len(u.beads),u.bead,keywords)
    # Recalculate the menu labels.
    u.setUndoTypes()
    return d
</t>
<t tx="ekr.20031218072017.3620">def undoDemote (self):
    
    u = self ; c = u.c

    p   = u.p.copy()
    ins = u.p.copy()
    last = u.lastChild
    assert(p.hasFirstChild)
    child = p.firstChild()
    
    # Do not undemote children up to last.
    # Do not use an iterator here.
    if last:
        while child and child != last:
            child = child.next()
        if child:
            child = child.next()

    while child:
        next = child.next()
        child.moveAfter(ins)
        ins = child
        child = next
    c.selectVnode(p)</t>
<t tx="ekr.20031218072017.3621"># Undoes the previous promote operation.
def undoPromote (self):
    
    u = self ; c = u.c
    next = u.p.next()
    last = u.lastChild
    assert(next)
    
    while next: # don't use an iterator here.
        p2 = next
        next = p2.next()
        n = u.p.numberOfChildren()
        p2.moveToNthChildOf(u.p,n)
        if p2 == last: break
    c.selectVnode(u.p)</t>
<t tx="ekr.20031218072017.3622">def undoSortChildren (self):

    u = self ; c = u.c
    assert(u.p)

    c.endEditing()
    index = 0
    for child in u.sort:
        child.moveToNthChildOf(u.p,index)
        index += 1</t>
<t tx="ekr.20031218072017.3623">def undoSortSiblings (self):
    
    u = self ; c = u.c

    parent = u.p.parent()
    assert(u.p and parent)
    
    c.endEditing()
    index = 0
    for sib in u.sort:
        sib.moveToNthChildOf(parent,index)
        index += 1
    parent.setDirty()</t>
<t tx="ekr.20031218072017.3624">def undoSortTopLevel (self):
    
    u = self ; c = u.c
    root = c.rootPosition()
    
    c.endEditing()
    v = u.sort[0]
    v.moveToRoot(oldRoot=root)
    for next in u.sort[1:]:
        next.moveAfter(v)
        v = next
        
    u.p = None # don't mark u.p dirty</t>
<t tx="ekr.20031218072017.3677"># It's weird to have the tree class be responsible for coloring the body pane!

def getColorizer(self):
    
    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):
    
    self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):
    
    if 0: # Do immediately
        self.colorizer.colorize(p.copy(),incremental)
    else: # Do at idle time
        self.colorizer.schedule(p.copy(),incremental)
    
def updateSyntaxColorer(self,p):
    
    return self.colorizer.updateSyntaxColorer(p.copy())</t>
<t tx="ekr.20031218072017.3705">def __init__ (self,frame):
    
    self.frame = frame
    self.c = c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).
    
    # "public" ivars: correspond to setters &amp; getters.
    self._dragging = False
    self._editPosition = None

    # Controlling redraws
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.redrawCount = 0 # For traces
    self.redrawScheduled = False # True if redraw scheduled.</t>
<t tx="ekr.20031218072017.3716">def dragging(self):
    return self._dragging

def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition
    
def setDragging(self,flag):
    self._dragging = flag

def setEditPosition(self,p):
    self._editPosition = p</t>
<t tx="ekr.20031218072017.3739">def setIdleTimeHook (self,idleTimeHookHandler,*args,**keys):
    
    pass # Not an error.
    
def setIdleTimeHookAfterDelay (self,delay,idleTimeHookHandler,*args,**keys):
    
   pass # Not an error.
</t>
<t tx="ekr.20031218072017.3768">self.outlineMenuTopMenuTable = (
    ("C&amp;ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&amp;opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste &amp;Retaining Clones",None,c.pasteOutlineRetainingClones),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&amp;n",None,c.sortChildren), # Conflicted with Hoist.
    ("&amp;Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("&amp;Hoist",None,c.hoist),
    ("D&amp;e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  c,d,e,h,i,k,m,n,o,p,r,s,u
</t>
<t tx="ekr.20031218072017.3776"></t>
<t tx="ekr.20031218072017.3777">def updateAllMenus (self):
    
    """The Tk "postcommand" callback called when a click happens in any menu.
    
    Updates (enables or disables) all menu items."""
    
    # A horrible kludge: set g.app.log to cover for a possibly missing activate event.
    g.app.setLog(self.frame.log,"updateAllMenus")
    
    # Allow the user first crack at updating menus.
    c = self.c ; v = c.currentVnode()

    if not g.doHook("menu2",c=c,v=v):
        self.updateFileMenu()
        self.updateEditMenu()
        self.updateOutlineMenu()</t>
<t tx="ekr.20031218072017.3778">def updateFileMenu (self):
    
    c = self.c ; frame = c.frame
    if not c: return

    try:
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("File")
        enable(menu,"Revert To Saved", c.canRevert())
        enable(menu,"Open With...", g.app.hasOpenWithMenu)
    except:
        g.es("exception updating File menu")
        g.es_exception()</t>
<t tx="ekr.20031218072017.3779">def updateOutlineMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    p = c.currentPosition()
    hasParent = p.hasParent()
    hasBack = p.hasBack()
    hasNext = p.hasNext()
    hasChildren = p.hasChildren()
    isExpanded = p.isExpanded()
    isCloned = p.isCloned()
    isMarked = p.isMarked()

    try:
        enable = frame.menu.enableMenu
        &lt;&lt; enable top level outline menu &gt;&gt;
        &lt;&lt; enable expand/contract submenu &gt;&gt;
        &lt;&lt; enable move submenu &gt;&gt;
        &lt;&lt; enable go to submenu &gt;&gt;
        &lt;&lt; enable mark submenu &gt;&gt;
    except:
        g.es("exception updating Outline menu")
        g.es_exception()</t>
<t tx="ekr.20031218072017.3780"># Returns True if text in the outline or body text is selected.

def hasSelection (self):
    
    body = self.frame.body

    if body:
        first, last = body.getTextSelection()
        return first != last
    else:
        return False</t>
<t tx="ekr.20031218072017.3902">def createFrame (self):

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;
    
    for widget in (self.find_text, self.change_text):
        widget.bind ("&lt;1&gt;",  self.resetWrap)
        widget.bind("&lt;Key&gt;", self.resetWrap)
        widget.bind("&lt;Control-a&gt;",self.selectAll)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    for widget in (outer, self.find_text, self.change_text):
        widget.bind("&lt;Key-Return&gt;", self.findButton)
        widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)
    
    self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
</t>
<t tx="ekr.20031218072017.3903">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
    (self.dict["radio-find-type"],"Plain Search","plain-search"),  
    (self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"Script Search","script-search")]
checkLists[0] = [
    ("Script Change",self.dict["script_change"])]
checkLists[1] = [
    ("Whole Word",  self.dict["whole_word"]),
    ("Ignore Case", self.dict["ignore_case"]),
    ("Wrap Around", self.dict["wrap"]),
    ("Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search Headline Text", self.dict["search_headline"]),
    ("Search Body Text",     self.dict["search_body"]),
    ("Mark Finds",           self.dict["mark_finds"]),
    ("Mark Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
        box.pack(fill="x")
        box.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.configure(state="disabled")
    for name, var in checkLists[i]:
        box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
        box.pack(fill="x")
        box.bind("&lt;1&gt;", self.resetWrap)
        if var is None: box.configure(state="disabled")</t>
<t tx="ekr.20031218072017.3904">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_text   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_text = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="ekr.20031218072017.3905"># Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# Create the first row of buttons
findButton=Tk.Button(buttons,width=8,text="Find",bd=4,command=self.findButton) # The default.
contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)

findButton.pack   (pady="1p",padx="25p",side="left")
contextBox.pack   (pady="1p",           side="left",expand=1)
findAllButton.pack(pady="1p",padx="25p",side="right",fill="x",)

# Create the second row of buttons
changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)

changeButton.pack    (pady="1p",padx="25p",side="left")
changeFindButton.pack(pady="1p",           side="left",expand=1)
changeAllButton.pack (pady="1p",padx="25p",side="right")</t>
<t tx="ekr.20031218072017.3960">

</t>
<t tx="ekr.20031218072017.3961">def createStatusLine (self):
    
    if self.statusFrame and self.statusLabel:
        return
    
    self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
    statusFrame.pack(fill="x",pady=1)
    
    text = "line 0, col 0"
    width = len(text) + 4
    self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
    self.statusLabel.pack(side="left",padx=1)
    
    bg = statusFrame.cget("background")
    self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
    self.statusText.pack(side="left",expand=1,fill="x")

    # Register an idle-time handler to update the row and column indicators.
    self.statusFrame.after_idle(self.updateStatusRowCol)</t>
<t tx="ekr.20031218072017.3962">def clearStatusLine (self):
    
    t = self.statusText
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")</t>
<t tx="ekr.20031218072017.3963">def putStatusLine (self,s,color=None):
    
    t = self.statusText ; tags = self.statusColorTags
    if not t: return

    t.configure(state="normal")
    
    if "black" not in self.log.colorTags:
        tags.append("black")
        
    if color and color not in tags:
        tags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")</t>
<t tx="ekr.20031218072017.3979"></t>
<t tx="ekr.20031218072017.3980"></t>
<t tx="ekr.20031218072017.3981">def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode() ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    if self.revertHeadline and v.edit_text() and v == tree.editPosition():
    
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        tree.select(v)
        if v and len(v.t.vnodeList) &gt; 0:
            tree.force_redraw() # force a redraw of joined headlines.</t>
<t tx="ekr.20031218072017.3982">def endEditLabelCommand (self):

    frame = self ; c = frame.c ; tree = frame.tree ; gui = g.app.gui
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
        return
    
    v = frame.tree.editPosition()

    # g.trace(v)
    if v and v.edit_text():
        tree.select(v)
    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        tree.force_redraw() # force a redraw of joined headlines.

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="ekr.20031218072017.3983">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; v = c.currentVnode()
    h = v.headString() # Remember the old value.
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return

    if v.edit_text():
        sel1,sel2 = g.app.gui.getTextSelection(v.edit_text())
        if sel1 and sel2 and sel1 != sel2: # 7/7/03
            v.edit_text().delete(sel1,sel2)
        v.edit_text().insert("insert",c.getTime(body=False))
        frame.tree.idle_head_key(v)

    # A kludge to get around not knowing whether we are editing or not.
    if h.strip() == v.headString().strip():
        g.es("Edit headline to append date/time")</t>
<t tx="ekr.20031218072017.3984"></t>
<t tx="ekr.20031218072017.3985">def toggleActivePane(self):
    
    c = self.c ; gui = g.app.gui
    if gui.get_focus(self) == self.bodyCtrl:
        gui.set_focus(c,self.canvas)
    else:
        gui.set_focus(c,self.bodyCtrl)</t>
<t tx="ekr.20031218072017.3986">def cascade(self):

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top

        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)

        # Set new x,y and old w,h
        frame.setTopGeometry(w,h,x,y,adjustSize=False)

        # Compute the new offsets.
        x += 30 ; y += 30
        if x &gt; 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
</t>
<t tx="ekr.20031218072017.3987">def equalSizedPanes(self):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="ekr.20031218072017.3988">def hideLogWindow (self):
    
    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="ekr.20031218072017.3989">def minimizeAll(self):

    self.minimize(g.app.findFrame)
    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
    
def minimize(self, frame):

    if frame and frame.top.state() == "normal":
        frame.top.iconify()</t>
<t tx="ekr.20031218072017.3990"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.
def toggleSplitDirection(self):
    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Switch directions.
    verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = g.choose(verticalFlag,"vertical","horizontal")
    g.app.config.setWindowPref("initial_splitter_orientation",orientation)
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="ekr.20031218072017.3991"></t>
<t tx="ekr.20031218072017.3992">def leoHelp (self):
    
    file = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

    if g.os_path_exists(file):
        os.startfile(file)
    else:	
        answer = g.app.gui.runAskYesNoDialog(
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,file,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception dowloading sbooks.chm")
                g.es_exception()</t>
<t tx="ekr.20031218072017.3993">def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:",count,size,total)
    if self.scale == None:
        &lt;&lt; create the scale widget &gt;&gt;
    self.scale.set(count*size)
    self.scale.update_idletasks()</t>
<t tx="ekr.20031218072017.3994">top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="ekr.20031218072017.3995">def getFocus(self):
    
    """Returns the widget that has focus, or body if None."""
    try:
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl
        
def getTitle (self):
    return self.top.title()
    
def setTitle (self,title):
    return self.top.title(title)
    
def get_window_info(self):
    return g.app.gui.get_window_info(self.top)
    
def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()
    
def lift (self):
    self.top.lift()
    
def update (self):
    self.top.update()
</t>
<t tx="ekr.20031218072017.4023">def selectAllText (self):

    try:
        w = self.bodyCtrl.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
    except:
        pass</t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4141"></t>
<t tx="ekr.20031218072017.4142">def deleteBindings (self):
    
    """Delete all tree bindings and all references to tree widgets."""
    
    # g.trace(len(self.tagBindings),len(self.bindings))

    count = 0
    # Unbind all the tag bindings.
    if 0:  # testing.
        self.tagBindings = []
        self.bindings = []
    else:
        for id,id2,binding in self.tagBindings:
            self.canvas.tag_unbind(id,binding,id2)
            count += 1
        self.tagBindings = []
        # Unbind all the text bindings.
        for t,id,binding in self.bindings:
            t.unbind(binding,id)
            count += 1
        self.bindings = []

        # g.trace("bindings freed:",count)</t>
<t tx="ekr.20031218072017.4143"># canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
    
    """Delete all widgets in the canvas"""
    
    # g.trace(len(self.widgets))
    
    self.icon_id_dict = {} # Delete all references to icons.
    self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
        
    # Fixes a _huge_ memory leak.
    for w in self.widgets:
        w.destroy() 

    self.widgets = []

    # g.trace("done")</t>
<t tx="ekr.20031218072017.4144"></t>
<t tx="ekr.20031218072017.4145">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(False) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="ekr.20031218072017.4146">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20031218072017.4147">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.4148">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20031218072017.4149">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

    # if not v1.isVisible(): print "yoffset not visible:",v1
    root = self.c.rootPosition()
    h, flag = self.yoffsetTree(root,v1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

# Returns the visible height of the tree and all sibling trees, stopping at p1

def yoffsetTree(self,p,p1):

    h = 0
    for p in p.siblings_iter():
        # print "yoffsetTree:", p
        if p == p1:
            return h, True
        h += self.line_height
        if p.isExpanded() and p.hasChildren():
            child = p.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    
    return h, False</t>
<t tx="ekr.20031218072017.4157"></t>
<t tx="ekr.20031218072017.4158"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20031218072017.4159">def editLabel (self,p):
    
    """Start editing p.edit_text."""
    
    # g.trace(p)

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)</t>
<t tx="ekr.20031218072017.4160">def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; gui = g.app.gui
    
    p = self.editPosition()

    if p and p.edit_text():
        self.setUnselectedLabelState(p)
        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="ekr.20031218072017.4161">def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

</t>
<t tx="ekr.20031218072017.4162">def setNormalLabelState (self,p): # selected, editing

    # g.trace(p)
    if p and p.edit_text():
        &lt;&lt; set editing headline colors &gt;&gt;
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

    # g.trace(p,g.callerName(2),g.callerName(3))
    if p and p.edit_text():
        &lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,p): # selected, not editing

    # g.trace(p)
    self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

    # g.trace(p)
    if p and p.edit_text():
        &lt;&lt; set unselected headline colors &gt;&gt;
</t>
<t tx="ekr.20031218072017.4163">config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    if selfg and selbg:
        p.edit_text().configure(
            selectforeground=selfg,selectbackground=selbg,
            state="normal",highlightthickness=1,fg=fg,bg=bg)
    else:
        p.edit_text().configure(
            state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20031218072017.4164">config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
    fg,bg = "black","gray80"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20031218072017.4165">config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20040105080119.4"></t>
<t tx="ekr.20040105210752"></t>
<t tx="ekr.20040105214540">@nocolor

Values for the state field.

No modifiers:  0
Shift: 1
Caps_lock: 2
Control: 4
Alt: 131072

A possible strategy:
	
1.  Only pass keys to body pane if state is 0, 1, 2 or 3.</t>
<t tx="ekr.20040105223536">def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)&gt;0:
        &lt;&lt; trace the key event &gt;&gt;

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status</t>
<t tx="ekr.20040105223536.1">try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state &lt; 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)</t>
<t tx="ekr.20040106095546">@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
    
    """Make sure drawing is enabled following an exception."""
        
    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
        self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.</t>
<t tx="ekr.20040106115311"></t>
<t tx="ekr.20040106145421"></t>
<t tx="ekr.20040107064101.1"></t>
<t tx="ekr.20040115163454"></t>
<t tx="ekr.20040117111755"></t>
<t tx="ekr.20040117113539.1"></t>
<t tx="ekr.20040117162509.16">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="ekr.20040117170612">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # Only called when normal lookup fails.
            print "unknown attribute",attr
            raise AttributeError</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    g.app.copies += 1

    return position(self.v,self.stack)</t>
<t tx="ekr.20040128174042">def warnAboutOrphandAndIgnoredNodes (self):
    
    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.isCloned() and p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())
                
    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()</t>
<t tx="ekr.20040130164211">if frame.body.hasFocus():
    data = frame.body.getSelectedText()
    canCut = data and len(data) &gt; 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) &gt; 0
enable(menu,"Paste",canPaste)</t>
<t tx="ekr.20040131170659">def canClone (self):

    c = self
    
    if c.hoistStack:
        current = c.currentPosition()
        p,junk = c.hoistStack[-1]
        return current != p
    else:
        return True</t>
<t tx="ekr.20040131171020">menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Paste Retaining Clones",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())</t>
<t tx="ekr.20040131171020.1">menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)</t>
<t tx="ekr.20040131171020.2">menu = frame.menu.getMenu("Move...")
enable(menu,"Move Down",c.canMoveOutlineDown())
enable(menu,"Move Left",c.canMoveOutlineLeft())
enable(menu,"Move Right",c.canMoveOutlineRight())
enable(menu,"Move Up",c.canMoveOutlineUp())
enable(menu,"Promote",c.canPromote())
enable(menu,"Demote",c.canDemote())</t>
<t tx="ekr.20040131171020.3">menu = frame.menu.getMenu("Go To...")
enable(menu,"Go Back",c.beadPointer &gt; 1)
enable(menu,"Go Forward",c.beadPointer + 1 &lt; len(c.beadList))
enable(menu,"Go To Prev Visible",c.canSelectVisBack())
enable(menu,"Go To Next Visible",c.canSelectVisNext())
if 0: # These are too slow.
    enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
    enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
enable(menu,"Go To Next Clone",isCloned)
enable(menu,"Go To Prev Node",c.canSelectThreadBack())
enable(menu,"Go To Next Node",c.canSelectThreadNext())
enable(menu,"Go To Parent",hasParent)
enable(menu,"Go To Prev Sibling",hasBack)
enable(menu,"Go To Next Sibling",hasNext)</t>
<t tx="ekr.20040131171020.4">menu = frame.menu.getMenu("Mark/Unmark...")
label = g.choose(isMarked,"Unmark","Mark")
frame.menu.setMenuLabel(menu,0,label)
enable(menu,"Mark Subheads",hasChildren)
if 0: # These are too slow.
    enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
    enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
enable(menu,"Mark Clones",isCloned)</t>
<t tx="ekr.20040206072057">csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]</t>
<t tx="ekr.20040206075634.1"></t>
<t tx="ekr.20040216153243.5"></t>
<t tx="ekr.20040218053305">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2429098
By: nobody

The Leo icon can eliminate the need for the word Leo.

What I did:

- Eliminate Leo in name of Find panel.
- Derived leoTkinterPrefs from leoTkinterDialog: creates icon.
- Derived leoComparePanel from leoTkinterDialog: creates icon.
- Eliminated the -t option when opening Idle: the idle window is now called "Python Shell"</t>
<t tx="ekr.20040227212621">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="ekr.20040227214711">def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level += 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level</t>
<t tx="ekr.20040227224946">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20040228060340"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="ekr.20040228060340.1">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20040228094013.1"></t>
<t tx="ekr.20040301071824"># These remain in 4.2: the file read logic calls these before creating positions.</t>
<t tx="ekr.20040301205720">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="ekr.20040302094109"></t>
<t tx="ekr.20040303163330"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20040303165342">def canDehoist(self):
    
    return len(self.hoistStack) &gt; 0
        
def canHoist(self):
    
    c = self
    root = c.rootPosition()
    p = c.currentPosition()

    if c.hoistStack:
        p2,junk = c.hoistStack[-1]
        return p2 != p
    elif p == root:
        return p.hasNext()
    else:
        return True</t>
<t tx="ekr.20040303175026"></t>
<t tx="ekr.20040303175026.2">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="ekr.20040303175026.3">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20040303175026.4">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="ekr.20040303175026.8">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="ekr.20040303175026.9"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20040303175026.10">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20040303175026.12">def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index += 1</t>
<t tx="ekr.20040303175026.13"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="ekr.20040303175026.14">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="ekr.20040303175026.15">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20040303175026.16">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20040303212445">def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count += 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed</t>
<t tx="ekr.20040305084926"></t>
<t tx="ekr.20040305162628"></t>
<t tx="ekr.20040305162628.1">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20040305171133">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20040305171133.1">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305171133.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172211.1">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20040305172211.2">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20040305172211.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172855">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305172855.1">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20040305172855.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20040305173343">class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20040305173343.1">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20040305173343.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305173559">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305173559.1">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305173559.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20040305222007"></t>
<t tx="ekr.20040306060312">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="ekr.20040306211032">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20040306214240.3">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="ekr.20040306220230.1">def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)</t>
<t tx="ekr.20040306220634.17"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20040307101707">if 0: # find the hang.
	try:    g.debug_count += 1
	except: g.debug_count  = 0
	g.trace(v)
	if g.debug_count &gt; 100: break</t>
<t tx="ekr.20040308153521"></t>
<t tx="ekr.20040309041826"></t>
<t tx="ekr.20040309045858">@nocolor

The problem was that the calls to tag_bind did not copy the position, and the position changed during the tree traversal in the tree drawing code.  Making a copy of the position for each binding solved the problem.

The draw_box </t>
<t tx="ekr.20040310062332"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="ekr.20040310062332.1">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="ekr.20040310062332.2">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="ekr.20040310062332.3">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20040310062332.4">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="ekr.20040310062332.5">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
</t>
<t tx="ekr.20040310062415.1"></t>
<t tx="ekr.20040310092400"></t>
<t tx="ekr.20040310104639"></t>
<t tx="ekr.20040310153624">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="ekr.20040311081401"></t>
<t tx="ekr.20040311113514">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20040311133449"></t>
<t tx="ekr.20040312015705"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="ekr.20040312015908"></t>
<t tx="ekr.20040312024615">@ This was a nasty one.  The problem was in linkAsRoot, not linkAfter.</t>
<t tx="ekr.20040312090934"></t>
<t tx="ekr.20040312092455.2">@

What I did:

- Enabled top_df.readAll
- Changed findChild to use p.v.t.vnodeList.
- Changed subtree_iter to c.allNodes_iter in putTnodes.
- Move tnodeList into tnodes. (Change made in getVnode).</t>
<t tx="ekr.20040312120107"></t>
<t tx="ekr.20040312145256">def dumpLink (self,link):
    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v</t>
<t tx="ekr.20040312213623">@nocolor

There were several difficult bugs here.

1. There is a potential confusion between these two kinds of methods:

- The p.moveToX methods:  these are internal use routines.

- The externally visible "Moving, Inserting, Deleting, Cloning, Sorting (position)" methods,

especially p.moveToRoot, p.moveAfter and p.moveToNthChildOf.

These routines must NOT create copies of their positions.  They must alter the position "in place".

2. p.linkAsRoot, p.linkAfter and p.linkAsNthChild must _recreate_ the stack.

3. p.level reported the wrong value, sometimes spectacularly wrong, during redraw for nested clones.

This was fixed by clearing the _parent link in linkAsNthChild when pushing the stack.

4. Moved tree.lastVisible to position class where it belongs.  Changed names to getLastVisible and moveToLastVisible.

5. Greatly simplified p.nodeAfter and p.threadNext.

6. Added assertions that the old or simplified versions of routines are equivalent to the new versions.

This is "having my cake and eating it too."</t>
<t tx="ekr.20040313083810"></t>
<t tx="ekr.20040313083810.1"></t>
<t tx="ekr.20040313083810.2"></t>
<t tx="ekr.20040313083810.3"></t>
<t tx="ekr.20040313150633"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")</t>
<t tx="ekr.20040314035615">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"</t>
<t tx="ekr.20040314035615.1">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"</t>
<t tx="ekr.20040314035615.2">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"</t>
<t tx="ekr.20040314043623">vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"</t>
<t tx="ekr.20040314043900">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")</t>
<t tx="ekr.20040314044652">s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")</t>
<t tx="ekr.20040314062338">if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False</t>
<t tx="ekr.20040314092716">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20040314092716.1">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20040314103754">@nocolor

The initial problem was a mistransliteration in drawTree.

While I was at it, I improved the code as follows:
	
- The hoist code now saves and restores the expansion state of outlines.
- The hoist plugin now dims/undims the buttons.

@color</t>
<t tx="ekr.20040314110927.1">@

- All unit tests now pass with p.__getattr__ ON or OFF.

- Moved Head &amp; body text setters from vnode class into position class.
- Added p.setTnodeText and v.setTnodeText as substitutes for p.v.t.setTnodeText.

- Added verbose and unittest params to c.checkOutline:
	- Don't run long tests during unit testing.</t>
<t tx="ekr.20040314111426"></t>
<t tx="ekr.20040315023430">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315023430.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20040315023430.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315023430.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="ekr.20040315031219.1"></t>
<t tx="ekr.20040316075317"></t>
<t tx="ekr.20040316075317.1"></t>
<t tx="ekr.20040317084001">@nocolor

Pep 262 says: More precisely, the first or second line must match the regular expression

"coding[:=]\s*([\w-_.]+)"

Therefore, Leo must not use the ".' or '-' character to terminate the encoding field.

For compatibility with previous versions I shall do the following:

1.  Writing:  end the field with ",."

2.  Reading: scan until ',' or '.', whichever comes first.

- If ',' comes first, no problem.

- If '.' comes first, the specification must have been written by an old version of Leo.  In that case, Leo may as well stop there: older versions of Leo could not handle encodings containing '.' anyway.</t>
<t tx="ekr.20040317094609">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for dict in iconsList:
            h2,w2 = self.drawUserIcon(where,x+w,y,dict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    return h,w</t>
<t tx="ekr.20040317095153">pass</t>
<t tx="ekr.20040317095153.1">pass</t>
<t tx="ekr.20040317095510">def drawUserIcon (self,where,x,y,dict):
    
    h,w = 0,0

    if where != dict.get("where","beforeHeadline"):
        return h,w
        
    # g.trace(where,x,y,dict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    type = dict.get("type")
    if type == "icon":
        s = dict.get("icon")
        &lt;&lt; draw the icon in string s &gt;&gt;
    elif type == "file":
        file = dict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif type == "url":
        url = dict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = dict.get("height",h)
    w = dict.get("width",w)

    return h,w</t>
<t tx="ekr.20040317100702">try:
    image = self.iconimages[file]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
    self.canvas.lift(id)
    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad</t>
<t tx="ekr.20040317171729">def force_draw_node(self,p,x,y):

    self.allocatedNodes += 1
    h,w = self.drawUserIcons(p,"beforeBox",x,y)
    xw = w # The extra indentation before the icon box.
    if p.hasChildren():
        box_id = self.drawBox(p,x+w,y)
    else:
        box_id = None

    w += box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
    h = max(h,h2) ; w += w2 ; xw += w2

    h2,w2 = self.drawIcon(p,x+w,y)
    h = max(h,h2) ; w += w2

    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
    h = max(h,h2) ; w += w2

    expand_x = x+w # save this for later.
    h2 = self.drawText(p,x+w,y,box_id)
    h = max(h,h2)
    w += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
    h = max(h,h2)
    
    self.drawClickFrame(p,y)

    return h,xw</t>
<t tx="ekr.20040317173849">xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20040318090335">def force_draw_nodeOLD(self,p,x,y):

    self.allocatedNodes += 1

    if p.hasChildren():
        box_id = self.drawBox(p,x,y)
    w = box_width # Even if the box isn't drawn.

    h2,w2 = self.drawIcon(p,x+w,y)
    w += w2

    h = self.drawText(p,x+w,y)
    
    return h,0
</t>
<t tx="ekr.20040318092028">@

At first, disabling the call to recolor_now in select speeded things up.  Now it doesn't (!!).

- Should there be a call to p.copy() in drawTree?

- Doing p = p.copy() in the coloring routines _seemed_ to solve this (for a while only!).
	I'm still not sure if this is needed...</t>
<t tx="ekr.20040318100124"></t>
<t tx="ekr.20040318100124.1"></t>
<t tx="ekr.20040318100124.2"></t>
<t tx="ekr.20040318112729"></t>
<t tx="ekr.20040318112908"># This is hard to do directly.
# A trick: let the drawing code do it?  That seems too clever.
</t>
<t tx="ekr.20040318125934">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20040318161816">@

- Moving a node up creates _way_ too many postions!</t>
<t tx="ekr.20040318164450">@ The fix was to optimize the iterators so they create no copies if they would return an empty sequence.

There were also several bugs in the iterators that caused to many nodes to be examined.</t>
<t tx="ekr.20040319104735"></t>
<t tx="ekr.20040321064134.1">@nocolor

Transition to @file-thin
	*** Is the present code always correct?
		What about a reference to a grandchild node?
	- Change @+leo sentinel for thin files.
	- Better warning when @file-thin overrides existing code?
		- Dialog warning about thin derived file:
			- Do you want outline version or derived file version.
	- Option for minimal @-node sentinel.

Design:
	- What to do about cloned siblings in thin trees?

Other commands:
	- Make Import Derived File command work with thin derived files.
	- Make Go To Line number command work with thin derived files.</t>
<t tx="ekr.20040321064134.5">def createThinChild (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #g.trace("last",last,last.t.fileIndex)
    #g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace("creating node",child,gnx)

    return child</t>
<t tx="ekr.20040321095547"></t>
<t tx="ekr.20040322074056"></t>
<t tx="ekr.20040322121338.1"></t>
<t tx="ekr.20040322122232">def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        g.trace(event,self,p)
        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)</t>
<t tx="ekr.20040322123611"></t>
<t tx="ekr.20040323072005"># The fix was to call endEditLabel from editLabel only if are in a different node.
# That is possible now that tree.editPosition() is available.</t>
<t tx="ekr.20040323073825">@nocolor

Moving a node right so that it becomes a child of an @file-thin node doesn't work.

The fix was in findAllPotentiallyDirtyNodes:
	- v.parents is only used if v._parent is None.
	- Added a code to add v._parent to the list of nodes.</t>
<t tx="ekr.20040323084434.1"></t>
<t tx="ekr.20040323084605"></t>
<t tx="ekr.20040323090456.1"></t>
<t tx="ekr.20040323090456.2">@nocolor

- (done) Rename v.parents to v.parentsList
- (done) Don't clear _parents link.
- (done) Look at len(_parent.v.t.vnodeList) to see if should pop stack.
- (done) Create v.directParents()
- (done) Use v.directParents in findAllPotentiallyDirtyNodes.
- (done) Created tests to make sure clones actually share subtrees.
	- Full unit tests now pass.

@color

</t>
<t tx="ekr.20040323100443">def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []</t>
<t tx="ekr.20040323155951">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others</t>
<t tx="ekr.20040323155951.1">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20040323161837">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"</t>
<t tx="ekr.20040323162707">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"</t>
<t tx="ekr.20040323171453">@nocolor

The following calls slow down the menu enablers too much:

@color

enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())

enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())

@nocolor

These all scan the entire file.  We have two choices:
	
1. scan the entire file once.

2. Always enable the above 4 commands.
	- Add a log message for these commands if there is no node found.
	
Choice two is plenty good enough.</t>
<t tx="ekr.20040323172420"></t>
<t tx="ekr.20040323191536">@nocolor

The call to idle_redraw happens as the result of the call to update_idletasks in tkLog.put.

To fix this I added the disableRedraw lockout ivar to the tk tree class.

This prevents the outline from being redrawn initially, so I added a call to redraw in the fileCommands read code.

endEditLabel calls force_redraw:
	- I changed this so that force_redraw gets called only if there was really some editing going on.

The call to update_idledraw in get_window_info is harder to disable: it is a dialog util.</t>
<t tx="ekr.20040323194538"></t>
<t tx="ekr.20040324080004"></t>
<t tx="ekr.20040324080359">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20040324080359.1"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20040324080359.2">self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
    g.es("can not open " + fileName)
    &lt;&lt; delete backup file &gt;&gt;
    return False</t>
<t tx="ekr.20040324080819">c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()</t>
<t tx="ekr.20040324080819.1">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20040324080819.2">g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
    try:
        self.outputFile.close()
        self.outputFile = None
    except:
        g.es("exception closing: " + fileName)
        g.es_exception()</t>
<t tx="ekr.20040324080819.3">try:
    self.outputFile.close()
    self.outputFile = None
except:
    g.es("exception closing: " + fileName)
    g.es_exception()</t>
<t tx="ekr.20040324082713"># Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode() and not v.isAtThinFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)</t>
<t tx="ekr.20040324085927">@nocolor

Most of the time is spent in putVnode.  It's taking 4 times as long to put the vnodes as the tnodes!

It's time to clean up isAnyAtFileNode, but I doubt this is a significant factor.

I changed p.x() to p.v.x() to reduce several function calls.
	- Hard to believe this could make a difference: it didn't.

** Amazingly, the code that puts the attribute bits is the bottleneck!!

The following tests are the bottleneck (!!!)

if p == self.topPosition:     attr += "T"
if p == self.currentPosition: attr += "V"

The call to p.childIndex was the bottleneck.  I did the following:

- Put the check against childIndex last.
- At leaset doubled the speed of p.childIndex.

** But the calls to p.__cmp__ are still too slow!!!
	- Would an explicit call to an p.equal routine work?
		- Yes !!!!! There is a huge performance bug in p.__cmp__ !!!!!!

</t>
<t tx="ekr.20040324090957">if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
</t>
<t tx="ekr.20040324090957.1"># Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
    self.canvas.after_idle(self.idle_scrollTo)

</t>
<t tx="ekr.20040324093353"></t>
<t tx="ekr.20040325073709">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="ekr.20040325104344"></t>
<t tx="ekr.20040325111920"></t>
<t tx="ekr.20040325115038">@nocolor

The problem was setMarked.  This calls:
	
g.doHook("set-mark",c=self.c,v=self)

I'm not sure why this generated go many positions, but it did.</t>
<t tx="ekr.20040325125426"></t>
<t tx="ekr.20040325142015">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None."""

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())</t>
<t tx="ekr.20040325203859"></t>
<t tx="ekr.20040325203859.1"></t>
<t tx="ekr.20040325203859.2"></t>
<t tx="ekr.20040325203859.3"></t>
<t tx="ekr.20040325203859.4"></t>
<t tx="ekr.20040325203859.5">@nocolor

The first screen draw got messed up if there was a scrollling operation.
This happened as the result of the call to idle_scrollTo.
To fix this, I added the scroll arg to redraw_now and idle_redraw.</t>
<t tx="ekr.20040326031436">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="ekr.20040326033431"></t>
<t tx="ekr.20040326035757">@nocolor

- Changed readAll so it uses c.nullPosition by default.
- Test p is None in scanDirectives.

These two changes _might_ be enough to ensure the arg to p.__cmp__ is always a position in Leo's _core_.  However, user code is a different matter!

The coding style is to use: "if p is None:" rather than "if p == None:".  However, there is no way to enforce that style, so I have left the test against None in p.__cmp__.

Use the p.equal method when speed is crucial.</t>
<t tx="ekr.20040326040442.1"></t>
<t tx="ekr.20040326052245">def convertStackToPosition (self,stack):

    c = self.c ; p2 = None
    if not stack: return None

    for p in c.allNodes_iter():
        if p.v == stack[0]:
            p2 = p.copy()
            for n in xrange(len(stack)):
                if not p2: break
                # g.trace("compare",n,p2.v,stack[n])
                if p2.v != stack[n]:
                    p2 = None
                elif n + 1 == len(stack):
                    break
                else:
                    p2.moveToParent()
            if p2: return p

    return None</t>
<t tx="ekr.20040326054052">current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
    c.setTopPosition(top)</t>
<t tx="ekr.20040326055828">if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)</t>
<t tx="ekr.20040326061545">@nocolor

At present, setting the top position simply scrolls to that position.

However, selecting a node also does that, so there is nothing to be gained by "restoring" this bogus setting.</t>
<t tx="ekr.20040326063413">def getExistingVnode (self,tref,headline):

    tref1 = tref
    assert(tref &gt; -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        # g.trace(tref1,t,t.vnodeList)
        return None</t>
<t tx="ekr.20040326063733"></t>
<t tx="ekr.20040326072847">@nocolor

What I did:

- Replaced v.edit_text() with p.edit_text()&gt;
	** v.edit_text still remains for testing; it will soon be removed.
- tree.edit_text_dict still has vnodes as keys, but now has list of pairs (p,widget) for values.
- p.edit_text searches this list looking for a match.
- Added the following code to tree.select to unselect the old selection:
@color
if old_p and old_p != p:
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)
@nocolor
- Changed the configuration code in drawText to test p and not p.v

That's _all_ !!  This is extremely clever code, and clever in a good way.</t>
<t tx="ekr.20040326101817"></t>
<t tx="ekr.20040326101817.1"></t>
<t tx="ekr.20040327105706">def __init__ (self,title,useNullUndoer=False):

    leoFrame.__init__(self) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer</t>
<t tx="ekr.20040327105706.1">if 0: # This causes no end of problems.

    def __getattr__(self,attr):
        g.trace("nullFrame",attr)
        return nullObject()</t>
<t tx="ekr.20040327105706.2">def finishCreate(self,c):

    self.c = c
    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)</t>
<t tx="ekr.20040327105706.3">def oops(self):
    
    # g.trace("nullFrame:", g.callerName(2))

    pass # This is NOT an error.</t>
<t tx="ekr.20040327132739.2"></t>
<t tx="ekr.20040328063421"></t>
<t tx="ekr.20040328082044"></t>
<t tx="ekr.20040328093126"></t>
<t tx="ekr.20040329094003.3"></t>
<t tx="ekr.20040330092305.1">@nocolor

The 'end1' event is not working. I believe the problem is a logic problem.

in leoApp.py:

@color

def finishQuit(self):

self.killed = True # Disable after events.

a little latter in the method:

doHook("end1")</t>
<t tx="ekr.20040331074940"></t>
<t tx="ekr.20040331080343"></t>
<t tx="ekr.20040331083824.1"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self):
        self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr &lt; len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)</t>
<t tx="ekr.20040331145826">rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]</t>
<t tx="ekr.20040331145826.1"></t>
<t tx="ekr.20040401103539">css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]</t>
<t tx="ekr.20040401104931">@nocolor

By: grayrest ( Karl Guertin ) 
 diff: css support   
2004-01-09 23:42  

 I got frustrated at leo's lack of support for CSS. The main difficulty I was having is that CSS only specifies the /* and */ comment delimiters and not any single line delimeter. Trying the depricated @comment /* */ doesn't work because it produces the output

/* @@comment /* */ */

which fails because the first */ on the line ends the comment, leaving the second */ as a syntax error in the file.

Anyway, while looking into it I figured I'd just add CSS as a supported language. It took longer than expected (there are a LOT of keywords in css) but the only hangup was that css keywords include dashes (e.g. margin-top). Diff against 4.1RC3 release is below.


In case it gets mangled, the diff can also be found at http://r39h92.res.gatech.edu:8788/leon_files/css.diff</t>
<t tx="ekr.20040401110507">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2361052
By: sbeards

It would be nice if [doNormalState] could also catch the following all of which should be valid when the language is PHP.

&lt;?_    (Note: replace the '_' with whitespace)
&lt;?=
&lt;?[pP][hH][pP] (Note: regex/mixed case is OK)

Can't we use the following regex to catch these cases?

"&lt;?(\s|=|[pP][hH][pP])"

Scott

EKR: This doesn't seem to work.  I did add code so that all cases of PHP get recoginized.</t>
<t tx="ekr.20040401111125">shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]</t>
<t tx="ekr.20040401111308">@nocolor

I recently wrote a few shell scripts (on linux) with leo, and I noticed
there was no colorizer support for shell (apart from comments), so I added
it: see the attached leo file. Note that this only adds colorizer support
for vanilla /bin/sh keywords -- one could customize it to add support for
all the different shell flavors out there (bash, ksh, etc), although I
think this is better left out for when we have a more flexible way of
specifying language grammars. Note that I changed the default extension
type for shell scripts from "txt" to "sh" (much more common for shell
scripts, I think).

In addition to what's specified in "How to add support for a new language"
(in LeoPy.leo), I also had to modify the &lt;&lt; handle single-line comment &gt;&gt;
block in colorizer.doNormalState to avoid that the built-in shell variable
'$#' starts a single-line comment.

As usual, feel free to modify at will.

Last thing: if I try to "Import to @file" a file with no extension, it
fails saying "&lt;filename&gt;.py does not exist" (where &lt;filename&gt; is the file I
want to load), i.e. Leo always tries to add a ".py" extension to files to
be imported if they don't have one. This is with Leo 4.1rc3 CVS version,
Python 2.3.2 on Linux.</t>
<t tx="ekr.20040403091954"></t>
<t tx="ekr.20040403095129">@nocolor

The problem was that the calls to put in execute script were disabling the redraw.

The solution is for the execute script command always to redraw the screen.</t>
<t tx="ekr.20040403104315"></t>
<t tx="ekr.20040403104315.1"></t>
<t tx="ekr.20040403104315.3"></t>
<t tx="ekr.20040409074345">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2361036
By: jasonic

I just had a great user interface idea to improve Leo tree behavior. 

The most common tree node clicking task people do is expand or contract by clicking
on the little +/- squares.

But why should one have such a small target?
HCI research studies have all shown one can improve interfaces just  by making
target areas as large as possible in ebery case. Preceise hand eye skills shoudl
not be squandered especially for repetitive tasks.

So in Leo's case one could make the target for each node exactly one line high,
and as wide as the entire pane. This could be an active rollover with a highlight
color. then single clicking would expand/contract that node.

The exception would be when you want to rename a node. Then clicking directly
on the name itself would only affect the name to make it editable as now.

Enhancements would be use of modifier Keys to alter the expand/contract nodeclick
behavior.

Ctrl+click would apply expand/contract one nested level down in that node.

Shift+click would apply expand/contract to all nested levels in that node.

Holding a number keyclick wouldapply/contract to the same number of nested levelsin
that node.
3+node click would affect 3 nested levels 
5+node click would affect  5 nested levels
etc.

I've mocked up a tiny flash version to help you explore the rollover idea yourselves.
In my minimal demo, the only active node "4.1 final".

Click on it and you can se how they could all work. Rollover the text and you
can see how that area could catch focus into editing. Colors are a little dull,
but they would be set all by preferences anyway.
[Also, complex clicking is not enabled in the this demo either. I'll play more
with it later when I have time and after some feedback. This direction is prelim
to my LeoFlashJabber project for 2004

http://tranzilla.net/leo/swf/tree_ui_idea_000.html

</t>
<t tx="ekr.20040409080127">@nocolor

I dragged the root node down, then did undo.

exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 135, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 800, in undo
    assert(u.p.hasParent())

AssertionError

C:\prog\leoCVS\leo&gt;

@color</t>
<t tx="ekr.20040409081506"></t>
<t tx="ekr.20040409081506.1"></t>
<t tx="ekr.20040409081716">@nocolor

goToLineNumber: u'leoUndo.py' &lt;pos 38659536 lvl: 2 [0] @file leoUndo.py&gt;
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 965, in idle_scrollTo

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1780, in lastVisible
    assert(p.isVisible())

AssertionError

--------

I'm not sure what caused this.  I added some defensive code in idle_scrollTo.</t>
<t tx="ekr.20040409083211"></t>
<t tx="ekr.20040409083211.1">@nocolor

This happened when deleting a clone (the first child of its parent)

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1861, in write_Leo_file
    self.putVnodes()

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1683, in putVnodes
    self.putVnode(p) # Write the next top-level node.

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1660, in putVnode
    p.moveToParent()

  File "C:\prog\leoCVS\leo\src\leoNodes.py", line 2762, in moveToParent
    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'

&gt;&gt;&gt;

----  Deleted (@file-thin) clone, then did Check Outline.

7536 nodes checked, 0 errors
test failed: oldLastVisible==lastVisible &lt;pos 29196336 lvl: 0 [0]  Diary&gt;

1 nodes checked, 1 errors
&gt;&gt;&gt;</t>
<t tx="ekr.20040409130322"></t>
<t tx="ekr.20040409130322.2"></t>
<t tx="ekr.20040409160021">@nocolor

This was a tricky one.  Normally, when a node is unlinked it is immediately relinked, so the _parent field of all its children need not change.  The exception is when we are actually deleting a cloned node.  In that case:

a) Another node (it was a clone, it may still be a clone) will refer to the shared tree.
b) We must reassign the _parent field of all children of the deleted node.

Rather than mess with unlink, I put the new code in p.doDelete.

While I was at it, I improved the p.dump method.

By luck I realized that unlinking a tree leaves most vnodeLists unchanged.  They must be cleared by doDelete and restored in the corresponding undo/redo methods.

----

Most code now works.  However, moving a node right destroyed part of the outline...</t>
<t tx="ekr.20040409163052"></t>
<t tx="ekr.20040409203454">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="ekr.20040409203454.1">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040410170806">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="ekr.20040410170806.1">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040411081633">if g.app.config.use_psyco:
    try:
        import psyco
        if 0:
            file = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",file,color="blue")
            psyco.log(file)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="ekr.20040411081633.1"></t>
<t tx="ekr.20040411091047"></t>
<t tx="ekr.20040412061129"></t>
<t tx="ekr.20040412061129.1"></t>
<t tx="ekr.20040414073612"></t>
<t tx="ekr.20040414073612.1"></t>
<t tx="ekr.20040629162300"></t>
<t tx="ekr.20040629162300.1"></t>
<t tx="ekr.20040629162300.2"></t>
<t tx="ekr.20040630070900.1"></t>
<t tx="ekr.20040701065235"></t>
<t tx="ekr.20040701065235.1">def getDescendentAttributes (self,s,tag=""):
    
    nodeIndices = g.app.nodeIndices
    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) &gt; 0]
    # g.trace(tag,result)
    return result
</t>
<t tx="ekr.20040701065235.2">def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())
            
    for theList,tag in ((marks,"marks="),(expanded,"expanded=")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            self.put('\n' + tag)
            self.put_in_dquotes(s)</t>
<t tx="ekr.20040701065235.4"></t>
<t tx="ekr.20040701065235.5"></t>
<t tx="ekr.20040701083349.1"></t>
<t tx="ekr.20040701193902"></t>
<t tx="ekr.20040701193902.1"># Potential real problems.
(fixed) c:\prog\leoCVS\leo\src\leoAtFile.py:5731: Variable (line) used before being set

# Not real problems...
c:\prog\leoCVS\leo\src\leoAtFile.py:4516: Overridden method (putCloseNodeSentinel)
 doesnt match signature in class (leoAtFile.oldDerivedFile)
c:\prog\leoCVS\leo\src\leoAtFile.py:4550: Overridden method (putOpenNodeSentinel)
  doesnt match signature in class (leoAtFile.oldDerivedFile)
c:\prog\leoCVS\leo\src\leoAtFile.py:4697: Overridden method (write)
  doesnt match signature in class (leoAtFile.oldDerivedFile)</t>
<t tx="ekr.20040701193902.2"># Real bugs
(fixed) c:\prog\leoCVS\leo\src\leoColor.py:654: No global (false) found
(fixed) c:\prog\leoCVS\leo\src\leoColor.py:2173: Base class (leoColor.colorizer) __init__() not called</t>
<t tx="ekr.20040701193902.3"># Potential real problems
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1529: Function return types are inconsistent
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4223: Function returns a value and also implicitly returns None
</t>
<t tx="ekr.20040701193902.4">c:\prog\leoCVS\leo\src\leoFileCommands.py:1977: No class attribute (targetFileName) found
c:\prog\leoCVS\leo\src\leoFileCommands.py:1977: No class attribute (writeError) found
</t>
<t tx="ekr.20040701193902.5"># Potential real problem.
(fixed) c:\prog\leoCVS\leo\src\leoFind.py:694: Function returns a value and also implicitly returns None</t>
<t tx="ekr.20040701193902.6">(suppressed) c:\prog\leoCVS\leo\src\leoImport.py:190: Object (lastVnode) has no attribute (insertAfter)
(suppressed) c:\prog\leoCVS\leo\src\leoImport.py:192: Object (lastVnode) has no attribute (insertAsNthChild)
(suppressed) c:\prog\leoCVS\leo\src\leoImport.py:197: Object (lastVnode) has no attribute (parent)</t>
<t tx="ekr.20040701193902.7"># Real bug.
(fixed) C:\prog\leoCVS\leo\src\leoUndo.py:699: Redefining attribute (saveTree) original line (628)

# Potential real problems.
(fixed) c:\prog\leoCVS\leo\src\leoNodes.py:1976: Format string argument count (1) doesnt match arguments (2)
(fixed) c:\prog\leoCVS\leo\src\leoNodes.py:1978: Format string argument count (1) doesnt match arguments (2)
(fixed) c:\prog\leoCVS\leo\src\leoNodes.py:1981: Function returns a value and also implicitly returns None
(fixed) c:\prog\leoCVS\leo\src\leoNodes.py:1936: Function returns a value and also implicitly returns None
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:753: Redefining attribute (hasChildren) original line (747)
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:2143: Redefining attribute (isDirty) original line (1704)
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:3212: Redefining attribute (invalidOutline) original line (2847)
</t>
<t tx="ekr.20040701193902.8"># Potential real problems.
(fixed) c:\prog\leoCVS\leo\src\leoTkinterFind.py:295: Function returns a value and also implicitly returns None
</t>
<t tx="ekr.20040701193902.9"># Potential real problem.
(suppressed) c:\prog\leoCVS\leo\src\leoTkinterFrame.py:2022: Overridden method (deleteTextSelection)
    doesnt match signature in class(leoFrame.leoBody)
</t>
<t tx="ekr.20040701193902.10"># Potential real problem.
(suppressed) c:\prog\leoCVS\leo\src\leoTkinterTree.py:445:
    Overridden method (redraw_now) doesnt match signature in class (leoFrame.leoTree)
</t>
<t tx="ekr.20040701193902.11"># Potential real problem
(fixed) c:\prog\leoCVS\leo\src\leoUndo.py:220: Format string argument count (2) doesnt match arguments (3)</t>
<t tx="ekr.20040701194847"></t>
<t tx="ekr.20040701203211">@killcolor

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:935: Module (binascii) re-imported
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:936: Module (pickle) re-imported

(suppressed) C:\prog\leoCVS\leo\src\leo.py:266: Module (profile) re-imported
(suppressed) C:\prog\leoCVS\leo\src\leo.py:153: Module (leo) imports itself
(suppressed) C:\prog\leoCVS\leo\src\leo.py:33: Imported module (pychecker) not used

(rewrote code) c:\prog\leoCVS\leo\src\leoApp.py:357:   No module attribute (leoID) found

(suppressed) c:\prog\leoCVS\leo\src\leoFind.py:694: Function returns a value and also implicitly returns None
(suppressed) C:\prog\leoCVS\leo\src\leoCommands.py:4223: Function returns a value and also implicitly returns None

(suppressed) c:\python23\lib\distutils\errors.py:13: Variable (__revision__) not used
</t>
<t tx="ekr.20040701212305">@killcolor

(fixed) C:\prog\leoCVS\leo\src\leoFrame.py:1221: No class attribute (insertPOint) found
(fixed) C:\prog\leoCVS\leo\src\leoGui.py:330: No class attribute (oop) found

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2047: No class attribute (targetFileName) found
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2047: No class attribute (writeError) found</t>
<t tx="ekr.20040702080759"></t>
<t tx="ekr.20040702085529">if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")</t>
<t tx="ekr.20040702090737">@
The following code would be way to expensive to insert in findAllPotentiallyDirtyNodes!
Also, it marks almost all @file nodes as dirty in LeoPy.leo.
@c

 if setDescendentsDirty:
    child = v2.firstChild()
    while child:
        if child not in nodes and child not in addedNodes:
            addedNodes.append(child)
        child = child.next()
        
@ Instead, p.setAllAncestorAtFileNodesDirty only marks direct descendent nodes as potential candidates.  This will do what is needed in most cases, but perhaps not in all cases involving clones.  It's an interesting proof...

Still, I think the present code will be good enough;  it plugs all the obvious holes.</t>
<t tx="ekr.20040702104823">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20040704102411"></t>
<t tx="ekr.20040705201018">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="ekr.20040709194954">if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 1: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040710050236">def drawClickFrame (self,p,y):
    
    h = self.line_height ;  defaultColor = ""
    
    # Define a slighly larger rect to catch clicks.

    click_rect = self.canvas.create_rectangle(0,y,1000,y+h-3,tag="clickBox")
    self.canvas.itemconfig(click_rect,fill=defaultColor,outline=defaultColor)
    
    id_click = self.canvas.tag_bind(click_rect, "&lt;1&gt;", p.OnBoxClick)
    self.tagBindings.append((click_rect,id_click,"&lt;1&gt;"),)
    
    if 0: # A major change to the user interface.
        
        # Define a slighly smaller rect to colorize.
        color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
        self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)
        
        # Color the click box or the headline
        def enterRect(event,id=color_rect,p=p,t=self.lastText):
            if 1: # Color or underline the headline
                t2 = self.lastColoredText
                if t2: # decolor the old headline.
                    if 1: # deunderline
                        t2.tag_delete('underline')
                    else: # decolor
                        t2.configure(background="white")
                if t and p != self.editPosition():
                    if 1: # underline
                        t.tag_add('underline','1.0','end')
                        t.tag_configure('underline',underline=True)
                    else: # color
                        t.configure(background="LightSteelBlue1")
                    self.lastColoredText = t
                else: self.lastColoredText = None
            else: # Color the click box.
                if self.lastClickFrameId:
                    self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
                self.lastClickFrameId = id
                color = "LightSteelBlue1"
                self.canvas.itemconfig(id,fill=color,outline=color)
    
        bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
        self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)
    </t>
<t tx="ekr.20040710060809">def onHeadlineClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.onHeadlineClick()
    
def onHeadlineRightClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineRightClick()
    
def onHeadlineKeyCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineKey()
    
    </t>
<t tx="ekr.20040712084911.1">def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20040716061450">if headline.strip() == v.headString().strip():
    t.setVisited() # Supress warning about unvisited node.
    return t
else:
    at.readError(
        "Mismatched headline.\nExpecting: %s\ngot: %s" %
        (headline,v.headString()))
    g.trace("Mismatched headline",headline,v.headString())
    g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
    return None</t>
<t tx="ekr.20040716064333">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()</t>
<t tx="ekr.20040716064333.1">at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
</t>
<t tx="ekr.20040716065356">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()</t>
<t tx="ekr.20040716105102">i = last_nosent_i

if i + 1 &lt; len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]</t>
<t tx="ekr.20040717112739">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.</t>
<t tx="ekr.20040717113036">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "&lt;perfectImport string-file&gt;"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None</t>
<t tx="ekr.20040717132539">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)</t>
<t tx="ekr.20040717133944"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20040718035658">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()</t>
<t tx="ekr.20040718045423">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break</t>
<t tx="ekr.20040718101315">def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    &gt;&gt;&gt; import leoGlobals as g
    &gt;&gt;&gt; s = "a\\n \\t\\n\\t\\t \\t\\nb"
    &gt;&gt;&gt; theLines = g.splitLines(s)
    &gt;&gt;&gt; theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    &gt;&gt;&gt; g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        stripped_line = lines[i].lstrip(" \t")
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines</t>
<t tx="ekr.20040725044521.1">def edit_text (self,p):
    
    c = self.c
    
    if c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.getEditTextDict(p.v)
        for p2,t2 in pairs:
            if p.equal(p2):
                # g.trace("found",t2)
                return t2
        return None
    else:
        return None</t>
<t tx="ekr.20040731053740"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"</t>
<t tx="ekr.20040731204831">def getLastTracebackLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return lineno
        except:
            g.trace("bad line number")
            return 0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        item = data[-1]
        n = item[1]
        return n</t>
<t tx="ekr.20040731211839">errList = traceback.format_exception(typ,val,tb)

print ; print "es_exception (format_exception)"
for item in errList:
    print item
# Strip cruft lines.
s1 = "Traceback (most recent call last):"
s2 = "exec script in {}"
lines = []
for line in errList[-4:]:
    if n is None:
        tag = 'File "&lt;string&gt;", line'
        i = line.find(tag)
        if i &gt; -1:
            &lt;&lt; compute n from the line &gt;&gt;
    if not g.match(line,0,s1) and line.find(s2) == -1:
        lines.append(line)</t>
<t tx="ekr.20040801060323">@ This file contains seldom-used project nodes.

I created this file by copying project nodes from leoPy.leo and pasting them
with the Paste Retaining Clones command.</t>
<t tx="ekr.20040803072955.7">def newBox (self,p,x,y,image):
    
    canvas = self.canvas ; tag = "plusBox" # 9/5/04: was plugBox.

    if self.freeBoxes:
        theId = self.freeBoxes.pop(0)
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),align=-20)

    assert(theId not in self.visibleBoxes)
    self.visibleBoxes.append(theId)

    assert(not self.ids.get(theId))
    assert(p)
    self.ids[theId] = p

    return theId</t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.redrawing = False # Used only to disable traces.
    self.trace = False
    self.verbose = False
    self.useBindtags = True
    self.generation = 0
    self.dragging = False
    self.prevPositions = 0
    self.expanded_click_area = g.app.config.getBoolWindowPref("expanded_click_area")
    
    self.createPermanentBindings()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.disableRedraw = False # True: reschedule a redraw for later.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.20">def createPermanentBindings (self):
    
    canvas = self.canvas

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','&lt;Button-1&gt;', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)
    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = Tk.Text(canvas) # This _must_ be a Text widget attached to the canvas!
        if 1: # Either way works properly.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
            t.bind("&lt;Key&gt;",      self.onHeadlineKey, '+')
        t.bind("&lt;Control-t&gt;",self.onControlT)
    
        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()</t>
<t tx="ekr.20040803072955.37">def drawClickBox (self,p,y):

    canvas = self.canvas ; h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        theId = self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20040803072955.38">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803072955.81">def onIconBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    tree = self ; canvas = tree.canvas
    
    if self.trace and self.verbose: g.trace()
    
    p = self.eventToPosition(event)
    if not p: return
    
    if not g.doHook("iconclick1",c=c,p=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        g.app.findFrame.handleUserClick(p) # 4/3/04
        g.doHook("iconclick2",c=c,p=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040803072955.91">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update p &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040803072955.92">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20040803072955.93">self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040803072955.94">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) &gt; limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040803072955.95">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040803072955.96"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20040803072955.97">if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040809071510"></t>
<t tx="ekr.20040809071510.1"></t>
<t tx="ekr.20040809071510.2">def scanAtFileOptions (h,err_flag=False):
    
    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        &lt;&lt; scan another @file option &gt;&gt;
        
    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)
            
    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList</t>
<t tx="ekr.20040809071510.3">i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err &gt; -1:
    g.es("unknown option:" + h[err:i] + " in " + h)</t>
<t tx="ekr.20040809071510.4">def skip_id(s,i,chars=None):

    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
</t>
<t tx="ekr.20040809071510.5">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20040809071510.6"></t>
<t tx="ekr.20040809071510.7">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="ekr.20040809071510.8">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="ekr.20040809071510.9"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="ekr.20040809071510.10">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="ekr.20040809071510.11">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="ekr.20040809071510.12">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="ekr.20040809071510.13">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="ekr.20040809071510.14">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="ekr.20040809071510.15">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="ekr.20040809071510.16"></t>
<t tx="ekr.20040809071510.17">@killcolor

- Leo now vetos the shutdown logic if saving a dirty file fails.

- Leo prints in red the warning about not being able save the read-only file.

- The user can use the Save To command to save the file. The Save To command
does not clear the file's dirty bit, so Leo will prompt again to save the file.
The user will have to ignore this prompt in order to exit. This is basically
correct: the _original_ file has not been saved.</t>
<t tx="ekr.20040809071510.18">def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.</t>
<t tx="ekr.20040809071510.19">def promptForSave (self):
    
    """Prompt the user to save changes.
    
    Return True if the user vetos the quit or save operation."""
    
    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))
        
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.</t>
<t tx="ekr.20040809071510.20"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")</t>
<t tx="ekr.20040809071510.21">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,v=v,fileName=fileName)
    if ok is None:
        c.beginUpdate()
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            c.setChanged(False) # Clears all dirty bits.
            g.es("saved: " + g.shortFileName(fileName))
            if g.app.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()
        c.endUpdate()
    g.doHook("save2",c=c,v=v,fileName=fileName)
    return ok</t>
<t tx="ekr.20040809071510.22">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c ; config = g.app.config

    self.assignFileIndices()
    if not outlineOnlyFlag:
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        &lt;&lt; create the output file &gt;&gt;
        &lt;&lt; update leoConfig.txt &gt;&gt;
        &lt;&lt; put the .leo file &gt;&gt;
    except:
        &lt;&lt; report the exception &gt;&gt;
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
    if self.outputFile:
        &lt;&lt; close the output file &gt;&gt;
        &lt;&lt; delete backup file &gt;&gt;
        return True
    else: # This probably will never happen because errors should raise exceptions.
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
        
write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20040809071510.23">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20040809071510.24"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20040809071510.25"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    try:
        backupName = g.os_path_join(g.app.loadDir,fileName)
        backupName = fileName + ".bak"
        if g.os_path_exists(backupName):
            os.unlink(backupName)
        # os.rename(fileName,backupName)
        g.utils_rename(fileName,backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception creating backup file: " + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception creating backup file: " + backupName)
        g.es_exception()
        backupName = None
        return False
else:
    backupName = None</t>
<t tx="ekr.20040809071510.26">self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
    g.es("can not open " + fileName)
    &lt;&lt; delete backup file &gt;&gt;
    return False</t>
<t tx="ekr.20040809071510.27">if backupName and g.os_path_exists(backupName):
    try:
        os.unlink(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
</t>
<t tx="ekr.20040809071510.28">c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()</t>
<t tx="ekr.20040809071510.29">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20040809071510.30">g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
    try:
        self.outputFile.close()
        self.outputFile = None
    except:
        g.es("exception closing: " + fileName)
        g.es_exception()</t>
<t tx="ekr.20040809071510.31">try:
    self.outputFile.close()
    self.outputFile = None
except:
    g.es("exception closing: " + fileName)
    g.es_exception()</t>
<t tx="ekr.20040809071510.32">g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
    try:
        os.unlink(fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting: " + fileName)
            g.es_exception()
    except:
        g.es("exception deleting: " + fileName)
        g.es_exception()
        
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    try:
        g.utils_rename(backupName, fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception renaming " + backupName + " to " + fileName)
            g.es_exception()
    except:
        g.es("exception renaming " + backupName + " to " + fileName)
        g.es_exception()</t>
<t tx="ekr.20040809071510.33"></t>
<t tx="ekr.20040809071510.34"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20040809071510.35"></t>
<t tx="ekr.20040809071510.36">@killcolor

- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.</t>
<t tx="ekr.20040809071510.37">def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script</t>
<t tx="ekr.20040809071510.38">def executeScript(self,p=None,script=None):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p)
    &lt;&lt; redirect output &gt;&gt;
    if script:
        script = script.strip()
    if script:
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            &lt;&lt; unredirect output &gt;&gt;
            if not script1:
                g.es("end of script",color="purple")
        except:
            &lt;&lt; unredirect output &gt;&gt;
            g.es("exception executing script")
            n = g.es_exception(full=False,c=c)
            if n is not None:
                &lt;&lt; dump the lines of script near the error &gt;&gt;
                if p and not script1:
                    c.goToScriptLineNumber(p,script,n)
            c.frame.tree.redrawAfterException()
    elif not error:
        &lt;&lt; unredirect output &gt;&gt;
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() </t>
<t tx="ekr.20040809071510.39">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20040809071510.40">lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    s = "line %d: %s" % (n,lines[n-1])
    print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1</t>
<t tx="ekr.20040809071510.41">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="ekr.20040809071510.42">def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    &lt;&lt; assert equivalence of lastVisible methods &gt;&gt;
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors</t>
<t tx="ekr.20040809071510.43">if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False</t>
<t tx="ekr.20040809071510.44"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")</t>
<t tx="ekr.20040809071510.45">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others</t>
<t tx="ekr.20040809071510.46">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"</t>
<t tx="ekr.20040809071510.47">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"</t>
<t tx="ekr.20040809071510.48">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"</t>
<t tx="ekr.20040809071510.49">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20040809071510.50">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"</t>
<t tx="ekr.20040809071510.51">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"</t>
<t tx="ekr.20040809071510.52">vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"</t>
<t tx="ekr.20040809071510.53"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"</t>
<t tx="ekr.20040809071510.54">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")</t>
<t tx="ekr.20040809071510.55">s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")</t>
<t tx="ekr.20040809071510.56">@killcolor

- Added to manifest.in:
    
include doc/default.css
include doc/leo_rst.css
include doc/silver_city.css

- Added to leo.nsi:

File c:\prog\leoCVS\leo\doc\default.css
File c:\prog\leoCVS\leo\doc\leo_rst.css
File c:\prog\leoCVS\leo\doc\silver_city.css

- Uploaded leo-stylesheets.zip to plugins package at SourceForge.</t>
<t tx="ekr.20040809071510.57"></t>
<t tx="ekr.20040809071510.58">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2655535
By: nobody

I think this solves your request:

@color

def selectWord( event ):
    event.widget.tag_add( 'sel', 'insert wordstart', 'insert' )
textwidget.bind( '&lt;Double-Button-1&gt;', selectWord )

@nocolor

add it to the code where the Text widget editor is created and you should have
the behavior and not feel grief anymore.  Oh yeah, 'textwidget' needs to be
the reference to the Text editor, whatever it's called.  This is actually shorter
than I thought it was going to be. :)

EKR: This doesn't seem to work, regardless of where it is placed.
</t>
<t tx="ekr.20040809071510.59"></t>
<t tx="ekr.20040809071510.60">def setTextSelection (self,t,start,end):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    t.mark_set("insert",end)</t>
<t tx="ekr.20040809071510.61">def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodydclick1",c=c,v=v,event=event):
            if event: # 8/4/02: prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked
                # 7/9/04
                event.widget.tag_add('sel', 'insert wordstart', 'insert wordend')
            body = self.bodyCtrl
            start = body.index(index + " wordstart")
            end = body.index(index + " wordend")
            self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.</t>
<t tx="ekr.20040809071510.62">def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("&lt;Button-1&gt;", frame.OnBodyClick)
    t.bind("&lt;Button-3&gt;", frame.OnBodyRClick)
    t.bind("&lt;Double-Button-1&gt;", frame.OnBodyDoubleClick)
    t.bind("&lt;Key&gt;", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)</t>
<t tx="ekr.20040809071510.63">def OnBodyClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyclick1",c=c,v=v,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyrclick1",c=c,v=v,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("iconrclick")</t>
<t tx="ekr.20040809071510.64">def OnActivateBody (self,event=None):

    try:
        frame = self ; c = frame.c ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
            # Reference to bodyCtrl is allowable in an event handler.
            gui.set_focus(c,frame.body.bodyCtrl) 
    except:
        g.es_event_exception("activate body")</t>
<t tx="ekr.20040809071510.65">http://sourceforge.net/forum/message.php?msg_id=2649750</t>
<t tx="ekr.20040809071510.66"></t>
<t tx="ekr.20040809071510.67">def createCanvas (self,parentFrame):
    
    frame = self ; config = g.app.config
    
    scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 1:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20040809071510.68">import threading
import time
way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('&lt;Shift Button-3&gt;',exe)
    canvas.bind_all('&lt;Shift Button-1&gt;',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;', off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;', off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;', exe)
    canvas.bind_all( '&lt;Button-1&gt;', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '&lt;ButtonRelease-1&gt;', off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;', off)</t>
<t tx="ekr.20040809071510.69"></t>
<t tx="ekr.20040809071510.70"></t>
<t tx="ekr.20040809071510.71">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2653456
By: nobody

askopenfilenames allows you to select and return multiple file names. This does
work on Windows.  I haven't tested it on Linux.</t>
<t tx="ekr.20040809071510.72">@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def CheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):
    import sre  # Unicode-aware regular expressions
    #
    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )
    #
    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )
    #
    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount &gt; len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount &gt; len(testVersion):
        tokenCount = len(testVersion)
    #
    # Apply the stringCompare flags
    justInteger = sre.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg
    #
    # Compare the versions
    if condition == "&gt;=":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == "&gt;":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "&lt;":
        for i in range(tokenCount):
            if testVersion[i] &gt;= testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "&lt;=":
        for i in range(tokenCount):
            if testVersion[i] &gt; testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal
    #
    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."</t>
<t tx="ekr.20040809071510.73">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    # askopenfilenames only exists in Python 2.3 or later
    if multiple and g.CheckVersion(sys.version,"2.3"):
        files = tkFileDialog.askopenfilenames(
            title=title, filetypes=filetypes)
        return list(files)
    else:
        file = tkFileDialog.askopenfilename(
            title=title, filetypes=filetypes)
        if multiple: return [file]
        else:        return file
    
        # DTHEIN 2004.01.31: remove default extension on open,
        # so that we can open files without extensions

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
    # EKR: 2004.01.31: remove default extensions on save too.
    # defaultextension=defaultextension)</t>
<t tx="ekr.20040809071510.74"></t>
<t tx="ekr.20040809071510.75"></t>
<t tx="ekr.20040809071510.76">def exportHeadlines (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.exportHeadlines(fileName)

</t>
<t tx="ekr.20040809071510.77">def flattenOutline (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.flattenOutline(fileName)

</t>
<t tx="ekr.20040809071510.78">def importAtRoot (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
</t>
<t tx="ekr.20040809071510.79">def importAtFile (self):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@file")</t>
<t tx="ekr.20040809071510.80">def importCWEBFiles (self):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
</t>
<t tx="ekr.20040809071510.81">def importFlattenedOutline (self):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
</t>
<t tx="ekr.20040809071510.82">def importNowebFiles (self):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
</t>
<t tx="ekr.20040809071510.83">def outlineToCWEB (self):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"cweb")

</t>
<t tx="ekr.20040809071510.84">def outlineToNoweb (self):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

</t>
<t tx="ekr.20040809071510.85">def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py")

    if names:
        c.importCommands.removeSentinelsCommand (names)</t>
<t tx="ekr.20040809071510.86">def weave (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.weave(fileName)
</t>
<t tx="ekr.20040809071510.87"></t>
<t tx="ekr.20040809071510.88">def removeSentinelsCommand (self,paths):

    self.setEncoding()

    for fileName in paths:
        path, self.fileName = g.os_path_split(fileName) # path/fileName
        &lt;&lt; Read file into s &gt;&gt;
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = g.app.config.remove_sentinels_extension
        if ext == None or len(ext) == 0:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        # g.trace(repr(s))
        &lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="ekr.20040809071510.89">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return</t>
<t tx="ekr.20040809071510.90"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None</t>
<t tx="ekr.20040809071510.91">try:
    mode = g.app.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    file = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    file.write(s)
    file.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()</t>
<t tx="ekr.20040809071510.92">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.webType = webType

    c.beginUpdate()
    for fileName in files:
        v = self.createOutlineFromWeb(fileName,current)
        v.contract()
        v.setDirty()
        c.setChanged(True)
    c.selectVnode(current)
    c.endUpdate()</t>
<t tx="ekr.20040809071510.93">def importFilesCommand (self,files,treeType,
    perfectImport=True,testing=False,verbose=False):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)</t>
<t tx="ekr.20040809071510.94">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)</t>
<t tx="ekr.20040809071510.95">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; at = c.atFileCommands
    current = c.currentVnode()
    
    c.beginUpdate()
    
    for fileName in paths:
        v = parent.insertAfter()
        v.initHeadString("Imported @file " + fileName)
        c.undoer.setUndoParams("Import",v,select=current)
        at.read(v,importFileName=fileName)
        c.selectVnode(v)
        v.expand()

    c.endUpdate()</t>
<t tx="ekr.20040809071510.96">def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v</t>
<t tx="ekr.20040809071510.97">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None</t>
<t tx="ekr.20040809071510.98"></t>
<t tx="ekr.20040809071510.99">@ Warning:
g.importFromPath uses imp.load_module, and that is equivalent to reload!
Calling this function to reload Leo files will crash Leo!
@c

def importFromPath (name,path,verbose=False):
    
    import imp

    try:
        file = None ; data = None ; result = None
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                if verbose:
                    s = "Can not import %s from %s" % (mod_name,path)
                    print s ; g.es(s,color="blue")
            if data:
                file,pathname,description = data
                try:
                    result = imp.load_module(mod_name,file,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if file: file.close()

    return result</t>
<t tx="ekr.20040809071510.100"># This is no longer used: we use toString logic instead.</t>
<t tx="ekr.20040809071510.101"></t>
<t tx="ekr.20040809071510.102">@language plain

For some reason, spurious entries in a tnodeList for @thin trees wipes out all the headlines in the @thin tree.  This needs more investigation.

This happened when running c.checkPythonCode from a script.  Apparently the script set tnodeList by mistake.

The quick fix was to set at.root.v.t.tnodeList = [] in the toString logic in new_df.write.</t>
<t tx="ekr.20040809071510.103"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    &lt;&lt; open the file; return on error &gt;&gt;
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.</t>
<t tx="ekr.20040809071510.104">if toString:
    at.targetFileName = "&lt;new_df.write string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return</t>
<t tx="ekr.20040809071510.105"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20040809071510.106"></t>
<t tx="ekr.20040809071510.107">@killcolor

https://sourceforge.net/forum/message.php?msg_id=2665410
By: bwmulder

I just updated from CVS. The attempt to open LeoPyRef.leo fails because
of runOpenFileDialog.

If "multiple" is false, it calls tkFileDialog.askopenfilename, and then makes
a list out of the result of this function, which is a list of characters.

Maybe this function should be really split into two versions: one for exactly
one file, and another one for a list of files? Probably the latter should *always*
return a list, even if the corresponding function really only returns one
filename.

[I am running on Windows XP].
</t>
<t tx="ekr.20040809071510.108">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)</t>
<t tx="ekr.20040809071510.109">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow==True and # The window was open on startup
    c.changed==False and c.frame.saved==False and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20040809071510.110"></t>
<t tx="ekr.20040809071510.111">@nocolor

when opening a leo document that contains an @file, say like @file helloworld.bas, leo reports upon opening that:

Leo Log Window...
Leo 4.2 beta 2, build 1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32
File encoding: UTF-8
reading: D:\Programming\HelloWorld.leo
reading: @file helloworld.bas
----- error reading @file helloworld.bas
Mismatched headline.
Expecting: @file helloworld
got: @file helloworld.bas
leoConfig.txt encoding: utf-8
@run encoding: mbcs
13 plugins loaded
leoID = fil
</t>
<t tx="ekr.20040809071510.112">def findChild (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
    
    if 0: # Old code:
        &lt;&lt; Check the headlines &gt;&gt;</t>
<t tx="ekr.20040809071510.113">if headline.strip() == v.headString().strip():
    t.setVisited() # Supress warning about unvisited node.
    return t
else:
    at.readError(
        "Mismatched headline.\nExpecting: %s\ngot: %s" %
        (headline,v.headString()))
    g.trace("Mismatched headline",headline,v.headString())
    g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
    return None</t>
<t tx="ekr.20040809071510.114"></t>
<t tx="ekr.20040809071510.115">By: Bernhard Mulder - bwmulder
Python check/pretty printing bug  
2004-07-18 13:09
It seems that the new python pretty printing / checking code has problems with triple quoted strings.

I tried this with an (updated) version of the basic_undo code posted on my site. </t>
<t tx="ekr.20040809071510.116">@ignore
@language python
@tabwidth -4</t>
<t tx="ekr.20040809071510.117">@killcolor

- More options, of course.  The following methods do the actual reformatting:
    
    - putOperator:      puts whitespace around operators.
    - putNormalToken:   puts whitespace around everything else.

Note that you can use putToken to dump lines for debugging.

- Once you have determined the 8323 formatting options that would be necessary to make _you_ happy, you can create those options in leoConfig.txt or a plugin :-)
</t>
<t tx="ekr.20040809071510.118">@killcolor

- Added onNodeOnly option to new_df.write.  This allows the Check Python command to get one node at a time for checking.

- Fixed bug in putNormalToken: @others was turned into others if there was leading whitespace.

- Fixed bug in setBodyStringOrPane (!).  The new code sets the selection properly.</t>
<t tx="ekr.20040809071510.119"># We borrow most of the Change/Change all logic.</t>
<t tx="ekr.20040809071510.120">def redoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        # g.trace(u.undoType,u.p,u.newText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.v.setTnodeText(u.newText)
            u.p.setDirty()
            count += 1
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.newText)
            count += 1
        else: assert(False)

    g.es("redo %d instances" % count)</t>
<t tx="ekr.20040809071510.121">def undoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        # g.trace(u.undoType,u.p,u.oldText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.setTnodeText(u.oldText)
            count += 1
            u.p.setDirty()
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.oldText)
            count += 1
        else: assert False, "bad undo type:" % u.undoType

    g.es("undo %d instances" % count)</t>
<t tx="ekr.20040809071510.122"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using v's body text &gt;&gt;
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            &lt;&lt; print mismatch trace &gt;&gt;
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)</t>
<t tx="ekr.20040809071510.123"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading &gt; 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading &gt; 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))</t>
<t tx="ekr.20040809071510.124"># Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result</t>
<t tx="ekr.20040809071510.125">textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result</t>
<t tx="ekr.20040809071510.126">print "undo mismatch"
print "expected:",result
print "actual  :",textResult</t>
<t tx="ekr.20040809071510.127"></t>
<t tx="ekr.20040809071510.128">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20040809071510.129">def setTextSelection (self,i,j=None):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j)</t>
<t tx="ekr.20040809071510.130">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)</t>
<t tx="ekr.20040809071510.131"></t>
<t tx="ekr.20040809071510.132"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set dict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return dict</t>
<t tx="ekr.20040809071510.133">j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i</t>
<t tx="ekr.20040809071510.134">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="ekr.20040809071510.135">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20040809071510.136">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.</t>
<t tx="ekr.20040809071510.137"># @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20040809071510.138">if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
</t>
<t tx="ekr.20040809071510.139">if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
</t>
<t tx="ekr.20040809071510.140">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20040809071510.141">if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20040809071510.142">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20040809071510.143">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20040809071510.144">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20040809071510.145">def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language</t>
<t tx="ekr.20040809071510.146">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20040809071510.147">def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()

    if full:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        
    if 1:
        n = g.getLastTracebackLineNumber()
    else:
        # old, kludgy code...
        &lt;&lt; look for lines containing a specific message &gt;&gt;

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    return n</t>
<t tx="ekr.20040809071510.148">errList = traceback.format_exception(typ,val,tb)

print ; print "es_exception (format_exception)"
for item in errList:
    print item
# Strip cruft lines.
s1 = "Traceback (most recent call last):"
s2 = "exec script in {}"
lines = []
for line in errList[-4:]:
    if n is None:
        tag = 'File "&lt;string&gt;", line'
        i = line.find(tag)
        if i &gt; -1:
            &lt;&lt; compute n from the line &gt;&gt;
    if not g.match(line,0,s1) and line.find(s2) == -1:
        lines.append(line)</t>
<t tx="ekr.20040809071510.149">i += len(tag)
j = line.find(',',i)
if j &gt; i: n = line[i:j]
else:     n = line[i:].strip()
# g.trace(n)
try: n = int(n)
except (TypeError,ValueError): n = None</t>
<t tx="ekr.20040809071510.150"></t>
<t tx="ekr.20040809071510.151">def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20040809071510.152"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="ekr.20040809071510.153">if kind == noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
    assert(not at.pending)
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (cDirective,codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.</t>
<t tx="ekr.20040809071510.154"></t>
<t tx="ekr.20040809071510.155"></t>
<t tx="ekr.20040809071510.156"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self
    if at.outputFile:
        at.outputFile.flush()
        if self.toStringFlag:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None</t>
<t tx="ekr.20040809071510.157">def writeOpenFile(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    at = self ; c = at.c
    
    &lt;&lt; init atFile ivars for writing &gt;&gt;
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    &lt;&lt; put all @first lines in root &gt;&gt;

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    &lt;&lt; put all @last lines in root &gt;&gt;
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()</t>
<t tx="ekr.20040809071510.158"># Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.raw = False
assert(at.toStringFlag == toString) # Must have been set earlier.

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.</t>
<t tx="ekr.20040809071510.159">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    self.os(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20040809071510.160">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        self.os(line[i:])</t>
<t tx="ekr.20040809071510.161">def norefWrite(self,root,toString=False):

    at = self

    c = at.c ; at.root = root
    at.errors = 0
    at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
    at.sentinels = True # 10/1/03
    at.thinFile = False # 5/17/04
    c.endEditing() # Capture the current headline.
    try:
        at.targetFileName = root.atNorefFileNodeName()
        ok = at.openWriteFile(root,toString)
        if not ok: return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.handleWriteException(root)
        
rawWrite = norefWrite
</t>
<t tx="ekr.20040809071510.162">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="ekr.20040809071510.163">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20040809071510.164">s2 = g.app.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20040809071510.165">at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) &gt; 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20040809071510.166">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()</t>
<t tx="ekr.20040809071510.167"></t>
<t tx="ekr.20040809071510.168"></t>
<t tx="ekr.20040809071510.169">def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta</t>
<t tx="ekr.20040809071510.170">def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20040809071510.171"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="ekr.20040809071510.172">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)</t>
<t tx="ekr.20040809071510.173"></t>
<t tx="ekr.20040809071510.174">def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True</t>
<t tx="ekr.20040809071510.175">def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20040809071510.176">def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta</t>
<t tx="ekr.20040809071510.177">def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)</t>
<t tx="ekr.20040809071510.178"></t>
<t tx="ekr.20040809071510.179">def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
</t>
<t tx="ekr.20040809071510.180">def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        if not at.perfectImportRoot: # A kludge: we shouldn't be importing derived files here!
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta</t>
<t tx="ekr.20040809071510.181">def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta</t>
<t tx="ekr.20040809071510.182">def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta</t>
<t tx="ekr.20040809071510.183"></t>
<t tx="ekr.20040809071510.184">def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()</t>
<t tx="ekr.20040809071510.185">def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == docDirective,"@+doc","@+at")
    directive = g.choose(kind == docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)</t>
<t tx="ekr.20040809071510.186">def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20040809071510.187">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)</t>
<t tx="ekr.20040809071510.188">def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)</t>
<t tx="ekr.20040809071510.189">def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()</t>
<t tx="ekr.20040809071510.190"></t>
<t tx="ekr.20040809071510.191"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return othersDirective
        elif g.match_word(s,j,"@all"):
            return allDirective
        else:
            return noDirective

    table = (
        ("@all",allDirective),
        ("@c",cDirective),
        ("@code",codeDirective),
        ("@doc",docDirective),
        ("@end_raw",endRawDirective),
        ("@others",othersDirective),
        ("@raw",rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 &gt;= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            noDirective,atDirective)

    # 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1&gt;= n or s[i+1] not in string.ascii_letters):
        return noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # 10/14/02: return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return miscDirective

    return noDirective</t>
<t tx="ekr.20040809071510.192">def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    return -1 &lt; n1 &lt; n2, n1, n2</t>
<t tx="ekr.20040809071510.193"># Note:  self.outputFile may be either a fileLikeObject or a real file.

</t>
<t tx="ekr.20040809071510.194">def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))</t>
<t tx="ekr.20040809071510.195">def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()</t>
<t tx="ekr.20040809071510.196">def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    if s and self.outputFile:
        try:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            self.outputFile.write(s)
        except:
            g.es("exception writing:",s)
            g.es_exception(full=True)</t>
<t tx="ekr.20040809071510.197">@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first &amp; @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        &lt;&lt; handle @delims &gt;&gt;
    elif g.match_word(s,k,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,k,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i</t>
<t tx="ekr.20040809071510.198"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")</t>
<t tx="ekr.20040809071510.199">self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")</t>
<t tx="ekr.20040809071510.200">self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")</t>
<t tx="ekr.20040809071510.201">def putVnode (self,p,ignored):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    if 1: # New in 4.2 b3: use ignored argument to compute this without leaking positions.
        ignored = ignored or p.isAtIgnoreNode()
    else:
        for p2 in p.self_and_parents_iter():
            if p2.isAtIgnoreNode():
                isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("&lt;v")
    &lt;&lt; Put tnode index &gt;&gt;
    &lt;&lt; Put attribute bits &gt;&gt;
    &lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;
    fc.put("&gt;")
    &lt;&lt; Write the head text &gt;&gt;

    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,ignored)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="ekr.20040809071510.202">if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")</t>
<t tx="ekr.20040809071510.203">attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)</t>
<t tx="ekr.20040809071510.204"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)</t>
<t tx="ekr.20040809071510.205">if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")</t>
<t tx="ekr.20040809071510.206">headString = p.v.headString()

if headString:
    fc.put("&lt;vh&gt;")
    fc.putEscapedString(headString)
    fc.put("&lt;/vh&gt;")</t>
<t tx="ekr.20040809071510.207"></t>
<t tx="ekr.20040809071510.208">outlineMenu = self.createNewMenu("&amp;Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

&lt;&lt; create check submenu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20040809071510.209">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)</t>
<t tx="ekr.20040809071510.210">expandMenu = self.createNewMenu("&amp;Expand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)</t>
<t tx="ekr.20040809071510.211">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)</t>
<t tx="ekr.20040809071510.212">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)</t>
<t tx="ekr.20040809071510.213">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)</t>
<t tx="ekr.20040809071510.214">def defineMenuTables (self):
    
    c = self.c ; f = self.frame
    
    &lt;&lt; define edit menu tables &gt;&gt;
    &lt;&lt; define file menu tables &gt;&gt;
    &lt;&lt; define outline menu tables &gt;&gt;
    &lt;&lt; define window menu tables &gt;&gt;
    &lt;&lt; define help menu tables &gt;&gt;</t>
<t tx="ekr.20040809071510.215">&lt;&lt; define editMenuTopTable &gt;&gt;
&lt;&lt; define editMenuEditBodyTable &gt;&gt;
&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;
&lt;&lt; define editMenuFindMenuTable &gt;&gt;
&lt;&lt; define editMenuTop2Table &gt;&gt;</t>
<t tx="ekr.20040809071510.216">self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &amp;U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &amp;R reserved for Redo
    ("-",None,None),
    ("Cu&amp;t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&amp;y","Ctrl+C",f.OnCopyFromMenu),
    ("&amp;Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&amp;Delete",None,c.delete),
    ("Select &amp;All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))</t>
<t tx="ekr.20040809071510.217">self.editMenuEditBodyTable = (
    ("Extract &amp;Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &amp;Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&amp;Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&amp;lanks",None,c.convertAllBlanks),
    ("Convert All T&amp;abs",None,c.convertAllTabs),
    ("Convert &amp;Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &amp;Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&amp;Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&amp;Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&amp;Indent","Ctrl+]",c.indentBody),
    ("&amp;Unindent","Ctrl+[",c.dedentBody),
    ("&amp;Match Brackets","Ctrl+K",c.findMatchingBracket))</t>
<t tx="ekr.20040809071510.218">self.editMenuEditHeadlineTable = (
    ("Edit &amp;Headline","Ctrl+H",c.editHeadline),
    ("&amp;End Edit Headline","Escape",f.endEditLabelCommand),
    ("&amp;Abort Edit Headline","Shift-Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&amp;Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))</t>
<t tx="ekr.20040809071510.219">self.editMenuFindMenuTable = (
    ("&amp;Find Panel","Ctrl+F",c.findPanel),
    ("-",None,None),
    ("Find &amp;Next","F3",c.findNext),
    ("Find &amp;Previous","F4",c.findPrevious),
    ("&amp;Replace","Ctrl+=",c.replace),
    ("Replace, &amp;Then Find","Ctrl+-",c.replaceThenFind))</t>
<t tx="ekr.20040809071510.220">try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
    
self.editMenuTop2Table = (
    ("&amp;Go To Line Number","Alt+G",c.goToLineNumber),
    ("&amp;Execute Script","Alt+Shift+E",c.executeScript),
    ("Set Fon&amp;t...","Shift+Alt+T",c.fontPanel),
    ("Set &amp;Colors...","Shift+Alt+C",c.colorPanel),
    (label,"Alt+V",c.viewAllCharacters),
    ("-",None,None),
    ("Prefere&amp;nces","Ctrl+Y",c.preferences))</t>
<t tx="ekr.20040809071510.221">&lt;&lt; define fileMenuTopTable &gt;&gt;
&lt;&lt; define fileMenuTop2Table &gt;&gt;
&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;
&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuImportMenuTable &gt;&gt;
&lt;&lt; define fileMenuExportMenuTable &gt;&gt;
&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</t>
<t tx="ekr.20040809071510.222">self.fileMenuTopTable = (
    ("&amp;New","Ctrl+N",c.new),
    ("&amp;Open...","Ctrl+O",c.open))</t>
<t tx="ekr.20040809071510.223">self.fileMenuTop2Table = (
    ("-",None,None),
    ("&amp;Close","Ctrl+W",c.close),
    ("&amp;Save","Ctrl+S",c.save),
    ("Save &amp;As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &amp;Tangle
    ("Re&amp;vert To Saved",None,c.revert)) # &amp;Read/Write</t>
<t tx="ekr.20040809071510.224">self.fileMenuReadWriteMenuTable = (
    ("&amp;Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &amp;Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &amp;Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &amp;Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&amp;Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes),
    ("-",None,None),
    ("Write 4.x Derived Files",None,c.writeNewDerivedFiles),
    ("Write 3.x Derived Files",None,c.writeOldDerivedFiles))</t>
<t tx="ekr.20040809071510.225">self.fileMenuTangleMenuTable = (
    ("Tangle &amp;All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &amp;Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&amp;Tangle","Shift+Ctrl+T",c.tangle))</t>
<t tx="ekr.20040809071510.226">self.fileMenuUntangleMenuTable = (
    ("Untangle &amp;All",None,c.untangleAll),
    ("Untangle &amp;Marked",None,c.untangleMarked),
    ("&amp;Untangle","Shift+Ctrl+U",c.untangle))</t>
<t tx="ekr.20040809071510.227">self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&amp;file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&amp;root",None,c.importAtRoot),
    ("Import &amp;CWEB Files",None,c.importCWEBFiles),
    
    ("Import &amp;noweb Files",None,c.importNowebFiles),
    ("Import Flattened &amp;Outline",None,c.importFlattenedOutline))</t>
<t tx="ekr.20040809071510.228">self.fileMenuExportMenuTable = [
    ("Export &amp;Headlines",None,c.exportHeadlines),
    ("Outline To &amp;CWEB",None,c.outlineToCWEB),
    ("Outline To &amp;Noweb",None,c.outlineToNoweb),
    ("&amp;Flatten Outline",None,c.flattenOutline),
    ("&amp;Remove Sentinels",None,c.removeSentinels),
    ("&amp;Weave",None,c.weave)]</t>
<t tx="ekr.20040809071510.229">self.fileMenuTop3MenuTable = (
    ("E&amp;xit","Ctrl-Q",g.app.onQuit),)</t>
<t tx="ekr.20040809071510.230">&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;
&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;
&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;
&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</t>
<t tx="ekr.20040809071510.231">self.outlineMenuTopMenuTable = (
    ("C&amp;ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&amp;opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste &amp;Retaining Clones",None,c.pasteOutlineRetainingClones),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&amp;n",None,c.sortChildren), # Conflicted with Hoist.
    ("&amp;Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("&amp;Hoist",None,c.hoist),
    ("D&amp;e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  c,d,e,h,i,k,m,n,o,p,r,s,u
</t>
<t tx="ekr.20040809071510.232">self.outlineMenuCheckOutlineMenuTable = (

    ("Check &amp;Outline",None,c.checkOutline),
    ("&amp;Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &amp;All Python Code",None,c.checkAllPythonCode),
    ("&amp;Check Python &amp;Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&amp;rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&amp;Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20040809071510.233">self.outlineMenuExpandContractMenuTable = (
    ("&amp;Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &amp;Node","Alt+[",c.contractNode),
    ("Contract &amp;Parent","Alt+0",c.contractParent),
    ("-",None,None),
    ("Expand P&amp;rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&amp;ext Level","Alt+=",c.expandNextLevel),
    ("-",None,None),
    ("Expand To Level &amp;1","Alt+1",c.expandLevel1),
    ("Expand To Level &amp;2","Alt+2",c.expandLevel2),
    ("Expand To Level &amp;3","Alt+3",c.expandLevel3),
    ("Expand To Level &amp;4","Alt+4",c.expandLevel4),
    ("Expand To Level &amp;5","Alt+5",c.expandLevel5),
    ("Expand To Level &amp;6","Alt+6",c.expandLevel6),
    ("Expand To Level &amp;7","Alt+7",c.expandLevel7),
    ("Expand To Level &amp;8","Alt+8",c.expandLevel8),
    # ("Expand To Level &amp;9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &amp;All","Alt+9",c.expandAllHeadlines),
    ("Expand N&amp;ode","Alt+]",c.expandNode))</t>
<t tx="ekr.20040809071510.234">self.outlineMenuMoveMenuTable = (
    ("Move &amp;Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &amp;Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &amp;Right","Ctrl+R",c.moveOutlineRight),
    ("Move &amp;Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&amp;Promote","Ctrl+{",c.promote),
    ("&amp;Demote", "Ctrl+}",c.demote))</t>
<t tx="ekr.20040809071510.235">self.outlineMenuMarkMenuTable = (
    ("&amp;Mark","Ctrl-M",c.markHeadline),
    ("Mark &amp;Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &amp;Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &amp;Roots","Alt+R",c.markChangedRoots),
    ("Mark &amp;Clones","Alt+K",c.markClones),
    ("&amp;Unmark All","Alt+U",c.unmarkAll))</t>
<t tx="ekr.20040809071510.236">self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &amp;Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&amp;hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &amp;Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &amp;First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &amp;Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &amp;Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&amp;rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &amp;Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&amp;isible","Alt-UpArrow",c.selectVisBack),
    ("Go To Next &amp;Visible","Alt-DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt-Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt-Shift-DnArrow",c.selectThreadNext))</t>
<t tx="ekr.20040809071510.237">self.windowMenuTopTable = (
    ("&amp;Equal Sized Panes","Ctrl-E",f.equalSizedPanes),
    ("Toggle &amp;Active Pane","Ctrl-T",f.toggleActivePane),
    ("Toggle &amp;Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&amp;de",None,f.cascade),
    ("&amp;Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &amp;Compare Window",None,c.openCompareWindow),
    ("Open &amp;Python Window","Alt+P",c.openPythonWindow))</t>
<t tx="ekr.20040809071510.238">self.helpMenuTopTable = (
    ("&amp;About Leo...",None,c.about),
    ("Online &amp;Home Page",None,c.leoHome),
    ("-",None,None),
    ("Open Online &amp;Tutorial",None,c.leoTutorial))
    
self.helpMenuTop2Table = (
    ("Open &amp;Offline Tutorial",None,f.leoHelp),)
    
self.helpMenuTop3Table = (
    ("Open Leo&amp;Docs.leo",None,c.leoDocumentation),
    ("-",None,None),
    ("Open Leo&amp;Config.leo",None,c.leoConfig),
    ("Apply &amp;Settings",None,c.applyConfig))</t>
<t tx="ekr.20040809071510.239"></t>
<t tx="ekr.20040809071510.240"></t>
<t tx="ekr.20040809071510.241">def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result</t>
<t tx="ekr.20040809071510.242">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20040809071510.243">def checkPythonCode (self,unittest=False,ignoreAtIgnore=True,suppressErrors=False):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking all Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result</t>
<t tx="ekr.20040809071510.244">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20040809071510.245">def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self
    
    h = p.headString()
    body = g.getScript(c,p.copy(),oneNodeOnly=True)
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            print s ; g.es(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest)</t>
<t tx="ekr.20040809071510.246"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return
        
    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))
        
    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
        
    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: p.setMarked()</t>
<t tx="ekr.20040809071510.247">def dumpOutline (self):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()</t>
<t tx="ekr.20040809071510.248"></t>
<t tx="ekr.20040809071510.249">def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()</t>
<t tx="ekr.20040809071510.250">def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()</t>
<t tx="ekr.20040809071510.251">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20040809071510.252">def __init__ (self,c):
    
    self.changed = False
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.c = c
    self.p = c.currentPosition()
    self.prevName = None</t>
<t tx="ekr.20040809071510.253">def clear (self):
    self.lines = []</t>
<t tx="ekr.20040809071510.254">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 1:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20040809071510.255">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20040809071510.256">def get (self):
    
    return self.lines</t>
<t tx="ekr.20040809071510.257">def prettyPrintNode(self,p,dump):

    pp = self ; c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        pp.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            pp.putToken(token5tuple)
        lines = pp.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        pp.dumpLines(p,lines)
    else:
        pp.replaceBody(p,lines)</t>
<t tx="ekr.20040809071510.258">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20040809071510.259">def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = t5
    name = token.tok_name[t1].lower()
    val = t2
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    # g.trace(name,repr(val))
    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        self.lines.append(''.join(a))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
        if self.prevName == "def": # A personal idiosyncracy.
            a.append(' ') # Retain the blank before '('.
        self.prevName = val
    elif name == "number":
        a.append(val)
    elif name in ("comment","string"):
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(val)
        for line in lines:
            a.append(line)
            if line and line[-1] == '\n':
                self.lines.append(''.join(a))
                self.array = []
    elif name == "errortoken":
        a.append(val)
        if val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(line,scol+1)
            ws = line[scol+1:i]
            if ws: a.append(ws)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)</t>
<t tx="ekr.20040809071510.260">def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20040809071510.261">def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)</t>
<t tx="ekr.20040809071510.262">def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)</t>
<t tx="ekr.20040809071510.263">def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)</t>
<t tx="ekr.20040809071510.264"></t>
<t tx="ekr.20040809071510.265">@killcolor

- p.isAncestorOf is used only in the move methods and in find.selectNextVnode.

- It is likely that the bug does not affect the move methods significantly.</t>
<t tx="ekr.20040809071510.266">exception executing command

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 166, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 2458, in findNext
    g.app.findFrame.findNextCommand(c)
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 230, in findNextCommand
    self.findNext()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 554, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 594, in findNextMatch
    v = self.v = self.selectNextVnode()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 743, in selectNextVnode
    if (c.suboutline_only_flag and self.onlyVnode and v and
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1867, in isAncestorOf
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3133, in vParentWithStack
    return self.stack[n],n-1 # simulate popping the stack.

IndexError: list index out of range</t>
<t tx="ekr.20040809071510.267">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20040809071510.268"></t>
<t tx="ekr.20040809071510.269">@killcolor

1.  Assignments.

find.selectNextVnode has several assignments like:

self.wrapVnode = v

However, this is _completely_ safe because the find code never calls p.moveToX.  Therefore, the assigned postion never changes!

Indeed, the code uses v.threadNext and v.threadBack, and these never change positions, they create new ones.


2. Assigning None to a possition.

This will work properly in all situations.

3.  Tests for equality against None

This should work properly.  p.__cmp__ allows tests against None.
</t>
<t tx="ekr.20040809071510.270"></t>
<t tx="ekr.20040809071510.271">@killcolor

We do _not_ have to make copies when assigning to an ivar because the find code never calls p.moveToX.

Furthermore, v.copy will fail if v is None.</t>
<t tx="ekr.20040809071510.272"># Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; v = self.v

    if c.selection_only_flag:
        return None

    # Start suboutline only searches.
    if c.suboutline_only_flag and not self.onlyVnode:
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.onlyVnode = v 

    # Start wrapped searches.
    if self.wrapping and not self.wrapVnode:
        assert(self.wrapPos != None)
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.wrapVnode = v 

    if self.in_headline and c.search_body_flag:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(v)
        return v

    if c.reverse_flag: v = v.threadBack()
    else:              v = v.threadNext()

    # Wrap if needed.
    if not v and self.wrapping and not c.suboutline_only_flag:
        v = c.rootVnode()
        if c.reverse_flag:
            # Set search_v to the last node of the tree.
            while v and v.next():
                v = v.next()
            if v: v = v.lastNode()

    # End wrapped searches.
    if self.wrapping and v and v == self.wrapVnode:
        # g.trace("ending wrapped search")
        v = None ; self.resetWrap()

    # End suboutline only searches.
    if (c.suboutline_only_flag and self.onlyVnode and v and
        (v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
        # g.trace("end outline-only")
        v = None ; self.onlyVnode = None

    # v.copy not needed because the find code never calls p.moveToX.
    # Furthermore, v might be None, so v.copy() would be wrong!
    self.v = v # used in initNextText().
    if v: # select v and set the search point within v.
        self.in_headline = c.search_headline_flag
        self.initNextText()
    return v</t>
<t tx="ekr.20040809071510.273"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not c.search_headline_flag and not c.search_body_flag:
        return None, None

    if len(c.find_text) == 0:
        return None, None

    v = self.v
    while v:
        pos, newpos = self.search()
        if pos:
            if c.mark_finds_flag:
                v.setMarked()
                c.frame.tree.drawIcon(v) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif c.node_only_flag:
            return None,None # We are only searching one node.
        else:
            v = self.v = self.selectNextVnode()
    return None, None</t>
<t tx="ekr.20040809071510.274"># The new code only writes tnodes for the current tree when pasting to the clipboard.</t>
<t tx="ekr.20040809071510.275">def putTnodes (self):
    
    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("&lt;tnodes&gt;") ; self.put_nl()
    &lt;&lt; write only those tnodes that were referenced &gt;&gt;
    self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="ekr.20040809071510.276">if self.usingClipboard: # write the current tree.
    iter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    iter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in iter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)</t>
<t tx="ekr.20040809071510.277"></t>
<t tx="ekr.20040809071510.278">@killcolor

- Added readline method to fileLikeObject class: new_df.readOpenFile calls readline.

- Added perfectImportRoot keyword arg to new_df.readOpenFile.

- Added perfectImportRoot ivar to new_df class.

- readEndNode counts the number of corrected nodes, and marks all corrected nodes.

- Forced at.perfectImportRoot = False in top-level read code.
    This corrects a problem with reading LeoDocs.leo during unit tests.</t>
<t tx="ekr.20040809071510.279"></t>
<t tx="ekr.20040809071510.280">def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return removeSentinelsFromLines(lines,delims)
    
def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""
    
    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    &lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;
    return result</t>
<t tx="ekr.20040809071510.281">i = last_nosent_i

if i + 1 &lt; len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]</t>
<t tx="ekr.20040809071510.282">def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """
    
    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)
    
    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping</t>
<t tx="ekr.20040809071510.283"></t>
<t tx="ekr.20040809071510.284"></t>
<t tx="ekr.20040809071510.285">def createThinChild (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #g.trace("last",last,last.t.fileIndex)
    #g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace("creating node",child,gnx)

    return child</t>
<t tx="ekr.20040809071510.286">def readOpenFile(self,root,file,firstLines,perfectImportRoot=None):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self
    
    # This is safe (just barely) because only this method calls scanText4&gt;
    at.perfectImportRoot = perfectImportRoot

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s</t>
<t tx="ekr.20040809071510.287">def scanText4 (self,file,p):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(file)
        if len(s) == 0: break
        kind = at.sentinelKind(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20040809071510.288"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20040809071510.289">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20040809071510.290">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20040809071510.291">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20040809071510.292">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20040809071510.293"></t>
<t tx="ekr.20040809071510.294">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(endAll)</t>
<t tx="ekr.20040809071510.295">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endDoc)
    
def skipToEndSentinel(self,s,i):
    end = self.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20040809071510.296">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20040809071510.297">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20040809071510.298">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild(headline)
    
    at.endSentinelStack.append(endNode)</t>
<t tx="ekr.20040809071510.299"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20040809071510.300"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20040809071510.301">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20040809071510.302">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(endOthers)</t>
<t tx="ekr.20040809071510.303"></t>
<t tx="ekr.20040809071510.304">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(endAll)</t>
<t tx="ekr.20040809071510.305">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(endDoc)
    at.inCode = True</t>
<t tx="ekr.20040809071510.306">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.file)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20040809071510.307">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20040809071510.308">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        if old:
            if at.perfectImportRoot:
                &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
                p.setMarked()
                at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
                at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
                at.c.setChanged(True)
            else:
                if not at.updateWarningGiven:
                    at.updateWarningGiven = True
                    g.es("Warning: updating changed text",color="blue")
                #g.es("old...\n%s\n" % old)
                #g.es("new...\n%s\n" % s)
                # Just set the dirty bit. Ancestors will be marked dirty later.
                at.t.setDirty()
                if 1: # We must avoid the full setChanged logic here!
                    c.changed = True
                else: # Far too slow for mass changes.
                    at.c.setChanged(True)
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)</t>
<t tx="ekr.20040809071510.309"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20040809071510.310">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(endOthers)</t>
<t tx="ekr.20040809071510.311">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    if 0: # new code.
        &lt;&lt; new code &gt;&gt;
    else:
        &lt;&lt; old code &gt;&gt;</t>
<t tx="ekr.20040809071510.312">if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(s) # The tag has already been removed.
at.docOut = []</t>
<t tx="ekr.20040809071510.313"># Remove the @doc or @space.  We'll add it back at the end.
if g.match(s,0,tag):
    s = s[len(tag):]
else:
    at.readError("Missing start of doc part")
    return

if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(tag + s)
at.docOut = []</t>
<t tx="ekr.20040809071510.314"></t>
<t tx="ekr.20040809071510.315">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20040809071510.316">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.file)
    at.out.append(s)</t>
<t tx="ekr.20040809071510.317">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20040809071510.318">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20040809071510.319">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20040809071510.320">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
    
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if g.match_word(s,i,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,i,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20040809071510.321"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20040809071510.322">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20040809071510.323">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20040809071510.324">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20040809071510.325">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20040809071510.326">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.file) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20040809071510.327">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    at.readError("Ignoring %s sentinel.  Expecting %s" %
        (at.sentinelName(at.endSentinelStack[-1]),
         at.sentinelName(expectedKind)))
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20040809071510.328"></t>
<t tx="ekr.20040809071510.329">def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None</t>
<t tx="ekr.20040809071510.330"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self):
        self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr &lt; len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)</t>
<t tx="ekr.20040809071510.331">def is_sentinel (line,delims):
    
    &lt;&lt; is_sentinel doc tests &gt;&gt;
    
    delim1,delim2,delim3 = delims
    
    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i &lt; j
    else:
        g.es("Can't happen: is_sentinel",color="red")
        return False
</t>
<t tx="ekr.20040809071510.332">"""

Return True if line starts with a sentinel comment.

&gt;&gt;&gt; py_delims = comment_delims_from_extension('.py')
&gt;&gt;&gt; is_sentinel("#@+node",py_delims)
True
&gt;&gt;&gt; is_sentinel("#comment",py_delims)
False

&gt;&gt;&gt; c_delims = comment_delims_from_extension('.c')
&gt;&gt;&gt; is_sentinel("//@+node",c_delims)
True
&gt;&gt;&gt; is_sentinel("//comment",c_delims)
False

&gt;&gt;&gt; html_delims = comment_delims_from_extension('.html')
&gt;&gt;&gt; is_sentinel("&lt;!--@+node--&gt;",html_delims)
True
&gt;&gt;&gt; is_sentinel("&lt;!--comment--&gt;",html_delims)
False

"""</t>
<t tx="ekr.20040809071510.333">import difflib,shutil

class mulderUpdateAlgorithm:
    
    """A class to update derived files using
    diffs in files without sentinels.
    """
    
    @others
    
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

    mu = mulderUpdateAlgorithm()

    mu.pull_source(sourcefilename,targetfilename)
    mu.copy_time(targetfilename,sourcefilename)</t>
<t tx="ekr.20040809071510.334">def __init__ (self,testing=False,verbose=False):
    
    self.testing = testing
    self.verbose = False
    self.do_backups = False</t>
<t tx="ekr.20040809071510.335">@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """
    
    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i &lt;= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos &lt; j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos</t>
<t tx="ekr.20040809071510.336">def copy_time(self,sourcefilename,targetfilename):
    
    """
    Set the target file's modification time to
    that of the source file.
    """

    st = os.stat(sourcefilename)

    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")</t>
<t tx="ekr.20040809071510.337"># These routines originally were part of push_filter &amp; push_filter_lines.</t>
<t tx="ekr.20040809071510.338">def separateSentinelsFromFile (self,filename):
    
    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return self.separateSentinelsFromLines(lines,delims)
    
def separateSentinelsFromLines (self,lines,delims):
    
    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""
    
    strippedLines = self.removeSentinelsFromLines(lines,delims)
    sentinelLines = self.getSentinelsFromLines(lines,delims)
    
    return strippedLines,sentinelLines</t>
<t tx="ekr.20040809071510.339">def getSentinelsFromFile (self,filename,delims):
    
    """Returns all sentinels lines in a file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return getSentinelsFromLines(lines,delims)
    
def getSentinelsFromLines (self,lines,delims):
    
    """Returns all sentinels lines in lines."""
    
    return [line for line in lines if g.is_sentinel(line,delims)]</t>
<t tx="ekr.20040809071510.340">def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
    
    &lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;
    
    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)
        
    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        &lt;&lt; paranoia check&gt;&gt;</t>
<t tx="ekr.20040809071510.341"># Get the sentinel comment delims.
delims = self.comment_delims_from_extension(sourcefilename)
if not delims:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)
    
    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.
    
    i_lines,mapping = self.create_mapping(fat_lines,delims)
    
    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return</t>
<t tx="ekr.20040809071510.342"># Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,delims)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")</t>
<t tx="ekr.20040809071510.343">def propagateDiffsToSentinelsLines (self,
    i_lines,j_lines,fat_lines,mapping):
    
    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    &lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;
    &lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        &lt;&lt; update and check the loop invariant &gt;&gt;
        if tag == 'equal':
            &lt;&lt; handle 'equal' tag &gt;&gt;
        elif tag == 'replace':
            &lt;&lt; handle 'replace' tag &gt;&gt;
        elif tag == 'delete':
            &lt;&lt; handle 'delete' tag &gt;&gt;
        elif tag == 'insert':
            &lt;&lt; handle 'insert' tag &gt;&gt;
        else: assert 0,"bad tag"
    &lt;&lt; copy the sentinels at the end of the file &gt;&gt;
    return write_lines</t>
<t tx="ekr.20040809071510.344"># Indices into i_lines, j_lines &amp; fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose</t>
<t tx="ekr.20040809071510.345">while fat_pos &lt; mapping[0]:

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "copy initial line",fat_pos,line,
    fat_pos += 1
</t>
<t tx="ekr.20040809071510.346"># We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, delims)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], delims)[1]</t>
<t tx="ekr.20040809071510.347"># Copy the lines, including sentinels.
while fat_pos &lt;= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)</t>
<t tx="ekr.20040809071510.348">@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line =&gt; orignal line.
@c

while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="ekr.20040809071510.349">if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="ekr.20040809071510.350">while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.</t>
<t tx="ekr.20040809071510.351">while fat_pos &lt; len(fat_lines):

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "Append last line",line
    fat_pos += 1
</t>
<t tx="ekr.20040809071510.352">def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    print '='*20
    print message
    
    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,
         
        print '='*20
    
        print lines2_message
        print '-'*20
        for line in lines2:
            print line,</t>
<t tx="ekr.20040809071510.353">def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    &gt;&gt;&gt; import leoGlobals as g
    &gt;&gt;&gt; s = "a\\n \\t\\n\\t\\t \\t\\nb"
    &gt;&gt;&gt; theLines = g.splitLines(s)
    &gt;&gt;&gt; theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    &gt;&gt;&gt; g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        stripped_line = lines[i].lstrip(" \t")
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines</t>
<t tx="ekr.20040809071510.354">def write_if_changed(self,lines,sourcefilename,targetfilename):
    """
    
    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.
    
    Optionally backs up the overwritten file.

    """
    
    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
        
    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            &lt;&lt; make backup file &gt;&gt;
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
</t>
<t tx="ekr.20040809071510.355">if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if testing:
        print "backup file in ", backupname</t>
<t tx="ekr.20040809071510.356">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    &lt;&lt; about this algorithm &gt;&gt;
    c = p.c ; root = p.copy()
    df = c.atFileCommands.new_df
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 0: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</t>
<t tx="ekr.20040809071510.357">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.</t>
<t tx="ekr.20040809071510.358">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()</t>
<t tx="ekr.20040809071510.359">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        id,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()</t>
<t tx="ekr.20040809071510.360">df.write(root,thinFile=True,toString=True)
s = df.stringOutput
if not s: return
</t>
<t tx="ekr.20040809071510.361">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)</t>
<t tx="ekr.20040809071510.362">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    df.correctedLines = 0
    df.targetFileName = "&lt;perfectImport string-file&gt;"
    df.inputFile = fo = g.fileLikeObject()
    df.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk = c.atFileCommands.scanHeader(fo,df.targetFileName)
    # To do: pass params to readEndNode.
    df.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = df.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None</t>
<t tx="ekr.20040809071510.363">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    df.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(df.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()</t>
<t tx="ekr.20040809071510.364">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break</t>
<t tx="ekr.20040809071510.365"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "_\\_ _(_ _)_", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20040809071510.366"></t>
<t tx="ekr.20040809071510.367">@killcolor

Apparently the code already intends to strip whitespace.  However, the old code has a bug that prevents this from happening.

Warning: changing from the old to the new code will change virtually every file.  I'm not sure I want to do this.  Maybe this is where the option should be implemented?

What about blank lines in doc parts?</t>
<t tx="ekr.20040809071510.368"></t>
<t tx="ekr.20040809071510.369">@nocolor

A recent change omitted the call to setSelectionAreas.  This was wrong: it fails to update the body pane, so the change doesn't take.

The new code calls setSelectionAreas to update the body pane and setTextSelection to force an empty selection.</t>
<t tx="ekr.20040809071510.370"># These are the heart of a two new commands.</t>
<t tx="ekr.20040809071510.371">def stripBlankLines(s):
    
    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j &gt;= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))
            
    return ''.join(lines)
</t>
<t tx="ekr.20040809071510.372">@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):
    
    """Kind is 'asis', 'zero' or 'one'."""
    
    pass</t>
<t tx="ekr.20040809071510.373"></t>
<t tx="ekr.20040809071510.374">def </t>
<t tx="ekr.20040809071510.375">@killcolor

Removed v.edit_text.

p.edit_text now just returns tree.edit_text.

I did this to avoid messing with edit_text in the outlines plugin.</t>
<t tx="ekr.20040809071510.376"></t>
<t tx="ekr.20040809071510.377">@killcolor

The problem was in g.doHook("set-mark",c=self.c,v=self).

There was a _big_ performance bug in the nodenavigator plugin.</t>
<t tx="ekr.20040809071510.378">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError:
        return None
    
    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
    
    if 0: # Don't use trace here!
        if tag != "idle":
            print "doHook",tag,c

    if not g.app.config.use_plugins:
        if tag == "start1":
            g.es("Plugins disabled: use_plugins is 0",color="blue")
        return None
    elif c and c.hookFunction:
        try:
            return c.hookFunction(tag,keywords)
        except:
            g.es("exception in c.hookFunction for " + c.frame.getTitle())
    elif g.app.hookFunction:
        try:
            return g.app.hookFunction(tag,keywords)
        except:
            g.es("exception in app.hookFunction")
    else:
        import leoPlugins
        try:
            g.app.hookFunction = leoPlugins.doPlugins
            return app.hookFunction(tag,keywords)
        except:
            g.app.hookFunction = None
            g.es("exception in plugin")

    # Handle all exceptions.
    g.es_exception()
    g.app.hookError = True # Supress this function.
    g.app.idleTimeHook = False # Supress idle-time hook
    return None # No return value</t>
<t tx="ekr.20040809071510.379">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20040809071510.380"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=True):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    &lt;&lt; warn on read-only files &gt;&gt;
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        &lt;&lt; scan all the xml elements &gt;&gt;
    except BadLeoFile, message:
        &lt;&lt; raise an alert &gt;&gt;
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    if ok and atFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    &lt;&lt; restore attributes in descendent tnodes &gt;&gt;
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio</t>
<t tx="ekr.20040809071510.381">try:
    self.read_only = False
    self.read_only = not os.access(fileName,os.W_OK)
    if self.read_only:
        g.es("read only: " + fileName,color="red")
except:
    if 0: # testing only: access may not exist on all platforms.
        g.es("exception getting file access")
        g.es_exception()</t>
<t tx="ekr.20040809071510.382">self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("&lt;leo_file&gt;") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="ekr.20040809071510.383"># All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))</t>
<t tx="ekr.20040809071510.384">for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
    # g.trace("done")</t>
<t tx="ekr.20040809071510.385"># We must make sure that state is "normal" in p.setHeadStringOrHeadline.</t>
<t tx="ekr.20040809071510.386">def redoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.newText)
    
    u.p.setHeadStringOrHeadline(u.newText)
    
    c.selectVnode(u.p)</t>
<t tx="ekr.20040809071510.387">def undoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.oldText)
    
    u.p.setHeadStringOrHeadline(u.oldText)
    
    c.selectVnode(u.p)

    </t>
<t tx="ekr.20040809071510.388">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20040809071510.389"></t>
<t tx="ekr.20040809071510.390"># Solution: openWriteFile must set self.root for the exception handling logic.

http://sourceforge.net/forum/message.php?msg_id=2654109

# @thin leo/4

errors writing: C:\prog\leoCVS\leo\test\leo\4
path does not exist: C:\prog\leoCVS\leo\test\leo
exception creating path:leo/4
Unexpected exception while writing @thin leo/4

Traceback (most recent call last):
    
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 731, in write
    try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile,toString=toString,oneNodeOnly=oneNodeOnly)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4766, in write
    ok = at.openWriteFile(root,toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2740, in openWriteFile
    self.writeError("exception creating path:" + fn)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2347, in writeError
    self.root.setOrphan()
AttributeError: 'NoneType' object has no attribute 'setOrphan'
</t>
<t tx="ekr.20040809071510.391"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root,toString):
    
    self.toStringFlag = toString
    self.errors = 0 # Bug fix: 6/25/04.
    self.root = root # Bug fix: 7/30/04: needed by error logic.

    try:
        self.scanAllDirectives(root)
        valid = self.errors == 0
    except:
        self.writeError("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False
        
    if valid and toString:
        self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
        self.outputFile = g.fileLikeObject()
        self.stringOutput = ""
        return valid

    if valid:
        try:
            fn = self.targetFileName
            self.shortFileName = fn # name to use in status messages.
            self.targetFileName = g.os_path_join(self.default_directory,fn)
            self.targetFileName = g.os_path_normpath(self.targetFileName)
            path = g.os_path_dirname(self.targetFileName)
            if not path or not g.os_path_exists(path):
                self.writeError("path does not exist: " + path)
                valid = False
        except:
            self.writeError("exception creating path:" + fn)
            g.es_exception()
            valid = False

    if valid and g.os_path_exists(self.targetFileName):
        try:
            if not os.access(self.targetFileName,os.W_OK):
                self.writeError("can not create: read only: " + self.targetFileName)
                valid = False
        except:
            pass # os.access() may not exist on all platforms.
        
    if valid:
        try:
            root.clearOrphan() # Bug fix: 5/25/04.
            self.outputFileName = self.targetFileName + ".tmp"
            self.outputFile = open(self.outputFileName,'wb')
            if self.outputFile is None:
                self.writeError("can not create " + self.outputFileName)
                valid = False
        except:
            g.es("exception creating:" + self.outputFileName)
            g.es_exception()
            valid = False
            self.outputFile = None # 3/22/04

    if not valid:
        root.setOrphan()
        root.setDirty()
        self.outputFile = None # 1/29/04
    
    return valid</t>
<t tx="ekr.20040809071510.392">def writeError(self,message):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20040809071510.393"></t>
<t tx="ekr.20040809071510.394">@nocolor
@language html
http://sourceforge.net/forum/message.php?msg_id=2645776
By: billp9619

Yes this works now. However, the opposite should also be true ...that instead
of &lt;find_string&gt;&lt;/find_string&gt; an outside process or editor is free to change
it to &lt;find_string/&gt;. This currently causes Leo to fail to load the file reprting
it was looking for &lt;/find_string&gt;.

This is original Leo xml:

@color
&lt;preferences&gt; 
&lt;/preferences&gt;
&lt;find_panel_settings&gt;
&lt;find_string&gt;&lt;/find_string&gt;
&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
@nocolor

My xml editor automatically changed it to this:

@color
&lt;preferences/&gt; &lt;!-- was ok --&gt;
&lt;find_panel_settings&gt;
&lt;find_string/&gt; &lt;!-- now ok --&gt;
&lt;change_string/&gt; &lt;!-- now ok --&gt;
&lt;/find_panel_settings&gt;
@nocolor

Leo will not load the edited "/&gt;" type empty tags. 

Both forms of empty tags should always be accepted because it is officially
identical in meaning for xml.</t>
<t tx="ekr.20040809071510.395">@nocolor

- getOpenTag returns True if the end of the tag was seen. (It throws an exception if the tag isn't seen at all).

- Add comments in several places to make what getOpenTag clearer.

- getFindPanelSettings has allowed &lt;find_panel_settings/&gt; for some time.

- For compatibility with older versions of Leo, Leo still writes:

&lt;find_panel_settings&gt;
    &lt;find_string&gt;&lt;/find_string&gt;
    &lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;

- Leo now allows the &lt;find_string&gt; and &lt;change_string&gt; tags to be collapsed.  For example,

&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;

- Changed getPrefs to allow &lt;preferences/&gt;

- Changed getGlobals to set reasonable defaults for &lt;globals/&gt;

- The &lt;leo_file&gt; and &lt;globals tags must not be terminated immediately.

- Leo writes &lt;defaultDirectory&gt; and &lt;TSyntaxMemo_options&gt; tags only if there is non-empty text between the opening and closing tags, so collapsing the tags is invalid.

- Therefore, the absolutely minimal .leo file is:

@color
@language html

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

@nocolor

I updated the empty_leo_file plugin to use this code.  This is also the contents test/minimalLeoFile.leo.

- The minimal .leo file that Leo might actually write is more like this:

@color

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

This is the contents of test/minimalLeoFile2.leo.</t>
<t tx="ekr.20040809071510.396">def getOpenTag (self,tag):
    
    """
    Look ahead for collapsed tag: tag may or may not end in "&gt;"
    Skips tag and /&gt; if found, otherwise does not alter index.
    Returns True if the closing part was found.
    Throws BadLeoFile if the tag does not exist.
    """

    if tag[-1] == "&gt;":
        # Only the tag itself or a collapsed tag are valid.
        if self.matchTag(tag):
            return False # Not a collapsed tag.
        elif self.matchTag(tag[:-1]):
            # It must be a collapsed tag.
            self.skipWs()
            if self.matchTag("/&gt;"):
                return True
        print "getOpenTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
    else:
        # The tag need not be followed by "/&gt;"
        if self.matchTag(tag):
            old_index = self.fileIndex
            self.skipWs()
            if self.matchTag("/&gt;"):
                return True
            else:
                self.fileIndex = old_index
                return False
        else:
            print "getOpenTag(", tag, ") failed:"
            raise BadLeoFile("expecting" + tag)</t>
<t tx="ekr.20040809071510.397"># For compatibility with old file formats.

def getCloneWindows (self):

    if not self.matchTag("&lt;clone_windows&gt;"):
        return # &lt;clone_windows/&gt; seen.

    while self.matchTag("&lt;clone_window vtag=\"V"):
        self.getLong() ; self.getDquote() ; self.getTag("&gt;")
        if not self.getOpenTag("&lt;global_window_position"):
            self.getTag("&lt;global_window_position")
            self.getPosition()
            self.getTag("/&gt;")
        self.getTag("&lt;/clone_window&gt;")
    self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="ekr.20040809071510.398">def getFindPanelSettings (self):

    c = self.c ; config = g.app.config ; findFrame = g.app.findFrame
    &lt;&lt; Set defaults of all flags &gt;&gt;
    if not self.getOpenTag("&lt;find_panel_settings"):
        while 1:
            if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
            elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
            elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
            elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
            elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
            elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
            elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
            elif self.matchTag("script_change="): c.script_change_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("script_search="): c.script_search_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
            elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
            elif self.matchTag("selection_only="): c.selection_only_flag = self.getDqBool() # 11/9/03
            elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
            elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
            elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
            elif self.matchTag("&gt;"): break
            else: self.getUnknownTag() # New in 4.1: ignore all other tags.

        # # 7/31/04: Allow only &lt;find_string&gt; or &lt;find_string/&gt;
        if self.getOpenTag("&lt;find_string&gt;"): 
            c.find_text = ""
        else:
            c.find_text = self.getEscapedString()
            self.getTag("&lt;/find_string&gt;")
        # 7/31/04: Allow only &lt;change_string&gt; or &lt;change_string/&gt;
        if self.getOpenTag("&lt;change_string&gt;"): 
            c.change_text = ""
        else:
            c.change_text = self.getEscapedString()
            self.getTag("&lt;/change_string&gt;")
        #
        self.getTag("&lt;/find_panel_settings&gt;")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    config.setCommandsFindIvars(c)
    # Update the settings immediately.
    if g.app.gui.guiName() == "tkinter":
        g.app.findFrame.init(c)</t>
<t tx="ekr.20040809071510.399">if g.app.gui.guiName() == "tkinter":

    for var in findFrame.intKeys:
        attr = "%s_flag" % (var)
        setattr(c,attr,False)
        # g.trace(attr)
</t>
<t tx="ekr.20040809071510.400">def getGlobals (self):

    if self.getOpenTag("&lt;globals"):
        # &lt;globals/&gt; seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

        self.getTag("&lt;global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/&gt;")

        self.getTag("&lt;global_log_window_position")
        self.getPosition()
        self.getTag("/&gt;") # no longer used.

        self.getTag("&lt;/globals&gt;")

    # 7/15/02: Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()</t>
<t tx="ekr.20040809071510.401">def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("&lt;preferences"):
        return # &lt;preferences/&gt; seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("&gt;"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    while 1:
        if self.matchTag("&lt;defaultDirectory&gt;"):
            # New in version 0.16.
            c.tangle_directory = self.getEscapedString()
            self.getTag("&lt;/defaultDirectory&gt;")
            if not g.os_path_exists(c.tangle_directory):
                g.es("default tangle directory not found:" + c.tangle_directory)
        elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
            self.getEscapedString() # ignored
            self.getTag("&lt;/TSyntaxMemo_options&gt;")
        else: break
    self.getTag("&lt;/preferences&gt;")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)</t>
<t tx="ekr.20040809071510.402">def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default</t>
<t tx="ekr.20040809071510.403"></t>
<t tx="ekr.20040809071510.404"></t>
<t tx="ekr.20040809071510.405"></t>
<t tx="ekr.20040809071510.406">@nocolor

- Added a call to self.top.lift() in base run() method.

- Disable additional prompting dialogs if one is already open.</t>
<t tx="ekr.20040809071510.407">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2683931
By: billp9619

Using Win XP:

On closing an unsaved file with changes , a Confirm" message box pops up. The
Leo main outline is locked but this Confirm box could be underneath the
Outline...acting like an independent window(if outline receives focus again
by clicking on it, etc.) Normally applications force these type of prompts to
stay on top of the related appl. window.

The above can can be confusing.  But it can be worse.

If I right click on the Leo icon on the task bar and select "Close" (say I am
confused now), what happens is it pops up another Confirm box.

After closing ...the extra Confirm boxes are left behind with no associated
Leo outline.

Leo Log Window...
Leo 4.2 beta 2, build  1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32</t>
<t tx="ekr.20040809071510.408">class leoTkinterDialog:
    """The base class for all Leo Tkinter dialogs"""
    @others</t>
<t tx="ekr.20040809071510.409">def __init__(self,title="",resizeable=True,canClose=True):
    
    """Constructor for the leoTkinterDialog class."""
    
    self.answer = None # Value returned from run()
    self.resizeable = resizeable
    self.title = title
    self.modal = None
    
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # g.app.root
    self.top = None # The toplevel Tk widget.
    self.focus_widget = None # The widget to get the first focus.
    self.canClose = canClose</t>
<t tx="ekr.20040809071510.410">def cancelButton(self):
    
    """Do default click action in cancel button."""
    
    self.answer="cancel"
    self.top.destroy()
    
def noButton(self):
    
    """Do default click action in no button."""
    
    self.answer="no"
    self.top.destroy()
    
def okButton(self):
    
    """Do default click action in ok button."""
    
    self.answer="ok"
    self.top.destroy()

def yesButton(self):
    
    """Do default click action in yes button."""

    self.answer="yes"
    self.top.destroy()</t>
<t tx="ekr.20040809071510.411">def center(self):
    
    """Center any leoTkinterDialog."""
    
    g.app.gui.center_dialog(self.top)
</t>
<t tx="ekr.20040809071510.412">def createButtons (self,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)
        
        if isDefault and command:
            self.defaultButtonCommand = command
        
    return buttonList</t>
<t tx="ekr.20040809071510.413">def createMessageFrame (self,message):
    
    """Create a frame containing a Tk.Label widget."""

    label = Tk.Label(self.frame,text=message)
    label.pack(pady=10)
</t>
<t tx="ekr.20040809071510.414">def createTopFrame(self):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    
    self.root = g.app.root

    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)

    if not self.resizeable:
        self.top.resizable(0,0) # neither height or width is resizable.

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")
    
    if not self.canClose:
        self.top.protocol("WM_DELETE_WINDOW", self.onClose)
    
    # Do this at idle time.
    def callback(top=self.top):
        g.app.gui.attachLeoIcon(top)
    
    self.top.after_idle(callback)</t>
<t tx="ekr.20040809071510.415">def onClose (self):
    
    """Disable all attempts to close this frame with the close box."""
    
    pass</t>
<t tx="ekr.20040809071510.416">def run (self,modal):
    
    """Run a leoTkinterDialog."""

    self.modal = modal
    
    self.center() # Do this after all packing complete.
    self.top.lift() # 7/31/04

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        if self.focus_widget == None:
            self.focus_widget = self.top
        self.focus_widget.focus_set() # Get all keystrokes.	
        self.root.wait_window(self.top)
        return self.answer
    else:
        self.root.wait_window(self.top)
        return None</t>
<t tx="ekr.20040809071510.417"></t>
<t tx="ekr.20040809071510.418"></t>
<t tx="ekr.20040809071510.419">@killcolor

This was tricky to get correct. The aha is that we must compute line numbers for
SyntaxErrors differently from other errors.

The traceback methods are very strange in this regard. For SyntaxError's,
format_exception_only computes the line number. For all other errors, extract_tb
gives the proper line number. It took a _long_ time to figure this out...

In the end, the calculations in getLastTracebackLineNumber are fairly
straightforward. In particular, it unpacks the line number for SyntaxErrors
using code lifted directly from format_exception_only.</t>
<t tx="ekr.20040809071510.420"></t>
<t tx="ekr.20040809071510.421">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2692347

+headline
++@thin a
++@thin b

I changed the headline, then saved the leo. apparently
the @thins in the subnode weren't marked dirty.
on next open I got a bunch of
getLeoFile: can not find tnode: gnx = leo4u.20040614190317
...
click on the @thin was empty, then it became a subnode of itself.
all without the leo marked as modifyed!

is the bug is that headline changes don't mark subnodes dirty?
I know edits in parent bodys now do, 
even if nothing should change in the @thin or @file.
now I see why.

in the @thin
#@+node:leo4u.20040730175028.1:@thin a.py

in the leo
&lt;v t="leo4u.20040511113712"
marks="leo4u.20040728143234.3,leo4u.20040728143234.4,leo4u.20040728143234.5,"
expanded="leo4u.20040614190317,leo4u.20040728160724,leo4u.20040728143234,leo4u.2
0040728143234.2,"&gt;&lt;vh&gt;@thin a.py&lt;/vh&gt;&lt;/v&gt;

from cvs the other day.
Leo 4.2 beta 2, build  1.141 , July 5, 2004
Python 2.3.3, Tk 8.4.3, win32</t>
<t tx="ekr.20040809071510.422"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20040809071510.423"></t>
<t tx="ekr.20040809071510.424">def goToLineNumber (self,root=None,lines=None,n=None):

    c = self ; p = c.currentPosition() ; root1 = root
    if root is None:
        &lt;&lt; set root to the nearest ancestor @file node &gt;&gt;
    if lines is None:
        &lt;&lt; read the file into lines &gt;&gt;
    if n is None:
        &lt;&lt; get n, the line number, from a dialog &gt;&gt;
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        &lt;&lt; count outline lines, setting p,n2,found &gt;&gt;
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        &lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;
    &lt;&lt; select p and make it visible &gt;&gt;
    &lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="ekr.20040809071510.425">fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break
    
if fileName:
    root = p.copy()
else:
    g.es("Go to line number: ancestor must be @file node", color="blue")
    return</t>
<t tx="ekr.20040809071510.426"># 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    file=open(fileName)
    lines = file.readlines()
    file.close()
except:
    g.es("not found: " + fileName)
    return</t>
<t tx="ekr.20040809071510.427">n = g.app.gui.runAskOkCancelNumberDialog("Enter Line Number","Line number:")
if n == -1:
    return</t>
<t tx="ekr.20040809071510.428">p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) &gt; 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines &gt;= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)</t>
<t tx="ekr.20040809071510.429">if gnx:
    &lt;&lt; 4.2: get node from gnx &gt;&gt;
elif childIndex == -1:
    &lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
    &lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="ekr.20040809071510.430">found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20040809071510.431"># This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
    tnodeIndex = max(0,tnodeIndex)
    &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
            
if not ok:
    # Fall back to the old logic.
    &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="ekr.20040809071510.432">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1</t>
<t tx="ekr.20040809071510.433">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False</t>
<t tx="ekr.20040809071510.434">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return</t>
<t tx="ekr.20040809071510.435">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex &lt;= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20040809071510.436">c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()</t>
<t tx="ekr.20040809071510.437">if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()</t>
<t tx="ekr.20040809071510.438">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    &lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
</t>
<t tx="ekr.20040809071510.439"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
</t>
<t tx="ekr.20040809071510.440">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1</t>
<t tx="ekr.20040809071510.441">if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.</t>
<t tx="ekr.20040809071510.442">if newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")</t>
<t tx="ekr.20040809071510.443">def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n</t>
<t tx="ekr.20040809071510.444"></t>
<t tx="ekr.20040809071510.445">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
</t>
<t tx="ekr.20040809071510.446">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="ekr.20040809071510.447">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20040809071510.448"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20040809071510.449">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20040809071510.450"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20040809071510.451"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20040809071510.452"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="ekr.20040809071510.453">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20040809071510.454">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20040809071510.455">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20040809071510.456"># Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)</t>
<t tx="ekr.20040809071510.457">def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char 
    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    # g.trace(repr(ch))

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # g.trace(p)
        
    # We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)

</t>
<t tx="ekr.20040809071510.458">def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)&gt;0:
        &lt;&lt; trace the key event &gt;&gt;

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status</t>
<t tx="ekr.20040809071510.459">try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state &lt; 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)</t>
<t tx="ekr.20040809071510.460"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20040809071510.461">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update p &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040809071510.462">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20040809071510.463">self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040809071510.464">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) &gt; 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040809071510.465">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040809071510.466"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20040809071510.467">if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040809071510.468">@killcolor

- Copied the code from the leoPlugins.leo.
- Removed all clones in project section to the old code.</t>
<t tx="ekr.20040809071510.469"># This prevents redundant warnings during mass updates.</t>
<t tx="ekr.20040809071510.470"></t>
<t tx="ekr.20040809071510.471">@nocolor

A MAJOR change: putVnode doesn't put tnodeLists for @thin nodes.

Instead it issues an informational message and deletes the tnodeList.

@color</t>
<t tx="ekr.20040809071510.472">@killcolor

New in 4.0:  &lt;v&gt; elements corresponding to @file nodes now contain tnodeList attributes.  The tnodeList attribute allows the read code in leoAtFile.py to recreate the order in which nodes should appear in the outline.  The tnodeList attribute is a list of gnx's: global node indices for tnodes.

N.B. Leo does _not_ write tnodeList attributes for @thin trees: @thin trees contain gnx's in each node.

N.B. tnodeList are _created_ by the atFile code but _written_ by the fileCommands code (to the .leo file).  Therefore, we must make SURE to autoSave .leo files whenever any @file node is written.

***** Possible bug.  The present code in putVnode DOES write tnodeList attributes for @thin tree.
THIS MAKES NO SENSE!!!!  Instead, the code should clear the tnodeList instead of writing it!

** When atFile classes are unified, it would make sense to clear root.v.t.tnodeList before _all_ writes.

Writing:

- atFile.old_df.write removes the tnodeList if it exist.
    - tnodeList is not needed in old-style derived files.
    - ????? WHY DOESN'T THIS SOLVE ALL tnodeList PROBLEMS ?????
- new_df.writeOpenFile sets at.root.v.t.tnodeList = [] initially.
- new_df.write _clears_ this after writing to a string.
    - ????? This caused problems when executing scripts, BUT WHY ?????
- atFile.new_df.putOpenNodeSentinel appends the tnode of the node being written to this list.
- top_df.writeAll returns mustAutoSave if any @file node was written.
    writing an @thin node does _not_ set mustAutoSave.

Reading:

- atFile.findChild returns the next tnode on this list.</t>
<t tx="ekr.20040809071510.473"></t>
<t tx="ekr.20040809071510.474"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    if thinFile:
        self.error("@file-thin not supported before 4.2")
        return
    
    # Remove any old tnodeList.
    if hasattr(root.v.t,"tnodeList"):
        # g.trace("removing tnodeList for ",root)
        delattr(root.v.t,"tnodeList")

    c = self.c
    &lt;&lt; initialize &gt;&gt;
    try:
        &lt;&lt; open the file; return on error &gt;&gt;
        root.clearAllVisitedInTree() # 1/28/04: clear both vnode and tnode bits.
        &lt;&lt; write then entire @file tree &gt;&gt;
        self.closeWriteFile()
        if not nosentinels:
            self.warnAboutOrphandAndIgnoredNodes()
        &lt;&lt; finish writing &gt;&gt;
    except:
        self.handleWriteException()
</t>
<t tx="ekr.20040809071510.475">self.sentinels = not nosentinels
self.raw = False

self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
c.endEditing() # Capture the current headline.</t>
<t tx="ekr.20040809071510.476">if nosentinels:
    self.targetFileName = root.atNoSentFileNodeName()
else:
    self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root,toString)
if not ok: return</t>
<t tx="ekr.20040809071510.477">next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="ekr.20040809071510.478">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # 21-SEP-2002 DTHEIN: write @first line, whether empty or not
    line = s[j:i]
    self.putBuffered(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20040809071510.479">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="ekr.20040809071510.480">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="ekr.20040809071510.481">@ We set the orphan and dirty flags if there are problems writing the file to force write_Leo_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
    root.setOrphan()
    root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
    os.remove(self.outputFileName) # Delete the temp file.
    g.es("Not written: " + self.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    self.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20040809071510.482">def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)
    
    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        at.root.v.t.tnodeList.append(p.v.t)</t>
<t tx="ekr.20040809071510.483"></t>
<t tx="ekr.20040809071510.484">def getTnodeList (self,s):

    """Parse a list of tnode indices in string s."""
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    
    fc = self ; 

    indexList = s.split(',') # The list never ends in a comma.
    tnodeList = []
    for index in indexList:
        index = self.canonicalTnodeIndex(index)
        t = fc.tnodesDict.get(index)
        if not t:
            # Not an error: create a new tnode and put it in fc.tnodesDict.
            # g.trace("not allocated: %s" % index)
            t = self.newTnode(index)
        tnodeList.append(t)
        
    # if tnodeList: g.trace(len(tnodeList))
    return tnodeList
</t>
<t tx="ekr.20040809071510.485">def putTnodeList (self,v):
    
    """Put the tnodeList attribute of a tnode."""
    
    # g.trace(v)
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        fc.put(" tnodeList=") ; fc.put_dquote()
        if g.app.use_gnx:
            for t in tnodeList:
                try: # Will fail for None or any pre 4.1 file index.
                    id,time,n = t.fileIndex
                except:
                    g.trace("assigning gnx for ",v,t)
                    gnx = nodeIndices.getNewIndex()
                    v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
            s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        else:
            s = ','.join([str(t.fileIndex) for t in tnodeList])
        fc.put(s) ; fc.put_dquote()</t>
<t tx="ekr.20040809071510.486">def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched &lt;v.
    while 1:
        if self.matchTag("a=\""):
            &lt;&lt; Handle vnode attribute bits &gt;&gt;
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = self.getDqString()
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            dict = self.getDescendentUnknownAttributes(s)
            if dict:
                self.descendentUnknownAttributesDictList.append(dict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag("&gt;"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("&lt;vh&gt;"):
        headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    &lt;&lt; Set the remembered status bits &gt;&gt;

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("&lt;v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    &lt;&lt; Append to current or top stack &gt;&gt;

    # End this vnode.
    self.getTag("&lt;/v&gt;")
    return v</t>
<t tx="ekr.20040809071510.487"># The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()</t>
<t tx="ekr.20040809071510.488">if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()</t>
<t tx="ekr.20040809071510.489">if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)</t>
<t tx="ekr.20040809071510.490">def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave</t>
<t tx="ekr.20040809071510.491">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()</t>
<t tx="ekr.20040809071510.492">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    df.fileChangedFlag = False # 1/9/04
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True</t>
<t tx="ekr.20040809071510.493">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")</t>
<t tx="ekr.20040809071510.494">def writeAtFileNodes (self):
    
    c = self.c

    self.assignFileIndices() # 4/3/04
    changedFiles = c.atFileCommands.writeAll(writeAtFileNodesFlag=True)
    assert(changedFiles != None)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20040809071510.495">def writeDirtyAtFileNodes (self): # fileCommands

    """The Write Dirty @file Nodes command"""
    
    c = self.c

    self.assignFileIndices() # 4/3/04
    changedFiles = c.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=True)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20040809071510.496">def writeMissingAtFileNodes (self):

    c = self.c ; v = c.currentVnode()

    if v:
        at = c.atFileCommands
        self.assignFileIndices() # 4/3/04
        changedFiles = at.writeMissing(v)
        assert(changedFiles != None)
        if changedFiles:
            g.es("auto-saving outline",color="blue")
            c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20040809071510.497"></t>
<t tx="ekr.20040809071510.498">@killcolor

The new code takes care to copy positions when needed, and ONLY when needed.</t>
<t tx="ekr.20040809071510.499">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition() ; root = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert p.equal(p.copy()) is True
    &gt;&gt;&gt; assert p.equal(root) is False
    &gt;&gt;&gt; assert g.app.positions == n + 1
    &gt;&gt;&gt; 
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
</t>
<t tx="ekr.20040809071510.500"></t>
<t tx="ekr.20040809071510.501">def currentPositionIsRootPosition (self):
    
    """Return True if the current position is the root position.
    
    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """
    
    c = self
    
    return (
        c._currentPosition and c._rootPosition and
        c._currentPosition == c._rootPosition)
        </t>
<t tx="ekr.20040809071510.502">def currentPositionHasNext (self):
    
    """Return True if the current position is the root position.
    
    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """
    
    c = self ; current = c._currentPosition 
    
    return current and current.hasNext()</t>
<t tx="ekr.20040809071510.503">def isCurrentPosition (self,p):
    
    """
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert c.isCurrentPosition(None) is False
    &gt;&gt;&gt; assert c.isCurrentPosition(p) is True
    &gt;&gt;&gt; assert g.app.positions == n
    &gt;&gt;&gt; 
    """
    
    c = self
    
    if p is None or c._currentPosition is None:
        return False
    else:
        return p.isEqual(c._currentPosition)</t>
<t tx="ekr.20040809071510.504">def isRootPosition (self,p):
    
    """
    &gt;&gt;&gt; c = g.top() ; p = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert c.isRootPosition(None) is False
    &gt;&gt;&gt; assert c.isRootPosition(p) is True
    &gt;&gt;&gt; assert g.app.positions == n
    &gt;&gt;&gt; 
    """
    
    c = self
    
    if p is None or c._rootPosition is None:
        return False
    else:
        return p.isEqual(c._rootPosition)</t>
<t tx="ekr.20040809071510.505"></t>
<t tx="ekr.20040809071510.506">def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self
    
    if c._currentPosition:
        if copy:
            return c._currentPosition.copy() # Must make a second copy now.
        else:
            # The caller MUST copy the position if it is passed to any other method.
            # At present no core method uses copy = False.
            g.trace("copy=False")
            return c._currentPosition
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition</t>
<t tx="ekr.20040809071510.507">def setCurrentPosition (self,p):
    
    """Set the presently selected position."""
    
    c = self
    
    if p:
        if p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy() 
    else:
        c._currentPosition = None
    
# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20040809071510.508"></t>
<t tx="ekr.20040809071510.509">def rootPosition(self):
    
    """Return the root position."""
    
    c = self
    
    if self._rootPosition:
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition</t>
<t tx="ekr.20040809071510.510">def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    if p:
        if p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
    
# For compatibiility with old scripts.
setRootVnode = setRootPosition</t>
<t tx="ekr.20040809071510.511"></t>
<t tx="ekr.20040809071510.512">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="ekr.20040809071510.513">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="ekr.20040809071510.514"></t>
<t tx="ekr.20040809071510.515">@killcolor

- canHoist and doHook are called at idle time.
    They must not generate positions!

- Menu enablers generate positions, but this is not serious.

- The only explicit call to p.copy in leoTkinterTree is now in drawTree.
    - No other methods call p.moveToX.

- Used p.isCurrent in several places in leoTkinterTree.

- onBodyKey and idle_body_key called c.currentPosition.
    - Only the call to idle_body_key was eliminated.

- putVnode calls self_and_parents_iter().
    - This iter doesn't make copies anyway, except for the first, so nothing can be done easily.</t>
<t tx="ekr.20040809071510.516">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.disableSave = False
    self.globalWindows = []
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_gnx = True # True: generate gnx's instead of tnode indices.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.findFrame = None
    self.pythonFrame = None
    
    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="ekr.20040809071510.517">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
</t>
<t tx="ekr.20040809071510.518">def __init__ (self,v,stack,trace=True):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="ekr.20040809071510.519"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    if g.app.tracePositions:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)</t>
<t tx="ekr.20040809071510.520">def canDehoist(self):
    
    return len(self.hoistStack) &gt; 0
        
def canHoist(self):
    
    c = self
    
    # N.B.  This is called at idle time, so minimizing positions is crucial!

    if 1: # minimizes positions

        if c.hoistStack:
            p2,junk = c.hoistStack[-1]
            return p2 and not p2.isCurrentPosition()
        elif c.currentPositionIsRootPosition():
            return c.currentPositionHasNext()
        else:
            return True

    else: # old code

        root = c.rootPosition()
        p = c.currentPosition()
    
        if c.hoistStack:
            p2,junk = c.hoistStack[-1]
            return p2 != p
        
        elif p == root:
            return p.hasNext()
        else:
            return True</t>
<t tx="ekr.20040809071510.521"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # New in 4.2 Beta 3. Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after 100 msec.  Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.app.idleTimeDelay,g.idleTimeHookHandler)
        # g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="ekr.20040809071510.522"></t>
<t tx="ekr.20040809071510.523">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;") ; self.put_nl()

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition,ignored=False) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            self.putVnode(p,ignored=False) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="ekr.20040809071510.524">@killcolor

doctest.DocTestSuite requires Python 2.3 or above.</t>
<t tx="ekr.20040809071510.525"># The interface is different and it isn't worth fixing.</t>
<t tx="ekr.20040809071510.526"></t>
<t tx="ekr.20040809071510.527">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        elif attr=="__del__":
            # This works around a Python 2.2 wierdness.
            return AttributeError # Silently ignore this.
        else:
            # Only called when normal lookup fails.
            print "unknown position attribute:",attr
            # import traceback ; traceback.print_stack()
            raise AttributeError</t>
<t tx="ekr.20040809095716"></t>
<t tx="ekr.20040809102904"></t>
<t tx="ekr.20040812033107">@nocolor

One problem is that continued lines don't have to be indented!  This should be fixed asap.

@color</t>
<t tx="ekr.20040828161347">@killcolor

https://sourceforge.net/forum/message.php?msg_id=2711908
By: nobody

import worked ok on a few files already ok since b3,
this one doesn't import well.
&lt;http://users.wpi.edu/~squirrel/programs/piemenu.html&gt;
&lt;http://users.wpi.edu/~squirrel/programs/piemenu.py&gt;

the methods are all in each class declaration node.
the nodes for each method are made and marked but empty.
same with the other 2 classes in the file.
the generated @file had indentation errors...

import to @file doesn't print status to log?
and why must it mark each method node?
did it know there were problems? why no errors?
maybe a config enabled backup dir to put bak files
if there are going to be some incomplete imports.

looks like it got confused on class variables
and some var = funct asssignments after methods.
some got put after @others at the wrong indent.

has anyone tried to import decorators?
no time like the present...
they import ok for a simple @memoize example.

Leo 4.2 beta 3, build  1.152 , August 10, 2004
Python 2.3.3, Tk 8.4.3, win32
e</t>
<t tx="ekr.20040829101055"></t>
<t tx="ekr.20040830210600"></t>
<t tx="ekr.20040831063427">@killcolor

I'm a new user and just installed 4.2b3 on a Win2ksp4 box with Python 2.2 and Tcl/Tk 8.4.6.1

Leo refuses to start. This is what I get when using the Python repl:

&gt;&gt;&gt; import leo
&gt;&gt;&gt; leo.run()
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
File "leo.py", line 45, in run
if not isValidPython(): return
File "leo.py", line 118, in isValidPython
import leoGlobals as g
File "k:\apps\Leo\src\leoGlobals.py", line 51, in ?
def createTopologyList (c=None,root=None,useHeadlines=False):
NameError: name 'False' is not defined

&gt; NameError: name 'False' is not defined

Thanks for this report.

Leo has code that is intended to warn if you aren't using the proper version of Python.  Apparently this code isn't getting a chance to execute before the traceback is generated.  This is a bug.  Thanks again.

Edward</t>
<t tx="ekr.20040831093934"></t>
<t tx="ekr.20040831093934.1">@killcolor

With TclTkAqua on the Mac (but *not* with tcltk installed via Fink), the tab
problem doesn't exist there), the tab, return, and backspace keys do not generate
ASCII codes, i.e. event.char is an empty string. So when I press the tab key,
Tk inserts a tab character and Leo isn't even aware of it.</t>
<t tx="ekr.20040831095613">@killcolor

Leo gave an error for every character of the file name!

This method got overlooked when runOpenFileDialog got changed recently.

Added unit test to test.leo.</t>
<t tx="ekr.20040831104303"></t>
<t tx="ekr.20040831104303.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2720802
By: billp9619

This  file testmini.leo

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences allow_rich_text="0"/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

Gives error message as follows.

Leo Log Window...
Leo 4.2 beta 3, build  1.152 , August 10, 2004
Python 2.3.4, Tk 8.4.3, win32

File encoding: UTF-8
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 610, in getLeoFile
    self.getPrefs()
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 814, in getPrefs
    self.getUnknownTag()
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 371, in
getUnknownTag
    tag = self.getStringToTag('=')
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 349, in
getStringToTag
    raise BadLeoFile("expecting string terminated by " + tag)
BadLeoFile: Bad Leo File:expecting string terminated by =
C:\Program Files\Leo\testmini.leo is not a valid Leo file: Bad Leo File:expecting
string terminated by =


A copy of LeoDocs.leo with the &lt;preferences allow_rich_text="0"/&gt; tag in it
gave this error message:

File encoding: UTF-8
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 610, in getLeoFile
    self.getPrefs()
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 827, in getPrefs
    self.getTag("&lt;/preferences&gt;")
  File "C:\Program Files\Leo\src\leoFileCommands.py", line 365, in getTag
    raise BadLeoFile("expecting" + tag)
BadLeoFile: Bad Leo File:expecting&lt;/preferences&gt;
C:\Program Files\Leo\leodocsTESTCOPY.leo is not a valid Leo file: Bad Leo
File:expecting&lt;/preferences&gt;

regards,

bill p</t>
<t tx="ekr.20040831110923"></t>
<t tx="ekr.20040831111203">@killcolor

From Dan Winkler:

On a couple of occasions, I tried to paste in a long @url node and got 
this message:

	Truncating headline to 250 characters

I wonder if the 250 character limit on headline length should be 
rethought in light of the @url directive and long web addresses.</t>
<t tx="ekr.20040831112005"></t>
<t tx="ekr.20040831112005.1">@killcolor

Dan Winkler

&gt; I've noticed that Leo often inserts a v when I hit command-v to paste.  
&gt; I'm sure I've got the command key down before I type the v, but Leo is 
&gt; more sensitive to the timing somehow than most apps.

&gt; Now I'm seeing a problem where when I use command-v to paste into a 
&gt; headline it pastes the text twice.  If I use the edit menu and choose 
&gt; paste it works correctly and only pastes once.  Also, if I paste into 
&gt; the body of a node with command-v, that works correctly too.  It's only 
&gt; when I use the command key to paste into a headline that I see the 
&gt; problem.

EKR:  I don't see any of these problems on my Mac.</t>
<t tx="ekr.20040831113849"></t>
<t tx="ekr.20040831120106"></t>
<t tx="ekr.20040831120106.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2714125

1) Create a node that contains the following.

@language html
@doc

Multi
line
HTML
comments

@c
&lt;p&gt;HTML code&lt;/p&gt;

2) Save the leo file.
3) Re-open leo and you'll get a "Missing open block comment in readLastDocLine:"
error.

Leo 4.2 beta 3, build  1.152 , August 10, 2004
Python 2.3.4, Tk 8.4.4, linux2</t>
<t tx="ekr.20040831121549.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2735294
By: lmcgign

If I create an @file or @thin node, clone that node, put an
'@first &lt;something&gt;' directive in it, save all changes and exit, and *then*
open up the file in Leo again, Leo indicates there have been changes (with the
'*' in the title bar) to the Leo file as soon as it starts up.

If the node is *not* cloned, or if the node does *not* contain a *non empty*
@first directive, this behavior does not appear.

I'm running Leo 4.2 beta 3, build  1.152,
Python 2.3.4, Tk 8.4.3, win32.

-----------

Small correction:

If the node is an @file one the behavior appears, even if the node has *not*
been cloned.

For an @thin node, though, the node needs to be cloned for the behavior
to appear.

Leo's console window indicates a Warning line when the behavior occurs:

reading: &lt;leo_filename&gt;
reading: @file gratis.py
Warning: updating changed text   &lt;--- 
leoConfig.txt encoding: utf-8

-Martin</t>
<t tx="ekr.20040901061935"></t>
<t tx="ekr.20040904080309">@killcolor

- This happens in leoPlugins.leo at present.

- It happens with @file and @first, but not with @thin and @first.</t>
<t tx="ekr.20040904081433">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20040906081644">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2706676
By: nobody

Ive downloaded 4.2B3 and really really dont want to use the left click select/expand
anywhere Tree functionality( Ive never had a problem selecting the node I want
:) ).  I looked in the config file and didnt see an option for turning it off.
So do I need to hack the leo code to do this?

Option name: expanded_click_area</t>
<t tx="ekr.20040907083404">@killcolor

A file containing tabs generates diffs for every line, which means that perfect import is totally confused.

I suppose that if perfect import is in effect then maybe we should leave whitespace alone, regardless of tab setting...

Hmmm...</t>
<t tx="ekr.20040910064225"></t>
<t tx="ekr.20040910064225.1">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoColor.py", line 1179, in colorizeAnyLanguage
    assert(state!="unknown")
    
This assert failed when when undoing a cut operation.</t>
<t tx="ekr.20040913111703"></t>
<t tx="ekr.20040914074643">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2756978
By: nobody

The tangle menu options tangle all the @root nodes in a Leo file regardless
of the selection made (tangle m tangle marked, tangle all). In some of my files
Two of more will tangle togeather leaving others alone. Any suggestions.

The fix was to do p = p.copy in tangleTree, tanglePass1 and untangleTree.  untangleTree calls tanglePass1 to traverse the tree, so there are the only changes needed.</t>
<t tx="ekr.20040914081306"></t>
<t tx="ekr.20040914081306.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2742238
By: hinsen

The shortcut definitions in Leo are quite inconvenient on the Mac, as those
using the Alt key don't work. Alt is used for entry of additional characters.
On the other hand, ctrl is available for shortcuts but not used in Leo, since
the ctrl-based shortcuts are shifted to the command key (following standard
Mac practice).

The patch at the end of this message simply shifts all Alt-shortcuts to Ctrl
on the Mac.

That leaves one minor clash: Command-` is used for CloneNode in Leo, although
it canonical MacOS function (switching between the windows of an application)
would be very useful in Leo as well. Removing the CloneNode binding is easy
enough, but it seems that I must implement a window switching function myself.
Not today :-)

Konrad.

</t>
<t tx="ekr.20040914082436"></t>
<t tx="ekr.20040930135204">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20041012082437">def __init__ (self):
    
    self.old = None</t>
<t tx="ekr.20041012082437.1">def isRedirected (self):

    return self.old != None</t>
<t tx="ekr.20041012082437.2"># For LeoN: just for compatibility.

def flush(self, *args):
    return 

</t>
<t tx="ekr.20041012082437.3">def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self</t>
<t tx="ekr.20041012082437.4">def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None</t>
<t tx="ekr.20041012082437.5">def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s</t>
<t tx="ekr.20041012091252">def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s</t>
<t tx="ekr.20041023105832">self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)</t>
<t tx="ekr.20041023110111"># Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste</t>
<t tx="ekr.20041026092141">def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20041107093219.3">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)</t>
<t tx="ekr.20041111093404"># This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break</t>
<t tx="ekr.20041120073824">def destroySelf (self):
    
    pass</t>
<t tx="ekr.20041124083125">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName</t>
<t tx="ekr.20041130065718">def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y</t>
<t tx="ekr.20041130065718.1">def setTopGeometry (self,w,h,x,y,adjustSize=True):
    
    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y</t>
<t tx="ekr.20041130065921">def deiconify (self):
    pass
    
def lift (self):
    pass
    
def update (self):
    pass</t>
<t tx="ekr.20041130065921.1"></t>
<t tx="ekr.20041130090749">def setInitialWindowGeometry (self):
    pass</t>
<t tx="ekr.20041130093254">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")</t>
<t tx="ekr.20041219072112"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)</t>
<t tx="ekr.20041219072416.1">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()</t>
<t tx="ekr.20050208133438">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False</t>
<t tx="ekr.20050211100535">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20050220030850">def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__</t>
<t tx="ekr.20050404151753">def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0
    
# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.</t>
<t tx="ekr.20050404151753.1">def clear (self):
    
    self.list = []


</t>
<t tx="ekr.20050404151753.2">def close (self):
    
    pass
    
    # The StringIo version free's the memory buffer.</t>
<t tx="ekr.20050404151753.3">def flush (self):
    
    pass</t>
<t tx="ekr.20050404151753.4">def get (self):

    return ''.join(self.list)
    
getvalue = get # for compatibility with StringIo
</t>
<t tx="ekr.20050404151753.5">def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr &lt; len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''</t>
<t tx="ekr.20050404151753.6">def write (self,s):
    
    if s:
        self.list.append(s)
</t>
<t tx="ekr.20050405103712">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050405103712.1">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050418084539">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())</t>
<t tx="ekr.20050418084539.2"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)</t>
<t tx="ekr.20050505104140">g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "&lt;string&gt;":
    c.goToScriptLineNumber(p,script,n)

&lt;&lt; dump the lines near the error &gt;&gt;
c.frame.tree.redrawAfterException()</t>
<t tx="ekr.20050526080309">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050526081024">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050526081024.1"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050712070251"></t>
<t tx="ekr.20050712070251.1"></t>
<t tx="ekr.20050712070251.2"></t>
<t tx="ekr.20050712070251.3"></t>
<t tx="ekr.20050712070251.4"></t>
<t tx="ekr.20050712070251.5">@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!</t>
<t tx="ekr.20050712070251.6">def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        g.es_print(s,color="blue")

    return None</t>
<t tx="ekr.20050712070251.7">def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module</t>
<t tx="ekr.20050712070251.8">def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module</t>
<t tx="ekr.20050712070251.9">def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module</t>
<t tx="ekr.20050712070251.10"></t>
<t tx="ekr.20050712070251.11">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 1:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20050712070251.12"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050712070251.13"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20050712070251.14"></t>
<t tx="ekr.20050712070251.15"></t>
<t tx="ekr.20050712070251.16">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2802138
By: rogererens

Using Leo4.2 on WinXP, control-clicking on a section reference:
instead of going to the section definition, I get the following log message:

exception handling , hypercclick,  event
AttributeError

and in the console:

unknown position attribute: redraw
Traceback (most recent call last):
  File "C:\Leo\src\leoTkinterTree.py", line 351, in OnHyperLinkControlClick
    self.redraw()
  File "C:\Leo\src\leoNodes.py", line 1534, in __getattr__
    raise AttributeError
AttributeError

Commenting out the line
self.redraw
in onHyperLinkControlClick
seems to work, but the comment above puts some doubts on the correctness of
this adaptation.

Also, the documentation w.r.t. hyperlinks seems outdated to me, since with the
'Recent' button one can quite easily navigate backward and forward like in web
browsers.
</t>
<t tx="ekr.20050712070251.17">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            # New in recycled nodes code:
            # Call self.redraw to inhibit calls to setLabelState.
            c.frame.tree.redraw()
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")</t>
<t tx="ekr.20050712070251.18"></t>
<t tx="ekr.20050712070251.19">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2805807
By: Ivan

In baseCommands.openWith(), the case for "openType == 'os.spawnv'" appears to
be broken. The two problems I see are that it actually invokes os.spawnl, and
that it does not allow the passing of a variable length list of parameters.

@color

# Replace the body of the os.spawnv case:

filename = g.os_path_basename(arg)
command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
apply(os.spawnl,(os.P_NOWAIT,arg,filename,path)))
 
# with:
    
filename = os.path.basename(arg[0])
vtuple = arg[1:]
vtuple.append(path)
command = "os.spawnv("+arg[0]+","+`vtuple`+")"
apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))

# This requires calls on openWith like
openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)</t>
<t tx="ekr.20050712070251.20">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the "Open With..." menu.
    openWithMenu = Tk.Menu(parent,tearoff=0)
    self.setMenu("Open With...",openWithMenu)
    parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
    # Populate the "Open With..." menu.
    shortcut_table = []
    for triple in table:
        if len(triple) == 3: # 6/22/03
            shortcut_table.append(triple)
        else:
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
            
    # for i in shortcut_table: print i
    self.createMenuItemsFromTable("Open &amp;With...",shortcut_table,openWith=True)</t>
<t tx="ekr.20050712070251.21">def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20050712070251.22">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20050712070251.23">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20050712070251.24">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20050712070251.25">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20050712070251.26">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20050712070251.27">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:] 
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20050712070251.28">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20050712070251.29">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20050712070251.30">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(os.path.abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20050712070251.31"></t>
<t tx="ekr.20050712070251.32">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2807391
By: spboulet

Running the File-&gt;Export-&gt;Remove Sentinels command on a file derived from an
@file node, I get "Can not open D" in the log window (the file is on my D partition).
I do have permission to write the file; tangling works fine.

-------

The fix was to add multiple=True in the call to g.app.gui.runOpenFileDialog in removeSentinels.

Apparently there is a Python bug in askopenfilename, but this fix avoids that.</t>
<t tx="ekr.20050712070251.33"># We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)</t>
<t tx="ekr.20050712070251.34">def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)</t>
<t tx="ekr.20050712070251.35">def removeSentinelsCommand (self,paths):
    
    c = self.c

    self.setEncoding()

    for fileName in paths:

        path, self.fileName = g.os_path_split(fileName)
        &lt;&lt; Read file into s &gt;&gt;
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        &lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="ekr.20050712070251.36">try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return</t>
<t tx="ekr.20050712070251.37"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None</t>
<t tx="ekr.20050712070251.38">try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()</t>
<t tx="ekr.20050712070251.39"></t>
<t tx="ekr.20050712070251.40">From Leo User

I forgot to mention that I had this happen twice today:
1. Copy node.
2. Paste Retaining Clone

...seemed to enter endless node creation loop.
</t>
<t tx="ekr.20050712070251.41">@killcolor

1. In &lt;&lt; recreate tnodesDict &gt;&gt;

    - Set self.tnodesDict ={}
    - Changed all_tnodes_iter to all_unique_tnodes_iter.

2. Set self.forbiddenTnodes in get_vnodes.  Also added reassignIndices keyword param.

3. Raise invalidPaste in get_vnode if the tnode (to be generated later) would be in self.forbiddenTnodes.

3. Fixed bugs:  tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!

4. Report exceptions in getLeoOutline rather than pasteOutline.</t>
<t tx="ekr.20050712070251.42">def pasteOutlineRetainingClones (self):
    
    c = self

    return c.pasteOutline(reassignIndices=False)</t>
<t tx="ekr.20050712070251.43"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    copiedBunchList = []
    if pasteAsClone:
        &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
    
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.beginUpdate()
    c.endEditing()
    if 1: # inside update...
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    c.endUpdate()
    c.recolor()</t>
<t tx="ekr.20050712070251.44">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())</t>
<t tx="ekr.20050712070251.45"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)</t>
<t tx="ekr.20050712070251.46"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []

    if not reassignIndices:
        &lt;&lt; recreate tnodesDict &gt;&gt;

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("&lt;leo_file&gt;") # &lt;leo_file/&gt; is not valid.
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("&lt;/leo_file&gt;")
        v = self.finishPaste(reassignIndices)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v</t>
<t tx="ekr.20050712070251.47">nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]</t>
<t tx="ekr.20050712070251.48">def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("&lt;vnodes&gt;"):
        return # &lt;vnodes/&gt; seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            &lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;

    while self.matchTag("&lt;v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("&lt;/vnodes&gt;")</t>
<t tx="ekr.20050712070251.49">self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)</t>
<t tx="ekr.20050712070251.50">def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched &lt;v.
    while 1:
        if self.matchTag("a=\""):
            &lt;&lt; Handle vnode attribute bits &gt;&gt;
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                &lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag("&gt;"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("&lt;vh&gt;"):
        headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    &lt;&lt; Set the remembered status bits &gt;&gt;

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("&lt;v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    &lt;&lt; Append to current or top stack &gt;&gt;

    # End this vnode.
    self.getTag("&lt;/v&gt;")
    return v</t>
<t tx="ekr.20050712070251.51"># The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()</t>
<t tx="ekr.20050712070251.52"># Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste</t>
<t tx="ekr.20050712070251.53">if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()</t>
<t tx="ekr.20050712070251.54">if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)</t>
<t tx="ekr.20050712070251.55"># The '@' sign is an operator in Python 2.4, not an error token.</t>
<t tx="ekr.20050712070251.56"></t>
<t tx="ekr.20050712070251.57">def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()</t>
<t tx="ekr.20050712070251.58">def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()</t>
<t tx="ekr.20050712070251.59">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20050712070251.60">def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    &lt;&lt; define dispatch dict &gt;&gt;</t>
<t tx="ekr.20050712070251.61">self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}</t>
<t tx="ekr.20050712070251.62">def clear (self):
    self.lines = []</t>
<t tx="ekr.20050712070251.63">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20050712070251.64">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20050712070251.65">def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)</t>
<t tx="ekr.20050712070251.66">def get (self):
    
    return self.lines</t>
<t tx="ekr.20050712070251.67">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)</t>
<t tx="ekr.20050712070251.68">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20050712070251.69">def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []</t>
<t tx="ekr.20050712070251.70">def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()</t>
<t tx="ekr.20050712070251.71">def doEndMarker (self):
    
    self.putArray()</t>
<t tx="ekr.20050712070251.72">def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)</t>
<t tx="ekr.20050712070251.73">def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
</t>
<t tx="ekr.20050712070251.74">def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow</t>
<t tx="ekr.20050712070251.75">def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
</t>
<t tx="ekr.20050712070251.76">def doNewline (self):
    
    self.array.append('\n')
    self.putArray()</t>
<t tx="ekr.20050712070251.77">def doNumber (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20050712070251.78">def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20050712070251.79">def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)</t>
<t tx="ekr.20050712070251.80">def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)</t>
<t tx="ekr.20050712070251.81">def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))</t>
<t tx="ekr.20050712070251.82">def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)</t>
<t tx="ekr.20050712070251.83">def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    </t>
<t tx="ekr.20050712070251.84"></t>
<t tx="ekr.20050712070251.85">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918934
By: ktenney

Current CVS, Win2000
When I select leo.py to import, I get the traceback;

exception executing command
Traceback (most recent call last):
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 161, in
doCommand
    command()
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 811, in
importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\Python23\Lib\site-packages\leo\src\leoImport.py", line 129,
in importDerivedFiles
    junk,read_new,isThin = at.scanHeader(theFile,fileName)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2504,
in scanHeader
    s = at.readLine(theFile)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2469,
in readLine
    u = g.toUnicode(s,self.encoding)
AttributeError: atFile instance has no attribute 'encoding'</t>
<t tx="ekr.20050712070251.86">@killcolor

What I did:
    
- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.</t>
<t tx="ekr.20050712070251.87">def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


</t>
<t tx="ekr.20050712070251.88">def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin</t>
<t tx="ekr.20050712070251.89">def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile</t>
<t tx="ekr.20050712070251.90">@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20050712070251.91">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    command = 'Import'

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        u.afterChangeGroup(p,command)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.92">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20050712070251.93"></t>
<t tx="ekr.20050712070251.94"></t>
<t tx="ekr.20050712070251.95">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2934617
By: bwmulder

According to various notes in the Leo documentation, "hoist" should restrict
you a subtree of the outline.

With the version I am using (CVS, a few days old), searching for strings stops
at nodes outside this subtree. The nodes where the string was found remains
invisible.
</t>
<t tx="ekr.20050712070251.96">def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')</t>
<t tx="ekr.20050712070251.97"># Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(p)
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p</t>
<t tx="ekr.20050712070251.98"></t>
<t tx="ekr.20050712070251.99">@killcolor

Changed scanDirectives and atFile.scanDirectives so they work like tangle.scanAllDirectives.  Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 
 
So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... 
</t>
<t tx="ekr.20050712070251.100">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;</t>
<t tx="ekr.20050712070251.101">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.</t>
<t tx="ekr.20050712070251.102"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)</t>
<t tx="ekr.20050712070251.103"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")</t>
<t tx="ekr.20050712070251.104">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)</t>
<t tx="ekr.20050712070251.105"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20050712070251.106">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e</t>
<t tx="ekr.20050712070251.107"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20050712070251.108"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")</t>
<t tx="ekr.20050712070251.109">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20050712070251.110">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w</t>
<t tx="ekr.20050712070251.111">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

</t>
<t tx="ekr.20050712070251.112"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20050712070251.113">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))</t>
<t tx="ekr.20050712070251.114">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        &lt;&lt; Collect @first attributes &gt;&gt;
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for print modes directives &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @root &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set self.tangle_directory &gt;&gt;</t>
<t tx="ekr.20050712070251.115">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

</t>
<t tx="ekr.20050712070251.116">if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="ekr.20050712070251.117">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20050712070251.118">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20050712070251.119">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
</t>
<t tx="ekr.20050712070251.120">if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
    if len(theDir) &gt; 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                &lt;&lt; handle absolute @path &gt;&gt;
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20050712070251.121">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)</t>
<t tx="ekr.20050712070251.122">if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) &gt; 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) &gt; 0:
                g.es("relative path in @path directive: " + relative_path)</t>
<t tx="ekr.20050712070251.123">if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w &gt; 0:
        self.page_width = w</t>
<t tx="ekr.20050712070251.124">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)</t>
<t tx="ekr.20050712070251.125">if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20050712070251.126">if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
</t>
<t tx="ekr.20050712070251.127">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) &gt; 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) &gt; 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                &lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="ekr.20050712070251.128">if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) &gt; 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) &gt; 0:
            g.es(kind + " directory: " + dir2)
</t>
<t tx="ekr.20050712070251.129">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20050712070251.130">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")</t>
<t tx="ekr.20050712070251.131"># 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20050712070251.132">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
</t>
<t tx="ekr.20050712070251.133">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
</t>
<t tx="ekr.20050712070251.134">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20050712070251.135">if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20050712070251.136">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20050712070251.137">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20050712070251.138">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20050712070251.139"></t>
<t tx="ekr.20050712070251.140">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2816347
By: osuchw

I have came upon a small bug related to how *.leo files are registered to be
open with windows.

Currently the command looks like.
&lt;pythondir&gt;\pythonw.exe "&lt;leodir&gt;\src\leo.py" %1
and it should be
"&lt;pythondir&gt;\pythonw.exe" "&lt;leodir&gt;\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.
For example rst2.py plugin fails if it is called from a leo file that has spaces
in it is path.
</t>
<t tx="ekr.20050712070251.141"></t>
<t tx="ekr.20050712070251.142"></t>
<t tx="ekr.20050712070251.143">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918938
By: ktenney

Any idea what might prevent the Control-E shortcut key from working?  Edit -&gt; Execute Script works fine

current cvs, Win2000, Python 2.3</t>
<t tx="ekr.20050712070251.144">@killcolor

- Restored non Pmw code in resizePanesToRatio.  This code got deleted by mistake.  The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.  It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo.  This overrides the default (Ctrl-E) and thereby prevents the default from overrideing the entry for ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been redefined.  Not sure if this is a wise idea, or indeed if it actually does anything :-)

I am tempted to remove all the default entries entirely.  This would simplify error reporting, but then Leo would hardly work at all if leoSettings.leo were not present.</t>
<t tx="ekr.20050712070251.145">class nullMenu(leoMenu):
    
    """A null menu class for testing and batch execution."""
    
    __pychecker__ = '--no-argsused' # This calss has many unused args.
    
    @others</t>
<t tx="ekr.20050712070251.146">def __init__ (self,frame):
    
    # Init the base class.
    leoMenu.__init__(self,frame)</t>
<t tx="ekr.20050712070251.147">def oops (self):

    g.trace("leoMenu", g.callerName(2))
    pass</t>
<t tx="ekr.20050712070251.148">def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    pass
def createMenuItemsFromTable (self,menuName,table,openWith=False):
    pass
def createMenusFromTables (self):
    pass
def defineMenuTables (self):
    pass
def createNewMenu (self,menuName,parentName="top",before=None):
    pass
def createRecentFilesMenuItems (self):
    pass
def deleteMenu (self,menuName):
    pass
def deleteMenuItem (self,itemName,menuName="top"):
    pass
def destroyMenu (self,menuName):
    pass
def getMenu (self,menuName):
    pass
def setMenu (self,menuName,menu):
    pass</t>
<t tx="ekr.20050712070251.149">def updateAllMenus (self):
    pass
def updateEditMenu (self):
    pass
def updateFileMenu (self):
    pass
def updateOutlineMenu (self):
    pass</t>
<t tx="ekr.20050712070251.150">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20050712070251.151">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050712070251.152">def defineMenuTables (self):
    
    __pychecker__ = 'maxlines=500'
    
    c = self.c ; f = self.frame
    
    # g.trace(c.shortFileName(),self,f)
    
    &lt;&lt; define edit menu tables &gt;&gt;
    &lt;&lt; define file menu tables &gt;&gt;
    &lt;&lt; define outline menu tables &gt;&gt;
    &lt;&lt; define window menu tables &gt;&gt;
    &lt;&lt; define help menu tables &gt;&gt;</t>
<t tx="ekr.20050712070251.153">&lt;&lt; define editMenuTopTable &gt;&gt;
&lt;&lt; define editMenuEditCursorTable &gt;&gt;
&lt;&lt; define editMenuEditBodyTable &gt;&gt;
&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;
&lt;&lt; define editMenuFindMenuTable &gt;&gt;
&lt;&lt; define editMenuTop2Table &gt;&gt;</t>
<t tx="ekr.20050712070251.154">self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &amp;U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &amp;R reserved for Redo
    ("-",None,None),
    ("Cu&amp;t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&amp;y","Ctrl+C",f.OnCopyFromMenu),
    ("&amp;Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&amp;Delete",None,c.delete),
    ("Select &amp;All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
    
# Top-level shortcuts here:  a,d,p,t,u,y,z
# Top-level shortcuts later: e,g,n,v</t>
<t tx="ekr.20050712070251.155">if 0: # Not ready yet.
    self.editMenuEditCursorTable = (
        ('Delete Right',c.deleteRightChar), # Tk: Del
        ('Delete Left',c.deleteLeftChar), # Tk: Backspace
        # Moving the cursor.
        ('Start of Line',c.moveToStartOfLine), # Tk: Home
        ('End of Line',c.moveToEndOfLine), # Tk: End
        ('Start of Node',c.moveToStartOfNode), # Tk: c-Home
        ('End of Node',c.moveToEndOfNode), # Tk: c-End
        ('-',None,None),
        # Extending the selection...
        ('Select Line',c.selectEntireLine),
        ('Extend To Start of Word',c.extendToStartOfWord),
        ('Extend To End of Word',c.extendToEndOfWord),
        ('Extend To Start Of Line',c.extendToStartOfLine), # Tk: s-Home
        ('Extend To End Of Line',c.extendToEndOfLine), # Tk: s-End
        ('Extend To End of Node',c.extendToEndOfNode), # Tk: s-c-End
        
        # The mark...
    )</t>
<t tx="ekr.20050712070251.156">self.editMenuEditBodyTable = (
    ("Extract &amp;Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &amp;Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&amp;Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&amp;lanks",None,c.convertAllBlanks),
    ("Convert All T&amp;abs",None,c.convertAllTabs),
    ("Convert &amp;Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &amp;Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&amp;Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&amp;Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&amp;Indent","Ctrl+]",c.indentBody),
    ("&amp;Unindent","Ctrl+[",c.dedentBody),
    ("&amp;Match Brackets","Ctrl+K",c.findMatchingBracket),
    ("Add Comments",None,c.addComments),
    ("Delete Comments",None,c.deleteComments),
)

# Shortcuts a,b,d,e,i,l,m,n,r,s,t,u</t>
<t tx="ekr.20050712070251.157">self.editMenuEditHeadlineTable = (
    ("Edit &amp;Headline","Ctrl+H",c.editHeadline),
    ("&amp;End Edit Headline","Escape",f.endEditLabelCommand),
    ("&amp;Abort Edit Headline","Shift+Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&amp;Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))</t>
<t tx="ekr.20050712070251.158">self.editMenuFindMenuTable = (
    ("&amp;Find Panel","Ctrl+F",c.showFindPanel),
    ("-",None,None),
    ("Find &amp;Next","F3",c.findNext),
    ("Find &amp;Previous","F4",c.findPrevious),
    ("&amp;Replace","Ctrl+=",c.replace),
    ("Replace, &amp;Then Find","Ctrl+-",c.replaceThenFind))</t>
<t tx="ekr.20050712070251.159">try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
    
self.editMenuTop2Table = (
    ("&amp;Go To Line Number","Alt+G",c.goToLineNumber),
    ("&amp;Execute Script","Alt+Shift+E",c.executeScript),
    # ("Set Fon&amp;t...",None,c.fontPanel), # To be replaced by general settings dialog.
    # ("Set &amp;Colors...",None,c.colorPanel), # To be replaced by general settings dialog.
    (label,"Alt+V",c.viewAllCharacters),
    # ("-",None,None),
    ("Setti&amp;ngs",None,c.preferences)
)

# Top-level shortcuts earlier: a,d,p,t,u,y,z
# Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20050712070251.160">&lt;&lt; define fileMenuTopTable &gt;&gt;
&lt;&lt; define fileMenuTop2Table &gt;&gt;
&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;
&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuImportMenuTable &gt;&gt;
&lt;&lt; define fileMenuExportMenuTable &gt;&gt;
&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</t>
<t tx="ekr.20050712070251.161">self.fileMenuTopTable = (
    ("&amp;New","Ctrl+N",c.new),
    ("&amp;Open...","Ctrl+O",c.open))</t>
<t tx="ekr.20050712070251.162">self.fileMenuTop2Table = (
    ("-",None,None),
    ("&amp;Close","Ctrl+W",c.close),
    ("&amp;Save","Ctrl+S",c.save),
    ("Save &amp;As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &amp;Tangle
    ("Re&amp;vert To Saved",None,c.revert)) # &amp;Read/Write</t>
<t tx="ekr.20050712070251.163">self.fileMenuReadWriteMenuTable = (
    ("&amp;Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &amp;Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &amp;Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &amp;Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&amp;Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes))</t>
<t tx="ekr.20050712070251.164">self.fileMenuTangleMenuTable = (
    ("Tangle &amp;All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &amp;Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&amp;Tangle","Shift+Ctrl+T",c.tangle))</t>
<t tx="ekr.20050712070251.165">self.fileMenuUntangleMenuTable = (
    ("Untangle &amp;All",None,c.untangleAll),
    ("Untangle &amp;Marked",None,c.untangleMarked),
    ("&amp;Untangle","Shift+Ctrl+U",c.untangle))</t>
<t tx="ekr.20050712070251.166">self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&amp;file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&amp;root",None,c.importAtRoot),
    ("Import &amp;CWEB Files",None,c.importCWEBFiles),
    
    ("Import &amp;noweb Files",None,c.importNowebFiles),
    ("Import Flattened &amp;Outline",None,c.importFlattenedOutline))</t>
<t tx="ekr.20050712070251.167">self.fileMenuExportMenuTable = [
    ("Export &amp;Headlines",None,c.exportHeadlines),
    ("Outline To &amp;CWEB",None,c.outlineToCWEB),
    ("Outline To &amp;Noweb",None,c.outlineToNoweb),
    ("&amp;Flatten Outline",None,c.flattenOutline),
    ("&amp;Remove Sentinels",None,c.removeSentinels),
    ("&amp;Weave",None,c.weave)]</t>
<t tx="ekr.20050712070251.168">self.fileMenuTop3MenuTable = (
    ("E&amp;xit","Ctrl+Q",g.app.onQuit),)</t>
<t tx="ekr.20050712070251.169">&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;
&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;
&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;
&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</t>
<t tx="ekr.20050712070251.170">self.outlineMenuTopMenuTable = (
    ("C&amp;ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&amp;opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Pas&amp;te Node As Clone",None,c.pasteOutlineRetainingClones),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&amp;n",None,c.sortChildren), # Conflicted with Hoist.
    ("&amp;Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&amp;Hoist",None,c.hoist),
    ("D&amp;e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
# Bindings for entries that go to submenus: a,g,k,m,x</t>
<t tx="ekr.20050712070251.171">self.outlineMenuCheckOutlineMenuTable = (

    ("Check &amp;Outline",None,c.checkOutline),
    ("&amp;Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &amp;All Python Code",None,c.checkAllPythonCode),
    ("&amp;Check Python &amp;Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&amp;rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&amp;Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20050712070251.172">self.outlineMenuExpandContractMenuTable = (
    ("&amp;Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &amp;Node","Alt+[",c.contractNode),
    ("Contract &amp;Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&amp;rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&amp;ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &amp;1","Alt+1",c.expandLevel1),
    ("Expand To Level &amp;2","Alt+2",c.expandLevel2),
    ("Expand To Level &amp;3","Alt+3",c.expandLevel3),
    ("Expand To Level &amp;4","Alt+4",c.expandLevel4),
    ("Expand To Level &amp;5","Alt+5",c.expandLevel5),
    ("Expand To Level &amp;6","Alt+6",c.expandLevel6),
    ("Expand To Level &amp;7","Alt+7",c.expandLevel7),
    ("Expand To Level &amp;8","Alt+8",c.expandLevel8),
    # ("Expand To Level &amp;9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &amp;All","Alt+9",c.expandAllHeadlines),
    ("Expand N&amp;ode","Alt+]",c.expandNode))</t>
<t tx="ekr.20050712070251.173">self.outlineMenuMoveMenuTable = (
    ("Move &amp;Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &amp;Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &amp;Right","Ctrl+R",c.moveOutlineRight),
    ("Move &amp;Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&amp;Promote","Ctrl+{",c.promote),
    ("&amp;Demote", "Ctrl+}",c.demote))</t>
<t tx="ekr.20050712070251.174">self.outlineMenuMarkMenuTable = (
    ("&amp;Mark","Ctrl+M",c.markHeadline),
    ("Mark &amp;Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &amp;Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &amp;Roots","Alt+R",c.markChangedRoots),
    ("Mark &amp;Clones","Alt+K",c.markClones),
    ("&amp;Unmark All","Alt+U",c.unmarkAll))</t>
<t tx="ekr.20050712070251.175">self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &amp;Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&amp;hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &amp;Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &amp;First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &amp;Last Node","Alt+Shift+H",c.goToLastNode),
    ('Go To Last Visible Node',c.goToLastVisibleNode),
    ("Go To &amp;Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&amp;rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &amp;Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&amp;isible","Alt+UpArrow",c.selectVisBack),
    ("Go To Next &amp;Visible","Alt+DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt+Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt+Shift+DnArrow",c.selectThreadNext))</t>
<t tx="ekr.20050712070251.176">self.windowMenuTopTable = (
    ("&amp;Equal Sized Panes","Ctrl+E",f.equalSizedPanes),
    ("Toggle &amp;Active Pane","Ctrl+T",f.toggleActivePane),
    ("Toggle &amp;Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&amp;de",None,f.cascade),
    ("&amp;Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &amp;Compare Window",None,c.openCompareWindow),
    ("Open &amp;Python Window","Alt+P",c.openPythonWindow))</t>
<t tx="ekr.20050712070251.177">self.helpMenuTopTable = (
    ("&amp;About Leo...",None,c.about),
    ("Online &amp;Home Page",None,c.leoHome),
    ("Open Online &amp;Tutorial",None,c.leoTutorial),
)
    
self.helpMenuTop2Table = (
    ("Open &amp;Offline Tutorial",None,f.leoHelp),
)
    
self.helpMenuTop3Table = (
    ("-",None,None),
    ("Open Leo&amp;Docs.leo",None,c.leoDocumentation),
    ("Open Leo&amp;Plugins.leo",None,c.leoPlugins),
    ("Open Leo&amp;Settings.leo",None,c.leoConfig),
)</t>
<t tx="ekr.20050712070251.178"></t>
<t tx="ekr.20050712070251.179"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)
    
def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()</t>
<t tx="ekr.20050712070251.180">def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&amp;'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&amp;'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
</t>
<t tx="ekr.20050712070251.181">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20050712070251.182">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20050712070251.183">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20050712070251.184"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20050712070251.185"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="ekr.20050712070251.186">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20050712070251.187">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            &lt;&lt; set name to the label for doCommand &gt;&gt;
            &lt;&lt; set accel to the shortcut for name &gt;&gt;
            &lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;
            &lt;&lt; define callback function &gt;&gt;
            &lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                &lt;&lt; handle bind_shorcut &gt;&gt;</t>
<t tx="ekr.20050712070251.188">name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
</t>
<t tx="ekr.20050712070251.189">rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.</t>
<t tx="ekr.20050712070251.190">bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("&lt;Control-c&gt;","&lt;Control-v&gt;","&lt;Control-x&gt;"):
        bind_shortcut = None</t>
<t tx="ekr.20050712070251.191">if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)</t>
<t tx="ekr.20050712070251.192">realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, &amp; bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&amp;")
if amp_index == -1:
    amp_index = realLabel.find("&amp;")

realLabel = realLabel.replace("&amp;","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""</t>
<t tx="ekr.20050712070251.193">d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True</t>
<t tx="ekr.20050712070251.194">def createMenuItemsFromTable (self,menuName,table,openWith=False):
    
    try:
        menu = self.getMenu(menuName)
        if menu == None:
            print "menu does not exist: ",menuName
            g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,openWith)
    except:
        s = "exception creating items for %s menu" % menuName
        g.es_print(s)
        g.es_exception()
        
    g.app.menuWarningsGiven = True</t>
<t tx="ekr.20050712070251.195">def createMenusFromTables (self):

    c = self.c
    &lt;&lt; create the file menu &gt;&gt;
    &lt;&lt; create the edit menu &gt;&gt;
    &lt;&lt; create the outline menu &gt;&gt;
    g.doHook("create-optional-menus",c=c)
    &lt;&lt; create the window menu &gt;&gt;
    &lt;&lt; create the help menu &gt;&gt;</t>
<t tx="ekr.20050712070251.196">fileMenu = self.createNewMenu("&amp;File")

self.createMenuEntries(fileMenu,self.fileMenuTopTable,init=True)
self.createNewMenu("Open &amp;With...","File")
self.createMenuEntries(fileMenu,self.fileMenuTop2Table,init=True)
&lt;&lt; create the recent files submenu &gt;&gt;
self.add_separator(fileMenu)
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
self.add_separator(fileMenu)
self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable,init=True)</t>
<t tx="ekr.20050712070251.197">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()</t>
<t tx="ekr.20050712070251.198">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable,init=True)</t>
<t tx="ekr.20050712070251.199">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable,init=True)</t>
<t tx="ekr.20050712070251.200">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable,init=True)</t>
<t tx="ekr.20050712070251.201">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable,init=True)</t>
<t tx="ekr.20050712070251.202">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable,init=True)</t>
<t tx="ekr.20050712070251.203">editMenu = self.createNewMenu("&amp;Edit")

self.createMenuEntries(editMenu,self.editMenuTopTable,init=True)

&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;

self.createMenuEntries(editMenu,self.editMenuTop2Table,init=True)</t>
<t tx="ekr.20050712070251.204">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable,init=True)</t>
<t tx="ekr.20050712070251.205">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable,init=True)</t>
<t tx="ekr.20050712070251.206">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable,init=True)</t>
<t tx="ekr.20050712070251.207">outlineMenu = self.createNewMenu("&amp;Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable,init=True)

&lt;&lt; create check submenu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20050712070251.208">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable,init=True)</t>
<t tx="ekr.20050712070251.209">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable,init=True)</t>
<t tx="ekr.20050712070251.210">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable,init=True)</t>
<t tx="ekr.20050712070251.211">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable,init=True)</t>
<t tx="ekr.20050712070251.212">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable,init=True)</t>
<t tx="ekr.20050712070251.213">windowMenu = self.createNewMenu("&amp;Window")

self.createMenuEntries(windowMenu,self.windowMenuTopTable,init=True)</t>
<t tx="ekr.20050712070251.214">helpMenu = self.createNewMenu("&amp;Help")

self.createMenuEntries(helpMenu,self.helpMenuTopTable,init=True)

if sys.platform=="win32":
    self.createMenuEntries(helpMenu,self.helpMenuTop2Table,init=True)

self.createMenuEntries(helpMenu,self.helpMenuTop3Table,init=True)</t>
<t tx="ekr.20050712070251.215">def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName)
        
        if 0: # 11/13/03: Allow parent to be None.
            if parent == None:
                g.es("unknown parent menu: " + parentName)
                return None

        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&amp;")
            label = label.replace("&amp;","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&amp;")
                index_label = index_label.replace("&amp;","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None</t>
<t tx="ekr.20050712070251.216">def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1</t>
<t tx="ekr.20050712070251.217">def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()</t>
<t tx="ekr.20050712070251.218">def deleteMenuItem (self,itemName,menuName="top"):
    
    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()</t>
<t tx="ekr.20050712070251.219">def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]</t>
<t tx="ekr.20050712070251.220">def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&amp;","")

    menu.entryconfig(realName,accelerator='')</t>
<t tx="ekr.20050712070251.221"></t>
<t tx="ekr.20050712070251.222"></t>
<t tx="ekr.20050712070251.223">exception executing command
Traceback (most recent call last):

File "C:\prog\leoCVS\leo\src\leoNodes.py", line 3044, in moveToParent
if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'</t>
<t tx="ekr.20050712070251.224">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p</t>
<t tx="ekr.20050712070251.225"># Leo looped after this assert failed.</t>
<t tx="ekr.20050712070251.226">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    if 0: # This assert is invalid.
        assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20050712070251.227"></t>
<t tx="ekr.20050712070251.228"></t>
<t tx="ekr.20050712070251.229">@language c

/*@+leo-ver=4*/
/*@+node:@file cat.c*/

/*@@language C*/
#ifdef COMMENT
/*@@comment /* */*/
#endif /* COMMENT */
/*@@path C:\Vlib\Src*/
/*@@tabwidth 4*/
/*@@markup wiki*/


/*@+doc*/
/*
 * Copies STDIN to STDOUT.
 * The basis for all filters.
*/
/*@-doc*/
/*@@code*/
/*@&lt;&lt; Header &gt;&gt;*/
/*@+node:&lt;&lt; Header &gt;&gt;*/

#include &lt;stdio.h&gt;
#include &lt;easy.h&gt;

void filecopy(FILE *fp);
/*@-node:&lt;&lt; Header &gt;&gt;*/
/*@nl*/
/*@&lt;&lt; Main &gt;&gt;*/
/*@+node:&lt;&lt; Main &gt;&gt;*/

void main(int argc, char *argv[])
begin
FILE *fp,
    *fopen();

   if(argc == 1) then
      filecopy(stdin);
   orelse
      while(--argc &gt; 0)
      begin
         if((fp = fopen(*++argv, "r")) == NULL) then
            fprintf( stderr,"cat: can't open %s\n", *argv);
            exit(1);
         orelse
            filecopy(fp);
            fclose(fp);
         endif
      endwhile
   endif
   exit(0);
end
/*@-node:&lt;&lt; Main &gt;&gt;*/
/*@nl*/
/*@&lt;&lt; File Copy &gt;&gt;*/
/*@+node:&lt;&lt; File Copy &gt;&gt;*/

void filecopy(FILE *fp)
begin
int c;
   while( (c = getc(fp)) != EOF)
      putc(c, stdout);
end
/*@-node:&lt;&lt; File Copy &gt;&gt;*/
/*@nl*/
/*@-node:@file cat.c*/
/*@-leo*/
</t>
<t tx="ekr.20050712070251.230">@nocolor

I think I have found the problem.   The readDirective method is changing the comment delimiters as the result of seeing the sentinels corresponding to @language or @comment directives.

But in general this makes no sense!  Comment delimiters should be set once and for all in the @+leo sentinel: there is no compiler in the world that tolerates mixed comment delimiters.  BTW, the way to set javascript "inner" comments is to use @delims, not @comment.  N.B.  The @language and @comment delimiters _will_ have an effect, and that effect is in the _write_ logic, not the read logic.  The effect is to set the comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective, like this:

@color

if 0: # New in 4.2.1: never change comment delims here...
....if g.match_word(s,i,"@language"):
........&lt;&lt; handle @language &gt;&gt;
....elif g.match_word(s,i,"@comment"):
........&lt;&lt; handle @comment &gt;&gt;

@nocolor

Does anyone have any idea why it may have been useful?

I'm kinda freaked out by this.  The number of file reading and writing options in the various versions of Leo has definitely passed the point at which I can understand them all myself.  Fortunately (I think), the new atFile code has simplified matters.

I just hope that the transition to the new code isn't going to be too painful.  Leo now requires gnx's for all nodes, which is a step in the right direction.  Alas, Leo actually doesn't read thin derived files that were written with gnx's disabled.  My _guess_ is that this has always been a hole in the read logic and that hardly anyone fell into the hole because use_gnx was the default.  The new code plugs this code by making sure all nodes get written with gnx's.

In short, my advice is to comment out the code as shown above and see what happens. This is a _speculative_ fix, although all unit tests pass (so much for unit tests :-)  Please let me know if this "fix" causes problems.  If so, the problems should tell me what, if anything, I was thinking about when I wrote the code above ;-)</t>
<t tx="ekr.20050712070251.231">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20050712070251.232"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20050712070251.233">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20050712070251.234">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20050712070251.235"></t>
<t tx="ekr.20050712070251.236">@killcolor

- Added g.app.failedPlugins list.
- Added moduleName arg to g.cantImport.
- Removed redundant print from cantImport.
- cantImport only writes one failure message per named plugin.</t>
<t tx="ekr.20050712070251.237"></t>
<t tx="ekr.20050712070251.238">@killcolor 

The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding  to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.</t>
<t tx="ekr.20050712070251.239"># This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen</t>
<t tx="ekr.20050712070251.240">def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            &lt;&lt; files are identical &gt;&gt;
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            &lt;&lt; report if the files differ only in line endings &gt;&gt;
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False</t>
<t tx="ekr.20050712070251.241">self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)</t>
<t tx="ekr.20050712070251.242">if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")</t>
<t tx="ekr.20050712070251.243"></t>
<t tx="ekr.20050712070251.244">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2813280
By: e

@file-nosent has sentinals.

The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.

Like this:

at.initWriteIvars(root,at.targetFileName,
    nosentinels=nosentinels,thinFile=thinFile,
    scriptWrite=scriptWrite,toString=toString)
</t>
<t tx="ekr.20050712070251.245"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    &lt;&lt; set at.targetFileName &gt;&gt;
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
</t>
<t tx="ekr.20050712070251.246">if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()</t>
<t tx="ekr.20050712070251.247"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20050712070251.248">class atFile:
    
    &lt;&lt; define class constants &gt;&gt;
    &lt;&lt; define sentinelDict &gt;&gt;
    
    """The class implementing the atFile subcommander."""

    @others</t>
<t tx="ekr.20050712070251.249"># These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	  =  5 # @code
cDirective		    =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
endAt			 = 21 # @-at
endBody			 = 22 # @-body
# not used   = 23
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @&lt; &lt; ... &gt; &gt;
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)</t>
<t tx="ekr.20050712070251.250">sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}</t>
<t tx="ekr.20050712070251.251"></t>
<t tx="ekr.20050712070251.252">def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20050712070251.253">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20050712070251.254">def initCommonIvars (self):
    
    """Init ivars common to both reading and writing.
    
    The defaults set here may be changed later."""
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    c = self.c
    
    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict

    &lt;&lt; set defaults for arguments and options &gt;&gt;
    &lt;&lt; init common ivars &gt;&gt;</t>
<t tx="ekr.20050712070251.255"># These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None</t>
<t tx="ekr.20050712070251.256"># These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.</t>
<t tx="ekr.20050712070251.257">def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    thinFile=False):
        
    importing = importFileName is not None

    self.initCommonIvars()
    
    &lt;&lt; init ivars for reading &gt;&gt;
    
    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = thinFile
</t>
<t tx="ekr.20050712070251.258">self.cloneSibCount = 0 # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.out = None
self.outStack = []
self.tnodeList = []
self.tnodeListIndex = 0
self.t = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
</t>
<t tx="ekr.20050712070251.259">def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    &lt;&lt; init ivars for writing &gt;&gt;
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []</t>
<t tx="ekr.20050712070251.260">@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""</t>
<t tx="ekr.20050712070251.261"></t>
<t tx="ekr.20050712070251.262">@

All reading happens in the readOpenFile logic, so plugins should need to
override only this method.</t>
<t tx="ekr.20050712070251.263">def openFileForReading(self,fileName,fromString=False):
    
    at = self
    
    if fromString:
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_join(at.default_directory,fileName)
        fn = g.os_path_normpath(fn)
        try:
            # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
            at.inputFile = self.openForRead(fn,'rb') #bwm
            &lt;&lt; warn on read-only file &gt;&gt;
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None</t>
<t tx="ekr.20050712070251.264"># os.access() may not exist on all platforms.
try:
    read_only = not os.access(fn,os.W_OK)
except AttributeError:
    read_only = False 
    
if read_only:
    g.es("read only: " + fn,color="red")</t>
<t tx="ekr.20050712070251.265"># The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    &lt;&lt; set fileName &gt;&gt;
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if not at.thinFile:
        &lt;&lt; warn about non-empty unvisited nodes &gt;&gt;
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            &lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;
    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return at.errors == 0</t>
<t tx="ekr.20050712070251.266">if fromString:
    fileName = "&lt;string-file&gt;"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False</t>
<t tx="ekr.20050712070251.267">for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.</t>
<t tx="ekr.20050712070251.268">for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()</t>
<t tx="ekr.20050712070251.269">for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")</t>
<t tx="ekr.20050712070251.270">def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")</t>
<t tx="ekr.20050712070251.271">def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;</t>
<t tx="ekr.20050712070251.272">try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s</t>
<t tx="ekr.20050712070251.273">def openForRead(self, *args, **kw):
    """
    Hook for the mod_shadow plugin.
    """
    return open(*args, **kw)</t>
<t tx="ekr.20050712070251.274">def openForWrite(self, *args, **kw):
    """
    Hook for the mod_shadow plugin
    """
    return open(*args, **kw)

</t>
<t tx="ekr.20050712070251.275"></t>
<t tx="ekr.20050712070251.276">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild3(self,n,parent,headline):
    
    """Create the nth child of the parent."""

    at = self
    assert(n &gt; 0)
    
    if at.importing:
        return at.createImportedNode(at.root,headline)

    # Create any needed dummy children.
    dummies = n - parent.numberOfChildren() - 1
    if dummies &gt; 0:
        if 0: # CVS produces to many errors for this to be useful.
            g.es("dummy created")
        at.errors += 1
    while dummies &gt; 0:
        dummies -= 1
        dummy = parent.insertAsLastChild(leoNodes.tnode())
        # The user should never see this headline.
        dummy.initHeadString("Dummy")

    if n &lt;= parent.numberOfChildren():
        &lt;&lt; check the headlines &gt;&gt;
    else:
        # This is using a dummy; we should already have bumped errors.
        result = parent.insertAsLastChild(leoNodes.tnode())
    result.initHeadString(headline)
    
    result.setVisited() # Suppress all other errors for this node.
    result.t.setVisited() # Suppress warnings about unvisited nodes.
    return result</t>
<t tx="ekr.20050712070251.277"># 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
    start = at.startSentinelComment
    end = at.endSentinelComment
    if end and len(end) &gt; 0:
        # 1/25/03: The kludgy fix.
        # Compare the headlines without the delims.
        h1 =   headline.replace(start,"").replace(end,"")
        h2 = resulthead.replace(start,"").replace(end,"")
        if h1.strip() == h2.strip():
            # 1/25/03: Another kludge: use the headline from the outline, not the derived file.
            headline = resulthead
        else:
            at.errors += 1
    else:
        at.errors += 1
</t>
<t tx="ekr.20050712070251.278">def handleLinesFollowingSentinel (self,lines,sentinel,comments = True):
    
    """convert lines following a sentinel to a single line"""
    
    at = self
    m = " following" + sentinel + " sentinel"
    start = at.startSentinelComment
    end   = at.endSentinelComment
    
    if len(lines) == 1: # The expected case.
        s = lines[0]
    elif len(lines) == 5:
        at.readError("potential cvs conflict" + m)
        s = lines[1]
        g.es("using " + s)
    else:
        at.readError("unexpected lines" + m)
        g.es(len(lines), " lines" + m)
        s = "bad " + sentinel
        if comments: s = start + ' ' + s

    if comments:
        &lt;&lt; remove the comment delims from s &gt;&gt;
        
    # Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
    if start[-1:] == '@':
        s = s.replace('@@','@')

    return s</t>
<t tx="ekr.20050712070251.279"># Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if g.match(s,0,comment):
    s = s[len(comment):]
else:
    at.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
    s = string.strip(s[:-1])
else:
    k = s.rfind(end)
    s = string.strip(s[:k]) # works even if k == -1</t>
<t tx="ekr.20050712070251.280"># We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,theFile):
    
    """	read lines following multiline sentinels"""
    
    at = self
    lines = []
    start = at.startSentinelComment + '@ '
    nextLine = at.readLine(theFile)
    while nextLine and len(nextLine) &gt; 0:
        if len(lines) == 0:
            lines.append(nextLine)
            nextLine = at.readLine(theFile)
        else:
            # 5/1/03: looser test then calling sentinelKind3.
            s = nextLine ; i = g.skip_ws(s,0)
            if g.match(s,i,start):
                lines.append(nextLine)
                nextLine = at.readLine(theFile)
            else: break

    return nextLine,lines</t>
<t tx="ekr.20050712070251.281"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc3(self,theFile,s,i,out,kind):
    
    at = self
    endKind = g.choose(kind ==at.startDoc,at.endDoc,at.endAt)
    single = len(at.endSentinelComment) == 0
    &lt;&lt; Skip the opening sentinel &gt;&gt;
    &lt;&lt; Skip an opening block delim &gt;&gt;
    nextLine = None ; kind = at.noSentinel
    while len(s) &gt; 0:
        &lt;&lt; set kind, nextLine &gt;&gt;
        if kind == endKind: break
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to out &gt;&gt;
        if nextLine:
            s = nextLine ; nextLine = None
        else: s = at.readLine(theFile)
    if kind != endKind:
        at.readError("Missing " + at.sentinelName(endKind) + " sentinel")
    &lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="ekr.20050712070251.282">assert(g.match(s,i,g.choose(kind == at.startDoc, "+doc", "+at")))

out.append(g.choose(kind == at.startDoc, "@doc", "@"))
s = at.readLine(theFile)
</t>
<t tx="ekr.20050712070251.283">if not single:
    j = g.skip_ws(s,0)
    if g.match(s,j,at.startSentinelComment):
        s = at.readLine(theFile)</t>
<t tx="ekr.20050712070251.284">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    j = g.skip_ws(s,0)
    blankLine = s[j] == '\n'
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
    if blankLine and nextKind == endKind:
        kind = endKind # stop the scan now
</t>
<t tx="ekr.20050712070251.285"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0, at.indent)
</t>
<t tx="ekr.20050712070251.286"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    out.append(line + '\n')
else:
    # trailing whitespace: the newline is not real.
    out.append(line)
</t>
<t tx="ekr.20050712070251.287"># This code will typically only be executed for HTML files.

if not single:

    delim = at.endSentinelComment
    n = len(delim)
    
    # Remove delim and possible a leading newline.
    s = string.join(out,"")
    s = s.rstrip()
    if s[-n:] == delim:
        s = s[:-n]
    if s[-1] == '\n':
        s = s[:-1]
        
    # Rewrite out in place.
    del out[:]
    out.append(s)
</t>
<t tx="ekr.20050712070251.288">def scanText3 (self,theFile,p,out,endSentinelKind,nextLine=None):
    
    """Scan a 3.x derived file recursively."""
    
    __pychecker__ = '--maxbranches=100 --maxlines=500'

    at = self
    lastLines = [] # The lines after @-leo
    lineIndent = 0 ; linep = 0 # Changed only for sentinels.
    while 1:
        &lt;&lt; put the next line into s &gt;&gt;
        &lt;&lt; set kind, nextKind &gt;&gt;
        if kind != at.noSentinel:
            &lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
            i = at.skipSentinelStart3(s,0)
        &lt;&lt; handle the line in s &gt;&gt;
    &lt;&lt; handle unexpected end of text &gt;&gt;
    assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
    return lastLines # We get here only if there are problems.</t>
<t tx="ekr.20050712070251.289">if nextLine:
    s = nextLine ; nextLine = None
else:
    s = at.readLine(theFile)
    if len(s) == 0: break</t>
<t tx="ekr.20050712070251.290">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
else:
    nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText3 returns.</t>
<t tx="ekr.20050712070251.291">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if at.raw: # 10/15/02
    linep =0
else:
    linep = at.skipIndent(s,0,at.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
    if s[i] == '\t': lineIndent += (abs(at.tab_width) - (lineIndent % abs(at.tab_width)))
    elif s[i] == ' ': lineIndent += 1
    else: break
    i += 1
# g.trace("lineIndent,s:",lineIndent,s)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="ekr.20050712070251.292">if kind == at.noSentinel:
    &lt;&lt; append non-sentinel line &gt;&gt;
&lt;&lt; handle common sentinels &gt;&gt;
&lt;&lt; handle rare sentinels &gt;&gt;
else:
    &lt;&lt; warn about unknown sentinel &gt;&gt;</t>
<t tx="ekr.20050712070251.293"># We don't output the trailing newline if the next line is a sentinel.
if at.raw: # 10/15/02
    i = 0
else:
    i = at.skipIndent(s,0,at.indent)

assert(nextLine != None)

if nextKind == at.noSentinel:
    line = s[i:]
    out.append(line)
else:
    line = s[i:-1] # don't output the newline
    out.append(line)
</t>
<t tx="ekr.20050712070251.294">elif kind in (at.endAt, at.endBody,at.endDoc,at.endLeo,at.endNode,at.endOthers):
        &lt;&lt; handle an ending sentinel &gt;&gt;
elif kind == at.startBody:
    &lt;&lt; scan @+body &gt;&gt;
elif kind == at.startNode:
    &lt;&lt; scan @+node &gt;&gt;
elif kind == at.startRef:
    &lt;&lt; scan old ref &gt;&gt;
elif kind == at.startAt:
    &lt;&lt; scan @+at &gt;&gt;
elif kind == at.startDoc:
    &lt;&lt; scan @+doc &gt;&gt;
elif kind == at.startOthers:
    &lt;&lt; scan @+others &gt;&gt;</t>
<t tx="ekr.20050712070251.295"># g.trace("end sentinel:", at.sentinelName(kind))

if kind == endSentinelKind:
    if kind == at.endLeo:
        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(theFile)
            if len(s) == 0: break
            lastLines.append(s) # Capture all trailing lines, even if empty.
    elif kind == at.endBody:
        at.raw = False
    # nextLine != None only if we have a non-sentinel line.
    # Therefore, nextLine == None whenever scanText3 returns.
    assert(nextLine==None)
    return lastLines # End the call to scanText3.
else:
    # Tell of the structure error.
    name = at.sentinelName(kind)
    expect = at.sentinelName(endSentinelKind)
    at.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="ekr.20050712070251.296">assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent</t>
<t tx="ekr.20050712070251.297">assert(g.match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = ""
&lt;&lt; Set headline and ref &gt;&gt;

# print childIndex,headline

if childIndex == 0: # The root node.
    if not at.importing:
        &lt;&lt; Check the filename in the sentinel &gt;&gt;
    # Put the text of the root node in the current node.
    at.scanText3(theFile,p,out,at.endNode)
    p.v.t.setCloneIndex(cloneIndex)
    # if cloneIndex &gt; 0: g.trace("clone index:",cloneIndex,p)
else:
    # NB: this call to createNthChild3 is the bottleneck!
    child = at.createNthChild3(childIndex,p,headline)
    child.t.setCloneIndex(cloneIndex)
    # if cloneIndex &gt; 0: g.trace("cloneIndex,child:"cloneIndex,child)
    at.scanText3(theFile,child,out,at.endNode)

&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</t>
<t tx="ekr.20050712070251.298">i = g.skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")</t>
<t tx="ekr.20050712070251.299">while i &lt; len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i &lt; len(s) and s[i] in string.digits:
            i += 1
        if j &lt; i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")</t>
<t tx="ekr.20050712070251.300"># Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    # 10/24/02: search from the right, not the left.
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1
    
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')

# Set reference if it exists.
i = g.skip_ws(s,i)

if 0: # no longer used
    if g.match(s,i,"&lt;&lt;"):
        k = s.find("&gt;&gt;",i)
        if k != -1: ref = s[i:k+2]</t>
<t tx="ekr.20050712070251.301">h = headline.strip()

if h[:5] == "@file":
    i,junk,junk = g.scanAtFileOptions(h)
    fileName = string.strip(h[i:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
    fileName = string.strip(h[8:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
else:
    at.readError("Missing @file in root @node sentinel")
</t>
<t tx="ekr.20050712070251.302">s = at.readLine(theFile)
kind = at.sentinelKind3(s)

if len(s) &gt; 1 and kind == at.startVerbatimAfterRef:
    s = at.readLine(theFile)
    # g.trace("verbatim:",repr(s))
    out.append(s)
elif len(s) &gt; 1 and at.sentinelKind3(s) == at.noSentinel:
    out.append(s)
else:
    nextLine = s # Handle the sentinel or blank line later.

</t>
<t tx="ekr.20050712070251.303">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(g.match(s,i,"&lt;&lt;"))

if len(at.endSentinelComment) == 0:
    line = s[i:-1] # No trailing newline
else:
    k = s.find(at.endSentinelComment,i)
    line = s[i:k] # No trailing newline, whatever k is.
        
# 10/30/02: undo cweb hack here
start = at.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
    line = line.replace('@@','@')

out.append(line)</t>
<t tx="ekr.20050712070251.304">assert(g.match(s,i,"+at"))
at.scanDoc3(theFile,s,i,out,kind)</t>
<t tx="ekr.20050712070251.305">assert(g.match(s,i,"+doc"))
at.scanDoc3(theFile,s,i,out,kind)</t>
<t tx="ekr.20050712070251.306">assert(g.match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

at.scanText3(theFile,p,out,at.endOthers)</t>
<t tx="ekr.20050712070251.307">elif kind == at.startComment:
    &lt;&lt; scan @comment &gt;&gt;
elif kind == at.startDelims:
    &lt;&lt; scan @delims &gt;&gt;
elif kind == at.startDirective:
    &lt;&lt; scan @@ &gt;&gt;
elif kind == at.startLeo:
    &lt;&lt; scan @+leo &gt;&gt;
elif kind == at.startVerbatim:
    &lt;&lt; scan @verbatim &gt;&gt;</t>
<t tx="ekr.20050712070251.308">assert(g.match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
</t>
<t tx="ekr.20050712070251.309">assert(g.match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = g.skip_ws(s,i-1+7)
    
# Get the first delim.
j = i
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    at.startSentinelComment = s[j:i]
    # print "delim1:", at.startSentinelComment

    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    end = g.choose(j&lt;i,s[j:i],"")
    i2 = g.skip_ws(s,i)
    if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
        at.endSentinelComment = "" # Not really two params.
        line = s[i0:j]
        line = line.rstrip()
        out.append(line+'\n')
    else:
        at.endSentinelComment = end
        # print "delim2:",end
        line = s[i0:i]
        line = line.rstrip()
        out.append(line+'\n')
else:
    at.readError("Bad @delims")
    # Append the bad @delims line to the body text.
    out.append("@delims")</t>
<t tx="ekr.20050712070251.310"># The first '@' has already been eaten.
assert(g.match(s,i,"@"))

if g.match_word(s,i,"@raw"):
    at.raw = True
elif g.match_word(s,i,"@end_raw"):
    at.raw = False

e = at.endSentinelComment
s2 = s[i:]
if len(e) &gt; 0:
    k = s.rfind(e,i)
    if k != -1:
        s2 = s[i:k] + '\n'
    
start = at.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
    s2 = s2.replace('@@','@')
out.append(s2)
# g.trace(s2)</t>
<t tx="ekr.20050712070251.311">assert(g.match(s,i,"+leo"))
at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20050712070251.312">assert(g.match(s,i,"verbatim"))

# Skip the sentinel.
s = at.readLine(theFile) 

# Append the next line to the text.
i = at.skipIndent(s,0,at.indent)
out.append(s[i:])
</t>
<t tx="ekr.20050712070251.313">j = i
i = g.skip_line(s,i)
line = s[j:i]
at.readError("Unknown sentinel: " + line)</t>
<t tx="ekr.20050712070251.314"># Issue the error.
name = at.sentinelName(endSentinelKind)
at.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="ekr.20050712070251.315">def sentinelKind3(self,s):

    """This method tells what kind of sentinel appears in line s.
    
    Typically s will be an empty line before the actual sentinel,
    but it is also valid for s to be an actual sentinel line.
    
    Returns (kind, s, emptyFlag), where emptyFlag is True if
    kind == at.noSentinel and s was an empty line on entry."""
    
    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # 10/30/02: locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # Do not skip whitespace here!
    if g.match(s,i,"@&lt;&lt;"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) &gt; 0 and at.sentinelDict.has_key(key):
        # g.trace("found:",key)
        return at.sentinelDict[key]
    else:
        # g.trace("not found:",key)
        return at.noSentinel</t>
<t tx="ekr.20050712070251.316">def skipSentinelStart3(self,s,i):
    
    """Skip the start of a sentinel."""
    
    at = self
    start = at.startSentinelComment
    assert(start and len(start)&gt;0)

    if g.is_nl(s,i): i = g.skip_nl(s,i)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i &lt; len(s) and s[i] == '@')
    return i + 1
</t>
<t tx="ekr.20050712070251.317"></t>
<t tx="ekr.20050712070251.318">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20050712070251.319">def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""
    
    __pychecker__ = '--no-argsused' # headline might be used for debugging.
    
    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t</t>
<t tx="ekr.20050712070251.320">def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20050712070251.321"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20050712070251.322">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20050712070251.323">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20050712070251.324">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20050712070251.325">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20050712070251.326"></t>
<t tx="ekr.20050712070251.327">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20050712070251.328">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20050712070251.329">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20050712070251.330">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20050712070251.331">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20050712070251.332"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20050712070251.333"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20050712070251.334">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20050712070251.335">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20050712070251.336"></t>
<t tx="ekr.20050712070251.337">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20050712070251.338">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20050712070251.339">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20050712070251.340">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20050712070251.341">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20050712070251.342">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20050712070251.343"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20050712070251.344">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20050712070251.345"></t>
<t tx="ekr.20050712070251.346">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20050712070251.347">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20050712070251.348">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20050712070251.349">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20050712070251.350">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20050712070251.351">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20050712070251.352">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20050712070251.353">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20050712070251.354">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20050712070251.355">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20050712070251.356">def sentinelKind4(self,s):
    
    """Return the kind of sentinel at s."""
    
    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')
        
    # 4.0: Look ahead for @[ws]@others and @[ws]&lt;&lt;
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j &gt; i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"&lt;&lt;"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@&lt;&lt;"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) &gt; 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel</t>
<t tx="ekr.20050712070251.357">def skipSentinelStart4(self,s,i):
    
    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)&gt;0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i &lt; len(s) and s[i] == '@')
    return i + 1
</t>
<t tx="ekr.20050712070251.358"></t>
<t tx="ekr.20050712070251.359"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j &gt;= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="ekr.20050712070251.360"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j &lt; -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1</t>
<t tx="ekr.20050712070251.361">def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                p.setBodyStringOrPane(s) # Sets v and v.c dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()</t>
<t tx="ekr.20050712070251.362">def createImportedNode (self,root,headline):
    
    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
        
    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p</t>
<t tx="ekr.20050712070251.363">def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    return valid,new_df,start,end,isThinDerivedFile</t>
<t tx="ekr.20050712070251.364"># s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    start = s[j:i]
else:
    valid = False</t>
<t tx="ekr.20050712070251.365">@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False</t>
<t tx="ekr.20050712070251.366">new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i &lt; len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j &lt; i:
        pass # version = s[j:i]
    else:
        valid = False
</t>
<t tx="ekr.20050712070251.367">if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True</t>
<t tx="ekr.20050712070251.368"># Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j &gt; -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j &gt; -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
</t>
<t tx="ekr.20050712070251.369"># The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]</t>
<t tx="ekr.20050712070251.370">def test_parseLeoSentinel (self):
    
    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.
    
    at=c.atFileCommands # Self is a dummy argument.
    
    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
</t>
<t tx="ekr.20050712070251.371">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
    
    self.error(message)
    
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20050712070251.372"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i &lt; n and ws &lt; width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i</t>
<t tx="ekr.20050712070251.373"></t>
<t tx="ekr.20050712070251.374"></t>
<t tx="ekr.20050712070251.375"># Plugins probably should not need to override these methods.</t>
<t tx="ekr.20050712070251.376"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None</t>
<t tx="ekr.20050712070251.377">def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
rawWrite = norefWrite
</t>
<t tx="ekr.20050712070251.378">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="ekr.20050712070251.379">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20050712070251.380">s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20050712070251.381">at.putOpenNodeSentinel(p)

s = p.bodyString()
if s and len(s) &gt; 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p)</t>
<t tx="ekr.20050712070251.382">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()</t>
<t tx="ekr.20050712070251.383">def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None
    
    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()
    
    return at.outputFile is not None</t>
<t tx="ekr.20050712070251.384">def openFileForWritingHelper (self,fileName):
    
    at = self

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            at.writeError("path does not exist: " + path)
            return
    except:
        at.exception("exception creating path:" + path)
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)</t>
<t tx="ekr.20050712070251.385"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput</t>
<t tx="ekr.20050712070251.386">def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave</t>
<t tx="ekr.20050712070251.387">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()</t>
<t tx="ekr.20050712070251.388">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True</t>
<t tx="ekr.20050712070251.389">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")</t>
<t tx="ekr.20050712070251.390">def writeMissing(self,p,toString=False):

    at = self
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = g.os_path_join(self.default_directory,at.targetFileName)
                at.targetFileName = g.os_path_normpath(at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    at.openFileForWriting(p,at.targetFileName,toString)
                    if at.outputFile:
                        &lt;&lt; write the @file node &gt;&gt;
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles &gt; 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.</t>
<t tx="ekr.20050712070251.391">if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True</t>
<t tx="ekr.20050712070251.392">@

All writing eventually goes through the asisWrite or writeOpenFile methods, so
plugins should need only to override these two methods.

In particular, plugins should not need to override the write, writeAll or
writeMissing methods.</t>
<t tx="ekr.20050712070251.393">def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            &lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
            &lt;&lt; Write p's body &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
silentWrite = asisWrite # Compatibility with old scripts.</t>
<t tx="ekr.20050712070251.394">s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) &gt; 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)</t>
<t tx="ekr.20050712070251.395">s = p.bodyString()

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)</t>
<t tx="ekr.20050712070251.396"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""
    
    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()</t>
<t tx="ekr.20050712070251.397"></t>
<t tx="ekr.20050712070251.398"># oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20050712070251.399"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="ekr.20050712070251.400">if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.</t>
<t tx="ekr.20050712070251.401"></t>
<t tx="ekr.20050712070251.402"></t>
<t tx="ekr.20050712070251.403">def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta</t>
<t tx="ekr.20050712070251.404">def putAtAllBody(self,p):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20050712070251.405"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="ekr.20050712070251.406">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)</t>
<t tx="ekr.20050712070251.407"></t>
<t tx="ekr.20050712070251.408">def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True</t>
<t tx="ekr.20050712070251.409">def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p)</t>
<t tx="ekr.20050712070251.410">def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta</t>
<t tx="ekr.20050712070251.411">def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)</t>
<t tx="ekr.20050712070251.412"></t>
<t tx="ekr.20050712070251.413">def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
</t>
<t tx="ekr.20050712070251.414">def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta</t>
<t tx="ekr.20050712070251.415">def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta</t>
<t tx="ekr.20050712070251.416">def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta</t>
<t tx="ekr.20050712070251.417"></t>
<t tx="ekr.20050712070251.418">def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()</t>
<t tx="ekr.20050712070251.419">def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)</t>
<t tx="ekr.20050712070251.420">def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20050712070251.421">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)</t>
<t tx="ekr.20050712070251.422">def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)</t>
<t tx="ekr.20050712070251.423">def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()</t>
<t tx="ekr.20050712070251.424"></t>
<t tx="ekr.20050712070251.425">def nodeSentinelText(self,p):
    
    """Return the text of a @+node or @-node sentinel for p."""
    
    at = self ; h = p.headString()
    &lt;&lt; remove comment delims from h if necessary &gt;&gt;
    
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h</t>
<t tx="ekr.20050712070251.426">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) &gt; 0:
    h = h.replace(start,"")
    h = h.replace(end,"")</t>
<t tx="ekr.20050712070251.427">def putLeadInSentinel (self,s,i,j,delta):
    
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    
    Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.</t>
<t tx="ekr.20050712070251.428">def putCloseNodeSentinel(self,p,middle=False):
    
    at = self
    
    s = self.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)</t>
<t tx="ekr.20050712070251.429">def putOpenLeoSentinel(self,s):
    
    """Write @+leo sentinel."""

    at = self
    
    if not at.sentinels:
        return # Handle @nosentinelsfile.
        
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    
    at.putSentinel(s)</t>
<t tx="ekr.20050712070251.430">def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.</t>
<t tx="ekr.20050712070251.431"># This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."
    
    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    &lt;&lt; apply the cweb hack to s &gt;&gt;
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()</t>
<t tx="ekr.20050712070251.432">@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]</t>
<t tx="ekr.20050712070251.433"></t>
<t tx="ekr.20050712070251.434">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective</t>
<t tx="ekr.20050712070251.435">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))</t>
<t tx="ekr.20050712070251.436">def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    return -1 &lt; n1 &lt; n2, n1, n2</t>
<t tx="ekr.20050712070251.437"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"&lt;&lt;"):
        return False, -1
    i = g.find_on_line(s,i,"&gt;&gt;")
    if i:
        return True, i + 2
    else:
        return False, -1</t>
<t tx="ekr.20050712070251.438"># Note:  self.outputFile may be either a fileLikeObject or a real file.

</t>
<t tx="ekr.20050712070251.439">def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))</t>
<t tx="ekr.20050712070251.440">def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()</t>
<t tx="ekr.20050712070251.441">def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    at = self
    
    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except:
            at.exception("exception writing:" + s)</t>
<t tx="ekr.20050712070251.442"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    self.os(s.replace('\n',self.output_newline))</t>
<t tx="ekr.20050712070251.443">def putAtFirstLines (self,s):
    
    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''

    at = self ; tag = "@first"

    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)</t>
<t tx="ekr.20050712070251.444">def putAtLastLines (self,s):
    
    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''

    at = self ; tag = "@last"
    
    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines) ; j = k = n - 1
    
    # Scan backwards for @last directives.
    while j &gt;= 0:
        line = lines[j]
        if g.match(line,0,tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break
        
    # Write the @last lines.
    for line in lines[j+1:k+1]:
        if g.match(line,0,tag):
            i = len(tag) ; i = g.skip_ws(line,i)
            at.os(line[i:])</t>
<t tx="ekr.20050712070251.445">@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first &amp; @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        &lt;&lt; handle @delims &gt;&gt;
    elif g.match_word(s,k,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,k,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i</t>
<t tx="ekr.20050712070251.446"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")</t>
<t tx="ekr.20050712070251.447">self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")</t>
<t tx="ekr.20050712070251.448">self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")</t>
<t tx="ekr.20050712070251.449">def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w &gt; 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)</t>
<t tx="ekr.20050712070251.450">def putInitialComment (self):
    
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)&gt; 0:
                self.putSentinel("@comment " + line)</t>
<t tx="ekr.20050712070251.451">def warnAboutOrphandAndIgnoredNodes (self):
    
    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.hasParent(): ## and p.isCloned():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())
                
    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()</t>
<t tx="ekr.20050712070251.452">def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20050712070251.453">def writeException (self,root=None):
    
    g.es("exception writing:" + self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None
    
    if self.outputFileName != None:
        try: # Just delete the temp file.
            os.remove(self.outputFileName)
        except:
            g.es("exception deleting:" + self.outputFileName,color="red")
            g.es_exception()

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()</t>
<t tx="ekr.20050712070251.454"></t>
<t tx="ekr.20050712070251.455">@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.</t>
<t tx="ekr.20050712070251.456">def chmod (self,fileName,mode):
    
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)</t>
<t tx="ekr.20050712070251.457">&lt;&lt; about os.rename &gt;&gt;

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.
    
    Change the mode of the renamed file if mode is given.
    
    Return True if all went well.'''

    head,tail=g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False</t>
<t tx="ekr.20050712070251.458">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.</t>
<t tx="ekr.20050712070251.459">def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'

    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')
    
    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)
    
    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)</t>
<t tx="ekr.20050712070251.460">def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False</t>
<t tx="ekr.20050712070251.461">def test_atFile_remove(self):
    
    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not at.remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert at.remove(path)
    assert not exists(path)</t>
<t tx="ekr.20050712070251.462">def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)</t>
<t tx="ekr.20050712070251.463">def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
</t>
<t tx="ekr.20050712070251.464">def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,'ascii')
            
def test_atFile_printError(self):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: (U+1FB9: Greek Capital Letter Alpha With Macron)")</t>
<t tx="ekr.20050712070251.465">def exception (self,message):
    
    self.error(message)
    g.es_exception()</t>
<t tx="ekr.20050712070251.466">def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""</t>
<t tx="ekr.20050712070251.467"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)</t>
<t tx="ekr.20050712070251.468"># We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path and len(path) &gt; 0:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")

</t>
<t tx="ekr.20050712070251.469">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()</t>
<t tx="ekr.20050712070251.470"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)</t>
<t tx="ekr.20050712070251.471"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
</t>
<t tx="ekr.20050712070251.472">def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex</t>
<t tx="ekr.20050712070251.473"># Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "&lt;no sentinel&gt;",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@&lt;&lt;",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"&lt;unknown sentinel!&gt;")</t>
<t tx="ekr.20050712070251.474"></t>
<t tx="ekr.20050712070251.475">@killcolor

This method should do noting if at.toString is True.</t>
<t tx="ekr.20050712070251.476"></t>
<t tx="ekr.20050712070251.477">def putVnode (self,p):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    # Must check all parents.
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("&lt;v")
    &lt;&lt; Put tnode index &gt;&gt;
    &lt;&lt; Put attribute bits &gt;&gt;
    &lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;
    fc.put("&gt;")
    &lt;&lt; Write the head text &gt;&gt;
    
    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="ekr.20050712070251.478">if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")</t>
<t tx="ekr.20050712070251.479">attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)</t>
<t tx="ekr.20050712070251.480"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)</t>
<t tx="ekr.20050712070251.481">if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")</t>
<t tx="ekr.20050712070251.482">headString = p.v.headString()

if headString:
    fc.put("&lt;vh&gt;")
    fc.putEscapedString(headString)
    fc.put("&lt;/vh&gt;")</t>
<t tx="ekr.20050712070251.483">Directory "c:\test" does not exist
exception writing:C:\prog\leoCVS\leo\test
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2756, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3020, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3752, in putOpenLeoSentinel
    if not at.sentinels:
AttributeError: atFile instance has no attribute 'sentinels'
saved: test.leo
</t>
<t tx="ekr.20050712070251.484"></t>
<t tx="ekr.20050712070251.485">@killcolor

There is a bug in how Leo writes adjacent @doc parts in @file trees.  This is the first serious bug in the atFile read/write logic reported in several years. As I write this I realize I don't know whether the @thin logic is affected as well.  I suspect it may be.

The bug happens if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo fails to write the closing #@-at sentinel that would finish the first @doc part.  (Another fix would be not to write the second #@+at sentinel.)  As a result of this bug, Leo fails to read the @file node properly and 'reverts' to the version of the code found in the .leo file.</t>
<t tx="ekr.20050712070251.486">@nocolor

c:\python24\lib\pickle.py:202: DeprecationWarning:
    The 'bin' argument to Pickler() is deprecated

@color</t>
<t tx="ekr.20050712070251.487"></t>
<t tx="ekr.20050712070251.488">def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        val = attrDict[key]
        self.putUa(torv,key,val)</t>
<t tx="ekr.20050712070251.489">def getUa(self,nodeType):
    
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    
    __pychecker__ = '--no-argsused' # nodeType not used: good for debugging.
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
        
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return attr,val
        
    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass
        
    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val</t>
<t tx="ekr.20050712070251.490"># The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.</t>
<t tx="ekr.20050712070251.491">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2936140
By: nobody

I have recently stumbled two or three times upon an error,
that causes leo to write  @thin files, that cannont be
untangled (I hope its correct to use this term here) later on.
The resulting Problem is really serious, since opening
the leo file in a new session causes leo immediately to hang.
The only way to recover the leo file I found, was to modify
the appropriate leo sentinels in the broken derived file.

Description:

create a file (must be @thin not @file),
which references a section, that is two levels
below the current level.
f.e.
&lt;&lt; current level&gt;&gt;
  reference to &lt;&lt; 3. level&gt;&gt;
    &lt;&lt; 1.level&gt;&gt;
        &lt;&lt; 2.level &gt;&gt;
            &lt;&lt; 3.level&gt;&gt;

Leo does not complain while saving.

Close leo. Opening leo now causes leo to hang while untangling the above
generated @thin file.

To make the file readable the *middle* sentinels surrounding the reference must
be removed.</t>
<t tx="ekr.20050712070251.492"></t>
<t tx="ekr.20050712070251.493"></t>
<t tx="ekr.20050712070251.494">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2792616
By: e

The recursion was happening in nullLog put &amp; write.

EKR:  The problem is that nullLog.write calls print, and if print is redirected we end up calling nullLog.write again.

sys.stdout.write() doesn't work any better than print
but inside g.app.log.disable/enable doesn't error.

redirect_execute_script_output_to_log_pane = 1
is not good in batch mode!

should that should be always zeroed in batch mode?
set to 0 and both sys.stdout.write and print works.
no recursion.
</t>
<t tx="ekr.20050712070251.495">@killcolor

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.</t>
<t tx="ekr.20050712070251.496">class redirectClass:
    
    """A class to redirect stdout and stderr."""

    &lt;&lt; redirectClass methods &gt;&gt;

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

&lt;&lt; define convenience methods for redirecting streams &gt;&gt;

if 0: # Test code: may be executed in the child node.
    &lt;&lt; test code &gt;&gt;</t>
<t tx="ekr.20050712070251.497">@others</t>
<t tx="ekr.20050712070251.498">def __init__ (self):
    
    self.old = None</t>
<t tx="ekr.20050712070251.499">def isRedirected (self):

    return self.old != None</t>
<t tx="ekr.20050712070251.500"># For LeoN: just for compatibility.

def flush(self, *args):
    return 

</t>
<t tx="ekr.20050712070251.501">def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s</t>
<t tx="ekr.20050712070251.502">def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self</t>
<t tx="ekr.20050712070251.503">def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None</t>
<t tx="ekr.20050712070251.504">def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s</t>
<t tx="ekr.20050712070251.505">@others</t>
<t tx="ekr.20050712070251.506"># Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()</t>
<t tx="ekr.20050712070251.507"># Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()</t>
<t tx="ekr.20050712070251.508">def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()</t>
<t tx="ekr.20050712070251.509"># Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)</t>
<t tx="ekr.20050712070251.510">import leoGlobals as g ; import sys
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
</t>
<t tx="ekr.20050712070251.511">def __init__ (self,frame,parentFrame):
    
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()</t>
<t tx="ekr.20050712070251.512">class nullLog (leoLog):
    
    __pychecker__ = '--no-argsused' # null classes have many unused args.
    
    @others</t>
<t tx="ekr.20050712070251.513">def __init__ (self,frame=None,parentFrame=None):
        
    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)
    self.isNull = True</t>
<t tx="ekr.20050712070251.514">def createControl (self,parentFrame):
    
    return None</t>
<t tx="ekr.20050712070251.515">def oops(self):

    g.trace("nullLog:", g.callerName(2))
    
</t>
<t tx="ekr.20050712070251.516">def put (self,s,color=None):
    if self.enabled:
        # g.trace('nullLog',s)
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")</t>
<t tx="ekr.20050712070251.517">def setFontFromConfig (self):
    pass
    
def setColorFromConfig (self):
    pass</t>
<t tx="ekr.20050712070251.518">class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    __pychecker__ = '--no-argsused' # null classes have many unused args.
    
    @others</t>
<t tx="ekr.20050712070251.519">def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40</t>
<t tx="ekr.20050712070251.520">def deiconify (self):
    pass
    
def lift (self):
    pass
    
def update (self):
    pass</t>
<t tx="ekr.20050712070251.521">def destroySelf (self):
    
    pass</t>
<t tx="ekr.20050712070251.522">def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)</t>
<t tx="ekr.20050712070251.523">def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y</t>
<t tx="ekr.20050712070251.524"></t>
<t tx="ekr.20050712070251.525">def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))</t>
<t tx="ekr.20050712070251.526">def setInitialWindowGeometry (self):
    pass</t>
<t tx="ekr.20050712070251.527">def setTopGeometry (self,w,h,x,y,adjustSize=True):
    
    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y</t>
<t tx="ekr.20050712070251.528"></t>
<t tx="ekr.20050712070251.529">def executeScript(self,p=None,script=None,
    useSelectedText=True,define_g=True,define_name=''):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                &lt;&lt; handle an exception in the script &gt;&gt;
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;

    # Force a redraw _after_ all messages have been output.
    c.redraw() </t>
<t tx="ekr.20050712070251.530">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20050712070251.531">if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="ekr.20050712070251.532">g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "&lt;string&gt;":
    c.goToScriptLineNumber(p,script,n)

&lt;&lt; dump the lines near the error &gt;&gt;
c.frame.tree.redrawAfterException()</t>
<t tx="ekr.20050712070251.533">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1</t>
<t tx="ekr.20050712070251.534">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="ekr.20050712070251.535">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20050712070251.536">@

The old code assumed that the error is always in the script itself.  Not true!  The error could happen in methods called by the script.

This code works with Python 2.3.4: it may be version dependent.</t>
<t tx="ekr.20050712070251.537">@killcolor
https://sourceforge.net/forum/message.php?msg_id=2792394

I've narrowed down when the IndexError happens,
probably any similar error would be the same.

import leoGlobals as g
c = g.top() 
p = c.currentPosition()
cv = c.currentVnode()
cv.moveOutlineRight()  #error

gives this error
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------

and this  additional traceback from 
leoCommands.py", line 1171, in executeScript
    s = "line %d: %s" % (n,lines[n-1])
IndexError: list index out of range

when run this script inside a def wrapper,

import leoGlobals as g
def x():
....c = g.top() 
....p = c.currentPosition()
....cv = c.currentVnode()  #insert sets the current node
....cv.moveOutlineRight()  #error
x()

all you get is
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------
so it appears the frame in the code that determines the 
line number n is off at least one.
in neither case is the line number of the error correct, so no error line
shows.

maybe getLastTracebackLineNumber needs to check for ValueError?
there is still a piece missing, how to tell what frame your in.

in #@+node: getLastTracebackLineNumber leoGlobals.py
data = traceback.extract_tb(tb, 2) seems like a good idea
and seems to fix the IndexError error shown above.
but now with error inside a def you get the function name
instead of the line the error is on. not good enough.

change to:
data = traceback.extract_tb(tb)
item = data[-2] or data[-1] 

this seems to work w/ error code indented 0 from far left, 
or nested inside a def inside another def or another,
I'll leave it in and see if there are additional problems.
the line number still doesn't match with row,col display.
thats confusing if you don't account for the sentinals.
maybe the line number minus a simple count of sentinal lines?

</t>
<t tx="ekr.20050712070251.538">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2792620

not a trivial simple count after all.
if the error is inside a node then would need to 
start count from the previous +node sentinal.
I didn't attempt to fix that,

lets see if the line number is always right first.

item = data[-2] or data[-1]

isn't fixing all cases.

this works better:

item = data[-1]
if not item[-1] is None:
    item = data[-2]
</t>
<t tx="ekr.20050712070251.539">def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.trace(data)
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n</t>
<t tx="ekr.20050712070251.540">def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch &gt; 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch &gt; 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n</t>
<t tx="ekr.20050712070251.541">def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__</t>
<t tx="ekr.20050712070251.542">def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)</t>
<t tx="ekr.20050712070251.543"></t>
<t tx="ekr.20050712070251.544"></t>
<t tx="ekr.20050712070251.545">@killcolor

When I start leo from the command line (linux) with e.g.

[davides@icarus utilities]$ leodev test.leo

(leodev is an alias to the latest cvs version)

and "test.leo" does not exist, the Log pane says

File not found: /localstore/computer/davides/SW/test/utilities/test.leo

but then I would expect that the current file name were set to "test.leo", so that when I do a save, "test.leo" gets saved. It is set to "untitled" instead, so that in essence in this case Leo ignores my command line argument. I would also change the log message to say something like "New file" or similar. Cf. what happens when you do e.g. "vi newfile.txt" (or "emacs", or even "edit" in ms-dos).

Davide </t>
<t tx="ekr.20050712070251.546">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # 5/13/05
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20050712070251.547">@nocolor

The code now clears previous shortcut, and tells what the previous entry was.

What I did:
    - Added init keyword param to createMenuEntries.
    - All calls to createMenuEntries from createMenusFromTables set init = True.
    - Changed &lt;&lt; handle bind_shorcut &gt;&gt; in createMenuEntries:
        - Changed menuShortcuts to a dict containing g.Bunch items.
    - Added clearAccel methods to leoMenu and leoTkinterMenu classes.

@color</t>
<t tx="ekr.20050712070251.548"></t>
<t tx="ekr.20050712070251.549">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2943715
By: nobody

Traceback (most recent call last):
  File "/usr/local/src/leoCVS42/src/leo.py", line 418, in ?
    run()
  File "/usr/local/src/leoCVS42/src/leo.py", line 139, in run
    c,frame = createFrame(fileName)
  File "/usr/local/src/leoCVS42/src/leo.py", line 315, in createFrame
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
  File "/usr/local/src/leoCVS42/src/leoGui.py", line 126, in
newLeoCommanderAndFrame
    c = leoCommands.Commands(frame,fileName)
  File "/usr/local/src/leoCVS42/src/leoCommands.py", line 59, in __init__
    c.importCommands = leoImport.leoImportCommands(c)
  File "/usr/local/src/leoCVS42/src/leoImport.py", line 34, in __init__
    self.output_newline = g.getOutputNewline()
  File "/usr/local/src/leoCVS42/src/leoGlobals.py", line 275,
in getOutputNewline
    s = s.lower()
AttributeError: 'NoneType' object has no attribute 'lower'</t>
<t tx="ekr.20050712070251.550">def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s</t>
<t tx="ekr.20050712070251.551">@nocolor

- It works for me in 4.3.

- fixed crasher:  shortcut entry was not in dispatchDict.

http://sourceforge.net/forum/message.php?msg_id=2944234
By: nobody

I am unable to remap the CTRL+Q keyboard shortcut. It seems to be hardwired
to File &gt; Exit. My attempts to override it have failed.</t>
<t tx="ekr.20050712070251.552"></t>
<t tx="ekr.20050712070251.553">@killcolor

My attention was brought to this code because pychecker rigthly complained about global vars.

- replaced global way with scrollWay ivar.  This keeps pychecker happy.

- Replaced lambda's with trivial functions.
    - The old code was absurdly and needlessly confusing.

- Disabled code in scrollUpOrDown that returned if find_overlapping was True.
    - The scrolling code works much better without it.</t>
<t tx="ekr.20050712070251.554"></t>
<t tx="ekr.20050712070251.555">@

Replace the try/except code with

    if multiple and g.CheckVersion(sys.version,"2.3") and g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4"):</t>
<t tx="ekr.20050712070251.556"></t>
<t tx="ekr.20050712070251.557">This implies:
    
- Deprecating old-style file formats.
- Removing commands that write old-style formats.</t>
<t tx="ekr.20050712070251.558">def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old</t>
<t tx="ekr.20050712070251.559">def writeNewDerivedFiles (self):
    
    c = self
    autoSave = c.atFileCommands.writeNewDerivedFiles()
    if autoSave:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to preserve tnodeList.
    
def writeOldDerivedFiles (self):
    
    c = self
    c.atFileCommands.writeOldDerivedFiles()
    g.es("auto-saving outline",color="blue")
    c.save() # Must be done to clear tnodeList.</t>
<t tx="ekr.20050712070251.560"></t>
<t tx="ekr.20050712070251.561">@killcolor

- Made sense of initialization:
    - ctor inits only permanent ivars.
    - All initing for reads and writes happens explicitly.
    - Separate initiing for reads and writes.
    - All non-permanent ivars deleted before all reads and writes (when testing).

- Move all constants into class.  No more module-level constants.

- All code is now in a single class.
    - This is _so_ much clearer than before.
    - There were only a few name conflicts:  resolved by renaming x to x3 or x4.

- Use methods rather than sections where possible.

- Removed unused oneNodeOnly args, except for putBody method.

- Tested reading 3.x files.  This passes simple tests.  I doubt if anyone actually using these old files....

- Added fromString arg to g.fileLikeObject ctor.

- Not much new is needed to support read/write from string.
    - Official methods that plugins can override:
        read, asisWrite, writeOpenFile</t>
<t tx="ekr.20050712070251.562"></t>
<t tx="ekr.20050712070251.563">@killcolor

- (to do) doc parts are reformatted improperly.

    - This is going to be even trickier when Python allows '@' characters.
    - The present code make no attempt to discover @doc parts;
      it simply preserves whitespace after @ signs!

- (fixed) doc strings were messed up.

    - The bug was improperly use a as a synonym for self.array.</t>
<t tx="ekr.20050712070251.564">@ 

Save As &amp; Save To are broken with new .leo files

c.mFileName was '.'  That should never happen.

I recently added code that set

c.mFileName = g.os_path_norm(fileName) in the ctor, but this converts an empty name to '.' (!!)

I removed g.os_path_norm and g.os_path_normabs.  These caused more problems than they solved.
</t>
<t tx="ekr.20050712070251.565">exception creating backup file: ..bak
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoFileCommands.py", line 2015, in write_Leo_file
    g.utils_rename(fileName,backupName)
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1604, in utils_rename
    os.rename(src,dst)
OSError: [Errno 13] Permission denied

--------------

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 154, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 626, in saveTo
    defaultextension=".leo")
  File "C:\prog\leoCVS\leo\src\leoTkinterGui.py", line 228, in runSaveFileDialog
    filetypes=filetypes)
  File "c:\python23\lib\lib-tk\tkFileDialog.py", line 131, in asksaveasfilename
    return SaveAs(**options).show()
  File "c:\python23\lib\lib-tk\tkCommonDialog.py", line 52, in show
    s = w.tk.call(self.command, *w._options(self.options))
TclError: invalid filename "."
</t>
<t tx="ekr.20050712070251.566">@killcolor

The following are all Python global functions:

(done) cmp -&gt; compare
(done) dict -&gt; theDict
(done) dir -&gt; theDir
(done) file -&gt; theFile
(done) id -&gt; theId
(done) type -&gt; theType
(done) input  (suppressed the warning)
(done) iter -&gt; theIter</t>
<t tx="ekr.20050712070251.567">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20050712070251.568">(fixed) c:\prog\leoCVS\leo\src\leoApp.py:209: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:224: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:368: (dir) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:401: (dir) shadows builtin</t>
<t tx="ekr.20050712070251.569">(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:40: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:53: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:67: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:72: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:74: (file) shadows builtin</t>
<t tx="ekr.20050712070251.570">(fixed) C:\prog\leoCVS\leo\src\leoColor.py:1948: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:2059: (dict) shadows builtin</t>
<t tx="ekr.20050712070251.571">(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:578: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1372: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1394: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1411: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1412: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1419: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1443: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1446: (id) shadows builtin</t>
<t tx="ekr.20050712070251.572">(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:44: (cmp) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:397: (cmp) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:468: (dir) shadows builtin</t>
<t tx="ekr.20050712070251.573">(fixed) c:\prog\leoCVS\leo\src\leoFind.py:864: (type) shadows builtin</t>
<t tx="ekr.20050712070251.574">(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:656: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:700: (dict) shadows builtin</t>
<t tx="ekr.20050712070251.575">(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:949: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:162: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:167: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:586: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:639: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:783: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:844: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:911: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1390: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1588: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1590: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:883: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:893: (file) shadows builtin</t>
<t tx="ekr.20050712070251.576">(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:807: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:566: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1233: (file) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:522: (type) shadows builtin
</t>
<t tx="ekr.20050712070251.577">(fixed) c:\prog\leoCVS\leo\src\leoTkinterPrefs.py:295: (dir) shadows builtin</t>
<t tx="ekr.20050712070251.578">(fixed) c:\prog\leoCVS\leo\src\leoTkinterGui.py:78: (file) shadows builtin</t>
<t tx="ekr.20050712070251.579">(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:336: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:490: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2157: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:473: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:549: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:551: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2142: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2278: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2280: (dir) shadows builtin
</t>
<t tx="ekr.20050712070251.580">(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:90: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:866: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1191: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1318: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1756: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:990: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2018: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1228: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1269: (dir) shadows builtin</t>
<t tx="ekr.20050712070251.581">(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2792: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:52: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:273: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2348: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2371: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2398: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2426: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2476: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:473: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1626: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1648: (id) shadows builtin
(fixed) :\prog\leoCVS\leo\src\leoImport.py:1650: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2303: (type) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2727: (type) shadows builtin

</t>
<t tx="ekr.20050712070251.582">(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:718: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:911: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:924: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3563: (dict) shadows builtin

c:\prog\leoCVS\leo\src\leoTangle.py:540: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:541: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:666: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3656: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3667: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3780: (dir) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:2038: (type) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3865: (type) shadows builtin</t>
<t tx="ekr.20050712070251.583">(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:324: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:340: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:346: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:468: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:480: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1677: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1721: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1770: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1800: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:2280: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:465: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:495: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:734: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1238: (file) shadows builtin</t>
<t tx="ekr.20050712070251.584"></t>
<t tx="ekr.20050712070251.585">@killcolor

Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.</t>
<t tx="ekr.20050712070251.586"></t>
<t tx="ekr.20050712070251.587"># This is part of the tangle code.

def update_file_if_changed(file_name,temp_name):

    """Compares two files.
    
    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(temp_name,file_name)
        
    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")</t>
<t tx="ekr.20050712070251.588">def utils_remove (fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            g.es("exception removing:" + fileName)
            g.es_exception()
        return False</t>
<t tx="ekr.20050712070251.589">def test_g_utils_remove():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
</t>
<t tx="ekr.20050712070251.590">&lt;&lt; about os.rename &gt;&gt;

def utils_rename(src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''
    
    head,tail=g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
        
    try:
        if 1: # Use rename in all cases.
            os.rename(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True
        else:
            # This isn't a great solution: distutils.file_util may not exist.
            if sys.platform=="win32":
                os.rename(src,dst)
            else:
                from distutils.file_util import move_file
                move_file(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True

    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False</t>
<t tx="ekr.20050712070251.591">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.</t>
<t tx="ekr.20050712070251.592">def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)</t>
<t tx="ekr.20050712070251.593">def utils_chmod (fileName,mode,verbose=True):
    
    if mode is None:
        return

    try:
        os.chmod(fileName,mode)
    except:
        if verbose:
            g.es("exception in os.chmod(%s)" % (fileName))
            g.es_exception()</t>
<t tx="ekr.20050712070251.594">def utils_stat (fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    try:
        mode = (os.stat(fileName))[0] &amp; 0777
    except:
        mode = None
        
    return mode</t>
<t tx="ekr.20050712070251.595">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete backup file &gt;&gt;
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20050712070251.596">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20050712070251.597"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20050712070251.598"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20050712070251.599">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20050712070251.600">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050712070251.601">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050712070251.602">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20050712070251.603"></t>
<t tx="ekr.20050712070251.604">@killcolor

C:\prog\leoCVS\leo\src\leoConfig.py:691: No global (encodingName) found

changed encodingName to ivar.</t>
<t tx="ekr.20050712070251.605">@killcolor

(wrong warning)
    C:\prog\leoCVS\leo\src\leoCommands.py:33: Imported module (token) not used

(not a real problem: cant be suppressed)
    C:\prog\leoCVS\leo\src\leo.py:210: No module attribute (leo_config_directory) found

C:\prog\leoCVS\leo\src\leoTkinterFrame.py:320: No class attribute (yview) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:321: No class attribute (yview) found
</t>
<t tx="ekr.20050712070251.606"># 2004</t>
<t tx="ekr.20050712070251.607">@nocolor

- leo.py:
    - Create nodeIndices early in starup logic.
    - Set g.app.config early in startup logic.
    
- leoCommands.py:
    - Added class configSettings to hold per-commander settings.

- leoFileCommands.py
    - putFindSettings and putPrefs write empty xml elements.
    - getFindPanelSettings and getPrefs ignore whatever settings they see.

@color</t>
<t tx="ekr.20050712070251.608"></t>
<t tx="ekr.20050712070251.609">@killcolor

- Disabled ill-fated Apply Settings command.
- Removed call to config.update from leoFileCommands.write code.
- Write only vestigial &lt;find settings/&gt;
- Write only vestigial &lt;preferences/&gt;
    - Will store prefs in @settings trees.
*** NO changes to the read code.  This ensures compatibility.
- Created computeHomeDir, computeGlobalConfig and startupEncoding in leo.py.
- Set g.app.homeDir and g.app.globalConfigDir in leo.py.
- Generalized g.app.setLeoID()
- Called g.app.setLeoID() _before_ loading plugins.</t>
<t tx="ekr.20050712070251.610">@nocolor

- Create configSettings class in leoCommands.py.

This is needed because the old g.app.ivars won't work with per-file settings.  So now each commander has its own settings.

    - c.config now points to a configSettings instance for each commander.
    - The configSettings class has convenience methods to get and set settings.

- Removed config.update.  One reference still exists.

The code accesses config ivar x via c.config.x

- Removed all section-specific getters from Leo's core and leoPlugins.leo.

- Changed g.app.config to c.config in these plugins: FileActions.py, word_export.py, rst.py, rst2.py

- Remove all references to configExists and configExists itself.

- Removed most references to g.app.config.x:  The main remaining refs are:
    g.app.config.use_plugins</t>
<t tx="ekr.20050712070251.611">getBoolColorsPref = getBool
getBoolComparePref = getBool
getBoolFindPref = getBool
getBoolPref = getBool
getBoolWindowPref = getBool

getIntComparePref = getInt
getIntPref = getInt
getIntWindowPref = getInt

getFloatWindowPref = getFloat

getStringColorsPref = getString
getStringComparePref = getString
getStringFindPref = getString
getStringPref = getString
getStringWindowPref = getString

# Generic prefs are strings too.
getColorsPref = getString
getComparePref = getString
getFindPref = getString
getPref = getString
getWindowPref = getString</t>
<t tx="ekr.20050712070251.612"></t>
<t tx="ekr.20050712070251.613"></t>
<t tx="ekr.20050712070251.614">Not sure this did anything.  However, using g.app.gui in the code should be replaced by c.frame.gui.</t>
<t tx="ekr.20050712070251.615">This allows g.app.destroyWindow to work on nullFrame's.</t>
<t tx="ekr.20050712070251.616">use_psyco can no longer be a config param:  it is used too early in the load process.</t>
<t tx="ekr.20050712070251.617">This is needed because loading .leo files requires g.app.leoID.

To make this work, I had to create an emergency "startup" gui in setLeoID. This in turn creates g.app.root, so I also changed
createNullGuiWithScript so it only creates the Tk root if it doesn't already exist.

Clearly, using g.app.gui is wrong.</t>
<t tx="ekr.20050712070251.618"></t>
<t tx="ekr.20050712070251.619"></t>
<t tx="ekr.20050712070251.620">@killcolor

- Implemented @if-gui
- Implemented @ratio.
- Fixed bug:  getBool was returning True for both True and False ;-)

- Removed g.app.globalWindows.
- Removed destroyAllGlobalWindows()
- Destroy find panel in frame.destroySelf.</t>
<t tx="ekr.20050712070251.621">@killcolor

canonicalizeSettingsName (munge) delete whitespace, underscores and '-' in settings names.

dictionary keys are munged names.</t>
<t tx="ekr.20050712070251.622"></t>
<t tx="ekr.20050712070251.623"></t>
<t tx="ekr.20050712070251.624">def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)</t>
<t tx="ekr.20050712070251.625">def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','&lt;no hash: %s&gt;' % c.hash())
        g.trace(dkind,setting,kind,val)</t>
<t tx="ekr.20050712070251.626">def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None</t>
<t tx="ekr.20050712070251.627">def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found</t>
<t tx="ekr.20050712070251.628">def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="&lt;unknown&gt;"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""
    
    __pychecker__ = '--no-argsused' # tag used for debugging.

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)</t>
<t tx="ekr.20050712070251.629"></t>
<t tx="ekr.20050712070251.630"></t>
<t tx="ekr.20050712070251.631">def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result</t>
<t tx="ekr.20050712070251.632">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20050712070251.633">def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False</t>
<t tx="ekr.20050712070251.634"></t>
<t tx="ekr.20050712070251.635">@killcolor

- Added updateRecentFiles keyword option to newLeoCommanderAndFrame.
    Default is True, but set to false when opening leoSettings.leo files on startup.
    Note: this will be False, then True when opening leoSettings.leo explicitly.

- Removed g.app.config.setRecentFiles.
    All work done in c.config.setRecentFiles.
    moved recentFiles ivar to configParser class.

- Moved call to c.config.setRecentFiles from c.updateRecentFiles to g.openWithFileName.

- settingsRoot, canonicalizeSettingName and findSettingsPosition now defined only in config class.
    These are always accessed via g.app.config.
    These seems better than defining functions in leoGlobals.py</t>
<t tx="ekr.20050712070251.636">def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20050712070251.637">def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20050712070251.638">def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
    
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame</t>
<t tx="ekr.20050712070251.639"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

</t>
<t tx="ekr.20050712070251.640">class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others</t>
<t tx="ekr.20050712070251.641">def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)</t>
<t tx="ekr.20050712070251.642">def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)</t>
<t tx="ekr.20050712070251.643">def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))</t>
<t tx="ekr.20050712070251.644">def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)</t>
<t tx="ekr.20050712070251.645"></t>
<t tx="ekr.20050712070251.646">def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)</t>
<t tx="ekr.20050712070251.647">def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set</t>
<t tx="ekr.20050712070251.648">@nocolor
Problem 1: a simple blunder in settingsParser.set.

Problem 2: use_plugin didn't get changed until after plugins get loaded.

Solution:  Read .leo files specified on the command line twice:
    
- Once before loading plugins, _without_ loading @file nodes.
- Once after (normal load)

What I did:

- Created completeFileName (does not depend on config).
- Added local file to list of files to be scanned in readSettingsFiles.
- Don't don't scan for settings in local file in createFrame.
    - Added readAtFileNodesFlag keyword arg to openWithFileName.
@color</t>
<t tx="ekr.20050712070251.649"></t>
<t tx="ekr.20050712070251.650">def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c</t>
<t tx="ekr.20050712070251.651">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20050712070251.652"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d</t>
<t tx="ekr.20050712070251.653">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()</t>
<t tx="ekr.20050712070251.654"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)</t>
<t tx="ekr.20050712070251.655">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()</t>
<t tx="ekr.20050712070251.656">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="ekr.20050712070251.657">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20050712070251.658">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName</t>
<t tx="ekr.20050712070251.659">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20050712070251.660">def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script</t>
<t tx="ekr.20050712070251.661">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")</t>
<t tx="ekr.20050712070251.662">def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    &lt;&lt; Set the default directory &gt;&gt;
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # Delete the file buffer
    self.fileBuffer = ""
    return ok</t>
<t tx="ekr.20050712070251.663">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) &gt; 0:
    c.openDirectory = theDir</t>
<t tx="ekr.20050712070251.664"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    &lt;&lt; warn on read-only files &gt;&gt;
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        &lt;&lt; scan all the xml elements &gt;&gt;
    except BadLeoFile, message:
        if not silent:
            &lt;&lt; raise an alert &gt;&gt;
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)

    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
        
    # g.trace(c.currentPosition())
    
    # New in 4.3.1: do this after reading derived files.
    if not self.usingClipboard:
        &lt;&lt; set current and top positions &gt;&gt;

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    &lt;&lt; restore attributes in descendent tnodes &gt;&gt;
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio</t>
<t tx="ekr.20050712070251.665"># os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")</t>
<t tx="ekr.20050712070251.666">self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("&lt;leo_file&gt;") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="ekr.20050712070251.667"># All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))</t>
<t tx="ekr.20050712070251.668">for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()</t>
<t tx="ekr.20050712070251.669">current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    # g.trace('using convertStackToPosition',current)
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
if 0:
    top = self.convertStackToPosition(self.topVnodeStack)
    if top:
        c.setTopPosition(top)</t>
<t tx="ekr.20050712070251.670"># The window titel problem was in completeFileName.

# The munging needs was done in doType and settingsParser.set.</t>
<t tx="ekr.20050712070251.671"></t>
<t tx="ekr.20050712070251.672">def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        &lt;&lt; fix problems with menus (XP) &gt;&gt;
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root</t>
<t tx="ekr.20050712070251.673">def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()</t>
<t tx="ekr.20050712070251.674">def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily</t>
<t tx="ekr.20050712070251.675">try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")</t>
<t tx="ekr.20050712070251.676">@

- The Pmw source files contain mixed tabs/spaces, which caused most of the problems.
    - A _single_ blank was spanning two indentations.
    - That is always going to be hard for Leo unless heroic measures are taken.

- Created self.tab_width ivar (set by getTabWidth) so import directives honor @tabwidth directives.</t>
<t tx="ekr.20050712070251.677">def __init__ (self,c):

    self.c = c
    
    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline(c=c)
    
    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"</t>
<t tx="ekr.20050712070251.678"></t>
<t tx="ekr.20050712070251.679">def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace("self.tab_width",self.tab_width)
    # g.trace(g.get_line(s,i))
    classIndent = self.getLeadingIndent(s,i)
    &lt;&lt; set classname and headline, or return i &gt;&gt;
    i = g.skip_line(s,i) # Skip the class line.
    &lt;&lt; create class_vnode &gt;&gt;
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=True)
    &lt;&lt; create nodes for all defs of the class &gt;&gt;
    &lt;&lt; append any other class material &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20050712070251.680"># Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    classname = s[j:i]
    headline = "class " + classname
else:
    return i</t>
<t tx="ekr.20050712070251.681"># Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# i points just after the class line.

# Add a docstring to the class node.
docStringSeen = False
j = g.skip_ws_and_nl(s,i)
if g.match(s,j,'"""') or g.match(s,j,"'''"):
    j = g.skip_python_string(s,j)
    if j != len(s): # No scanning error.
        i = j ; docStringSeen = True

body = s[start:i]
body = self.undentBody(body)
if docStringSeen: body = body + '\n'
class_vnode = self.createHeadline(parent,prefix + body,headline)</t>
<t tx="ekr.20050712070251.682">indent =  self.getLeadingIndent(s,i)
start = i = g.skip_blank_lines(s,i)
parent_vnode = None
# g.trace(classIndent)
while i &lt; len(s) and indent &gt; classIndent:
    progress = i
    if g.is_nl(s,i):
        backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
        j = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,j)
            if indent &gt; classIndent: i = j
            else: break
        else: i = j
    elif g.match_c_word(s,i,"def"):
        if not parent_vnode:
            &lt;&lt; create parent_vnode &gt;&gt;
        i = start = self.scanPythonDef(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif g.match_c_word(s,i,"class"):
        if not parent_vnode:
            &lt;&lt; create parent_vnode &gt;&gt;
        i = start = self.scanPythonClass(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
    elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress &lt; i)</t>
<t tx="ekr.20050712070251.683"># This must be done after the declaration reference is generated.
if self.treeType == "@file":
    class_vnode.appendStringToBody("\t@others\n")
else:
    ref = g.angleBrackets(" class " + classname + " methods ")
    class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode</t>
<t tx="ekr.20050712070251.684">s2 = s[start:i]
if s2:
    class_vnode.appendStringToBody(s2)</t>
<t tx="ekr.20050712070251.685">def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    &lt;&lt; set headline or return i &gt;&gt;
    &lt;&lt; skip the Python def &gt;&gt;
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    &lt;&lt; Create def node &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20050712070251.686">i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i</t>
<t tx="ekr.20050712070251.687"># Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = g.skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
#g.trace(defIndent,indent)
#g.trace(g.get_line(s,i))
while i &lt; len(s) and indent &gt; defIndent:
    progress = i
    ch = s[i]
    if g.is_nl(s,i):
        backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
        i = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,i)
            if indent &lt;= defIndent:
                break
    elif ch == '#':
        i = g.skip_to_end_of_line(s,i) # 7/29/02
    elif ch == '"' or ch == '\'':
        i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress &lt; i)</t>
<t tx="ekr.20050712070251.688"># Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20050712070251.689">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    done = False ; start = i
    while not done and i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent &lt;= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; break on def or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j &lt; i:
        &lt;&lt; Create a child node for declarations &gt;&gt;
    return i</t>
<t tx="ekr.20050712070251.690">if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)</t>
<t tx="ekr.20050712070251.691">headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)</t>
<t tx="ekr.20050712070251.692"># See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; handle possible Python function or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    if not decls_seen: # 2/17/03
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
    &lt;&lt; Append a reference to the methods of this file &gt;&gt;
    &lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="ekr.20050712070251.693">if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file": # 7/29/02
            parent.appendStringToBody("@others\n") # 7/29/02
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)</t>
<t tx="ekr.20050712070251.694">if self.treeType == "@root" and self.methodsSeen:
    parent.appendStringToBody(
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")</t>
<t tx="ekr.20050712070251.695"># Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i &lt; len(s):
    parent.appendStringToBody(s[start:])</t>
<t tx="ekr.20050712070251.696">@

The fix really should be in putDescendentAttributes and putUnknownAttributes.

These methods shouldn't write gnx's that don't exist.</t>
<t tx="ekr.20050712070251.697">def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())

    for theList,tag in ((marks,"marks="),(expanded,"expanded=")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            self.put('\n' + tag)
            self.put_in_dquotes(s)</t>
<t tx="ekr.20050712070251.698"># Added isNullGui ivar to gui classes.</t>
<t tx="ekr.20050712070251.699">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value</t>
<t tx="ekr.20050712070251.700">@

I haven't been able to use the base drawTopTree method.

Don't know just why: some problem with the canvas, probably.
</t>
<t tx="ekr.20050712070251.701">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount,c.rootPosition())

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20050712070251.702">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20050712070251.703">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20050712070251.704">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t</t>
<t tx="ekr.20050712070251.705">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="ekr.20050712070251.706">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20050712070251.707">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20050712070251.708">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050712070251.709">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20050712070251.710">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20050712070251.711">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20050712070251.712">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20050712070251.713">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20050712070251.714">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050712070251.715">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20050712070251.716">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20050712070251.717">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20050712070251.718">class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20050712070251.719">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20050712070251.720">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20050712070251.721">def expandAllAncestors (self,p):
    
    redraw_flag = False
    
    # g.trace(p)

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

</t>
<t tx="ekr.20050712070251.722"></t>
<t tx="ekr.20050712070251.723"></t>
<t tx="ekr.20050712070251.724"></t>
<t tx="ekr.20050712070251.725">def __init__(self,frame,fileName):

    c = self
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    # initialize the sub-commanders
    self.editCommands = leoEditCommands.editCommands(c)
    self.fileCommands = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20050712070251.726">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20050712070251.727">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20050712070251.728">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20050712070251.729">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20050712070251.730"></t>
<t tx="ekr.20050712070251.731">@killcolor

- g.openWithFileName now calls:
    frame.c.config.setRecentFiles(g.app.config.recentFiles)

That is, all new files get the global file list.

- Created config.appendToRecentFiles.

- c.ConfigParser.setRecentFiles calls config.appendToRecentFiles.

That is, we never remove files from the recent files list, we only add files.

- Added &lt;&lt; update recent files from d &gt;&gt; to config.readSettingsFiles.

This calls config.appendToRecentFiles(files) to actually set the files.</t>
<t tx="ekr.20050712070251.732">@killcolor

Leo writes the recent files node correctly, but does not init them correctly.</t>
<t tx="ekr.20050712070251.733">def findSettingsPosition (self,c,setting):
    
    """Return the position for the setting in the @settings tree for c."""
    
    munge = self.munge
    
    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()
        
    setting = munge(setting)
        
    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()
    
    return c.nullPosition()</t>
<t tx="ekr.20050712070251.734">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)</t>
<t tx="ekr.20050712070251.735"></t>
<t tx="ekr.20050712070251.736">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2866490

I've noticed that even if the mod_speling.ini is changed, the language is alway
set as en_US !

to Correct this and being able to launch the correct language, i've changed
he following code :

''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir)

by :
''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir, lang=local_language_code)

..................
This seem to work on my install !

BUT
the hardcodding of the aspell_dir in the plugin code is UGLY !!!

It should also be fine to add a directive or a menu under the plugins_menu"
to change the language and reinitialise the spell_checker for spelling multilingual
documents.....
</t>
<t tx="ekr.20050712070251.737"></t>
<t tx="ekr.20050712070251.738">@

What ivars get changed--local (c) or global(g.app.config) ??

Presently, only g.app.config.page_width and g.app.config.tab_width get changed.</t>
<t tx="ekr.20050712070251.739">@ignore</t>
<t tx="ekr.20050712070251.740">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }</t>
<t tx="ekr.20050712070251.741"># Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False

# TO BE REMOVED:
self.write_old_format_derived_files = False # Use new format if leoConfig.txt does not exist.</t>
<t tx="ekr.20050712070251.742"># Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.</t>
<t tx="ekr.20050712070251.743"># Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)</t>
<t tx="ekr.20050712070251.744"></t>
<t tx="ekr.20050712070251.745">def parseFont (self,p):
    
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)
        
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
        
    return d</t>
<t tx="ekr.20050712070251.746">def parseFontLine (self,line,d):
    
    s = line.strip()
    if not s: return
    
    try:
        s = str(s)
    except UnicodeError:
        pass
    
    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip() ; val = s[i+1:].strip()

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.</t>
<t tx="ekr.20050712070251.747">def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)</t>
<t tx="ekr.20050712070251.748">@ It is essential to retain a link to a font.  Otherwise changes to one font may affect other fonts.

This appears to be a bug in Tk or Tkinter.</t>
<t tx="ekr.20050712070251.749">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize, tag = "log")

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20050712070251.750">def setFontFromConfig (self):

    c = self.c ; body = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "body")
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    body.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))</t>
<t tx="ekr.20050712070251.751">def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):
    
    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")
    
    self.setFont(font)</t>
<t tx="ekr.20050712070251.752">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20050712070251.753">def setFontFromConfig (self):
    
    c = self.c
    
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold")
    
    if self.bold_font:
        self.bold_font.configure(weight="bold")
    
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer italic")
        
    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")
    
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold italic")
        
    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")
        
    self.color_tags_list = []
    self.image_references = []</t>
<t tx="ekr.20050712070251.754">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    
    d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        t = Tk.Text(canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
            t.bind("&lt;Control-t&gt;",self.onControlT)

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # Bug fix 7/31/04:  We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString(),tag="newText")
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # New in 4.2 b3: entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList

    # g.trace(p,t)
    return t</t>
<t tx="ekr.20050712070251.755">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
    t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
    t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("&lt;Button-4&gt;", PropagateButton4)
    t.bind("&lt;Button-5&gt;", PropagateButton5)
    t.bind("&lt;MouseWheel&gt;", PropagateMouseWheel)

</t>
<t tx="ekr.20050712070251.756"></t>
<t tx="ekr.20050712070251.757"></t>
<t tx="ekr.20050712070251.758">def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()</t>
<t tx="ekr.20050712070251.759">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20050712070251.760">def setColorFromConfig (self):
    
    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        self.canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()</t>
<t tx="ekr.20050712070251.761"></t>
<t tx="ekr.20050712070251.762"></t>
<t tx="ekr.20050712070251.763">@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared &gt; threshold:
        point.isok = True
@c

class Bunch (object):
    
    """A class that represents a colection of things.
    
    Especially useful for representing a collection of related variables."""
    
    def __init__(self,**keywords):
        self.__dict__.update (keywords)
        
    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()
        
    def keys(self):
        return self.__dict__.keys()
        
    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    # Used by new undo code.
    def __setitem__ (self,key,value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__,key,value)
        
    def __getitem__ (self,key):
        '''Support aBunch[key]'''
        return operator.getitem(self.__dict__,key)
        
    def get (self,key,theDefault=None):
        return self.__dict__.get(key,theDefault)
        
bunch = Bunch</t>
<t tx="ekr.20050712070251.764">for key in d.keys():
    
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files from %s..." % fileName
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)</t>
<t tx="ekr.20050712070251.765"></t>
<t tx="ekr.20050712070251.766"></t>
<t tx="ekr.20050712070251.767">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20050712070251.768">def equalSizedPanes(self):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="ekr.20050712070251.769">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20050712070251.770"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050712070251.771"></t>
<t tx="ekr.20050712070251.772">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20050712070251.773">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20050712070251.774">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20050712070251.775">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20050712070251.776"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20050712070251.777"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20050712070251.778">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20050712070251.779">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20050712070251.780">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20050712070251.781">def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    &lt;&lt; create the toplevel and outer frames &gt;&gt;
    &lt;&lt; create the icon bar &gt;&gt;
    &lt;&lt; create the splitters and their subframes &gt;&gt;
    &lt;&lt; create the status line &gt;&gt;
    &lt;&lt; create the first tree node &gt;&gt;
    &lt;&lt; create the menu bar &gt;&gt;
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)</t>
<t tx="ekr.20050712070251.782">frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

if g.os_path_exists(g.app.user_xresources_path):
    frame.top.option_readfile(g.app.user_xresources_path)

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("&lt;Button-1&gt;", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("&lt;Activate&gt;",frame.OnActivateLeoEvent)
frame.top.bind("&lt;Deactivate&gt;",frame.OnDeactivateLeoEvent)

frame.top.bind("&lt;Control-KeyPress&gt;",frame.OnControlKeyDown)
frame.top.bind("&lt;Control-KeyRelease&gt;",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)</t>
<t tx="ekr.20050712070251.783">self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()</t>
<t tx="ekr.20050712070251.784">self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()</t>
<t tx="ekr.20050712070251.785">t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
</t>
<t tx="ekr.20050712070251.786">self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20050712070251.787">self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)</t>
<t tx="ekr.20050712070251.788">def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2</t>
<t tx="ekr.20050712070251.789">@

This did not work: _tkinter.TclError: can't place

.24597368.24598448.24610776.24610936 relative to
.24597368.24598448.24598768.24599008.24608856.24609096</t>
<t tx="ekr.20050712070251.790">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20050712070251.791">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20050712070251.792"></t>
<t tx="ekr.20050712070251.793">class componentBaseClass:

    @others</t>
<t tx="ekr.20050712070251.794">def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    self.c = c
    self.frame = frame    # The Tk.Frame containing the component.
    self.isVisible = False # True if the component is visible.
    self.name = name      # The component's name: the key for c.frame.componentsDict.
    self.obj = obj        # Optional object (typically not a Tk.Frame.)
    self.packer = packer
    self.unpacker = unpacker

    c.frame.componentsDict[name] = self</t>
<t tx="ekr.20050712070251.795">def __repr__ (self):
    
    return '&lt;component %s&gt;' % self.name</t>
<t tx="ekr.20050712070251.796">def oops (self):
    
    print ("componentBaseClass oops:",
        g.callerName(2),
        "must be overridden in subclass")
</t>
<t tx="ekr.20050712070251.797"># Getters...
def getFrame    (self): return self.frame
def getObject   (self): return self.obj
def getPacker   (self): return self.packer
def getUnpacker (self): return self.unpacker
</t>
<t tx="ekr.20050712070251.798">def destroy (self):
    self.oops()</t>
<t tx="ekr.20050712070251.799"># Pack always packs the widget, which can make it visble in two places.
# Show packs a new widget only if it is not visible.

def hide (self):
    if self.isVisible:
        self.isVisible = False
        self.unpack()

def pack (self):
    self.oops()
    
def show (self):
    if not self.isVisible:
        self.isVisible = True
        self.pack()
    
def unpack (self):
    self.oops()
    
</t>
<t tx="ekr.20050712070251.800">class componentClass (leoFrame.componentBaseClass):
    
    '''A class to manage components of Leo windows'''
    
    @others</t>
<t tx="ekr.20050712070251.801">def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    # Init the base class.
    leoFrame.componentBaseClass.__init__(
        self,c,name,frame,obj,packer,unpacker)
    
    self.setPacker(packer)
    self.setUnpacker(unpacker)</t>
<t tx="ekr.20050712070251.802">def __repr__ (self):
    
    return '&lt;component %s&gt;' % self.name</t>
<t tx="ekr.20050712070251.803">def destroy (self):
    
    try:
        del c.frame.componentsDict[self.name]
    except KeyError:
        g.es("No component named %s" % name,color='blue')</t>
<t tx="ekr.20050712070251.804"># Setters...
def setPacker (self,packer):
    if not packer: # Define default packer.
        def packer():
            if self.frame:
                self.frame.pack(side='top',expand=1,fill='both')
    self.packer = packer

def setUnpacker (self,unpacker):
    if not unpacker: # Define default unpacker.
        def unpacker():
            if self.frame:
                self.frame.pack_forget()
    self.unpacker = unpacker</t>
<t tx="ekr.20050712070251.805">def pack (self):

    self.packer()
    
def unpack (self):

    self.unpacker()</t>
<t tx="ekr.20050712070251.806"></t>
<t tx="ekr.20050712070251.807">def placePane1(self,verticalFlag,pane1,frac):
    if verticalFlag:
        pane1.place(relx=0.5,rely=0,anchor="n",relwidth=1.0,relheight=frac)
    else:
        pane1.place(rely=0.5,relx=0,anchor="w",relheight=1.0,relwidth=frac)
        
def placePane2(self,verticalFlag,pane2,frac):
    if verticalFlag:
        pane2.place(relx=0.5,rely=1.0,anchor="s",relwidth=1.0,relheight=1-frac)
    else:
        pane2.place(rely=0.5,relx=1.0,anchor="e",relheight=1.0,relwidth=1-frac)

# These are the packers of the corresponding components.
# These are called from, packComponent('body'), etc.
def packBody (self):
    # Pane 2 of primary splitter.
    self.placePane2(self.splitVerticalFlag,self.split1Pane2,self.ratio)
def packLog (self):
    # Pane 2 of secondary splitter.
    self.placePane2(not self.splitVerticalFlag,self.split2Pane2,self.secondary_ratio)
def packTree (self):
    # Pane 1 of secondary splitter.
    self.placePane1(not self.splitVerticalFlag,self.split2Pane1,self.secondary_ratio)</t>
<t tx="ekr.20050712070251.808"></t>
<t tx="ekr.20050712070251.809">def replaceBodyPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packBody)
            component.setUnpacker(self.unpackBody)
            self.unpackComponent('body')
            self.split1Pane2 = f
            self.packBody()</t>
<t tx="ekr.20050712070251.810">def replaceLogPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packLog)
            component.setUnpacker(self.unpackLog)
            self.unpackComponent('log')
            self.split2Pane2 = f
            self.packLog()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)</t>
<t tx="ekr.20050712070251.811">def replaceTreePaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packTree)
            component.setUnpacker(self.unpackTree)
            self.unpackComponent('tree')
            self.split2Pane1 = f
            self.packTree()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)</t>
<t tx="ekr.20050712070251.812"># These are the packers of the corresponding components.

def unpackBody(self):
    self.split1Pane2.place_forget()
    
def unpackLog(self):
    self.split2Pane2.place_forget()

def unpackTree(self):
    self.split2Pane1.place_forget()</t>
<t tx="ekr.20050712070251.813"># Note: the 'packers' for the 'body', 'log' and 'tree' components are actually placers,
# so packing twice does not duplicate those component.

def packComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.pack()
    elif verbose:
        g.es("packComponent: no component named %s" % name,color='blue')

def unpackComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.unpack()
    elif verbose:
        g.es("unpackComponent: no component named %s" % name,color='blue')</t>
<t tx="ekr.20050712070251.814">def hideComponent (self,name):
    component = self.component(name)
    if component:
        component.hide()
    else:
        g.es("hideComponent: no component named %s" % name,color='blue')

def showComponent (self,name):
    component = self.component(name)
    if component:
        component.show()
    else:
        g.es("showComponent: no component named %s" % name,color='blue')</t>
<t tx="ekr.20050712070251.815">class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others</t>
<t tx="ekr.20050712070251.816">def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("&lt;Button-1&gt;", self.onActivate)</t>
<t tx="ekr.20050712070251.817">def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")</t>
<t tx="ekr.20050712070251.818">def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='statusLine.disable')
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.frame.statusLineWantsFocus(t,tag='statusLine.ensable')
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled</t>
<t tx="ekr.20050712070251.819">def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""</t>
<t tx="ekr.20050712070251.820">def getFrame (self):
    
    return self.statusFrame</t>
<t tx="ekr.20050712070251.821">def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)</t>
<t tx="ekr.20050712070251.822">def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack</t>
<t tx="ekr.20050712070251.823">def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()</t>
<t tx="ekr.20050712070251.824">if 0: # No longer used in 4.3.  Done as the result of statusLineWantsFocus.

    def setFocus (self):
    
        # Force the focus to the icon area.
        t = self.textWidget
        if t:
            t.focus_set()</t>
<t tx="ekr.20050712070251.825">def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack</t>
<t tx="ekr.20050712070251.826">def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col &gt; 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)</t>
<t tx="ekr.20050712070251.827">def getIconBarObject(self):
    component = self.component(self.iconBarComponentName)
    if not component: return g.trace("No iconBar component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.iconBarComponentName))
                
def callIconBar(self,name,*args,**keys):
    obj = self.getIconBarObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.iconBarComponentName,name))

def addIconButton (self,*args,**keys):
    return self.callIconBar('add',*args,**keys)

def clearIconBar (self):
    return self.callIconBar('clear')

def createIconBar (self):
    self.callIconBar('show')
    return self.getIconBarObject() # For compatibility.

def hideIconBar (self):
    return self.callIconBar('hide')</t>
<t tx="ekr.20050712070251.828">def getStatusObject(self):
    component = self.component(self.statusLineComponentName)
    if not component: return g.trace("No statusLine component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.statusLineComponentName))
                
def callStatus(self,name,*args,**keys):
    obj = self.getStatusObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.statusLineComponentName,name))

def createStatusLine (self):
    self.callStatus('show')
    return self.getStatusObject() # For compatibility.

def clearStatusLine (self):
    return self.callStatus('clear')
    
def disableStatusLine (self,background=None):
    return self.callStatus('disable',background)

def enableStatusLine (self,background="white"):
    return self.callStatus('enable',background)

def getStatusLine (self):
    return self.callStatus('get')
    
def putStatusLine (self,s,color=None):
    return self.callStatus('put',s,color)
    
def setFocusStatusLine (self):
    return self.callStatus('setFocus')

def statusLineIsEnabled(self):
    return self.callStatus('isEnabled')</t>
<t tx="ekr.20050712070251.829"></t>
<t tx="ekr.20050712070251.830">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20050712070251.831"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.revertHeadline = None # Previous headline text for abortEditLabel.
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20050712070251.832">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20050712070251.833">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20050712070251.834"></t>
<t tx="ekr.20050712070251.835">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20050712070251.836"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20050712070251.837">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20050712070251.838">def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()</t>
<t tx="ekr.20050712070251.839"></t>
<t tx="ekr.20050712070251.840"></t>
<t tx="ekr.20050712070251.841">@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.</t>
<t tx="ekr.20050712070251.842">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)</t>
<t tx="ekr.20050712070251.843">encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)</t>
<t tx="ekr.20050712070251.844">def setShortcut (self,name,val):
    
    # g.trace(name,val)
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",val)</t>
<t tx="ekr.20050712070251.845">def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20050712070251.846">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)</t>
<t tx="ekr.20050712070251.847">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    rawKey = key.replace('&amp;','') # Allow '&amp;' in names.
    val = self.get(c,rawKey,"shortcut")
    if val is None:
         return rawKey,None
    else:
        # g.trace(key,val)
        return rawKey,val</t>
<t tx="ekr.20050712070251.848"></t>
<t tx="ekr.20050712070251.849">@killcolor

- Created setIvarsFromSettings.
    - Called from end of readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init commmander ivars.

- leoPrefs.py and leoTkinterPrefs are no longer used.</t>
<t tx="ekr.20050712070251.850">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)</t>
<t tx="ekr.20050712070251.851"></t>
<t tx="ekr.20050712070251.852"></t>
<t tx="ekr.20050712070251.853"></t>
<t tx="ekr.20050712070251.854">@killcolor

What I did:

- Placed comment and setter widgets in a ScrolledCanvas widget.

This is _far_ better than using two separate scrollers.

- Put label on same line as icons.

- All parts of the canvas now use a common background color.

It's surprisingly hard to pick a good color. Neither 'white' nor dark colors look good.</t>
<t tx="ekr.20050712070251.855"></t>
<t tx="ekr.20050712070251.856">@killcolor

- Fixed latent bug in setBodyStringOrPane.

This method now updates the body pane if any clone of the current node changes.

This is important, the settings node found by findSettingsPosition may be a clone of the current node!

- clearRecentFiles now calls c.config.setRecentFiles.</t>
<t tx="ekr.20050712070251.857">def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)</t>
<t tx="ekr.20050712070251.858"></t>
<t tx="ekr.20050712070251.859">@killcolor

c.updateRecentFiles now 'munges' all names during the compare, so capitalization difference don't matter:  all files matching the file name get removed.
</t>
<t tx="ekr.20050712070251.860"></t>
<t tx="ekr.20050712070251.861">def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '&lt;none&gt;'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
            elif ikind == 'shortcuts':
                s = 'updating shortcuts in %s' % ip.headString()
            else:
                # Convert unicode strings to strings safe for printing.
                # The calls to str are needed because g.toEncodedString only changes unicode strings.
                strOldVal = str(g.toEncodedString(oldVal,'ascii'))
                strNewVal = str(g.toEncodedString(newVal,'ascii'))
                strIname  = str(g.toEncodedString(iname,'ascii'))
                s = "write  %10s -&gt; %10s %s" % (strOldVal,strNewVal,strIname)
            g.es_print(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")</t>
<t tx="ekr.20050712070251.862">def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)</t>
<t tx="ekr.20050712070251.863">def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Just put the new the values in the body.
                p.setBodyStringOrPane(val)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))</t>
<t tx="ekr.20050712070251.864">def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'&lt;none&gt;'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body</t>
<t tx="ekr.20050712070251.865">def writeChangedList (self,changedList,tag):
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    filesInfoDict = self.filesInfoDict
    if 0:
        &lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -&gt; %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []</t>
<t tx="ekr.20050712070251.866">for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print</t>
<t tx="ekr.20050712070251.867">def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."</t>
<t tx="ekr.20050712070251.868"></t>
<t tx="ekr.20050712070251.869">def doCommand (self,command,label):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()

    # A horrible kludge: set g.app.log to cover for a possibly missing activate event.
    g.app.setLog(c.frame.log,"doCommand")
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label == "cantredo": label = "redo"
    if label == "cantundo": label = "undo"
    g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            command()
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            c.frame.tree.redrawAfterException() # 1/26/04
    
    c = g.top() # 6/17/04: The command can change the commander.
    if c:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20050712070251.870">def onAnyButton(self,name):
    
    c = self.c
    endDialog = name in (None,"OK","Cancel")
    
    # g.trace(name)
    
    dispatchDict = {
        "Apply":    self.writeChangedVars,
        "Cancel":   None, # Do nothing.
        "OK":       self.writeChangedVars,
        "Revert":   self.revert,
    }
    
    f = dispatchDict.get(name)
    if f: f()
        
    if self.replaceBody:
        if endDialog:
            c.frame.replaceTreePaneWithComponent('tree')
            c.frame.replaceBodyPaneWithComponent('body')
            c.disableCommandsMessage = '' # Re-enable all commands.
    else:
        if endDialog:
            self.dialog.destroy()
            c.disableCommandsMessage = '' # Re-enable all commands.
        else:
            self.dialog.withdraw()
            self.dialog.deiconify()</t>
<t tx="ekr.20050712070251.871"></t>
<t tx="ekr.20050712070251.872"></t>
<t tx="ekr.20050712070251.873">menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
enable(menu,"Expand Or Go Right",hasChildren)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)</t>
<t tx="ekr.20050712070251.874">def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
 
    if v.hasChildren() and v.isExpanded():
        c.contractNode()
    elif v.hasParent():
        c.goToParent()</t>
<t tx="ekr.20050712070251.875">def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
    if not v.hasChildren(): return

    if v.isExpanded():
        c.beginUpdate()
        c.selectVnode(v.firstChild())
        c.endUpdate()
    else:
        c.expandNode()</t>
<t tx="ekr.20050712070251.876"></t>
<t tx="ekr.20050712070251.877"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""
    
    @others</t>
<t tx="ekr.20050712070251.878">def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0
    
# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.</t>
<t tx="ekr.20050712070251.879">def clear (self):
    
    self.list = []


</t>
<t tx="ekr.20050712070251.880">def close (self):
    
    pass
    
    # The StringIo version free's the memory buffer.</t>
<t tx="ekr.20050712070251.881">def flush (self):
    
    pass</t>
<t tx="ekr.20050712070251.882">def get (self):

    return ''.join(self.list)
    
getvalue = get # for compatibility with StringIo
</t>
<t tx="ekr.20050712070251.883">def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr &lt; len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''</t>
<t tx="ekr.20050712070251.884">def write (self,s):
    
    if s:
        self.list.append(s)
</t>
<t tx="ekr.20050712070251.885"></t>
<t tx="ekr.20050712070251.886"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20050712070251.887">ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]</t>
<t tx="ekr.20050712070251.888"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "&lt;&lt;"
    self.rb = "&gt;&gt;"
else:
    self.lb = g.choose(self.language == "cweb","@&lt;","&lt;&lt;")
    self.rb = g.choose(self.language == "cweb","@&gt;","&gt;&gt;")</t>
<t tx="ekr.20050712070251.889"></t>
<t tx="ekr.20050712070251.890">@killcolor

- Tab toggles between the Search to the Replace areas.
- Control-Tab inserts a tab.
- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  (The Enter key activates the Find button.)
- As usual, Alt-F4 dismisses the Find panel.

To do next:  allow all search settings and commands to be activated from the status line.</t>
<t tx="ekr.20050712070251.891">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20050712070251.892">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20050712070251.893">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20050712070251.894">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.callback)
</t>
<t tx="ekr.20050712070251.895"># The hot key has been hit.  Call the button's command.

def callback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20050712070251.896"></t>
<t tx="ekr.20050712070251.897">def __init__(self,c,resizeable=False,title=None):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable)
    
    if g.app.unitTesting:return

    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20050712070251.898">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20050712070251.899">def destroySelf (self):
    
    self.top.destroy()</t>
<t tx="ekr.20050712070251.900">def createFrame (self):

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("&lt;1&gt;",  self.resetWrap)
        widget.bind("&lt;Key&gt;", self.resetWrap)
        widget.bind("&lt;Control-a&gt;",self.selectAll)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    for widget in (outer, self.find_ctrl, self.change_ctrl):
        widget.bind("&lt;Key-Return&gt;", findButtonCallback)
        widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)
    
    self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
</t>
<t tx="ekr.20050712070251.901">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)
&lt;&lt; Bind Tab and control-tab &gt;&gt;

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="ekr.20050712070251.902">def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20050712070251.903">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&amp;Script Search","script-search")]
checkLists[0] = [
    ("Scrip&amp;t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&amp;Whole Word",  self.dict["whole_word"]),
    ("&amp;Ignore Case", self.dict["ignore_case"]),
    ("Wrap &amp;Around", self.dict["wrap"]),
    ("&amp;Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &amp;Headline Text", self.dict["search_headline"]),
    ("Search &amp;Body Text",     self.dict["search_body"]),
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20050712070251.904"># Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None):
    __pychecker__ = '--no-argsused' # the event param must be present.
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.
findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&amp;xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&amp;d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&amp;Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &amp;Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)</t>
<t tx="ekr.20050712070251.905">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20050712070251.906">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20050712070251.907">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20050712070251.908"></t>
<t tx="ekr.20050712070251.909">@ It's not clear that this support is so useful for debugging scripts...</t>
<t tx="ekr.20050712070251.910">@nocolor

Forth support by David McNab, &lt;david@freenet.org.nz&gt;.

Changes by EKR:
    
- Look for extension files in plugins folder.
- Moved data structures into leoColor class.
- Suppress message about extra words during unit testing and in batch mode.
- Created this project node.

@color</t>
<t tx="ekr.20050712070251.911"></t>
<t tx="ekr.20050712070251.912"></t>
<t tx="ekr.20050712070251.913"># Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]</t>
<t tx="ekr.20050712070251.914"># Associate files with lists: probably no need to edit this.
forth_items = (
    (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
    (self.forth_keywords, "leo-forthwords.txt", "words"),
    (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
    (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
    (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
    (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
)

# Add entries from files (if they exist) and to the corresponding wordlists.
for (lst, path, typ) in forth_items:
    try:
        extras = []
        path = g.os_path_join(g.app.loadDir,"..","plugins",path) # EKR.
        for line in file(path).read().strip().split("\n"):
            line = line.strip()
            if line and line[0] != '\\':
                extras.append(line)
        if extras:
            if 0: # I find this annoying.  YMMV.
                if not g.app.unitTesting and not g.app.batchMode:
                    print "Found extra forth %s" % typ + ": " + " ".join(extras)
            lst.extend(extras)
    except IOError:
        # print "Not found",path
        pass</t>
<t tx="ekr.20050712070251.915">## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state</t>
<t tx="ekr.20050712070251.916"></t>
<t tx="ekr.20050712070251.917">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j</t>
<t tx="ekr.20050712070251.918">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.</t>
<t tx="ekr.20050712070251.919">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20050712070251.920">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2</t>
<t tx="ekr.20050712070251.921">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)</t>
<t tx="ekr.20050712070251.922">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)</t>
<t tx="ekr.20050712070251.923">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20050712070251.924"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2</t>
<t tx="ekr.20050712070251.925"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j</t>
<t tx="ekr.20050712070251.926">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"</t>
<t tx="ekr.20050712070251.927">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)</t>
<t tx="ekr.20050712070251.928"></t>
<t tx="ekr.20050712070251.929">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1</t>
<t tx="ekr.20050712070251.930"></t>
<t tx="ekr.20050712070251.931"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20050712070251.932"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)</t>
<t tx="ekr.20050712070251.933">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1

</t>
<t tx="ekr.20050712070251.934">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1</t>
<t tx="ekr.20050712070251.935">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1</t>
<t tx="ekr.20050712070251.936"># self.tag("normal",i,i+1)
i += 1</t>
<t tx="ekr.20050712070251.937"></t>
<t tx="ekr.20050712070251.938">def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        p.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p</t>
<t tx="ekr.20050712070251.939">try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None</t>
<t tx="ekr.20050712070251.940">def scanForthText (self,s,parent):
    
    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    parent.setBodyStringOrPane("@ignore\n" + "@language forth\n" + self.rootLine + s)</t>
<t tx="ekr.20050712070251.941"></t>
<t tx="ekr.20050712070251.942">@killcolor

What I did:

- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without this?

- Added sciptFind ivar and related logic to goToLineNumber and it allies.</t>
<t tx="ekr.20050712070251.943">def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        &lt;&lt; set root &gt;&gt;
    if lines is None:
        &lt;&lt; read the file into lines &gt;&gt;
    if n is None:
        &lt;&lt; get n, the line number, from a dialog &gt;&gt;
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        &lt;&lt; count outline lines, setting p,n2,found &gt;&gt;
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        &lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;
    &lt;&lt; select p and make it visible &gt;&gt;
    &lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="ekr.20050712070251.944"># First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,</t>
<t tx="ekr.20050712070251.945"># 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return</t>
<t tx="ekr.20050712070251.946">n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return</t>
<t tx="ekr.20050712070251.947">p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) &gt; 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines &gt;= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)</t>
<t tx="ekr.20050712070251.948">if scriptFind:
    &lt;&lt; just scan for the node name &gt;&gt;
elif gnx:
    &lt;&lt; 4.2: get node from gnx &gt;&gt;
elif childIndex == -1:
    &lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
    &lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="ekr.20050712070251.949"># This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break</t>
<t tx="ekr.20050712070251.950">found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20050712070251.951"># This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    g.es_print(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
    tnodeIndex = max(0,tnodeIndex)
    &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
            
if not ok:
    # Fall back to the old logic.
    &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="ekr.20050712070251.952">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1</t>
<t tx="ekr.20050712070251.953">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False</t>
<t tx="ekr.20050712070251.954">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return</t>
<t tx="ekr.20050712070251.955">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex &lt;= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20050712070251.956">c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()</t>
<t tx="ekr.20050712070251.957">if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()</t>
<t tx="ekr.20050712070251.958">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    &lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
</t>
<t tx="ekr.20050712070251.959"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
</t>
<t tx="ekr.20050712070251.960">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1</t>
<t tx="ekr.20050712070251.961">if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.</t>
<t tx="ekr.20050712070251.962">if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")</t>
<t tx="ekr.20050712070251.963">def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n</t>
<t tx="ekr.20050712070251.964"></t>
<t tx="ekr.20050712070251.965">Added the following back:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event

Added documentation for the following:
    


Added leoPlugins.unregisterHandler and getHandlersFor tag for testing.

</t>
<t tx="ekr.20050712070251.966"></t>
<t tx="ekr.20050712070251.967">def getHandlersForTag(tags):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        result = []
        for tag in tags:
            fn = getHandlersForOneTag(tag) 
            result.append((tag,fn),)
        return result
    else:
        return getHandlersForOneTag(tags)

def getHandlersForOneTag (tag):

    global handlers

    bunch = handlers.get(tag)
    return bunch.fn</t>
<t tx="ekr.20050712070251.968">def unregisterHandler(tags,fn):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            unregisterOneHandler(tag,fn)
    else:
        unregisterOneHandler(tags,fn)

def unregisterOneHandler (tag,fn):

    global handlers
    
    if 1: # New code
        bunches = handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.fn != fn]
        handlers[tag] = bunches
    else:
        fn_list = handlers.get(tag)
        if fn_list:
            while fn in fn_list:
                fn_list.remove(fn)
            handlers[tag] = fn_list
            # g.trace(handlers.get(tag))</t>
<t tx="ekr.20050712070251.969"></t>
<t tx="ekr.20050712070251.970"></t>
<t tx="ekr.20050712070251.971">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""
    
    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    &lt;&lt; set vdrag, childFlag &gt;&gt;
    if c.config.getBool("allow_clone_drags"):
        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
            self.controlDrag = c.frame.controlKeyIsDown

    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
        &lt;&lt; drag p to vdrag &gt;&gt;
    elif self.trace and self.verbose:
        g.trace("Cancel drag")
    
    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
</t>
<t tx="ekr.20050712070251.972">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20050712070251.973">if self.trace and self.verbose:
    g.trace("*** end drag   ***",\
        theId,x,y,p.headString(),vdrag.headString())
if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20050712070251.974"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    if self.trace and self.verbose:
        g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20050712070251.975">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20050712070251.976"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20050712070251.977">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20050712070251.978">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20050712070251.979">def onClickBoxClick (self,event):
    
    c = self.c
    
    if self.trace and self.verbose: g.trace()
    p = self.eventToPosition(event)
    if not p: return

    if not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        if p.isExpanded(): p.contract()
        else:              p.expand()
        self.active = True
        # Schedule the redraw _before_ calling select.
        # This disables any call that would configure old text widgets.
        self.redraw()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
            
        c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='onClickBoxClick')
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20050712070251.980"></t>
<t tx="ekr.20050712070251.981">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20050712070251.982">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivate(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20050712070251.983">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20050712070251.984">@killcolor

Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",</t>
<t tx="ekr.20050712070251.985"></t>
<t tx="ekr.20050712070251.986">@killcolor

- Removed createGlobalsWindows: Leo has no more global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.

- Ignore all find settings in getFindPanelSettings.  leoFind.init gets these from @settings.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, an allie of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.

@color</t>
<t tx="ekr.20050712070251.987">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20050712070251.988">def getFindPanelSettings (self):
    
    if self.getOpenTag("&lt;find_panel_settings"):
        return # &lt;find_panel_settings/&gt; seen.
    
    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag("&gt;"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only &lt;find_string&gt; or &lt;find_string/&gt;
    if self.getOpenTag("&lt;find_string&gt;"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("&lt;/find_string&gt;")
    # Allow only &lt;change_string&gt; or &lt;change_string/&gt;
    if self.getOpenTag("&lt;change_string&gt;"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("&lt;/change_string&gt;")
    self.getTag("&lt;/find_panel_settings&gt;")</t>
<t tx="ekr.20050712070251.989"></t>
<t tx="ekr.20050712070251.990">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2871977

- (done) created g.app.extensionsDir

- (done) created g.importModule and g.importExtension.

Now you can put Pmw into the extensions directory and have Leo easily import it from there.

Doing so gives you a way to add Pmw easily and any other 3rd party libs Leo ever needs.</t>
<t tx="ekr.20050712070251.991"></t>
<t tx="ekr.20050712070251.992">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2915750
By: cmbanker

The HOME environment variable on windows machines is often a referrence to yet
another environment variable.  i.e.  %HOME% --&gt; %USERENVIRONMENT% --&gt; "C:\Documents
and Settings\...."

The fix: Patch computeHomeDir() to test the first retrieval of the %HOME% var and grab
it's results if it is infact another enviroment variable.

@color

def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    
    home = os.getenv('HOME',default=dotDir)
    
    #verify that we've not got an indirect reference to true home
    if (home[0]=='%') and ( home[-1]=='%'):
	    #yep, must be a win32 machine - get this one
	    home = os.getenv(home[1:-1],default=dotDir)


    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
</t>
<t tx="ekr.20050712070251.993">def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home</t>
<t tx="ekr.20050712070251.994"></t>
<t tx="ekr.20050712070251.995">@killcolor

- Used g.Bunch in handlers data structure.
- Use a stack to associate moduleNames with handlers.
    - loadOnePlugin pushes the plugin's short file on the stack.
    - callTagHandler pushes the handler's moduleName on the stack so
      calls to registerHandler, etc. inside handlers get associated with the proper module.

Note: at present unit tests are very difficult to test properly. UnloadOnePlugin
is not enough: simply deactivating all handers is not enough. For example, this
does undo Tk bindings.

- At the least, an 'unload' hook would be required to reverse the effect of the plugin.
- For now, I'll see if having registerHandler do nothing if g.app.unitTesting is in effect suffices.</t>
<t tx="ekr.20050712070251.996">@killcolor

Fixed bug in how iconBar was created that resulted in rowcol plugin working improperly.</t>
<t tx="ekr.20050712070251.997">def plugin_signon(module_name,verbose=False):
    
    # The things we do to keep pychecker happy... 
    m = g.Bunch(__name__='',__version__='')
    
    exec("import %s ; m = %s" % (module_name,module_name))
    
    if verbose: # or g.app.unitTesting:
        g.es("...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))

        print m.__name__, m.__version__
        
    app.loadedPlugins.append(module_name)</t>
<t tx="ekr.20050712070251.998">def registerHandler(tags,fn):
    
    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""
    
    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '&lt;no module&gt;'
    
    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:
        
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)
        
    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items</t>
<t tx="ekr.20050712070251.999"></t>
<t tx="ekr.20050712070251.1000"></t>
<t tx="ekr.20050712070251.1001">@killcolor

Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.  It is never a good idea to use g.top().
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.
</t>
<t tx="ekr.20050712070251.1002">def os_path_join(*args,**keys):
    
    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]
    
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    
    path = g.toUnicodeFileEncoding(path,encoding)

    return path</t>
<t tx="ekr.20050712070251.1003"></t>
<t tx="ekr.20050712070251.1004">def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None</t>
<t tx="ekr.20050712070251.1005"></t>
<t tx="ekr.20050712070251.1006"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
</t>
<t tx="ekr.20050712070251.1007">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]</t>
<t tx="ekr.20050712070251.1008">def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,</t>
<t tx="ekr.20050712070251.1009">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()</t>
<t tx="ekr.20050712070251.1010"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set theDict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return theDict</t>
<t tx="ekr.20050712070251.1011">j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i</t>
<t tx="ekr.20050712070251.1012">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="ekr.20050712070251.1013">def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None</t>
<t tx="ekr.20050712070251.1014">def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None</t>
<t tx="ekr.20050712070251.1015">def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val &gt; 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
</t>
<t tx="ekr.20050712070251.1016">def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

</t>
<t tx="ekr.20050712070251.1017">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20050712070251.1018">def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language</t>
<t tx="ekr.20050712070251.1019"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c=None):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
</t>
<t tx="ekr.20050712070251.1020">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        &lt;&lt; stop the url after any whitespace &gt;&gt;
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,p=p,v=p)</t>
<t tx="ekr.20050712070251.1021"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
    </t>
<t tx="ekr.20050712070251.1022">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20050712070251.1023">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

</t>
<t tx="ekr.20050712070251.1024"></t>
<t tx="ekr.20050712070251.1025"></t>
<t tx="ekr.20050712070251.1026">@killcolor

The original problem with the UNL plugin not staying on top was that button-1
was bound to OnActivateTree, which called g.app.gui.set_focus.

However, there was another problem, the idle-time code in the status line logic
was also messing with the focus. It turns out that repeatedly calling
g.app.gui.set_focus is a bad idea: it interferes with opening new windows.

To deal with this I basically rewrote all the code that sets focus. The new code
replaces direct calls to g.app.gui.set_focus with calls to frame.bodyWantsFocus,
frame.statusLineWantsFocus, frame.treeWantsFocus and frame.logWantsFocus.
Actually, they all do the same thing, but using different methods improves
traces.

This is an excellent pattern. Rather than setting the focus directly, these
xWantsFocus methods merely signal their intension to set the focus. This allows
very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours to get it
just right. It queues up a 'one-shot' callback. That is, at most one copy of the
callback is ever waiting to be executed. Furthermore, the callback is only
queued for execution at the result of a call to xWantsFocus; it is never run
automatically at idle time. Finally, even when executed, the callback does
nothing if the last requested commander (in the new ivar, g.app.wantedFocus)
does not match the commander to which the callback was bound. These checks allow
the UNL plugin to open a window properly and keep it topmost :-)

This is a big step forward for Leo. Using delayed focus methods ensures that the
body pane always has focus unless the code has a specific, positive reason for
the focus to be elsewhere. This was difficult (or rather impossible) to do with
the old code: there are _many_ Tk calls that can affect the focus. Moreover, it
minimizes calls to g.app.gui.set_focus.

Oh yes, one more thing. All the new methods support a 'tag' keyword argument.
This is typically set to the name of the routine in which the call takes place.
It is a big help in making sense of traces.

More details:
- 'later' keyword arg
- eliminates most calls to g.app.gui.set_focus
- A case could be made for using a single, global one-shot callback in g.app.gui.set_focus.
- Stresses Tk much less.
- A problem with losing data in test.leo.</t>
<t tx="ekr.20050712070251.1027">def set_focus(self,c,widget,tag=''):
    
    __pychecker__ = '--no-argsused' # c and tag not used at present.
    
    """Put the focus on the widget."""
    
    # g.trace(tag,widget)
    
    # g.trace(c.frame.top.wm_stackorder())
    
    if widget:
        widget.focus_set()

    if 0: # Causes a weird problem on some machines.
        if c.frame.top:
            focus = c.frame.top.focus_displayof()
            if focus != widget:
                widget.focus_set()</t>
<t tx="ekr.20050712070251.1028">@

N.B. There is NO WAY to keep track reliably of which window is on top!! Leo must
never ever depend on this knowledge!!
</t>
<t tx="ekr.20050712070251.1029">def OnActivate (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        c = self.c
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20050712070251.1030">current = c.currentPosition()

if p == current:
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(self.canvas,later=False,tag='OnActivate')
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='OnActivate')

self.active = True</t>
<t tx="ekr.20050712070251.1031">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
        self.bodyWantsFocus(self.bodyCtrl,tag='OnActivateBody')
    except:
        g.es_event_exception("activate body")</t>
<t tx="ekr.20050712070251.1032">def OnActivateLeoEvent(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(self.c.shortFileName())

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")</t>
<t tx="ekr.20050712070251.1033">def OnActivateTree (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self
        g.app.setLog(frame.log,"OnActivateTree")
        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            frame.bodyWantsFocus(frame.bodyCtrl,tag='OnActivateTree')
            
    except:
        g.es_event_exception("activate tree")
</t>
<t tx="ekr.20050712070251.1034">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus(self.logCtrl,tag='onActivateLog')
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20050712070251.1035"># Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return
    if not p.exists(c):
        g.trace('does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20050712070251.1036"># Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20050712070251.1037">frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20050712070251.1038">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20050712070251.1039"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20050712070251.1040">c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')</t>
<t tx="ekr.20050712070251.1041">@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.</t>
<t tx="ekr.20050712070251.1042">@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,self.c.shortFileName())
    self.set_focus(widget,later=later,tag=tag)
    
def logWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def statusLineWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def treeWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
    
def widgetWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)</t>
<t tx="ekr.20050712070251.1043">@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''
    
    __pychecker__ = '--no-argsused' # tag good for debugging.

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None</t>
<t tx="ekr.20050712070251.1044"></t>
<t tx="ekr.20050712070251.1045"></t>
<t tx="ekr.20050712070251.1046">@

Improved status_line.py in leoPlugins.leo</t>
<t tx="ekr.20050712070251.1047"># See @button Configurator in test.leo for the motivating example.</t>
<t tx="ekr.20050712070251.1048">def getPluginModule (moduleName):
    
    global loadedModules
    
    return loadedModules.get(moduleName)</t>
<t tx="ekr.20050712070251.1049">def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            g.es_print(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
        
    if result is None:
        s = 'can not load enabled %s plugin' % moduleName
        g.es_print(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        g.es_print(s,color="blue")
    
    return result
</t>
<t tx="ekr.20050712070251.1050"></t>
<t tx="ekr.20050712070251.1051">@killcolor

*** Alas, using g.importExtension does not seem to work properly with Tkinter.

- plugins_menu.py now checks at runtime to see if the plugin has been successfully loaded before calling the topLevelMenu() function.

- Added pluginName keyword arg to g.importX functions.

    - All such functions now have pluginName and verbose keyword args.

- Used g.cantImport to print all messages in g.importX functions.</t>
<t tx="ekr.20050712070251.1052">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1930, in doHook
    return None # No return value
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 34, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 135, in doHandlersForTag
    ret = handle_fn(tag,keywords)
  File "C:\prog\leoCVS\leo\plugins\at_view.py", line 97, in icondclick2
    hs = self.current.headString()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 5110, in currentPosition
    if c._currentPosition:
AttributeError: Commands instance has no attribute '_currentPosition'</t>
<t tx="ekr.20050712070251.1053">@killcolor

Created callTagHandler.

This checks 'idle' hooks to make sure that any commander referenced by the 'c','new_c' or 'old_c' keywords still exists.
</t>
<t tx="ekr.20050712070251.1054">def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                if not hasattr(c,'frame'): return None
                if c.frame not in g.app.windowList:
                    return None # c has (or will be) destroyed.

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result</t>
<t tx="ekr.20050712070251.1055">def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch,tag,keywords)

    return None</t>
<t tx="ekr.20050712070251.1056">def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()

    return doHandlersForTag(tag,keywords)</t>
<t tx="ekr.20050712070251.1057"></t>
<t tx="ekr.20050712070251.1058">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2876473

I'm using 4.2 final, build 1.173, on Linux, and experience intermittent lockups
exactly as described here.

I've turned off almost all plugins, except for mod_tempfname, nodenavigator,
plugin_manager, and plugins_menu. It seems that I never experience the lockups
if I disable the hoist plugin, but that I do sometimes experience the lockups
if I enable hoist. Maybe a quick review of hoist might be in order to see if
anything looks suspicious. I believe hoist uses an idle handler, which I vaguely
feel might be able to lead to lockups of this sort.

Anyway, I'm not sure about this, but it is kind of frustrating to have leo lock
up totally, so hopefully this small data tidbit will help flush out this bug.</t>
<t tx="ekr.20050712070251.1059">@killcolor

- leoPlugins.registerOneHandler wasn't working properly at all.  In effect, only the last registered hook was ever being remembered!

- leoPlugins.doHandlersForTag now executes the list of hook handlers for a particular tag (hook name) until one of the handlers returns a non-None result.  doHandersForTag no longer tries to "sort" handlers, so the order that the handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks interfering with each other.  If two handlers try to return a non-None result only one of them will ever execute.  doHandlersForTag can't do much about this: a better solution would require more conceptual framework.  Not now...

3.  g.idleTimeHookHandler works for me as it stands.  N.B.  It may have changed since 4.2.  At present the code calls g.doHook('idle',...), which in turn calls doHandlersForTag('idle').  The code then queues itself up for re-execution after a nominal delay of at least 100 msec.  This queuing is done (eventually) by the Tk call g.app.root.after  This works for me on XP.  However, g.app.root.after_idle does tend to hang on XP.
</t>
<t tx="ekr.20050712070251.1060">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20050712070251.1061"></t>
<t tx="ekr.20050712070251.1062">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.</t>
<t tx="ekr.20050712070251.1063"># Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False</t>
<t tx="ekr.20050712070251.1064"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args &amp; keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # New in 4.2 Beta 3. Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="ekr.20050712070251.1065"></t>
<t tx="ekr.20050712070251.1066">@</t>
<t tx="ekr.20050712070251.1067">@killcolor

With the latest CVS on Linux, attempting to access the preferences dialog when
the chapters plugin is enabled causes a blank window to appear in the Leo outline
pane.

Fix:
    
chapters.py requires that the canvas have a name ivar, so 
    
&lt;&lt; replace tree pane with settings tree &gt;&gt; now sets treeCanvas.name = '1'</t>
<t tx="ekr.20050712070251.1068">tree = c.frame.component('tree')

# The new frame must be a child of splitter2Frame.
splitter2Frame = c.frame.component('splitter2Frame').getFrame()

# Create a Pmw scrolled canvas.
scrolledTreeCanvas = Pmw.ScrolledCanvas(splitter2Frame,
    hscrollmode='none',borderframe=3)

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Set canvas.name ivar for chapters.py plugin.
# This must be a tab number.  The number '1' should work well enough.
treeCanvas.name = '1'

# Create the settingsTree component.
c.frame.componentClass(c,'settingsTree',scrolledTreeCanvas,self,
    tree.getPacker(),tree.getUnpacker())

c.frame.replaceTreePaneWithComponent('settingsTree')

self.tree = settingsTree(c,c.frame,treeCanvas,self)
self.tree.setColorFromConfig()</t>
<t tx="ekr.20050712070251.1069"></t>
<t tx="ekr.20050712070251.1070">@killcolor

- Removed following files and corresponding imports.
    - leoColorPanel.py
    - leoFontPanel.py
    - leoPrefs.py
    - leoTkinterColorPanels.py
    - leoTkinterFontPanel.py
    - leoTkinterPrefs.py

- moved colorNamesList from leoTkinterColorPanels.py to leoConfig.py

- Removed unused code from gui.Tkinter panels.</t>
<t tx="ekr.20050712070251.1071"></t>
<t tx="ekr.20050712070251.1072"></t>
<t tx="ekr.20050712070251.1073">http://sourceforge.net/forum/message.php?msg_id=2795653

By: Paul Paterson - paulpaterson
Bug: minor asymmetry with undo insert node  
2004-10-08 13:49
Very minor hangnail,

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc commands don't work until you click on something with the mouse

In an ideal world, after #3 it should be as if #2 never happened.

----------------

http://sourceforge.net/forum/message.php?msg_id=2795656
By: paulpaterson

Hmm, there's something interesting here after all.

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory
lives on ...
</t>
<t tx="ekr.20050712070251.1074">def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    if 1: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p)
        c.selectPosition(p)
    c.endUpdate()
    return p # for mod_labels plugin.</t>
<t tx="ekr.20050712070251.1075">def undoInsertNodes (self):
    
    u = self ; c = u.c
    
    if 0: # Paste retaining clones can't be undone!
        # Remember the previous headline.
        old = c.currentPosition().headString()
    
    c.selectPosition(u.p)
    c.deleteOutline()

    if u.select:
        c.selectPosition(u.select)
        
    # New in 4.3: Support for Paste As Clone.
    if 0: # Paste retaining clones can't be undone!
        if u.headString:
            new = u.headString
            g.trace('old',old,'new',new)
            u.p.setHeadStringOrHeadline(new)
            u.headString=old</t>
<t tx="ekr.20050712070251.1076"></t>
<t tx="ekr.20050712070251.1077">@killcolor

&gt; leo\src\leoTkinterFind.py:  
inconsistent use of tabs and spaces in indentation.
 
much of PMW has inconsistent use of tabs and spaces in indentation in various files .py </t>
<t tx="ekr.20050712070251.1078"></t>
<t tx="ekr.20050712070251.1079">def leoConfig (self):

    c = self
    name = 'leoSettings.leo'
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))</t>
<t tx="ekr.20050712070251.1080"></t>
<t tx="ekr.20050712070251.1081">http://sourceforge.net/forum/message.php?msg_id=2966541
By: jasonic

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

With chapters 0.66 enabled -- same behavior. 

Jason</t>
<t tx="ekr.20050712070251.1082">Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.</t>
<t tx="ekr.20050712070251.1083"></t>
<t tx="ekr.20050712070251.1084">def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)</t>
<t tx="ekr.20050712070251.1085"></t>
<t tx="ekr.20050712070251.1086">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.
</t>
<t tx="ekr.20050712070251.1087"></t>
<t tx="ekr.20050712070251.1088"># All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        &lt;&lt; put newline to log control &gt;&gt;
    else:
        &lt;&lt; put newline to logWaiting and print newline &gt;&gt;</t>
<t tx="ekr.20050712070251.1089">if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)</t>
<t tx="ekr.20050712070251.1090">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="ekr.20050712070251.1091">self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')</t>
<t tx="ekr.20050712070251.1092">g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print</t>
<t tx="ekr.20050712070251.1093">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False</t>
<t tx="ekr.20050712070251.1094">def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines &lt; n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,</t>
<t tx="ekr.20050712070251.1095">def writeWaitingLog (self):

    if self.log:
        for s,color in self.logWaiting:
            g.es(s,color=color,newline=0) # The caller must write the newlines.
        self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'</t>
<t tx="ekr.20050712070251.1096"></t>
<t tx="ekr.20050712070251.1097"></t>
<t tx="ekr.20050712070251.1098"></t>
<t tx="ekr.20050712070251.1099">@killcolor

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write        
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write    
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)
    
AttributeError: 'tnode' object has no attribute 'tnodeList'</t>
<t tx="ekr.20050712070251.1100"># The button callback just calls c.executeScript</t>
<t tx="ekr.20050712070251.1101">@killcolor

The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.</t>
<t tx="ekr.20050712070251.1102"># The problem was simply some extra print statements. No idea why they were there.</t>
<t tx="ekr.20050712070251.1103">class logClass:
    
    def __init__ (self,textWidget):
        self.textWidget = textWidget
        self.colorTags = []
        
    def put(self,s,color=None):
        w = self.textWidget
        &lt;&lt; put s to w &gt;&gt;
        
    def putnl (self):
        w = self.textWidget
        if sys.platform == "darwin": print
        w.insert("end",'\n')
        w.see("end")
        w.update_idletasks()</t>
<t tx="ekr.20050712070251.1104">if type(s) == type(u""):
    s = g.toEncodedString(s,g.app.tkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        w.tag_config("black",foreground="black")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see("end")
w.update_idletasks()</t>
<t tx="ekr.20050712070251.1105">@killcolor

This makes the test more robust in case of failure.</t>
<t tx="ekr.20050712070251.1106">@killcolor

Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass.</t>
<t tx="ekr.20050712070251.1107"></t>
<t tx="ekr.20050712070251.1108">@killcolor

*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.</t>
<t tx="ekr.20050712070251.1109">redirect script IO to log pane setting isn't working, </t>
<t tx="ekr.20050712070251.1110"></t>
<t tx="ekr.20050712070251.1111"></t>
<t tx="ekr.20050712070251.1112"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()</t>
<t tx="ekr.20050712070251.1113">def findAll(self):

    c = self.c ; t = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    while 1:
        pos, newpos = self.findNextMatch()
        if pos:
            # g.trace(pos,newpos,self.p.headString())
            count += 1
            line = gui.getLineContainingIndex(t,pos)
            self.printLine(line,allFlag=True)
        else: break
    c.endUpdate()
    g.es("found: %d matches" % (count))
    self.restore(data)</t>
<t tx="ekr.20050712070251.1114"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p
    while p:
        pos, newpos = self.search()
        if pos:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextVnode()
    return None, None</t>
<t tx="ekr.20050712070251.1115"></t>
<t tx="ekr.20050712070251.1116"></t>
<t tx="ekr.20050712070251.1117">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.</t>
<t tx="ekr.20050712070251.1118"></t>
<t tx="ekr.20050712070251.1119">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3006092
Viktor Ransmayr

In Leo-4.3.a2 there is a small problem with the location of the created .leoID.txt
file.

When I installed the new version of Leo, I started Leo
and entered a LeoID, when asked. For whatever reason
this was stored in C:\Programme\Leo\test\.leoID.txt
and not in C:\Programme\Leo\config\.leoID.txt, where
it is expected.

The net-result is that you asked for a new LeoID,
whenever you open an existing Leo-file in any
directory other than C:\Programme\Leo\test.</t>
<t tx="ekr.20050712070251.1120">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file &amp; tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!</t>
<t tx="ekr.20050712070251.1121">@killcolor

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
- Improved signon message.
- Better error handling and reporting. </t>
<t tx="ekr.20050712070251.1122">def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    &lt;&lt; return if we can set self.leoID from sys.leoID &gt;&gt;
    &lt;&lt; return if we can set self.leoID from "leoID.txt" &gt;&gt;

    &lt;&lt; put up a dialog requiring a valid id &gt;&gt;
    &lt;&lt; attempt to create leoID.txt &gt;&gt;</t>
<t tx="ekr.20050712070251.1123"># This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None</t>
<t tx="ekr.20050712070251.1124">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()</t>
<t tx="ekr.20050712070251.1125"># New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")</t>
<t tx="ekr.20050712070251.1126">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')</t>
<t tx="ekr.20050712070251.1127"># This now works: g.es('',color='red')</t>
<t tx="ekr.20050712070251.1128"></t>
<t tx="ekr.20050712070251.1129">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2983923
By: tyndal

I tried again with the a2 cvs and it still isnt working correctly, the "reduced"
leo window is still showing up, however the error messages are different:

---------------

Leo Log Window...
Leo 4.3 alpha 2, build  1.217 , January 30, 2005
Python 2.3.4, Tk 8.4.3, win32

exception executing command
Traceback (most recent call last):
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 170,
in doCommand
    command()
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 328, in open
    ok, frame = g.openWithFileName(fileName,c)
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoGlobals.py", line 637,
in openWithFileName
    g.es("exceptions opening: %s" % g.toEncodedString(fileName),color="red")
TypeError: toEncodedString() takes at least 2 arguments (1 given)

---------------

However, opening a regular file after failing to open a file now seems to work
correctly.

-Tyndal

</t>
<t tx="ekr.20050712070251.1130"></t>
<t tx="ekr.20050712070251.1131">def isUnicode(s):
    
    return s is None or type(s) == type(u' ')</t>
<t tx="ekr.20050712070251.1132">def isValidEncoding (encoding):
    
    try:
        if len(encoding) == 0:
            return False
        unicode("a",encoding)
        return True
    except:
        return False
</t>
<t tx="ekr.20050712070251.1133">def reportBadChars (s,encoding):
    
    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except: errors += 1
        if errors:
            # traceback.print_stack()
            g.es("%d errors converting %s to %s" % 
                (errors, s.encode(encoding,"replace"),encoding))

    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % 
                (errors, unicode(s,encoding,"replace"),encoding)) # 10/23/03</t>
<t tx="ekr.20050712070251.1134"></t>
<t tx="ekr.20050712070251.1135">def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s</t>
<t tx="ekr.20050712070251.1136">def toEncodedStringWithErrorCode (s,encoding):
    
    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok</t>
<t tx="ekr.20050712070251.1137">def toUnicode (s,encoding,reportErrors=False):
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
    
</t>
<t tx="ekr.20050712070251.1138">def toUnicodeWithErrorCode (s,encoding):
    
    ok = True
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok</t>
<t tx="ekr.20050712070251.1139">def test_round_trip_toUnicode_toEncodedString ():
   
    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('',  'utf-8'),
        ('',  'mbcs'),
        ('',   'utf-8'),
        ('',   'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s</t>
<t tx="ekr.20050712070251.1140">def test_failure_with_ascii_encodings():

    encoding = 'ascii'
    
    s = ''
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = u''
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s</t>
<t tx="ekr.20050712070251.1141"># Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        &lt;&lt; define getpreferredencoding using _locale &gt;&gt;
    else:
        &lt;&lt; define getpreferredencoding for *nix &gt;&gt;
        
__pychecker__ = '--reuseattr'
</t>
<t tx="ekr.20050712070251.1142"># On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None</t>
<t tx="ekr.20050712070251.1143"># On Unix, if CODESET is available, use that.

__pychecker__ = '--no-noeffect' # Note: this is at the top level!

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None</t>
<t tx="ekr.20050712070251.1144">@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.</t>
<t tx="ekr.20050712070251.1145">def os_path_abspath(path,encoding=None):
    
    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path</t>
<t tx="ekr.20050712070251.1146">def os_path_basename(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path</t>
<t tx="ekr.20050712070251.1147">def os_path_dirname(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path</t>
<t tx="ekr.20050712070251.1148">def os_path_exists(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)</t>
<t tx="ekr.20050712070251.1149">def os_path_getmtime(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)</t>
<t tx="ekr.20050712070251.1150">def os_path_isabs(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)</t>
<t tx="ekr.20050712070251.1151">def os_path_isdir(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)</t>
<t tx="ekr.20050712070251.1152">def os_path_isfile(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)</t>
<t tx="ekr.20050712070251.1153">if 0:  # A bad idea.
    
    def os_path_norm(path,encoding=None):
    
        """Normalize both the path and the case."""
    
        path = g.toUnicodeFileEncoding(path,encoding)
    
        path = os.path.normcase(path)
        path = os.path.normpath(path)
        
        path = g.toUnicodeFileEncoding(path,encoding)
        
        return path</t>
<t tx="ekr.20050712070251.1154">if 0: # A bad idea.

    def os_path_normabs (path,encoding=None):
    
        """Convert the file name to a fully normalized absolute path.
        
        There is no exact analog to this in os.path"""
        
        path = g.os_path_abspath(path,encoding = encoding)
        path = g.os_path_norm(path,encoding = encoding)
    
        return path</t>
<t tx="ekr.20050712070251.1155">def os_path_normcase(path,encoding=None):
    
    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path</t>
<t tx="ekr.20050712070251.1156">def os_path_normpath(path,encoding=None):
    
    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path</t>
<t tx="ekr.20050712070251.1157">def os_path_split(path,encoding=None):
    
    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail</t>
<t tx="ekr.20050712070251.1158">def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail</t>
<t tx="ekr.20050712070251.1159">def toUnicodeFileEncoding(path,encoding):

    if not encoding:
        if sys.platform == "win32":
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)</t>
<t tx="ekr.20050712070251.1160">@ According to Martin v. Lwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    try: locale_encoding = g.getpreferredencoding()
    except exception: locale_encoding = None
    
    try: sys_encoding = sys.getdefaultencoding()
    except exception: sys_encoding = None

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        (locale_encoding,"locale"),
        (sys_encoding,"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding):
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding:
            color = g.choose(self.tkEncoding=="ascii","red","blue")
            g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
            
    </t>
<t tx="ekr.20050712070251.1161"></t>
<t tx="ekr.20050712070251.1162"></t>
<t tx="ekr.20050712070251.1163">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2987569
By: e

goto linenumber popup gets hidden behind the leo.

EKR: This happens when focus is in body pane.

Arrrrrgh.  The delayed focus logic requires a commander to work.

What I did:

- Added a c argument to all dialogs except runAskLeoIDDialog.
- Added tk.gui.widget_wants_focus.
- Added unit tests to test ctors for all dialogs and panels.
    - All dialog ctors return after initing the base class when unit testing.
</t>
<t tx="ekr.20050712070251.1164"></t>
<t tx="ekr.20050712070251.1165">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()</t>
<t tx="ekr.20050712070251.1166">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")
    
def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)
    
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")</t>
<t tx="ekr.20050712070251.1167">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)</t>
<t tx="ekr.20050712070251.1168">def run (self,modal):
    
    """Run a leoTkinterDialog."""
    
    if g.app.unitTesting: return None

    c = self.c ; self.modal = modal

    self.center() # Do this after all packing complete.
    self.top.lift()

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        
    if self.focus_widget == None:
        self.focus_widget = self.top
        
    self.focus_widget.focus_set() # Get all keystrokes.
    if c:
        # g.trace(self.focus_widget,c)
        g.app.gui.widget_wants_focus(c,self.focus_widget)
       
    self.root.wait_window(self.top)
    
    if self.modal:
        return self.answer
    else:
        return None</t>
<t tx="ekr.20050712070251.1169">def widget_wants_focus(self,c,widget,tag=''):

    """Indicate that a widget want to get focus."""
    
    if c:
        c.frame.widgetWantsFocus(widget,True,tag=tag)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20050712070251.1170"></t>
<t tx="ekr.20050712070251.1171"></t>
<t tx="ekr.20050712070251.1172"># Bugs fixed 2/12/05
1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.
    
2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found
    
    # Local --&gt; locale
    # Might cause getpreferredencoding to fail on *nix.
    
3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.
    
4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)
        
5. (removed code) from &lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;
    - last_p is None at first, so last_p.insertAfter does not make sense.</t>
<t tx="ekr.20050712070251.1173">@killcolor

Apparantly pychecker was confused by the complexity of the code in settingsController.__init__.

Created replaceBodyWithDialog and createStandAloneDialog helpers, and this eliminated the warnings(!)</t>
<t tx="ekr.20050712070251.1174"></t>
<t tx="ekr.20050712070251.1175">@killcolor

The problem was with a change I made in createSettingsTree in response to a pychecker complaint.
This change altered the local settings tree...

In spite of what pychecker may say, last_p IS defined properly when it is used.</t>
<t tx="ekr.20050712070251.1176">def findCorrespondingNode (self,root1,root2,p1):
    
    """Return the node corresponding to p1 (in root1) in the root2's tree."""
    
    if p1 == root1: return root2

    # Go up tree 1, computing child indices.
    childIndices = []
    for p in p1.self_and_parents_iter():
        #g.trace(p)
        if p == root1: break
        childIndices.append(p.childIndex())
        
    childIndices.reverse()
    # g.trace(childIndices)
    
    # Go down tree 2, moving to the n'th child.
    p2 = root2.copy()
    for n in childIndices:
        # g.trace(p2)
        p2.moveToNthChild(n)

    # g.trace(p2)
    return p2</t>
<t tx="ekr.20050712070251.1177">@nocolor

It is surprisingly difficult to give a warning that only the global setting applies.

I added some more documentation to the setting in leoSettings.leo and removed the confusing entry from test.leo.

@color</t>
<t tx="ekr.20050712070251.1178"></t>
<t tx="ekr.20050712070251.1179"></t>
<t tx="ekr.20050712070251.1180">@killcolor

Up until Leo 4.3, Leo's undo-typing mechanism was character-by-character. This
was clunky, to say the least.

leoSettings.leo now contains an 'undo_granularity' setting. There are four
possible value for this setting:

node: start a new undo unit when typing moves to a new node.
line: start a new undo unit when typing moves to new line.
word: start a new undo unit when typing starts a new word.
char: start a new undo unit for each character typed.

'line' granularity is the default used if no valid setting is specified. 'char'
granularity is not recommened: it wastes lots of computer memory.

The definitions of 'node', 'line' and 'char' granularities are straightforward.
However, recognizing the start of a word for the purposes of undo is something
people may want to play with. Therefore, setUndoTypingParams calls the
recognizeStartOfTypingWord helper method to do this.

recognizeStartOfTypingWord is potentially user-modifiable method that should
return True if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity.
    
setUndoTypingParams calls this method only when the typing could possibly
continue a previous word. In other words, undo will work safely regardless of
the value returned. See the actual code for recognizeStartOfTypingWord for more
details.</t>
<t tx="ekr.20050712070251.1181"></t>
<t tx="ekr.20050712070251.1182">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2963175
By: bwmulder

There have been some postings a while ago about using pydoc to browse Leo source
code.

It seems that pydoc imports modules. Pydoc, at that time, failed on some modules
because of setup code which was executed in some plugins, and which did not
work when some things were not setup.

I am wondering if it would be better to factor out setup code in plugins so
that the setup part (reading config file, etc) will be done only as part of
a function call. This way, imports of the module would always work.

You can currently test leoGlobals.app and such, but it seems to me that this
is more of a hack.

I realize that this would be a change in the plugin interface, but you can not
have improvements without some pain.

[Another lesson I learned recently is to avoid module level variables, and use
classes instead. You can always create new instances, but its hard to create
new instances of modules].

I was just thinking of adding a function in my mock module which would import
a module to figure out what modules are imported in that module. By replacing
the real modules with mock modules, one can be assured to control the total
environment of that module.
</t>
<t tx="ekr.20050712070251.1183">@killcolor

I just had two Aha's regarding this proposal:

1. The init function can return True if the plugin was, in fact, loaded correctly.  This is information that up until now has not been available, and it is very useful.  For example, the code in the '@button Check spelling...' node would be much simplified if leoPlugins.loadOnePlugin only returned properly inited plugins.

2. There is no need to change all plugins all at once.  The plugin manager can try calling plugin's init code, but can 'guess' that the plugin was correctly loaded if the init method does not exist.  In this way, we can add the init code to plugins that would really benefit from having it, without having to add init functions to all plugins.</t>
<t tx="ekr.20050712070251.1184">@killcolor

The code attempts to call the init method when importing the plugin. If the
top-level init function exits, the plugin manager will record the plugin as
having been loaded successfully only if init returns True (or equivalent). If
the top-level init function does not exist, the plugin manager considers that
the plugin was loaded successfully. This guess is needed for compatibility with
old plugins.

Other changes:

- Added init to the spellpyx plugin.
- Changed the scripts in the '@button Check spelling...' nodes in test.leo and leoPy.leo and leoPyRef.leo.

Edward</t>
<t tx="ekr.20050712070251.1185">@killcolor

https://sourceforge.net/forum/message.php?msg_id=2963461
By: ktenney

Howdy,

I only just now realized that
Outline -&gt; Paste Retaining Clone
would _create_ a clone from any node on the clipboard.
It's name led me to believe that I had to create a clone, copy it, and use 'Paste
Retaining Clones'

It would make more sense to me if it was called
"Paste As Clone" 
Maybe it could be given a hotkey, such as Shft+Ctrl+Z
</t>
<t tx="ekr.20050712070251.1186">menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Paste Node As Clone",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())</t>
<t tx="ekr.20050712070251.1187"></t>
<t tx="ekr.20050712070251.1188">@killcolor

A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True.</t>
<t tx="ekr.20050712070251.1189">@killcolor

Documentation problem in "Leo\config\leoSettings.leo"

- (done) The body text shows 1: &amp; 0: as selections, not True/False.
    - @bool write_strips_blank_lines = True
    - @bool allow_clone_drags = False"
    - @bool enable_drag_messages = False"

- (done) @bool script_change = None
    What's a 'script change'?
    All the nodes under "Checkboxes" could use descriptions.

- (done) @page Syntax colors &amp; options

    It would be nice if there were spaces before &amp; after the "=" to allow easier
    double-click selection of just the colors.</t>
<t tx="ekr.20050712070251.1190"></t>
<t tx="ekr.20050712070251.1191"></t>
<t tx="ekr.20050712070251.1192"></t>
<t tx="ekr.20050712070251.1193">@killcolor

These are now defined in the calling environment.

See testRoutineTestCase.runTest in test.leo.
</t>
<t tx="ekr.20050712070251.1194"></t>
<t tx="ekr.20050712070251.1195">@killcolor

1.  g.getScript calls the new g.removeExtraLws function to remove extra indentation.

This is required to keep Python happy.

2.  g.getScript does not call at.write if there is, in fact, a selection.

This disables handling of directives and section references, but it handles indentation.

This should be improved further, but that would require some hacks to at.write.

N.B. The primary usage of this is to execute test routines immediately by
selecting the text without the def. This eliminates the need to use this
pattern:

def test_whatever():
    stuff

if 0: test_whatever()

BTW, I played around with using:

if g.app.inScript:
    test_whatever()

But there are several problems with this idea. First, it is much more work than
just selecting the body of test_whatever. Worse, it can not be used in
leoGlobals.py because g.app will be None in the initial import of leoGlobals.
This bad special case doomed the entire idea.

3. g.executeScript now just adds a trailing newline to the script.

In particular, it does not call strip!</t>
<t tx="ekr.20050712070251.1196">def removeExtraLws (s,tab_width):
    
    '''Remove extra indentation from one or more lines.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    
    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result</t>
<t tx="ekr.20050712070251.1197">def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))</t>
<t tx="ekr.20050712070251.1198"></t>
<t tx="ekr.20050712070251.1199"></t>
<t tx="ekr.20050712070251.1200"></t>
<t tx="ekr.20050712070251.1201"></t>
<t tx="ekr.20050712070251.1202">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2998446
By: djsg

g.create_temp_name() calls tempfile.mktemp or mkstemp(), but these return different values!

mktemp returns the filename(a string); mkstemp returns a tuple (handle,filename)

What I did:

- Changed g.create_temp_name to g.create_temp_file.
- Removed the file open logic in tangle.put_all_roots (now done in g.create_temp_file)
- Rewrote g.create_temp_file so it works in both cases.
- Create test routine for g.create_temp_file
- Created very simple unit tests in test.leo for tangle and untangle.</t>
<t tx="ekr.20050712070251.1203">@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is True only changed roots are actually written.
@c

def put_all_roots(self):

    c = self.c ; outline_name = c.mFileName

    for section in self.root_list:
    
        # g.trace(section.name)
        file_name = g.os_path_join(self.tangle_directory,section.name)
        file_name = g.os_path_normpath(file_name)
        mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        textMode = mode == 'platform'
        self.output_file,temp_name = g.create_temp_file(textMode=textMode)
        if not temp_name:
            g.es("Can not create temp file")
            break
        &lt;&lt;Get root specific attributes&gt;&gt;
        &lt;&lt;Put @first lines&gt;&gt;
        if self.use_header_flag and self.print_mode == "verbose":
            &lt;&lt; Write a banner at the start of the output file &gt;&gt;
        for part in section.parts:
            if part.is_root:
                self.tangle_indent = 0 # Initialize global.
                self.put_part_node(part,False) # output first lws
        self.onl() # Make sure the file ends with a cr/lf
        self.output_file.close()
        self.output_file = None
        if self.errors == 0:
            g.update_file_if_changed(file_name,temp_name)
        else:
            g.es("unchanged:  " + file_name)
            &lt;&lt; Erase the temporary file &gt;&gt;</t>
<t tx="ekr.20050712070251.1204"># Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines</t>
<t tx="ekr.20050712070251.1205"># Stephen P. Schaefer 9/13/2002
if self.first_lines:
    self.os(self.first_lines)</t>
<t tx="ekr.20050712070251.1206">if self.single_comment_string:
    self.os(self.single_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
    self.os(self.start_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.oblank() ; self.os(self.end_comment_string)
    self.onl() ; self.onl()
</t>
<t tx="ekr.20050712070251.1207">try: # Just delete the temp file.
    os.remove(temp_name)
except: pass
</t>
<t tx="ekr.20050712070251.1208">def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''
    
    # mktemp is deprecated, but we can't get rid of it
    # because mkstemp does not exist in Python 2.2.1.
    __pychecker__ = '--no-deprecate'
    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
        # g.trace(fd,theFile)
    except AttributeError:
        # g.trace("mkstemp doesn't exist")
        theFileName = tempfile.mktemp()
        try:
            mode = g.choose(textMode,'w','wb')
            theFile = file(theFileName,mode)
        except IOError:
            theFile,theFileName = None,''
    except Exception:
        g.es('Unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName</t>
<t tx="ekr.20050712070251.1209">def test_g_create_temp_file():
    
    __pychecker__ = '--no-reimport'
    import types

    theFile,theFileName = g.create_temp_file()

    assert type(theFile) == types.FileType, 'not file type'
    assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'</t>
<t tx="ekr.20050712070251.1210"></t>
<t tx="ekr.20050712070251.1211">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2999651
By: nobody

I was pleasantly surprised to discover the reST2 plug-in working under 4.3a2
(this is one the first thing I try as I'd like to use Leo as an editor
for that).

As mentioned in early threads, it still needs @rst for each node to be included
in the reST rendering process. So I put @rst test.html and then a child with
@rst and some reST code and it worked !!

Then I tried to to get a simple rst file using @rst test but the plugin complained:

[snip]

  File "C:\dn_apps\Leo\plugins\rst2.py", line 164, in onIconDoubleClick
    writeTreeAsRst(rstFile,fname,p,c)
TypeError: writeTreeAsRst() takes exactly 5 arguments (4 given)

So I looked at the rst2.py and found a way to get it working but I would need
someone to verify it :

line 164, replaced   writeTreeAsRst(rstFile,fname,p,c)  by

syntax = False
writeTreeAsRst(rstFile,fname,p,c,syntax)

And it worked!
</t>
<t tx="ekr.20050712070251.1212"></t>
<t tx="ekr.20050712070251.1213"># This appears to be a bug in python-mode.el.</t>
<t tx="ekr.20050712070251.1214"></t>
<t tx="ekr.20050712070251.1215">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3005140
By: ktenney

- perform a search which marks a number of nodes

- select "Outline -&gt; Mark/Unmark -&gt; Unmark All"

- Several marks are still listed in in the nodenavigator "Marks" list.
  (They are not marked in the outline.)</t>
<t tx="ekr.20050712070251.1216">@killcolor

- The p.set/clearMark methods now call the hook _after_ changing the marked status.
  This fixes the apparent bug in nodenavigator.py.

- Rewrote nav_buttons.py.  The old code was a mess; the new code is clean.

- Changed the vnodeList ivar in leoTkinterDialog to positionList.

- Rewrote c.unmarkAll to make clear that it is using positions.
    - Added test_c_unmark_all test routine.</t>
<t tx="ekr.20050712070251.1217"></t>
<t tx="ekr.20050712070251.1218">def markChangedHeadlines (self): 

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            p.setMarked()
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    g.es("done",color="blue")
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1219">def markChangedRoots (self):

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    g.es("done",color="blue")
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1220">def markAllAtFileNodesDirty (self):

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    if 1: # In update...
        while p:
            if p.isAtFileNode()and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1221">def markAtFileNodesDirty (self):

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    changed = False
    c.beginUpdate()
    if 1: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1222">def markClones (self):

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    if 1: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1223">def markHeadline (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    if 1: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            p.clearMarked()
        else:
            p.setMarked()
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
</t>
<t tx="ekr.20050712070251.1224">def markSubheads(self):

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    if 1: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
</t>
<t tx="ekr.20050712070251.1225">def unmarkAll(self):

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    if 1: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.clearMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1226">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20050712070251.1227">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20050712070251.1228"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    self.v.clearMarked()
    g.doHook("clear-mark",c=self.c,p=self,v=self)

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)
    
def setMarked (self):
    self.v.setMarked()
    g.doHook("set-mark",c=self.c,p=self,v=self)

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="ekr.20050712070251.1229"></t>
<t tx="ekr.20050712070251.1230">def pdb ():
    
    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    pdb.set_trace()</t>
<t tx="ekr.20050712070251.1231">def test_g_pdb():
    
    import sys
    
    # Not a good unit test; it probably will never fail.
    def aFunction(): pass
    assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)
    
    class myStdout:
        def write(self,s):
            pass # g.es('From pdb:',s)
        
    class myStdin:
        def readline (self):
            return 'c' # Return 'c' (continue) for all requests for input.
            
    def restore():
        sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__
     
    try:
        sys.stdin = myStdin() # Essential
        sys.stdout=myStdout() # Optional
        g.pdb()
        restore()
        # assert False,'test of reraising'
    except Exception:
        restore()
        raise</t>
<t tx="ekr.20050712070251.1232"></t>
<t tx="ekr.20050712070251.1233">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3008045
By: digitig

Um, I must be missing something about how to script in Leo. If I cut-and-paste
that code into a Leo main window, select it and hit ctrl-E the log window kindly
informs me:

exception executing command
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "C:\Program Files\Leo\src\leoCommands.py", line 1141, in executeScript
    script = g.getScript(c,p,useSelectedText=useSelectedText)
  File "C:\Program Files\Leo\src\leoGlobals.py", line 4357, in getScript
    if c.atFileCommands.output_newline == '\r\n':
AttributeError: atFile instance has no attribute 'output_newline'</t>
<t tx="ekr.20050712070251.1234">@killcolor

- Call g.getOutputNewline(c=c) rather than look at atFile.output_newline.

atFile.output_newline may not exist if a) the file is new and b) g.getScript
doesn't call atfile.write.

- Set scripting=scriptWrite in call to atFile.scanAllDirectives in atFile.write.

This suppresses an erroneous message: "No absolute directory specified anywhere." in scripts.

- Rewrote the unit test for g.getScript and renamed it: test_g_getScript_strips_crlf
</t>
<t tx="ekr.20050712070251.1235"></t>
<t tx="ekr.20050712070251.1236">This allows plugins such as plugin_manager.py to work on Python 2.2.x.</t>
<t tx="ekr.20050712070251.1237"></t>
<t tx="ekr.20050712070251.1238"></t>
<t tx="ekr.20050712070251.1239"></t>
<t tx="ekr.20050712070251.1240"></t>
<t tx="ekr.20050712070251.1241">@killcolor

WARNING: This is not correct!

http://sourceforge.net/forum/forum.php?thread_id=1214682&amp;forum_id=10228

Leo can _appear_ to be losing data after a cvs-update when in fact nothing
serious has happened. This is confusing but it doesn't really lose data. This
issue goes back at least to 4.2.

Here is what is happening:

1. There must be a clone in the outline _outside_ of an @thin node, and a
corresponding clone inside an @thin node.

2. One or more of the cloned nodes are _deleted_ in a checked out copy of the
thin derived file. The change is then committed.

3. The data 'loss' happens when reading the updating the file (on another
machine). Leo's read code 'sees' the deleted node because it exists in the
outline outside of the @thin tree, but there is nothing in the node because Leo
intentionally doesn't write a node if it is cloned in any thin file.

So the node looks as if its data has mysteriously disappeared when in fact the
node itself should have been deleted.

The fix will be to remove all 'unreferenced' nodes. I'm not sure why I didn't do
this a long time ago; it may have been an oversight.</t>
<t tx="ekr.20050712070251.1242">@killcolor

- Removed unused ignored param from putVnode.

- Added, then removed &lt;&lt; delete all unvisited nodes &gt;&gt; in atFile.read.
    
    - Thin derived files are completely self contained, only the root node gets saved in the outline.

At present, I have no idea what happened!</t>
<t tx="ekr.20050712070251.1243"></t>
<t tx="ekr.20050712070251.1244"></t>
<t tx="ekr.20050712070251.1245">def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir</t>
<t tx="ekr.20050712070251.1246">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None</t>
<t tx="ekr.20050712070251.1247">def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')</t>
<t tx="ekr.20050712070251.1248">def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding</t>
<t tx="ekr.20050712070251.1249"></t>
<t tx="ekr.20050712070251.1250">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3035871
By: e

open leoPy.leo
exceptions opening: C:\c\leo\V43leos\leo\src\LeoPyRef.leo
Traceback (most recent call last):
  File "c:\c\leo\V43leos\leo\src\leoGlobals.py", line 630, in openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "c:\c\leo\V43leos\leo\src\leoFileCommands.py", line 1285, in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
  File "c:\c\leo\V43leos\leo\src\leoFileCommands.py", line 632, in getLeoFile
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 486, in readAll
    at.read(p,thinFile=True)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 432, in read
    self.copyAllTempBodyStringsToTnodes(root,thinFile)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 2382, in
copyAllTempBodyStringsToTnodes
    c.mod_label_controller.add_label(p,"before change:",old_body)
AttributeError: Commands instance has no attribute 'mod_label_controller'

leo stops loading so a save would lose information?
leo is changed but isn't indicated,
on exit you get the save/cancel popup.</t>
<t tx="ekr.20050712070251.1251"></t>
<t tx="ekr.20050712070251.1252">@killcolor

in LeoDocs.leo in Tangling @root trees with the Tangle commands

the node starts out with the @nocolor directive, but Python keywords
(e.g. 'is', 'for', etc.) are coloured blue anyway.
</t>
<t tx="ekr.20050712070251.1253">def continueDocPart (self,s,i):
    
    state = "doc"
    if self.language == "cweb":
        &lt;&lt; handle cweb doc part &gt;&gt;
    else:
        &lt;&lt; handle noweb doc part &gt;&gt;
    return i,state</t>
<t tx="ekr.20050712070251.1254">word = self.getCwebWord(s,i)
if word and len(word) &gt; 0:
    j = i + len(word)
    if word in ("@&lt;","@(","@c","@d","@f","@p"):
        state = "normal" # end the doc part and rescan
    else:
        # The control code does not end the doc part.
        self.tag("keyword",i,j)
        i = j
        if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
            j = s.find("@&gt;",i)
            if j &gt; -1:
                self.tag("cwebName",i,j)
                self.tag("nameBrackets",j,j+2)
                i = j + 2
elif g.match(s,i,self.lb):
    j = self.doNowebSecRef(s,i)
    if j == i + 2: # not a section ref.
        self.tag("docPart",i,j)
    i = j
elif self.latex_cweb_docs:
    # Everything up to the next "@" is latex colored.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.doLatexLine(s,i,j)
    i = j
else:
    # Everthing up to the next "@" is in the doc part.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.tag("docPart",i,j)
    i = j</t>
<t tx="ekr.20050712070251.1255">if i == 0 and g.match(s,i,"&lt;&lt;"):
    # Possible section definition line.
    return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
    j = self.skip_id(s,i+1,chars='-')
    word = s[i:j]
    word = word.lower()
else:
    word = ""
    
if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
    # End of the doc part.
    self.body.tag_remove("docPart",self.index(i),self.index(j)) # 10/27/03
    self.tag("leoKeyword",i,j)
    state = "normal"
    if word != '@nocolor': i = j # 3/8/05: Rescan @nocolor.
else:
    # The entire line is in the doc part.
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="docPart"):
        self.tag("docPart",i,j)
    i = j # skip the rest of the line.
</t>
<t tx="ekr.20050712070251.1256"></t>
<t tx="ekr.20050712070251.1257">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3035471
By: brianvanden

Leo 4.3 alpha 3, build  1.224 , February 24, 2005
Python 2.4.0, Tk 8.4.7, win32
Windows Me.

Open a leo file with an @wrap directive somewhere within it. Visit a node in
an @wrap subtree (it need not be the node which contains the @wrap directive;
a descendant of such a node will do). The horizontal scrollbar disappears.

Now, visit a node without an @wrap, nor within the scope of an @wrap. The horizontal
scrollbar does not come back, even if the text extends past the edge of the
window.

The only way I have found to get it back is to quit leo and relaunch. Then,
the horizontal scrollbar is in place again, but only until an @wrap node is
visited.

The only forum post I found on point was
&lt;http://sourceforge.net/forum/message.php?msg_id=2171987&gt;, which males me wonder
if the behaviour I observe is a bug that has been introduced in the meantime.

Brian vdB</t>
<t tx="ekr.20050712070251.1258">def setWrap (self,p):
    
    c = self.c
    theDict = g.scanDirectives(c,p)
    if not theDict: return
    
    wrap = theDict.get("wrap")
    if self.body.wrapState == wrap: return

    self.body.wrapState = wrap
    # g.trace(wrap)
    if wrap:
        self.bodyCtrl.configure(wrap="word")
        self.bodyXBar.pack_forget()
    else:
        self.bodyCtrl.configure(wrap="none")
        # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        self.bodyCtrl.pack_forget()
        self.bodyXBar.pack(side="bottom", fill="x")
        self.bodyCtrl.pack(expand=1,fill="both")</t>
<t tx="ekr.20050712070251.1259"></t>
<t tx="ekr.20050712070251.1260">@killcolor

The problem was a race condition: writing to the log disabled the next redraw!

The solution is to put calls to c.endUpdate() after all calls to g.es().

This is a global constraint on all calls to c.endUpdate.  I've made a note of it.

Fixed similar problem with the Mark Changed Headlines and Mark Changed Roots
commands. While I was at it, I converted the code to use c.allNodes_iter().

-------------

A second bug: the current headline wasn't being updated.

Fixed this by _removing_ the calls to:

    c.frame.tree.onHeadChanged(v)
    c.frame.body.onBodyChanged(v,"Can't Undo")

in changeAll.  Apparently these were interfering with later redraws.</t>
<t tx="ekr.20050712070251.1261">@killcolor

https://sourceforge.net/forum/message.php?msg_id=3042593
By: brianvanden

Leo 4.3 alpha 3, build  1.224 , February 24, 2005
Python 2.4.0, Tk 8.4.7, win32

I used the find panel to change all occurrences of some string, say "foobar",
within a Leo file to another, say "spamham". The find panel was configured to
process headline titles, and a visible node had a headline containing "foobar";
it did not appear to have been changed. However, if you collapse a parent node
of the "foobar" containing headline and then re-expand it, the headline now
contains "spamham" as desired.

The principle of least surprise suggest that Leo ought not require the
collapse/expand epicycle to reflect the change. Have I overlooked a good reason
for this behaviour? Assuming not:

My naive (I am almost totally ignorant of Tkinter, not an accomplished Python
programmer, and have read little of Leo's code) armchair analysis makes me think
Leo ought keep track of whether any headline text was changed by a change command,
and if so, automatically repaint the tree.

If a fix for this is more than a few minutes (and thus not trivial enough to
leap to near the top of the `todo' list), I would be interested in seeing what
sense I could make of the situation. In that event, given the naivety mentioned
above, any nudging towards the right direction would be most welcome.</t>
<t tx="ekr.20050712070251.1262">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3045823
By: nobody

Running with latest CVS version. Start Leo. It displays an empty outline with
"NewHeader". Press CTRL-F. Replace "e" with "ZZZ". Select "Plain search", unselect
"whole word", select "entire outline", select "search headline text", unselect
"search body text". Click "Change All". The headline remains unchanged  even
though the log window says it changed 3 instances.

Add a new node. Leave the title "NewHeadline". Click on the first node. Do the
same change operation again. The second headline (unmarked) gets changed; the
first headline (the marked current node) remains unchanged, even though the
log window says it changed 6 occurrences (it really only changed 3).</t>
<t tx="ekr.20050712070251.1263">@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; st = self.s_ctrl ; gui = g.app.gui
    # Replace the selection with self.change_text
    if gui.compareIndices(st,pos1, "&gt;", pos2):
        pos1,pos2=pos2,pos1
    gui.replaceSelectionRangeWithText(st,pos1,pos2,self.change_text)
    s = gui.getAllText(st)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+'+'+str(len(self.change_text))+'c')
    gui.setSelectionRange(st,insert,insert)
    gui.setInsertPoint(st,insert)
    # Update the node
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;</t>
<t tx="ekr.20050712070251.1264">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
    
    u.afterChangeNodeContents(p,'Change Headline',undoData)</t>
<t tx="ekr.20050712070251.1265">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.setBodyStringOrPane(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
     
    u.afterChangeNodeContents(p,'Change Body',undoData)</t>
<t tx="ekr.20050712070251.1266">def changeAll(self):

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    st = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if not pos1: break
            count += 1
            self.batchChange(pos1,pos2)
            line = gui.getLineContainingIndex(st,pos1)
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
        self.restore(saveData)
    c.endUpdate()
</t>
<t tx="ekr.20050712070251.1267"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # Bug fix: Cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.
    self.disableRedraw = True
    self.canvas.update_idletasks()
    self.disableRedraw = False
        
    # Now do the actual redraw.
    self.idle_redraw(scroll=scroll)</t>
<t tx="ekr.20050712070251.1268">def endUpdate(self, flag=True):
    
    '''End a beginUpdate/endUpdate region.
    
    Redraw the tree if this is the outermost endUpdate.
    
    Note that calls to g.es() will disable redraws, so calls to endUpdate
    should follow all such writes to the log pane.'''
    
    
    self.frame.tree.endUpdate(flag)
    
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="ekr.20050712070251.1269">def endUpdate (self,flag=True):
    
    '''Redraw the tree if this is the outermost endUpdate.
    
    Calls to g.es() will disable redraws, so calls to c.endUpdate
    should follow all such writes to the log pane.'''

    assert(self.updateCount &gt; 0)
    self.updateCount -= 1
    # g.trace(self.updateCount, 'disableRedraw',self.disableRedraw)

    if flag and self.updateCount == 0:
        # Bug fix: 3/11/05. Force a redraw here.
        # Writing to the log sets self.disableRedraw.
        self.disableRedraw = False
        self.redraw()</t>
<t tx="ekr.20050712070251.1270"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(self.updateCount,self.redrawScheduled)
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20050712070251.1271">def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    &lt;&lt; return if disabled, or quitting or dragging &gt;&gt;

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            self.canvas.after_idle(self.idle_scrollTo)
        if 0:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20050712070251.1272"># g.trace('disableRedraw',self.disableRedraw)

if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return</t>
<t tx="ekr.20050712070251.1273"></t>
<t tx="ekr.20050712070251.1274"></t>
<t tx="ekr.20050712070251.1275"></t>
<t tx="ekr.20050712070251.1276"></t>
<t tx="ekr.20050712070251.1277"></t>
<t tx="ekr.20050712070251.1278">def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050712070251.1279">def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050712070251.1280"></t>
<t tx="ekr.20050712070251.1281"></t>
<t tx="ekr.20050712070251.1282">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3028085
By: randomandy

I was unable to get the vim plugin working on my Leo. After digging around I
finally discovered that it was an issue with the openWithTempFilePath() method.

The method tries to create a temp directory using the username. But in Windows
at least, user names may contain special characters which cause the tempdir
mkdir to choke. There may be some way to escape some quotes, but my attempt
at it was unsuccessful. I'm sure the layers of quote nesting there don't help
the odds any.

So what I chose to do instead was to just sanitize the directory name being
created with from the user name. (The base path is already sanitized at the
end.) That solved it for my case.  My user name has a period and spaces.
@color

def openWithTempFilePath (self,v,ext):

    """Return the path to the temp file corresponding to v and ext.

    Replaces the Commands method."""    

    try:
        #This allows a loophole
        #leoTempDir = getpass.getuser() + "_" + "Leo"
                   
        #At least in Windows, user name may contain special characters
        #which would require escaping quotes. Not wanting to deal with
        #layers of nested quotes, I chose to just sanitize the directory
        #name.     
        leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
    except:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)

    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)

    name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
    path = os.path.join(td,name)
    return path</t>
<t tx="ekr.20050712070251.1283">@killcolor

This is apparently a fix to the mod_tempfname plugin.</t>
<t tx="ekr.20050712070251.1284"></t>
<t tx="ekr.20050712070251.1285"></t>
<t tx="ekr.20050712070251.1286">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr</t>
<t tx="ekr.20050712070251.1287">@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):

    setattr(theClass,name or f.__name__,f)
    # g.trace(name)</t>
<t tx="ekr.20050712070251.1288"></t>
<t tx="ekr.20050712070251.1289">def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        # Set the focus immediately
        self.frame.treeWantsFocus(p.edit_text(),later=False,tag='setNormalLabelState')</t>
<t tx="ekr.20050712070251.1290">def setDisabledLabelState (self,p): # selected, disabled

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return

    if p and p.edit_text():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20050712070251.1291">def setSelectedLabelState (self,p): # selected, not editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    # g.trace(p)
    self.setDisabledLabelState(p)

</t>
<t tx="ekr.20050712070251.1292">def setUnselectedLabelState (self,p): # not selected.

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    if p and p.edit_text():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20050712070251.1293">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20050712070251.1294">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20050712070251.1295">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20050712070251.1296"></t>
<t tx="ekr.20050712070251.1297">@killcolor

How it used to work:
    
- openWithFileName called 'open1' and 'open2' hooks.

- newLeoCommanderAndFrame called 'after-create-leo-frame' _after_ calling frame.finishCreate.

mod_scripting plugin doesn't create blue buttons if newLeoCommanderAndFrame always calls open1 and open2 hooks.
    - Changing 'open2' to 'open1' in mod_scripting creates other problems.

Conclusions:

1. 'open1' and 'open2' hooks _must_ stay as they are.
    - That is newLeoCommanderAndFrame must NOT call 'open1' and 'open2' hooks!

2. The 'after-create-leo-frame' hook isn't useful for plugins that want to insert menus.
    - In particular, it can not be used to register a 'create-optional-menus' hook.

What I did:

Warning: All the following items (except the first) have a (slight?) chance of impacting existing code.

- Added 'onCreate' hook in newLeoCommanderAndFrame.  This is called just _before_ calling frame.finishCreate.

- newLeoCommanderAndFrame calls 'onCreate' and 'after-create-leo-frame' hooks only if not g.app.initing.  This ensures that plugins won't be bothered with these hooks being while reading leoSettings.leo files.

- Leo clears g.app.initing before calling createFrame in leo.py.  This ensures that 'open1', 'open2', 'onCreate' and 'after-create-leo-frame' hooks get called for the initial window.  (Hopefully this will fix some problems that 'e' mentioned.)

- createFrame in leo.py calls a 'new' hook if createFrame doesn't call g.openWithFileName.  This ensures that a 'new' hook always gets called if an 'open1' and 'open2' hook doesn't get called.</t>
<t tx="ekr.20050712070251.1298">def new (self):

    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    
    # 5/16/03: Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    
    c.beginUpdate()
    if 1: # within update
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    c.endUpdate()

    frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20050712070251.1299"></t>
<t tx="ekr.20050712070251.1300"> </t>
<t tx="ekr.20050712070251.1301">Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 2180, in doHook
    return f(tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 73, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 51, in callTagHandler
    result = handler(tag,keywords)

  File "c:\prog\leoCVS\leo\plugins\mod_scripting.py", line 160, in createAllButtons
    self.createStandardButtons()

  File "c:\prog\leoCVS\leo\plugins\mod_scripting.py", line 238, in createStandardButtons
    c = self.c ; p = c.currentPosition()

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 5232, in currentPosition
    if c._currentPosition:

AttributeError: Commands instance has no attribute '_currentPosition'</t>
<t tx="ekr.20050712070251.1302">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3035661
By: nobody

new mod scripting run script/script button 
is installing twice. not at all on new leo.
from cvs 3/4/05 and 3/7 just now, uses onCreate hook.
may be anomaly or I just
didn't notice it yesterday.

open leo from shortcut
open a recent or new leo, no script buttons
close it
there are another set of script buttons on the first leo!
and then you can't rclick away @buttons in the first leo.
you can when you first open the leo from shortcut.
open leo file does get script buttons.
close it now the first has 3 sets of buttons.

redo the sequence
this time close the first leo, leave the new leo open
and magically script buttons appear where there were none.

replacing the comented out register line using
open2 and new doesn't work anymore in mod_scripting.
same problems w/py2.4 or 2.3 after reboot.
my local copies of a few plugins still work ok.

appropo of your comment about rewritting the hooks:
there was an indirect url to a joel on software artical 
on daily python the other day. from a comment by Guido,
why python 3000 will not be a complete rewrite.
how netscape might have lost valuable time and 
marketshare by rewriting netscape 6 from scratch
with very few of the origional v4 developers to boot.
they even had to completely trash version 5 for 
some possibly unrelated reason. details are fuzzy. 
maybe Internet Explorer was at version 6 
by the time they had a beta ready?
&lt;http://joelonsoftware.com/articles/fog0000000069.html&gt;

e</t>
<t tx="ekr.20050712070251.1303">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3024624
By: e

- Changed 'new_c' logic to 'c' logic.
- Replaced 'start2' hook with 'new' hook.</t>
<t tx="ekr.20050712070251.1304">Changed these plugins:

ConceptualSort.py
macros.py
scheduler.py
templates.py
dyna_menu.py
arrows.py
autocompleter.py
nodenavigator.py
nodebar.py
UASearch.py
URLloader.py
open_with.py
read_only_nodes.py
mod_scripting.py
base64Packager.py
multifile.py
cleo.py
mod_read_dir_outline.py</t>
<t tx="ekr.20050712070251.1305">import_cisco_config.py
scheduler.py
table.py
autocompleter.py
color_markup.py
nodebar.py
UASearch.py
URLloader.py
open_with.py
at_produce.py
read_only_nodes.py
usetemacs.py
xsltWithNodes.py
fastGotoNode.py
groupOperations.py
multifile.py</t>
<t tx="ekr.20050712070251.1306">What I did:
    - Disabled initial scan during unit test.
      The outline was being destroyed before the scan finished.

.Exception in thread Thread-21:
Traceback (most recent call last):
  File "c:\python24\lib\threading.py", line 442, in __bootstrap
    self.run()
  File "c:\python24\lib\threading.py", line 422, in run
    self.__target(*self.__args, **self.__kwargs)
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 440, in scan
    readOutline( c )
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 557, in readOutline
    setLanguage( z )
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 787, in setLanguage
    pos = pos.parent()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1812, in getParent
    def getParent        (self): return self.copy().moveToParent()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1603, in copy
    return position(self.v,self.stack,trace=False)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1547, in __init__
    if v: self.c = v.c
AttributeError: 'vnode' object has no attribute 'c'</t>
<t tx="ekr.20050712070251.1307"></t>
<t tx="ekr.20050712070251.1308">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3044258
By: nobody

The current cvs has broken the emacs/vim plugins. They open the node but the
changes aren't written back to leo.

EKR:  See &lt;&lt; version history &gt;&gt; in each plugin for full details.</t>
<t tx="ekr.20050712070251.1309"></t>
<t tx="ekr.20050712070251.1310"></t>
<t tx="ekr.20050712070251.1311">@killcolor

The essential point is that tnodeLists are a _substitute_ for gnx's. They are
used only for @file trees, not @thin trees.

Writing: When writing an @file putOpenNodeSentinel does:

    at.root.v.t.tnodeList.append(p.v.t)

So the tnodeList is a list of tnodes for the nodes in the order in which they
were written. 

Reading: When reading an @file tree, findChild4 does:

    t = at.root.v.t.tnodeList[at.tnodeListIndex]
    v = t.vnodeList[0] # Get any vnode joined to t.

That is, findChild4 finds a vnode given the next tnode in the tnodeList.

This assumes that the tnodeList (stored in the .leo file) matches the structure
of the thin derived file, which is ok in a single-user environment only.</t>
<t tx="ekr.20050712070251.1312"></t>
<t tx="ekr.20050712070251.1313"></t>
<t tx="ekr.20050712070251.1314"></t>
<t tx="ekr.20050712070251.1315"></t>
<t tx="ekr.20050712070251.1316">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3048149
By: bwmulder

Create a node with some code:

x = 0
import pdb; pdb.set_trace()
y = 1
z = z + 1

And then either use the "run_script" button from the plugin, or "execute script"
from the menu. You get:


&gt;&gt; &lt;string&gt;(5)?()

(Pdb) s

&gt;&gt; &lt;string&gt;(6)?()

(Pdb) s
NameError: "name 'z' is not defined"

&gt;&gt; &lt;string&gt;(6)?()

(Pdb) s
NameError: "name 'z' is not defined"

&gt;&gt; c:\bwm\svn_checkouts\oracle_ipf\trunk\python\other\leo_cvs\src\leocommands.py(

1195)executeScript()
-&gt; exec script in d # Use {} to get a pristine environment!

[Assuming that you have a DOS window in which you started leo.py].

The debugger indicates some line numbers, but no source lines.

When you remove the import line, you just get:

exception executing script 
NameError: name 'z' is not defined</t>
<t tx="ekr.20050712070251.1317">@killcolor

The problem arose from a misguided attempt to eliminate non-useful information from traces.  Alas, the baby got thrown out with the bath water.

Here are the changes I made:

 - c.executeScript now calls g.es_exception(full=True) to ensure that a full stack trace always gets produced.  This is especially important when the exception happens in a module (file) called by the script.

-  c.executeScript now always executes the section &lt; &lt; dump the lines near the error &gt; &gt;,  regardless of context.  The lines are printed (in black) in the log.  This is useful information in almost all cases.

- After much experimentation, g.es_exception is basically unchanged.

Note: If the error occurs in your script itself (as contrasted with an exception thrown from a file called by your script) Leo always has properly put the cursor on the offending line.  I made no changes in this logic.

BTW, calling pdb.set_trace() in your scripts may cause more problems than it is worth.  Indeed.pdb.set_trace() uses only the information on the stack, and that may not be enough information to be useful.  I usually use g.trace to find out what is happening.  This works well.</t>
<t tx="ekr.20050712070251.1318">def executeScript (name):
    
    """Execute a script whose short python file name is given"""
    
    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except:
        g.es("Exception executing " + name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()</t>
<t tx="ekr.20050712070251.1319"></t>
<t tx="ekr.20050712070251.1320">def dump(s):
    
    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out
        
def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out</t>
<t tx="ekr.20050712070251.1321">def es_error (s,color=None):

    if color is None and g.app.config: # May not exist during initialization.
        color = g.app.config.getColor(None,"log_error_color")

    g.es(s,color=color)</t>
<t tx="ekr.20050712070251.1322">def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)
        
    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()</t>
<t tx="ekr.20050712070251.1323">def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b</t>
<t tx="ekr.20050712070251.1324">def printGlobals(message=None):
    
    # Get the list of globals.
    globs = list(globals())
    globs.sort()
    
    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    for glob in globs:
        print glob</t>
<t tx="ekr.20050712070251.1325">def printLeoModules(message=None):
    
    # Create the list.
    mods = []
    for name in sys.modules.keys():
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    mods.sort()
    for m in mods:
        print m,
    print</t>
<t tx="ekr.20050712070251.1326"></t>
<t tx="ekr.20050712070251.1327">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053699
By: nobody

I also struggled with leoID after changing from v4.2 to v4.3 on Windows (I started
http://sourceforge.net/forum/forum.php?thread_id=1240664&amp;forum_id=10226).

Without HOME environmental variable or sitecustomize.py Leo creates leoID.txt
in the current working directory, not in the globalConfigDir as before.
My understanding is that HOME is not typically present on Windows, so this could
keep confusing HOME-less windows users.

The problem is computeHomeDir(). It returns current working directory if HOME
does not exist. From computeHomeDir() definition:

home = os.getenv('HOME',default=None) # home = None
home = g.os_path_abspath(home,encoding) # current working directory!

Note that it does not help if computeHomeDir() returns None. In that case
f = open(fn,'w') in
Code--&gt;Core classes...--&gt;@thin leoApp.py--&gt;app.setLeoID--&gt;&lt;&lt; attempt to create
leoID.txt &gt;&gt;
still creates '.leoID.txt' in the current directory.

Things that work if HOME does not exist (not sure if work on Mac and Win98):
from user import home
os.path.expanduser('~')

Hope this is useful.

'vpe'

_____________________</t>
<t tx="ekr.20050712070251.1328">@killcolor

There were three similar bugs, all arising from the fact that g.os_path_abs and g.os_path_join return the _working_ directory if the initial path is None!

I removed my HOME directory for testing.  This was essential.

- Compute home directory must return None, rather than the working directory if the HOME variable is None.

- app.setLeoId must be careful (in two sections) to do nothing if any of (homeDir,globalConfigDir,loadDir) is None.</t>
<t tx="ekr.20050712070251.1329"></t>
<t tx="ekr.20050712070251.1330">@killcolor

The problem is that newButtons must use @nosent, so any changes to newButtons must be accompanied by a change to LeoPluginsRef.py.  There is nothing more that needs to be done.</t>
<t tx="ekr.20050712070251.1331">Warning: updating changed text in @file-noref newButtons.py
----- error reading @file: newButtons.py
bad tnodeList index: 14, &lt;vnode 22734128:'@file-noref newButtons.py'&gt;

</t>
<t tx="ekr.20050712070251.1332"># The De-hoist command conflicted with the Expand/Contract submenu.
# Also, the Paste Node As Clone conflicted with the Mark submenu.</t>
<t tx="ekr.20050712070251.1333"></t>
<t tx="ekr.20050712070251.1334">@killcolor

g.app.gui typically not defined when the config settings are loaded, so to use a
setting in @if-gui a plugin would have to call g.app.config.readSettingsFiles.</t>
<t tx="ekr.20050712070251.1335">def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind)) or self.doComment
    if f is not None:
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
            return None</t>
<t tx="ekr.20050712070251.1336">def visitNode (self,p):
    
    """Init any settings found in node p."""
    
    # g.trace(p.headString())
    
    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind == "settings":
        pass
    elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all data types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
    elif name:
        # self.error("unknown type %s for setting %s" % (kind,name))
        # Just assume the type is a string.
        self.set(p,kind,name,val)
    
    return None</t>
<t tx="ekr.20050712070251.1337">def traverse (self):
    
    c = self.c
    
    p = g.app.config.settingsRoot(c)
    if not p:
        return None

    self.settingsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            s = 'skipping settings in %s' % p.headString()
            g.es_print(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
            
    return self.settingsDict</t>
<t tx="ekr.20050712070251.1338">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20050712070251.1339"></t>
<t tx="ekr.20050712070251.1340">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1341">def doColor (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1342">def doDirectory (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory</t>
<t tx="ekr.20050712070251.1343">def doFloat (self,p,kind,name,val):
    
    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1344">def doIf(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None</t>
<t tx="ekr.20050712070251.1345">def doIfGui (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.
    
    # g.trace(repr(name))
    
    if not g.app.gui or not g.app.gui.guiName():
        s = '@if-gui has no effect: g.app.gui not defined yet'
        g.es_print(s,color='blue')
        return "skip"
    elif g.app.gui.guiName().lower() == name.lower():
        return None
    else:
        return "skip"</t>
<t tx="ekr.20050712070251.1346">def doIfPlatform (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.
    
    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"</t>
<t tx="ekr.20050712070251.1347">def doIgnore(self,p,kind,name,val):

    return "skip"</t>
<t tx="ekr.20050712070251.1348">def doInt (self,p,kind,name,val):
    
    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1349">def doInts (self,p,kind,name,val):
    
    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')
    
    # g.trace(kind,name,val)

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1350">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.</t>
<t tx="ekr.20050712070251.1351">def doRatio (self,p,kind,name,val):
    
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1352">def doString (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20050712070251.1353">def doStrings (self,p,kind,name,val):
    
    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''
    
    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)</t>
<t tx="ekr.20050712070251.1354">def valueError (self,p,kind,name,val):
    
    """Give an error: val is not valid for kind."""
    
    __pychecker__ = '--no-argsused' # p not used, but needed.
    
    self.error("%s is not a valid %s for %s" % (val,kind,name))</t>
<t tx="ekr.20050712070251.1355"></t>
<t tx="ekr.20050712070251.1356">@killcolor

&gt; I...change the @settings node to @string server = mail.otherisp.net

the script doesn't print  -mail.otherisp.net-
until I restart Leo.

# EKR:  The change _is_ available if the change is made from the settings panel.  However, it is not available if the change is made in the Leo outline.  So opening the settings dialog should reload the files!

g.app.config.readSettingsFiles(c.fileName(),verbose=True) reloads all settings files.</t>
<t tx="ekr.20050712070251.1357">@killcolor

The status bits weren't being passed to v.initStatus.</t>
<t tx="ekr.20050712070251.1358">Exception executing command
Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1418, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1442, in undoDeleteNode
    elif u.parent:
AttributeError: undoer instance has no attribute 'parent'

</t>
<t tx="ekr.20050712070251.1359">def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    c.selectPosition(u.p)</t>
<t tx="ekr.20050712070251.1360">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 863, in importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 137, in importDerivedFiles
    isThin = at.scanHeaderForThin(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 570, in scanHeaderForThin
    junk,junk,isThin = at.scanHeader(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2616, in scanHeader
    at.error("Bad @+leo sentinel in: %s" % fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4500, in error
    self.printError(message)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4509, in printError
    if self.errors == 0:
AttributeError: atFile instance has no attribute 'errors'
</t>
<t tx="ekr.20050712070251.1361"></t>
<t tx="ekr.20050712070251.1362">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1409, in idle_scrollTo
    h1 = self.yoffset(p)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1488, in yoffset
    h, flag = self.yoffsetTree(root,v1)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1506, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)
  
# Maximum recursion depth exceeded.</t>
<t tx="ekr.20050712070251.1363">def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()</t>
<t tx="ekr.20050712070251.1364">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20050712070251.1365">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20050712070251.1366">def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        __pychecker__ = '--no-argsused' # event not used.

        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)</t>
<t tx="ekr.20050712070251.1367">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20050712070251.1368"></t>
<t tx="ekr.20050712070251.1369"></t>
<t tx="ekr.20050712070251.1370">@killcolor

- Moved computeGlobalConfigDir, computeHomeDir, computeLoadDir and startupEncoding from leo.py to leoGlobals.py.

- Created g.computeStandardDirectories and used it in leo.py.

- Created g.createStandAloneApp using the above functions.  This function was based on the 'Standalone Operation' classed in the plugin_manager plugin.  g.createStandAloneApp doesn't actually use any of these classes because the nullGui class is basically a clumsier version of the BlackHole class.

- Added a do-nothing attachLeoIcon method to nullGui class to suppress a warning.  As I said, the nullGui class is not as elegant as Paul's BlackHole class.

- Added &lt;&lt;importLeoGlobals&gt;&gt; button to newButtons plugin.  This creates a node named
  &lt;&lt; define importLeoGlobals &gt;&gt; whose body text defines an importLeoGlobals function.

The idea is that importing leoGlobals from a stand-alone plugin is a bit tricky.  The importLeoGlobals handles these details.  Note that we don't want to define importLeoGlobals in a node included by @others, because this function must be available to the code in the &lt;&lt; imports &gt;&gt; section.  So we use a named section and reference it in before referencing the &lt;&lt; imports &gt;&gt; section.  See the plugin_manager plugin for an example.

- Changed the plugin_manager plugin as follows:
    - Used the newButtons plugin to add an &lt;&lt; define importLeoGlobals &gt;&gt; section.
    - Simplified the import logic using importLeoGlobals function.
    - Commented out the Standalone Operation classes.
    - Called g.createStandAloneApp in the '__name__ == "__main__"' code.

The new code passes all unit tests.  It's not too surprising that g.createStandAloneApp works in the plugin_manager plugin because all the new code was based on the old plugin_manager code.  Still, I believe the new code will be generally useful.</t>
<t tx="ekr.20050712070251.1371">def createStandAloneApp(pluginName=''):
    
    '''Create a version of the g.app object for 'stand-alone' plugins.'''
    
    if not g.app:
        Tk = g.importExtension('Tkinter',pluginName=pluginName,verbose=True)
        if Tk:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            g.app.gui = leoGui.nullGui('&lt;stand-alone app gui&gt;')
            g.computeStandardDirectories()
    return g.app</t>
<t tx="ekr.20050712070251.1372"></t>
<t tx="ekr.20050712070251.1373">@killcolor

- config.openSettingsFile returns None if there is a read error.
- leoFileCommand.open gives no BadLeoFile message if silent is True.</t>
<t tx="ekr.20050712070251.1374">Or better yet, use CStringIO?</t>
<t tx="ekr.20050712070251.1375">@killcolor

- Simplified write_Leo_file using new leoFileCommand.deleteFileWithMessage and g.utils_rename.

- Eliminated outputList var.
    - The code that writes to a clipboard sets self.outputFile to g.fileLikeObject.

- Speeded up put routine: it always writes to self.outputFile.

- self.outputFile is now a cStringIo object.  However, the heart of the put routine is:

    s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
    self.outputFile.write(s)

and it appears that the call to g.toEncodedString is the limiting factor.</t>
<t tx="ekr.20050712070251.1376"></t>
<t tx="ekr.20050712070251.1377"></t>
<t tx="ekr.20050712070251.1378">def put (self,s):
    '''
    Put string s to self.outputFile.
    All output eventually comes here.
    '''
    # Improved code: self.outputFile (a cStringIO object) always exists.
    if s:
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        self.outputFile.write(s)

def put_dquote (self):
    self.put('"')
        
def put_dquoted_bool (self,b):
    if b: self.put('"1"')
    else: self.put('"0"')
        
def put_flag (self,a,b):
    if a:
        self.put(" ") ; self.put(b) ; self.put('="1"')
        
def put_in_dquotes (self,a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')

def put_nl (self):
    self.put("\n")
    
def put_tab (self):
    self.put("\t")
    
def put_tabs (self,n):
    while n &gt; 0:
        self.put("\t")
        n -= 1</t>
<t tx="ekr.20050712070251.1379"># Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

    self.outputFile = g.fileLikeObject()
    self.usingClipboard = True
    self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
    self.putProlog()
    self.putClipboardHeader()
    self.putVnodes()
    self.putTnodes()
    self.putPostlog()
    s = self.outputFile.getvalue()
    self.outputFile = None
    self.usingClipboard = False
    return s</t>
<t tx="ekr.20050712070251.1380">def deleteFileWithMessage(self,fileName,kind):
    
    __pychecker__ = '--no-argsused' # kind unused: retained for debugging.

    try:
        os.remove(fileName)

    except Exception:
        if self.read_only:
            g.es("read only",color="red")
        g.es("exception deleting backup file:" + fileName)
        g.es_exception(full=False)
        return False</t>
<t tx="ekr.20050712070251.1381">def test_fc_deleteFileWithMessage(self):

    fc=c.fileCommands # Self is a dummy argument.
    fc.deleteFileWithMessage('xyzzy','test')
    
if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)</t>
<t tx="ekr.20050712070251.1382"></t>
<t tx="ekr.20050712070251.1383">@nocolor

- Use the old generalized code?
    - Yes!  The old code works.
    - The new code should just repackage the old code.
- Use g.Bunch to simplify code.
- Added 'before' &amp; 'after' methods
- Added entries to optionalIvars dynamically in bead methods.
- Eliminated 'case-itis' by making it unnessesary ever to add more cases.
- Removed 'v' key in undoer:  replaced it with 'p'.
- Replaced u.v by u.p and v by p in find code (It's too confusing).
- p.setDirty and p.setAllAncestorAtFileNodesDirty  return list of nodes that were marked dirty.
- Create new top-level before/after methods &amp; helpers:
    before/afterClone
    before/afterDeleteNode
    before/afterInsertNode
    before/afterHoist
    before/afterDeHoist
- Changed setUndoTypingParams to use new dispatch method.
    - (Undo/redo typing now works again.)
- Removed makeBeadDict.
- Removed updateSetChangedFlag.
- Added new methods to nullUndoer class.
- Moved undo methods from leoNodes.py to leoUndo.py
- Added dirtyVnodeList param to afterChangeNodeContents.
@color</t>
<t tx="ekr.20050712070251.1384"></t>
<t tx="ekr.20050712070251.1385"></t>
<t tx="ekr.20050712070251.1386"></t>
<t tx="ekr.20050712070251.1387"></t>
<t tx="ekr.20050712070251.1388">def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()</t>
<t tx="ekr.20050712070251.1389">def copyOutline(self):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)</t>
<t tx="ekr.20050712070251.1390"></t>
<t tx="ekr.20050712070251.1391">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
    
    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True</t>
<t tx="ekr.20050712070251.1392">def deleteOutline (self,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing() # Make sure we capture the headline for Undo.
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
    c.validateOutline()</t>
<t tx="ekr.20050712070251.1393">def clone (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    if 1: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    c.endUpdate()

    return clone # For mod_labels plugin.</t>
<t tx="ekr.20050712070251.1394"># Makes sure all nodes are valid.

def validateOutline (self):

    c = self
    
    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True</t>
<t tx="ekr.20050712070251.1395">def sortChildren(self):

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    if 1: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1396">def sortChildrenHelper (self,p):
    
    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1</t>
<t tx="ekr.20050712070251.1397">def sortSiblings (self):
    
    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        if 1: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20050712070251.1398">def sortTopLevel (self):

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()
 
    c.beginUpdate()
    if 1: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1399"></t>
<t tx="ekr.20050712070251.1400">def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    if 1: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20050712070251.1401">def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    if 1: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20050712070251.1402">def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList</t>
<t tx="ekr.20050712070251.1403">def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList</t>
<t tx="ekr.20050712070251.1404">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p</t>
<t tx="ekr.20050712070251.1405">def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050712070251.1406">def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1407">def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    c.endUpdate()</t>
<t tx="ekr.20050712070251.1408">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return</t>
<t tx="ekr.20050712070251.1409">def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()</t>
<t tx="ekr.20050712070251.1410">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]</t>
<t tx="ekr.20050712070251.1411">def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool</t>
<t tx="ekr.20050712070251.1412">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)</t>
<t tx="ekr.20050712070251.1413">def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)</t>
<t tx="ekr.20050712070251.1414"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="ekr.20050712070251.1415">def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview</t>
<t tx="ekr.20050712070251.1416">def indentBody (self):

    c = self ; undoType = 'Indent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050712070251.1417">def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(p,undoType,oldSel=oldSel)</t>
<t tx="ekr.20050712070251.1418">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20050712070251.1419">def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;</t>
<t tx="ekr.20050712070251.1420">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL</t>
<t tx="ekr.20050712070251.1421">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20050712070251.1422"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20050712070251.1423">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()</t>
<t tx="ekr.20050712070251.1424">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo by calling setUndoTypingParams (in idle_body_key).
    body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    if 1: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList</t>
<t tx="ekr.20050712070251.1425"></t>
<t tx="ekr.20050712070251.1426">def demote(self):

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext(): return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(current)
    c.endUpdate()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1427">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
            c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1428">if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)</t>
<t tx="ekr.20050712070251.1429">def moveOutlineLeft(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasParent(): return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1430">def moveOutlineRight(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1431">def moveOutlineUp(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        return

    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1432">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)</t>
<t tx="ekr.20050712070251.1433">def promote(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren(): return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20050712070251.1434"></t>
<t tx="ekr.20050712070251.1435">def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty() # 1/12/04
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.</t>
<t tx="ekr.20050712070251.1436">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    
    c.beginUpdate()
    if 1: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone(p) # Creates clone &amp; dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete(p) # Destroys clone and makes p the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20050712070251.1437">def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.</t>
<t tx="ekr.20050712070251.1438">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    if 1: # In update...
        clone = p.clone(p) # Creates clone.  Does not set undo.
        # g.trace("p,after:",p.headString(),after.headString())
        if not c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            # g.trace("invalid clone drag")
            clone.doDelete(p) # Destroys clone &amp; dependents. Makes p the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        inAtIgnoreRange = clone.inAtIgnoreRange()
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveAfter(after)
        if inAtIgnoreRange and not clone.inAtIgnoreRange():
            # The moved node have just become newly unignored.
            dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20050712070251.1439">def readAtFileNodes (self):

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    
    c.fileCommands.readAtFileNodes()
    
    u.afterChangeTree(p,'Read @file Nodes',undoData)</t>
<t tx="ekr.20050712070251.1440"></t>
<t tx="ekr.20050712070251.1441"></t>
<t tx="ekr.20050712070251.1442">def importFlattenedOutline (self,files):

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    &lt;&lt; Read the file into array &gt;&gt;

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")</t>
<t tx="ekr.20050712070251.1443">try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
</t>
<t tx="ekr.20050712070251.1444">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)
    
    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        p.setBodyStringOrPane("@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p</t>
<t tx="ekr.20050712070251.1445"></t>
<t tx="ekr.20050712070251.1446">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        &lt;&lt; update p &gt;&gt;
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"</t>
<t tx="ekr.20050712070251.1447">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20050712070251.1448">self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20050712070251.1449">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) &gt; limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20050712070251.1450">c.beginUpdate()
if 1: # In update...

    # Update changed bit.
    if not c.changed:
        c.setChanged(True)

    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()

    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)

c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20050712070251.1451"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20050712070251.1452">if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20050712070251.1453"></t>
<t tx="ekr.20050712070251.1454"></t>
<t tx="ekr.20050712070251.1455">@killcolor

By: Graham Horler - grahamh
 paste retaining clones bug: old data zaps new   
2005-01-27 12:31  
Leo 4.3 alpha 1, build 1.208 , January 24, 2005 
Python 2.3.4, Tk 8.4.7-1, Debian GNU/Linux 3.0 
 
(Please excuse my leo-newbieness) 
 
Is this a bug?: 
 
Create a new headline "Head1", insert some body text. 
Click Outline/Copy Node. 
Type some more body text in "Head1" and change its name to "Head1a". 
Create another headline "Head2". 
Click Outline/Paste Retaining Clones. 
Your changes to "Head1" are destroyed (bug 1). 
Undo does NOT undo the destruction (bug 2) 
 
Hope this helps, Graham
 
</t>
<t tx="ekr.20050712070251.1456">@killcolor

&gt; Edward wants to empty the undo stack. So all should still behave as expected if you do copy / paste retaining clones without making changes in between, except that you might loose undo and get pestered with warnings.  
 
You have just convinced me that clearing the undo stack and issuing a warning is not good.
 
Besides, it should be possible to undo Paste As Clone. The paste code "just" needs to create a list of changed nodes. This list must be created while pasting; it can not be created after the fact. 
 
I put quotes around the word 'just' above because the paste code is, in fact, quite complex. The difficult part is in leoFileCommands.getVnode, and I suspect that this is the part that must remember changed data.

4/18/05:  The code actually remembers _all_ body and headline text in the entire outline.  It probably should also remember marks, but it doesn't...</t>
<t tx="ekr.20050712070251.1457"></t>
<t tx="ekr.20050712070251.1458">def getTnode (self):

    # we have already matched &lt;t.
    index = -1 ; attrDict = {}
    # New in version 1.7: attributes may appear in any order.
    while 1:	
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag("&gt;"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    &lt;&lt; handle unknown attributes &gt;&gt;
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("&lt;/t&gt;")</t>
<t tx="ekr.20050712070251.1459">keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        g.es_print(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)</t>
<t tx="ekr.20050712070251.1460">def getExistingVnode (self,tref,headline):

    assert(tref &gt; -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None</t>
<t tx="ekr.20050712070251.1461">def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(c,t)
        v.moveToRoot()

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) &gt; 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    &lt;&lt; handle unknown vnode attributes &gt;&gt;
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip</t>
<t tx="ekr.20050712070251.1462">keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)</t>
<t tx="ekr.20050712070251.1463"></t>
<t tx="ekr.20050712070251.1464">def putTnode (self,t):

    self.put("&lt;t")
    self.put(" tx=")

    gnx = g.app.nodeIndices.toString(t.fileIndex)
    self.put_in_dquotes(gnx)

    if hasattr(t,"unknownAttributes"):
        self.putUnknownAttributes(t)

    self.put("&gt;")

    # g.trace(t)
    if t.bodyString:
        self.putEscapedString(t.bodyString)

    self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="ekr.20050712070251.1465"></t>
<t tx="ekr.20050712070251.1466">def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    
    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    
    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch</t>
<t tx="ekr.20050712070251.1467">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    
    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()</t>
<t tx="ekr.20050712070251.1468">def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.p)</t>
<t tx="ekr.20050712070251.1469">def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)</t>
<t tx="ekr.20050712070251.1470"></t>
<t tx="ekr.20050712070251.1471">@killcolor

I have been going round and round with ideas for improving uA's.  The more I think about this issue, the more I am inclined to make absolutely the minimal changes possible.

My first thought was to define new xml elements that could be embedded in &lt;v&gt; and &lt;t&gt; elements.  This would be the natural way to extend Leo's file format from an xml purist's point of view.  However,   I absolutely want to avoid trying to define a set of xml elements that will magically be perfect for all plugins.  This way madness lies: I couldn't bear to entertain endless proposals for further 'improvements'.

Moreover, I'm not sure a new set of elements embedded in &lt;v&gt; and &lt;t&gt; elements actually addresses the present requests.  There are two such requests:

1. The first was originally from Martin Clifford.  The request was not to pickle and hexlify plain strings.  (BTW, Martin has already worked around the problem on his own.)  This request makes sense: we would like allow myAttrib="myAttribute" to remain readable in the xml file if "myAttribute" is a plain string.

2. The second was from BH, aka Leo User.  The request was to allow base64 values as the value of attributes.  Like this:  myAttrib="base64value".

What if we don't change Leo's file format at all?  What if we just change how Leo encodes and decodes items in t.unknownAttributes and v.unknownAttributes?

Absent new information from the file format, the only way to tell Leo how to write attributes is to use naming conventions.  The idea is that when writing attributes, Leo will do the following:

- Do nothing except apply xml escapes if the attribute name (in t.unknownAttributes or v.unknownAttributes) starts with str_ and the attribute is, in fact, a string.  If the string is a Unicode string Leo must convert the Unicode string to an encoded string.

- Try to convert the value to base64 if the attribute names starts with base64_.  Fall back to the present pickling/hexlifying scheming if converting to base64 fails.

- Use the present pickling/hexlifying scheming otherwise.  In particular, issue a warning and ignore the attribute if the attribute can not be pickled.

Leo will do the reverse when reading.

BTW, plugins could add their own naming conventions in an emergency.  Indeed, the conventions will be confined to code in atFile.putUa and atFile.getUa, so a plugin would only need to override these two methods.</t>
<t tx="ekr.20050712070251.1472"></t>
<t tx="ekr.20050712070251.1473">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of g.Bunches rather
than a list of tuples.  Each of these bunches could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR</t>
<t tx="ekr.20050712070251.1474">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20050712070251.1475">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20050712070251.1476">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20050712070251.1477">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20050712070251.1478">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20050712070251.1479">pass</t>
<t tx="ekr.20050712070251.1480">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20050712070251.1481">pass</t>
<t tx="ekr.20050712070251.1482"></t>
<t tx="ekr.20050712070251.1483">@nocolor</t>
<t tx="ekr.20050712070251.1484">New in 4.0: Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt; elements.  Everything else is a foreign attribute.

New in 4.2: The "marks", "expanded" and "descendentTnodeUnknownAttributes" attributes are "native" attribute of &lt;v&gt; elements.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about how to avoid potential conflicts in naming new attributes.

New in 4.2:

All members of these dictionaries should be "pickleable".  That is, Leo uses Python's Pickle module to encode all values in these dictionaries.  Leo will discard any attributes that can not be pickled.  This should not be a major problem to plugins.  For example, instead of putting a tnode into these dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

Leo writes only t.unknownAttributes when writing @thin trees to the .leo file.  Leo puts (the encoding of) these elements into an attribute called descendentTnodeUnknownAttributes.  This attribute is part of the &lt;v&gt; element representing the @thin node.

The reason Leo does _not_ write v.unknownAttributes in @thin trees is that only tnodes have gnx's in thin derived files.  In effect, vnodes are anonymous.  We could attempt to get around this by identifying vnodes by their corresponding tnodes, but that's not a general solution and it is, in effect, equivalent to writing only t.unknownAttributes.  So it seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using unknownAttributes is concerned.  This won't work in all cases.  For example, a plugin that creates an arbitrary directed graph between vnodes must distinguish between joined vnodes.  In that case, the plugin should confine itself to @file trees, or just vnodes in .leo files, for that matter.</t>
<t tx="ekr.20050712070251.1485">Plugins may create (or add to) v.tempAttributes (for vnodes) or t.tempAttributes (for tnodes).  These will work just like the corresponding unknownAttributes dicts except that Leo will _not_ read or write these dictionaries when reading or writing files.  Note: nothing needs to change in Leo to support this convention.</t>
<t tx="ekr.20050712070251.1486">@nocolor

We wish to avoid the possibility that two plugins might unwittingly choose the same name for attributes in the unknownAttributes or tempAttributes dictionaries.  The following convention eliminates that possibility.

Each plugin should create its own dictionary _inside_ any tempAttributes or unknownAttributes dictionaries that it intends to create or modify.  Something like this:

@color

# Create the tempAttributes dict for this vnode.
if not v.hasattr("tempAttributes"):
	v.tempAttributes = {}

# Create a subdictionary for the private use of my plugin.
d = v.tempAttributes.get("myPluginName")
if d is None:
	v.tempAttributes["myPluginName"] = d = {}

@nocolor

Now the plugin can set and get fields in d.  Similar code would be used for the t.tempAttributes, v.unknownAttributes and t.unknownAttributes dictionaries.</t>
<t tx="ekr.20050712070251.1487"></t>
<t tx="ekr.20050712070251.1488"></t>
<t tx="ekr.20050712070251.1489">def getDescendentAttributes (self,s,tag=""):
    
    '''s is a list of gnx's, separated by commas from a &lt;v&gt; or &lt;t&gt; element.
    Parses s into a list.
    
    This is used to record marked and expanded nodes.
    '''
    
    __pychecker__ = '--no-argsused' # tag used only for debugging.

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) &gt; 0]
    # g.trace(tag,result)
    return result
</t>
<t tx="ekr.20050712070251.1490"># Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        return None</t>
<t tx="ekr.20050712070251.1491"></t>
<t tx="ekr.20050712070251.1492">def putDescendentUnknownAttributes (self,p):

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                tnodes.append((p,t),)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodes:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            for key in d.keys():
                try: pickle.dumps(d[key],bin=True)
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict"
        for key in resultDict:
            print ; print key,resultDict[key]
        
    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            s = pickle.dumps(resultDict,bin=True)
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            self.put(field)
        except pickle.PicklingError:
            g.trace("can't happen",color="red")</t>
<t tx="ekr.20050712070251.1493">def putUa (self,torv,key,val):
    
    '''Put attribute whose name is key and value is val to the output stream.'''
    
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,self.xmlEscape(val))
            self.put(attr)
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
        return
    try:
        try:
            # Protocol argument is new in Python 2.3
            # Use protocol 1 for compatibility with bin.
            s = pickle.dumps(val,protocol=1)
        except TypeError:
            s = pickle.dumps(val,bin=True)
        attr = ' %s="%s"' % (key,binascii.hexlify(s))
        self.put(attr)

    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")</t>
<t tx="ekr.20050712070251.1494">@nocolor

Removed inAtOthers  param from putOpen/CloseNodeSentinel.
Removed inAtAll param from putCloseNodeSentinel.
Removed putCloseSentinel param from putAtAllBody
Removed putCloseSentinel param from putBody

Removed toString param from openFileForWritingHelper
Removed toString param from v.putUnknownAttributes

Note: most(all?) top-level atFile.write methods pass toString to initWriteIvars.</t>
<t tx="ekr.20050712070251.1495"></t>
<t tx="ekr.20050712070251.1496">def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20050712070251.1497">def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20050712070251.1498"></t>
<t tx="ekr.20050712070251.1499">@killcolor

- Properly implemented undo/redo Clear Recent Files.

- readSettingsFiles now reads @recentfiles nodes from all settings files.

- Created @settings nodes and @recent-files nodes if they do not exist.</t>
<t tx="ekr.20050712070251.1500">@killcolor

You all have convinced me that storing recent files data in .leo files is a dubious idea. My new plan is as follows:

1. Leo will store recent files info in files called .leoRecentFiles.txt.  These will be a plain text files with one line per recent files entry.  These will be local files, so problems concerning directory structure and path specifications should go away.

2.  On startup, Leo will search for the .leoRecentFiles.txt files in the user's home directory, if it exists.  Leo will look in Leo's config directory next, but only if the home directory does not exist, or does not contain a .leoRecentFiles.txt file.  In other words, Leo will use at most one .leoRecentFiles.txt file on startup.

3.  When opening a .leo file, Leo will look for .leoRecentFiles.txt in the directory containing the file.

4.  At no time after installation will Leo create any .leoRecentFiles.txt file.  This will allow users (or their managers) to set policy regarding where to store this information (if anywhere).

5.  Leo will write at most one .leoRecentFiles.txt file when saving a .leo file, namely the file read in item 3 if it exists, or the file read in item 2 otherwise.

6.  Leo will have settings to tell which .leoRecentFiles.txt files may be written.

7. Leo will never create @settings nodes or @recent-files nodes automatically.  Moreover, I shall remove the @recent-files panel from the settings dialog and the corresponding @recent-files code from the config classes.

I believe this will address everyone's concerns without the need for resolving thorny questions about exactly where recent files info belongs.

</t>
<t tx="ekr.20050712070251.1501"></t>
<t tx="ekr.20050712070251.1502">def readRecentFilesFile (self,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'

    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    
    if not g.os_path_exists(fileName):
        # g.trace('----- no file',kind,fileName)
        return

    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return
            
    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20050712070251.1503">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        # g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)</t>
<t tx="ekr.20050712070251.1504">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()</t>
<t tx="ekr.20050712070251.1505"></t>
<t tx="ekr.20050712070251.1506"># This means that Leo writes all config files whenever the user chooses OK.</t>
<t tx="ekr.20050712070251.1507">def copyExpansionState(self,p1,p2):
 
    # Don't depend on p.nodeAfterTree, etc.
    if p1.isExpanded():
        # g.trace("p1",p1)
        # g.trace("p2",p2)
        p2.expand()
        child1 = p1.firstChild()
        child2 = p2.firstChild()
        while child1:
            self.copyExpansionState(child1,child2)
            child1 = child1.next()
            child2 = child2.next()</t>
<t tx="ekr.20050712070251.1508">def createSettingsTree (self):
    
    """Create a tree of vnodes representing all settings."""

    createEmptyRootNodes = False
    c = self.c ; config = g.app.config
    root_p = None ; last_p = None
    for kind,path,otherFileFlag in (
        ("Global",config.globalConfigFile,True),
        ("Home",config.homeFile,True),
        ("Local",c.fileName(),False),
    ):
        if path:
            if otherFileFlag: c2 = config.openSettingsFile(path)
            else: c2 = c
            root2 = g.app.config.settingsRoot(c2)
        else:
            root2 = None
        if root2 or createEmptyRootNodes:
            &lt;&lt; create a node p for kind &amp; root2 &gt;&gt;
    if self.createSummaryNode: root_p.expand()
    return root_p</t>
<t tx="ekr.20050712070251.1509">if not root_p:
    t = leoNodes.tnode()
    root_v = leoNodes.vnode(c,t) # Using c2 --&gt; oops: nullTree.
    root_p = leoNodes.position(root_v,[])
    if self.createSummaryNode:
        root_p.initHeadString("All settings")
        root_p.scriptSetBodyString(self.rootNodeComments())
        p = root_p.insertAsLastChild()
    else:
        p = root_p.copy()
    last_p = p.copy()
else:
    # Pychecker may complain, but last_p _is_ defined here!
    p = last_p.insertAfter()
    last_p = p.copy()

if root2:
    root2.copyTreeFromSelfTo(p)  # replace p by root2.

self.copyExpansionState(root2,p)
# g.trace(p.isExpanded(),p.headString())

&lt;&lt; add entry for p to filesInfoDict &gt;&gt;

path2 = g.choose(otherFileFlag,path,g.shortFileName(path))
p.initHeadString("%s settings: %s" % (kind,path2))</t>
<t tx="ekr.20050712070251.1510">self.filesInfoDict[p] = {
    'c': c2,
    'changes': [],
    'p': p.copy(),
    'path': path,
    'isLocal':  not otherFileFlag,
}</t>
<t tx="ekr.20050712070251.1511">def rootNodeComments(self):
    
    c = self.c ; fileName = g.shortFileName(c.mFileName)
    
    s = """This tree shows Leo's global and home settings, as well as the local settings in %s."""\
        % (fileName)
    
    return s</t>
<t tx="ekr.20050712070251.1512"></t>
<t tx="ekr.20050712070251.1513">def select (self,p,updateBeadList=True):
    
    __pychecker__ = '--no-argsused' # updateBeadList required for compatibility.

    old_p = self.old_p
    
    # g.trace(p.headString())

    # Unselect the old
    if old_p:
        t = self.getTextWidget(old_p)
        if t: self.setUnselectColors(t)

    # Select the new
    t = self.getTextWidget(p)
    if t: self.setSelectColors(t)
    
    # N.B. Do not change the commander's notion of the present position.
    self.old_p = p

    self.controller.onTreeClick(p)
    
    # For the UNL plugin.
    g.doHook("select2",c=p.c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20050712070251.1514">def __init__ (self,c,replaceBody=True):
    
    self.createSummaryNode = True # Works either way.

    &lt;&lt; init ivars &gt;&gt;
    &lt;&lt; define Tk color names&gt;&gt;

    if not Pmw:
        s = 'Setting dialog requires Pmw: see http://pmw.sourceforge.net'
        g.es_print(s,color='red')
        return
    
    # Reread the settings files so any changes will take effect.
    g.app.config.readSettingsFiles(c.fileName(),verbose=True)
    self._settingsPosition = p = self.createSettingsTree()
    self.parser = settingsDialogParserClass(c,p,self)
    &lt;&lt; set background color for widgets &gt;&gt;
    c.disableCommandsMessage = 'All commands disabled while settings dialog is open'
    if self.replaceBody:
        self.replaceBodyWithDialog()
        self.log = g.app.log
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
    else:
        d = self.createStandAloneDialog()
        self.log = self.logClass(self.logText)
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
        self.center()
        g.app.gui.widgetWantsFocus(None,None)
        if self.modal: d.activate()</t>
<t tx="ekr.20050712070251.1515">self._settingsPosition = None
self.alterComments = None # position for which to alter comments.
self.alteredCommentsString = None
self.c = c
self.buttonNames = ('OK', 'Cancel','Apply','Revert')
self.colorSettingDict = {} # Contains entries for all changed colors.
self.commentWidget = None
self.commonBackground = None
self.dialog = None
self.initValueDict = {} # Initial value of settings in present pane.
self.fileValueDict = {} # Values of settings written to file.
self.filesInfoDict = {} # Info about all settings file in the settings outline.
    # Keys are positions, values are dicts giving info for a setting file.
self.fontRefs = {} # A dict to retain references to fonts.
self.modal = False
self.old_p = c.currentPosition()
self.old_root = c.rootPosition()
self.p = None # Used to revert settings.
self.panes = {}
self.parser = None
self.replaceBody = replaceBody
self.sc = None
self.setterLabel = None
self.suppressComments = None # position for which to suppress comments.
self.title = "Settings for %s" % g.shortFileName(c.fileName())
self.top = None
self.tree = None</t>
<t tx="ekr.20050712070251.1516">self.colorNamesList = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20050712070251.1517">if 0:
    # Get the color from the background color of the body text widget.
    self.commonBackground = c.frame.body.bodyCtrl.cget('background')
    
else:
    # 'LightSteelBlue1' # too blue.
    # 'gray80' # too dark.
    # 'gray90' # Possible: very light.
    # '#f2fdff' # Same as log window.  Too cute.
    
    self.commonBackground = 'gray90'</t>
<t tx="ekr.20050712070251.1518"></t>
<t tx="ekr.20050712070251.1519">@nocolor

I know you don't like to maintain the tangle code, but here is a patch to remove a hangnail of mine ...

The current way Leo works is that if you do a tangle on a node then it searches for child nodes which are @root's and then tangles them. However, in my workflow, the most common use case is that I make a quick change to a method and want to tangle the *parent* file. If you make the change and then hit ctrl-shift-t then Leo says "No roots in node".

What this patch does is to extend the current behaviour. If (and only if) there are no @roots in the node then it tries to find a parent node which is a @root. If if finds one then it tangles it and then stops. In most cases I think this is what the user would want to happen.

You will probably say,

a) I should be using @thin's, or
b) marking nodes and then using the tangle-marked function

(a) is not currently workable on my main project (14,000 nodes and 700+ files!) since writing the Leo file itself takes 30 seconds or more. I do use marked nodes but even then if I have several large nodes marked it takes 10+ seconds to tangle them and so I often want to just do a quick tangle to a single file without losing my current node location.

Anyway, here is the patch ... it affects only the tangle method of baseTangleCommands in leoTangle.py ...

   def tangle(self):
         c = self.c ; p = c.currentPosition()
       self.initTangleCommand()
       if not self.tangleTree(p,report_errors):
           g.es("Looking for a parent to tangle")
           while p:
               if g.get_directives_dict(p.bodyString(),[self.head_root]).has_key("root"):
                   g.es("Tangling parent")
                   self.tangleTree(p,report_errors)
                   break
               p.moveToParent()


This could have been a plugin but it seems to me that this is probably just easier to roll into Leo rather than have another tiny plugin to support.
</t>
<t tx="ekr.20050712070251.1520"># Anyway, here is the patch ... it affects only the tangle method of baseTangleCommands in leoTangle.py ...

def tangle(self):
    c = self.c ; p = c.currentPosition()
    self.initTangleCommand()
    if not self.tangleTree(p,report_errors):
        g.es("Looking for a parent to tangle")
        while p:
            if g.get_directives_dict(p.bodyString(),[self.head_root]).has_key("root"):
                g.es("Tangling parent")
                self.tangleTree(p,report_errors)
                break
            p.moveToParent()</t>
<t tx="ekr.20050712070251.1521">def tangle(self):
    
    c = self.c ; p = c.currentPosition()
    self.initTangleCommand()
    
    if 1: # Paul Paterson's patch.
        if not self.tangleTree(p,report_errors):
            g.es("looking for a parent to tangle...")
            while p:
                d = g.get_directives_dict(p.bodyString(),[self.head_root])
                if d.has_key("root"):
                    g.es("tangling parent")
                    self.tangleTree(p,report_errors)
                    break
                p.moveToParent()
    else:
        self.tangleTree(p,report_errors)
    
    g.es("tangle complete")
</t>
<t tx="ekr.20050712070251.1522"></t>
<t tx="ekr.20050712070251.1523"></t>
<t tx="ekr.20050712070251.1524">def readAtFileNodes (self):

    c = self.c ; current = c.currentPosition()
    c.atFileCommands.readAll(current,partialFlag=True)
    c.redraw()
    
    # Force an update of the body pane.
    current.setBodyStringOrPane(current.bodyString())
    c.frame.body.onBodyChanged(current,undoType=None)</t>
<t tx="ekr.20050712070251.1525">def importDerivedFile (self):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(p,names)</t>
<t tx="ekr.20050712070251.1526"></t>
<t tx="ekr.20050712070251.1527"></t>
<t tx="ekr.20050712070251.1528"></t>
<t tx="ekr.20050712070251.1529">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3054876
By: mstarzyk

It looks to me like there is a bug in baseCommands.openWith(("os.spawnv"...))
(Or in vim.py plugin that calls it)

The executable should be passed twice to os.spawnv - first 
as the "path" param, then as the first item in "args"
But in line leoCommands.py:485 the executable is not included
in the "args" param.

Python manual says:
    os.spawnv
    The "v" variants are good when the number of parameters 
    is variable [...]
    In either case, the arguments to the child process must 
    start with the name of the command being run. 

With the current code the process runs, but the first parameter 
is not passed to it. 
So for example in the vim plugin vim is actually started 
without the "--servername LEO" param.

Additionally - on windows the executable in "args" should 
be surrounded with doublequotes if the path contains whitespace.

Cheers, 
Maciek</t>
<t tx="ekr.20050712070251.1530">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3122633
By: davidschein

In leoCommands.baseCommands.openWith(..) I added

@color

elif openType == "desHACK": apply(os.spawnv,(os.P_NOWAIT, r"c:\vim\vim63\gvim.exe",
[" --servername LEO "," --remote-silent "]+[shortPath]))

# and in vim.open_in_vim(..) I made the call to open Vim

#des: the big HACK
g.top().openWith(("desHACK",None, None))

@nocolor

I know it is outrageous, but I was in a hurry and it does the trick for now.
I thought I would just share it in case it points to a proper solution.</t>
<t tx="ekr.20050712070251.1531">@nocolor

I think you misunderstand how Leo calls os.spawnv. 
 
The following works for me: 
 
table = ('spawnv',None,( 
'os.spawnv',[ 
r'c:\vim\vim63\gvim.exe', 
' --servername LEO ', 
' --remote-silent ', 
], 
".py")) 
 
c.frame.menu.createOpenWithMenuFromTable(table) 
 
This works because c.openWith takes the first element of the list (in this case, r'c:\vim\vim63\gvim.exe') and uses it as the first argument to spawnv. 
 
I grant you that this is not well documented :-) 
 
Edward 
 
P.S. Here is the actual code in openWith: 
 
elif openType == "os.spawnv": 
    filename = os.path.basename(arg[0])  
    vtuple = arg[1:]  
    vtuple.append(path) 
    apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple)) 
 
EKR
</t>
<t tx="ekr.20050712070251.1532">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3133917

Having the Nodenavigator plugin enabled by default: 
in an empty, new outline, no 'Recently' nor 'Marked' button shows up in the tool bar</t>
<t tx="ekr.20050712070251.1533"></t>
<t tx="ekr.20050712070251.1534">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3133915
By: Greg

Latex keywords aren't colored when certain characters are after them.  For example,
"\documentclass" in

\documentclass{report}

is not colorized, but it is when you add a space like so:

\documentclass {report}

I've traced the problem to line 1684 in LeoColor.py (as it appears in CVS).
This is in the section labeled "&lt;&lt; handle possible latex keyword &gt;&gt;".  This
line currently reads

j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03

So what I think is happening is that, since "{" and "}" are considered special
keyword characters, it's parsing the entire command "\documentclass{report}"
as a single keyword, rather than just "\documentclass".  The fix is easy:  just
get rid of the chars= keyword like so:

j = self.skip_id(s,i+1)

This seems to be  working for me... it's kinda odd that someone put that in
there in the first place, though, so maybe it does something else that
I'm missing?

Also, disclaimer:  I'm currently running 4.1 on my computer.  Although line
1684 appears the same on the CVS as it does in my version, maybe something else
was changed in the latest version to make it work.</t>
<t tx="ekr.20050712070251.1535">The code must handle the following with special-case code:
    
"\\@", "\\(", "\\)", "\\{", "\\}",</t>
<t tx="ekr.20050712070251.1536">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]</t>
<t tx="ekr.20050712070251.1537"></t>
<t tx="ekr.20050712070251.1538">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3051870
By: e

if you make a script button, the error is printed
to the console only. no redirection to log if enabled.</t>
<t tx="ekr.20050712070251.1539"></t>
<t tx="ekr.20050712070251.1540">@killcolor

The nav_buttons plugin was using self.c rather than keywords.get('c') in a hook
handler. The general rule is that hook handlers should do nothing if self.c !-
keywords.get('c').  This was an old bug, arising from the rewrite of the plugin.

I added a warning to that effect in the plugin template.

It would perhaps be better to specify an optional commander in registerHandler
and only call the handler if the commander matches. However, this isn't so easy
or clean to do.</t>
<t tx="ekr.20050712070251.1541">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3138608

With nav_buttons plugin loaded. the first click in the outline window after
loading an outline produces:
Traceback (most recent call last):
  File "C:\Program Files\leo\src\leoGlobals.py", line 2286, in doHook
    return f(tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 73, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 51, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\leo\plugins\nav_buttons.py", line 395, in updateRecent
    self.updateButtons()
  File "C:\Program Files\leo\plugins\nav_buttons.py", line 374, in
updateButtons
    for b,b2,enabled_image,disabled_image,cond in (
AttributeError: Commands instance has no attribute 'beadPointer'</t>
<t tx="ekr.20050712070251.1542"># Autocompleter appears to work as expected with the 4.3b1 release.</t>
<t tx="ekr.20050712070251.1543">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3052150
By: brianvanden

Leo Log Window...
Leo 4.3 alpha 4, build  1.231 , March 15, 2005
Python 2.4.0, Tk 8.4.7, win32

I installed a4 today, made some changes to leoSettings.leo, and began exploring
plugins. If autocompleter.py is enabled while the other plugins are left as
in a fresh leo install, and the body pane is set not to wrap, then, when a line
is longer than the screen, there is no horizontal scrollbar in the body pane.
(I've observed this in both nodes not in a @nowrap sub- tree as well as those
in such a sub-tree.)

If autocompleter.py is disabled and leo is relaunched, the horizontal scroll
bar appears as expected.

but http://sourceforge.net/forum/forum.php?thread_id=1244118&amp;forum_id=10226
might be relevant.</t>
<t tx="ekr.20050712070251.1544"></t>
<t tx="ekr.20050712070251.1545"></t>
<t tx="ekr.20050712070251.1546">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3051866
By: nobody

3)When enabling the chapters plugin, starting up Leo (which gives me an untitled
window) and use the File--&gt;Open menu to open leopluginsref.leo I get the following
in the log pane:

Leo Log Window...
Leo 4.3 alpha 4, build  1.234 , March 15, 2005
Python 2.3.4, Tk 8.4.3, win32

exceptions opening: C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\plugins\leoPluginsRef.leo
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\src\leoGlobals.py", line 630, in openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\plugins\chapters.py", line 924, in newOpen
    return oldOpen(self,file,fileName,readAtFileNodesFlag)
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\src\leoFileCommands.py", line 1285, in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
TypeError: newGetLeoFile() got an unexpected keyword argument 'silent'

of the newly opened window. In the still open 'untitled' window I can see a
second 'no reportlab' line added to the log.</t>
<t tx="ekr.20050712070251.1547"></t>
<t tx="ekr.20050712070251.1548">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3073752
By: nobody

I just tried Chapters (latest CVS from a few hours ago) and I had a major bug,
one that I've noticed for a few months now. I have 5 chapters and many cross-chapter
clones.

At unexpected times, when clicking on a node in one of the Chapters, Leo suddenly
loses track of an entire subtree or the entirety of nodes in the outline. Just
minutes ago, I clicked on a node in my first chapter (containing my entire outline,
with subparts cloned to other chapters), and the ENTIRE CONTENTS of the chapter
DISAPPEARED with the exception of one "New Headline" node, which was odd because
I didn't add anything new in the first chapter. I tried CTRL+1, CTRL+2 to force
Leo to redraw the outline in case the  nodes were present but somehow hidden,
but no luck - all the nodes really seemed to be gone. The other chapters (containing
clones from the first chapter) still looked ok. I had saved a few minutes earlier,
so I quit without saving, hoping my earlier-saved version would still be OK,
but to my disappointment the earlier-saved version had a one-node ("New Headline")
outline in the first chapter.

I had noticed this behavior since a few months (unfortunately I can't recall
starting with which version), so I had been refraining from using Chapters,
but it appears that there is still a serious bug lurking somewhere in there.</t>
<t tx="ekr.20050712070251.1549">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3073757
By: nobody

Regarding my previous message about Chapters deleting my entire outline, I just
remembered my sequence of steps more clearly. This may provide some hint towards
reproducing and fixing the bug.

What I did:
- Enabled Chapters, re-started Leo (latest CVS).
- Load my huge outline. It appears in Chapter 1.
- Add a chapter.
- ***MAYBE IMPORTANT?*** The new chapter contains a new node, "New Headline".
I leave this headline as it is, for now.
- Clone some/many nodes into the new Chapters.
- Add a few more chapters, again not touching the default "New Headline" node,
and cloning nodes from Chapter 1 (big outline) into the new chapters.

Up until now everything "seems" ok.

Then, I started with Chapter 5, and deleted the "New Headline" node with the
right-mouse-click menu. I did the same in Chapter 4, Chapter 3, and Chapter 2.

Now, I returned to Chapter 1, clicked somewhere in the huge outline, and suddenly
my entire outline disappeared, and a single "New Headline" node took its place.

It looks as if some links or references between nodes/chapters are getting out
of sync. Anyway, I know this information is not extremely specific, but maybe
it will help in finding the bug.</t>
<t tx="ekr.20050712070251.1550"></t>
<t tx="ekr.20050712070251.1551"># This happened when creating a new chapter with chapters.py enabled.</t>
<t tx="ekr.20050712070251.1552">idle_scrollTo: does not exist: NewHeadline
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1416, in idle_scrollTo
    h2 = self.yoffset(last)

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1493, in yoffset
    h,flag = self.yoffsetTree(root,p1)

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1509, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)

TypeError: unpack non-sequence</t>
<t tx="ekr.20050712070251.1553"></t>
<t tx="ekr.20050712070251.1554">@killcolor

http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226
By: Nic Cave-Lynch - niccl
a few more bugs in 4.3 b1  
2005-05-10 15:33
1: Bug in undo: 
I just found that if you do a new line, then backspace (to go to previouslevel of indent) you get: 
 
Exception in setUndoRedoTypingParams 
Traceback (most recent call last): 
File "C:\Program Files\leo\src\leoUndo.py", line 1154, in setUndoTypingParams 
new_ch = new_s[new_col-1] 
IndexError: string index out of range 
 
undo granularity is set to word

The fix was to recompute newSel in &lt;&lt; handle backspace with negative tab_width &gt;&gt; in idle_body_key.

There may be a problem in updateBodyPane as well.</t>
<t tx="ekr.20050712070251.1555">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)</t>
<t tx="ekr.20050712070251.1556">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(ch,ord(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        &lt;&lt; handle special characters &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"</t>
<t tx="ekr.20050712070251.1557"># Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20050712070251.1558">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20050712070251.1559">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050712070251.1560"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.</t>
<t tx="ekr.20050712070251.1561">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20050712070251.1562">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20050712070251.1563">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20050712070251.1564">def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing</t>
<t tx="ekr.20050712070251.1565">def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        &lt;&lt; convert tab no matter where it is &gt;&gt;
    else:
        &lt;&lt; convert only leading tabs &gt;&gt;</t>
<t tx="ekr.20050712070251.1566">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050712070251.1567"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050712070251.1568">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    &lt;&lt; return if there is nothing to do &gt;&gt;
    # g.trace(undo_type)
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    u.setUndoTypes() # Recalculate the menu labels.
    return bunch</t>
<t tx="ekr.20050712070251.1569">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None</t>
<t tx="ekr.20050712070251.1570"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()</t>
<t tx="ekr.20050712070251.1571">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"</t>
<t tx="ekr.20050712070251.1572">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines</t>
<t tx="ekr.20050712070251.1573">#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20050712070251.1574">@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
else:
    bunch = old_d

bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview

u.beads[u.bead:] = [bunch]
    
# g.trace(u.bead,len(u.beads))</t>
<t tx="ekr.20050712070251.1575">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True</t>
<t tx="ekr.20050712070251.1576">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)</t>
<t tx="ekr.20050712070251.1577"></t>
<t tx="ekr.20050712070251.1578">@killcolor

Two problems:
    
1. The section name loses its indentation.
2. The created section has extra indentation.

These were introduced during a 'simplification' of the code, so it's not a big deal.

The unit tests didn't properly test indentation.  Now they do.</t>
<t tx="ekr.20050712070251.1579"></t>
<t tx="ekr.20050712070251.1580">@killcolor

Undoing does not remove the inserted section node.

The problem was that the undo/redoTyping helpers were setting u.redrawFlag to false.

The fix was to disable that logic when inside a group.

</t>
<t tx="ekr.20050712070251.1581">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
    
    if u.groupCount == 0:
        u.redrawFlag = (current != u.p)</t>
<t tx="ekr.20050712070251.1582">def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
        
    if u.groupCount == 0:
        u.redrawFlag = (current != u.p)</t>
<t tx="ekr.20050712070251.1583"></t>
<t tx="ekr.20050712070251.1584">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3143895
By: e

select something in headline,
Edit-&gt;Delete
nothing happens.</t>
<t tx="ekr.20050712070251.1585">def delete(self):

    c = self ; p = c.currentPosition()
    body = c.frame.body
    w = body.bodyCtrl.focus_get()
    
    # Don't assume the body has focus.
    if w == body.bodyCtrl:
        oldSel = body.getTextSelection()
        body.deleteTextSelection()
        body.onBodyChanged(p,"Delete",oldSel=oldSel)
    else:
        # Assume we are changing a headline...
        # This works even if the assumption is incorrect.
        start,end=g.app.gui.getTextSelection(w)
        g.app.gui.replaceSelectionRangeWithText(w,start,end,'')
        c.frame.tree.onHeadChanged(p)</t>
<t tx="ekr.20050712070251.1586"></t>
<t tx="ekr.20050712070251.1587">@killcolor

http://sourceforge.net/forum/forum.php?thread_id=1282631&amp;forum_id=10226
 
Using the latest CSV, the marks dialog of the nav_buttons plugin doesn''t work. Ie, double clicking on a line in the marks crashes Leo.  

The plugin was failing to set the positionList ivar (in the base tkinterListBoxDialog class).  This was a fairly recent blunder:  I saw that positionList wasn't used in the plugin directly, so I 'improved' the code by using a local var instead of self.positionList.  This illustrates a hazard of using subclassing.</t>
<t tx="ekr.20050712070251.1588">def go(self,event=None):
    
    """Handle clicks in the "go" button in a list box dialog."""
    
    __pychecker__ = '--no-argsused' # the event param must be present.
    
    c = self.c ; box = self.box
    
    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        p = self.positionList[n]
        c.beginUpdate()
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p,updateBeadList=True) # A case could be made for updateBeadList=False
        c.endUpdate()
        c.frame.tree.idle_scrollTo(p)</t>
<t tx="ekr.20050712070251.1589"></t>
<t tx="ekr.20050712070251.1590">@killcolor

The following methods changed:
I also rewrote the code using explicit positions.

- markAllAtFileNodesDirty
- markAtFileNodesDirty
- markClones
- markHeadline
- markSubheads</t>
<t tx="ekr.20050712070251.1591"></t>
<t tx="ekr.20050712070251.1592">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20050712070251.1593">def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    g.trace()
    v = self ; c = v.c
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons</t>
<t tx="ekr.20050712070251.1594">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="ekr.20050712070251.1595">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="ekr.20050712070251.1596">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="ekr.20050712070251.1597">def initStatus (self, status):

    self.statusBits = status</t>
<t tx="ekr.20050712070251.1598">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20050712070251.1599">def setOrphan (self):

    self.statusBits |= self.orphanBit</t>
<t tx="ekr.20050712070251.1600"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit</t>
<t tx="ekr.20050712070251.1601"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20050712070251.1602"></t>
<t tx="ekr.20050712070251.1603">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20050712070251.1604">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20050712070251.1605">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    dirtyVnodeList = []
    
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    c.beginUpdate()
    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!
    c.endUpdate(changed)

    return dirtyVnodeList</t>
<t tx="ekr.20050712070251.1606"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c ; dirtyVnodeList = []
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            dirtyVnodeList.append(p.v)
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
        dirtyVnodeList.extend(dirtyVnodeList2)
        changed = len(dirtyVnodeList) &gt; 0
    c.endUpdate(changed)

    return dirtyVnodeList</t>
<t tx="ekr.20050712070251.1607">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20050712070251.1608"></t>
<t tx="ekr.20050712070251.1609">@killcolor

http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

2: @orientation missing from options for new windows in settings. The head line is there in the outline, but the option doesn't show in the page, and if you click on the heading in the outline, the body pane is just grey 
</t>
<t tx="ekr.20050712070251.1610">@killcolor

&gt; @strings initial_splitter_orientation [vertical,horizontal] = horizontal 
 
That works in leoSettings.leo, but it doesn't really work in the settings dialog. The problem is that the settings dialog changes the line to: 
 
@strings[vertical,horizontal]initial_splitter_orientation = horizontal 
 
The options [vertical,horizontal] follow the @strings, not the settings name. This makes more sense because logically the options are 'part of' the @strings type. But the parser for @strings expects the first way! 
 
I changed doStrings and doInts so they allow either form.</t>
<t tx="ekr.20050712070251.1611"></t>
<t tx="ekr.20050712070251.1612">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3149604
By: ngirard

Hi there,

here's a procedure to reproduce this defect:
- open a leo file
- hoist a node 'n'
- select 'n' and do Ctrl-I to create n1
- select 'n1' and do Ctrl-I to create n2

Observed:
Traceback (most recent call last):
  File "/usr/local/lib/leo/src/leoCommands.py", line 177, in doCommand
    command()
  File "/usr/local/lib/leo/src/leoCommands.py", line 2920, in insertHeadline
    if ((current.hasChildren() and current.isExpanded()) or
AttributeError: 'Bunch' object has no attribute 'current'


I'd be much interested to know how to fix this before the beta2 release...

Cheers,
Nicolas
</t>
<t tx="ekr.20050712070251.1613">@killcolor

Changed c.hoistStack[-1].current to c.hoistStack[-1].p in c.insertHeadline.</t>
<t tx="ekr.20050712070251.1614"></t>
<t tx="ekr.20050712070251.1615">@killcolor

http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226
 
3: If you start leo with no .leo file, then go straight to settings from the edit menu, there are no scroll bars in the outline, which makes things like checking the thing above a challenge... If ther's a .leo file open, then the scrol bars are there.

The problem only happens when splitting horizontally.

Actually, the problem is that settings dialog is grossly misplaced when splitting horizontally.  It's a packing problem, not a scrollbar problem.  Moreover, the problem goes away if the body pane (vertical bar) is manually resized.  This indicates it is an initing problem, not a fundamental packing problem.</t>
<t tx="ekr.20050712070251.1616">@killcolor

The fix:  in createFrame in leo.py after:

frame.setInitialWindowGeometry()

Insert the following line:

frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)

Not only does this fix this bug, it honors the following settings:

- initial_horizontal_ratio
- initial_horizontal_secondary_ratio
- initial_vertical_ratio
- initial_vertical_secondary_ratio</t>
<t tx="ekr.20050712070251.1617"></t>
<t tx="ekr.20050712070251.1618">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3138608

How do I bind GoToLine from Alt-G to Ctrl-G using the settings system?

When I did what I thought might work, ie replace
the Alt-G with Ctrl-G, and then 'apply', it renamed the '@shortcuts Alt and
Shift-Alt' outline heading to something about Go To Line, and turned the actual
displayed settings to complete rubbish.

Try it for an explanation: it required copying a backup of the settings.leo to fix it.</t>
<t tx="ekr.20050712070251.1619">@killcolor

The shortcuts panel seems very clunky.  Why not just use a text widget?  That way the user can add and delete entries at will.</t>
<t tx="ekr.20050712070251.1620">def updateSetter (self,p,updateDicts=True):
    
    """Create a setter pane for position p."""

    sc = self.sc ; interior = sc.interior()
    
    if updateDicts:
        self.fileValueDict = {}
        self.initValueDict = {}
        self.colorSettingDict = {}
    
    # Destroy the previous widgets
    for w in interior.winfo_children():
        w.destroy()

    # Visit the node, and possibly its subtree, looking for widgets to create.
    self.parser.widgets = []
    self.suppressComments = None # May be set in parser.
    self.parser.visitNode(p)
    if self.parser.widgets:
        self.createWidgets(self.parser.widgets,interior,p)
        
    self.sc.resizescrollregion()
    self.sc.yview('moveto',0)
    self.updateSetterLabel(p)
    g.app.gui.widgetWantsFocus(None,None)</t>
<t tx="ekr.20050712070251.1621">def createWidgets (self,widgets,parent,p):

    munge = g.app.config.munge

    &lt;&lt; define creatorDispatchDict &gt;&gt;
    
    # g.trace(p.headString())
    
    # self.printWidgets(widgets)
    
    self.h = 0 # Offset from top of pane for first widget.
    self.createSpacerFrame(parent,size=15)
    
    if p != self.suppressComments:
        self.createComments(parent,p.copy())

    for data in widgets:
        p,kind,name,vals = data
        if kind.startswith('ints'):
            self.createInts(parent,p,kind,name,vals)
        if kind.startswith('strings'):
            self.createStrings(parent,p,kind,name,vals)
        else:
            f = creatorDispatchDict.get(munge(kind))
            if f is not None:
                try:
                    f(parent,p,kind,name,vals)
                except TypeError:
                    g.es_exception()
                    g.trace("***No handler***",kind)</t>
<t tx="ekr.20050712070251.1622">creatorDispatchDict = {
    'bool':         self.createBool,
    'color':        self.createColor,
    'comment':      self.createOnlyComments, # New in 4.3.1
    'directory':    self.createDirectory,
    'font':         self.createFont,
    'int':          self.createInt,
    'ints':         self.createInts,
    'float':        self.createFloat,
    'path':         self.createPath,
    'ratio':        self.createRatio,
    'shortcut':     self.createShortcut,
    'shortcuts':    self.createShortcuts,
    'string':       self.createString,
    'strings':      self.createStrings,
}</t>
<t tx="ekr.20050712070251.1623">def createBool (self,parent,p,kind,name,val):
    
    val = g.choose(val.lower()=='true',1,0)

    # Inits the checkbutton widget. 
    var = Tk.IntVar()
    var.set(val)

    def boolCallback():
        val2 = g.choose(var.get(),True,False)
        # g.trace(name,val2)
        return val2
    
    val = g.choose(val,True,False)
    self.initValue(p,name,kind,val,boolCallback)

    box = Tk.Checkbutton(parent,text=name,variable=var,background=self.commonBackground)

    self.sc.create_window(10,self.h,anchor='w',window=box)
    self.h += 30</t>
<t tx="ekr.20050712070251.1624">def createColor (self,parent,p,kind,name,val):
    
    munge = g.app.config.munge
    noColor = "&lt;no color&gt;"
    colorNamesList = list(self.colorNamesList)
    
    f = Tk.Frame(parent,background=self.commonBackground) # No need to pack.
    &lt;&lt; munge val and add val to colorNamesList &gt;&gt;
    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;
    Tk.Label(f,text=name,background=self.commonBackground).pack(side='left')
    
    self.colorSettingDict [munge(name)] = val

    def getColorCallback ():
        return self.colorSettingDict.get(munge(name))

    self.initValue(p,name,kind,val,getColorCallback)

    self.sc.create_window(15,self.h+8,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1625">if val in ("None",None): val = noColor
val = str(val) # Get rid of unicode.

if noColor in colorNamesList:
    colorNamesList.remove(val)
if val is not noColor and val not in colorNamesList:
     colorNamesList.append(val)
colorNamesList.sort()
colorNamesList.insert(0,noColor)

initVal = val
if val is noColor: val = None</t>
<t tx="ekr.20050712070251.1626">colorBox = Pmw.ComboBox(f,scrolledlist_items=colorNamesList)
colorBox.selectitem(initVal)
colorBox.pack(side="left",padx=2)

color = g.choose(val is None,f.cget('background'),val)
colorSample = Tk.Button(f,width=8,background=color)
colorSample.pack(side='left',padx=2)

def colorCallback (newName):
    # g.trace(repr(newName))
    if not newName or newName.lower() in ('none','&lt;none&gt;','&lt;no color&gt;'):
        self.colorSettingDict[munge(name)] = None
        color = f.cget('background')
        colorSample.configure(background=color)
    else:
        try:
            colorSample.configure(background=newName)
            self.colorSettingDict[munge(name)] = g.choose(newName is noColor,None,newName)
        except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20050712070251.1627">def pickerCallback (color=val):

    rgb,val = tkColorChooser.askcolor(parent=parent,color=color)
    if rgb or val:
        # g.trace(rgb,val)
        self.colorSettingDict[munge(name)] = val
        colorSample.configure(background=val,activebackground=val,text=val)

b = Tk.Button(f,text="Color Picker...",command=pickerCallback,background=self.commonBackground)
b.pack(side="left")</t>
<t tx="ekr.20050712070251.1628">def createComments (self,parent,p):
    
    # g.trace(p.headString())
    
    bg = self.commonBackground

    s = p.bodyString().strip()
    if not s: return
    
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='comments',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background=bg,
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=5,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',s)
    t.configure(state='disabled')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 70</t>
<t tx="ekr.20050712070251.1629">def createOnlyComments (self,parent,p,kind,name,val):
    
    pass # The existence of the 'comments' widget is enough.</t>
<t tx="ekr.20050712070251.1630">def createDirectory (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20050712070251.1631">def createFloat (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent,background=bg)
    Tk.Entry(f,textvariable=var,background=bg).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def floatCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,floatCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1632">def createFont (self,parent,p,kind,fontName,val):
    
    """Create a font picker.  val is a dict containing the specified values."""
    bg = self.commonBackground
    d = val
    munge = g.app.config.munge
    f = Tk.Frame(parent,background=bg) # No need to pack.
    self.alterComments = p.copy()
    self.alteredCommentsString = d.get('comments')
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    Tk.Label(f,text=fontName,background=bg).pack(side='left')
    &lt;&lt; define fontCallback &gt;&gt;

    familyBox.configure(selectioncommand=fontCallback)
    slantBox.configure(selectioncommand=fontCallback)
    weightBox.configure(selectioncommand=fontCallback)

    self.initValue(p,munge(fontName),'font',d,fontCallback)

    self.sc.create_window(15,self.h,anchor='w',window = f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1633">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

data = d.get('family')
initialitem = 0
if data:
    name2,val = data
    if val and val in names:
        initialitem = names.index(val)

familyBox = Pmw.ComboBox(f,
    labelpos="we",label_text='Family:',
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(initialitem)
familyBox.pack(side="left",padx=2)</t>
<t tx="ekr.20050712070251.1634">Tk.Label(f,text="Size:",background=bg).pack(side="left")

sizeEntry = Tk.Entry(f,width=4)
sizeEntry.pack(side="left")

data = d.get('size')
if data:
    kind,val = data
    if val not in (None,'None','none'):
        try:
            int(val)
            sizeEntry.insert('end',val)
        except ValueError:
            s = "invalid size: %s" % val
            print s ; self.es(s,color="blue")</t>
<t tx="ekr.20050712070251.1635">initialitem = 0
values = ['&lt;None&gt;','normal','bold']
data = d.get('weight')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

weightBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Weight:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

weightBox.selectitem(initialitem)
weightBox.pack(side="left",padx=2)</t>
<t tx="ekr.20050712070251.1636">initialitem = 0
values=['&lt;None&gt;','roman','italic']
data = d.get('slant')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

slantBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Slant:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

slantBox.selectitem(initialitem)
slantBox.pack(side="left",padx=2)</t>
<t tx="ekr.20050712070251.1637">def fontCallback(*args,**keys):
    
    __pychecker__ = '--no-argsused' # not used, but needed.
    
    d2 = d.copy() # The update logic must compare distinct dicts.
    
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:   val = sizeEntry.get().strip()
        if not val or  val.lower() in ('none','&lt;none&gt;',): val = None

        data = d.get(key)
        name,oldval = data
        d2[key] = name,val
    
    return d2</t>
<t tx="ekr.20050712070251.1638">def createInt (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')

    def intCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
    
    self.initValue(p,name,kind,val,intCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1639">def createInts (self,parent,p,kind,name,val):
    
    # g.trace(repr(kind),repr(name),val)
    
    bg = self.commonBackground
    
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 &lt; i &lt; j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'&lt;none&gt;')
    
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent)

    intsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background=bg,
        scrolledlist_items=items)

    intsBox.selectitem(initialitem)
    intsBox.pack(side="left",padx=2)
    
    def intsCallback():
        val2 = intsBox.get()
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val

    self.initValue(p,name,kind,val,intsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1640">def createPath (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20050712070251.1641">def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 &lt;= val2 &lt;= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1642">def createShortcut (self,parent,p,kind,name,val):
    
    g.trace(name,val)
    
    if name:
        self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20050712070251.1643">def createShortcuts (self,parent,p,kind,name,vals):
    
    __pychecker__ = '--no-argsused' # vals not used.
    
    t = self.createText(parent,p)
    
    def shortcutsCallback():
        val = t.get('1.0','end').rstrip()
        return val

    self.initValue(p,name,kind,vals,shortcutsCallback)</t>
<t tx="ekr.20050712070251.1644">def createSpacerFrame (self,parent,size=10):
    
    f = Tk.Frame(parent)
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += size</t>
<t tx="ekr.20050712070251.1645">def createString (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    if val in (None,'None'): val = ""
    
    # Inits the Entry widget.
    var = Tk.StringVar()
    var.set(val)
    
    f = Tk.Frame(parent) # No need to pack.
    Tk.Entry(f,textvariable=var,width=40).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def stringCallback():
        val = var.get()
        # g.trace(name,val)
        return val

    self.initValue(p,name,kind,val,stringCallback)
    
    self.sc.create_window(15,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1646">def createStrings (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # g.trace(repr(kind),repr(name),val)
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 &lt; i &lt; j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'&lt;none&gt;')
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent,background=bg)

    stringsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background = bg,
        scrolledlist_items=items)

    stringsBox.selectitem(initialitem)
    stringsBox.pack(side="left",padx=2)
    
    def stringsCallback():
        return stringsBox.get()

    self.initValue(p,name,kind,val,stringsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20050712070251.1647">def createText (self,parent,p):
    
    bg = self.commonBackground
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='shortcuts',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background='white',
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=10,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',p.bodyString().strip())
    t.configure(state='normal')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 140
    
    return t</t>
<t tx="ekr.20050712070251.1648">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    self.set(p,kind,name,s)
    self.controller.suppressComments=p.copy()</t>
<t tx="ekr.20050712070251.1649"></t>
<t tx="ekr.20050712070251.1650"></t>
<t tx="ekr.20050712070251.1651">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3135170
By: trishul

I am also using leo partly as a pim and partly for warehousing code in W2K.
The clickable "@url file://" nodes work fine, but how
do you manage spaces in filenames ?  (the %20 substitute appears to work only
in http:// url's and quoting didn't help)
</t>
<t tx="ekr.20050712070251.1652">@ For tests of this, see the script in test.leo at:
    
Scripts--&gt;Script to execute @test, @suite or file

Read the documentation in that node before running the script.</t>
<t tx="ekr.20050712070251.1653">def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return
    
    try: import subprocess # Exists in Python 2.4 or later.
    except ImportError: subprocess = None

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)
    
    if subprocess: # Only exists in Python 2.4.
        &lt;&lt; define subprocess_wrapper &gt;&gt;
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
             print 'return code', rc
        print so, se
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        execfile(fname, d)  #, globals()
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)</t>
<t tx="ekr.20050712070251.1654">def subprocess_wrapper(cmdlst):
    
    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde</t>
<t tx="ekr.20050712070251.1655"></t>
<t tx="ekr.20050712070251.1656">@killcolor

g.getScript now fully processes all scripts, regardless of where they came from.

- Changed g.getScript:
    - p arg is now required.
    - Removed unused script arg.
    - Added forcePythonSentinels arg (default is True).
    - g.getScript no longer temporarily alters any body text.
        - atFile.writeFromString gets the initial text using the fromString arg.
    - g.getScript now always calls atFile.writeFromString to handle all Leo directives.

- Added forcePythonSentinels to atFile.initWriteIvars and atFile.scanAllDirectives.
    - Default is None, in which case the code sets forcePythonSentinels to the scriptWrite arg.

- Added forcePythonSentinels to atFile.scanAllDirectives.
    - Default is False.

- Created atFile.putAtFirstLines and atFile.putAtLastLines.
    - These replace the corresonding sections in writeOpenFile.
    - It was not actually necessary to define these, but it cleans up the code.

- Created atFile.writeFromString.
    - This handles all the details of simulating a write _from_ a string _to_ a string.

- atFile.initWriteIvars and atFile.openFileForWriting now allow root to be None.
    - This is not used at present: root is always defined.

- Added fromString arg to atFile.writeOpenFile and atFile.putBody.</t>
<t tx="ekr.20050712070251.1657">@killcolor

At present c.executeScript does not call at.write if the script came from a selection.

In fact, at.write assumes the 'root' node is c.currentPosition(). This must
change if selections are to support Leo directives and section references.</t>
<t tx="ekr.20050712070251.1658">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3017712

maybe not yet, except as a conditional script.
its really only a very first draft.
py2.4 ok
py2.3 if you put subprocess.py in extensions
and their compiled extension from effbot.org
unless pywin32 is installed one or the other.
no extension needed for nix.
2.2 not even sure.
but worse, subprocess doesn't work well under puthonw.exe
I emailed the author, no one filed a bug report!

and the redirection is external you'll notice,
that should be internal or the results should
be passed back. print to console otherwise is useless.
good enough in this application but not ready for primetime.

I see subprocess is used in temacs plugin too.
so subprocess should be in extensions in any case. and the merge of both use
functions should
be possible in a general way we can all use.</t>
<t tx="ekr.20050712070251.1659">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3018068

a few other considerations,
executeFile is now a misnomer. I originally expected
to only need to make __name__ = '__main__',
but then what about options?
what about running another program than python?
the other sticky problem from Leo, what about packing 
sys.args for the spawned program? which I didn't attempt.
and to duplicate the experience many programs expect args.
execfile() was not going to cut it.

the fallback for pythonw for now is:

.    child_stdin, child_stdout, child_stderr = os.popen3(cmds)
.    output = child_stdout.read()
.    outerr = child_stderr.read()
.    return output, outerr

but, no return code? maybe popen4 is required for that.
subprocess handles it allot better.
not to mention piping the output from one program into another.
we don't want to have people tripping over shell
escaping problems to do simple things in a secure way.
and did I read in another thread the mac has pythonw?
does it suffer the same lack of stdout/stderr as 
windows' pythonw?
no one problem insurmountable. I could imagine 
python.org taking the compatibility lead providing
a py2224.zip with a few of the missing pieces.
subprocess, datetime, sets, itertools, csv what have you.
then instead of everyone incompletely trying
to piece together compatibility those that want it
could install a compete package.
then there would only be PMW.
we probably need elementtree and celementtree too.</t>
<t tx="ekr.20050712070251.1660">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3023147
By: e

a little IPython integration woulden't be a bad thing.
not with IPython code as much as in its execution.

there '%' is now the magic char (was @) 

you can also have automagic enabled.
in scripting we have the static approach where you have
to carefully think about what function to call
the system and if it works on this or that OS.
how to construct the call, list or string, 
do I need to escape etc.

what about a less static:
filename = 'whatever.py'
%python filename &gt; &lt;&lt;details&gt;&gt;
%cat &lt;&lt;details&gt;&gt; | sort

maybe that would make too much work
for executeScript.  just a thought.
code to follow RSN.

&gt;&gt;I'll discuss them in detail when getting around to moving this work into Leo's core

there are many places in Leo code, 
openwith g.executeScript and various plugins
all doing similar things in multitues of ways.
a little more centralization might be called for.
by then maybe subprocess will be updated.</t>
<t tx="ekr.20050712070251.1661"></t>
<t tx="ekr.20050712070251.1662">@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1281640&amp;forum_id=10228

Pre-define __name__ in scripts?

There was some discussion recently about defining __name__ in scripts.  The relevant part of c.executeScript is:

@color
p = c.currentPosition()
d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
exec script in d
@nocolor

If the define_g argument is True (the default) Leo executes the script in a context including c, g and p. Otherwise,Leo executes the script in a completely pristine environment.

My idea is to add a define_name keyword to executeScript.  The code becomes:

@color
p = c.currentPosition()
d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
if define_name: d['__name__'] = define_name
exec script in d
@nocolor

What should the default value of define_name be?  (This will be the value used by the Execute Script command).  I am thinking that '' (the empty string) would be best in general, which means that the Execute Script command will work exactly as before.  Various other callers of c.executeScript could make other decisions.</t>
<t tx="ekr.20050712070251.1663"></t>
<t tx="ekr.20050712070251.1664">@killcolor

http://sourceforge.net/forum/forum.php?thread_id=1260345&amp;forum_id=10227

I try to quickly jump between words using CTRL+ left and right arrows. The problem is it seems leo jumps according to spaces, not words. For instance, if I my cursor is at the end of a line like: 
Pmw.ComboBox(r,label_text 
and I press CTRL-left, leo will jump to the beginning of the line. But I want it to jump to the beginning of the word "label_text".

How can I do this in leo?</t>
<t tx="ekr.20050712070251.1665">@killcolor

The reason that Leo does not support the default Tk bindings described at: 
 
http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm 
 
is that idle_body_key contains return 'break' statements throughout. I deleted
the last return 'break' and the shift/control arrow keys mostly work. You can
try to replace return 'break' by just return throughout, but there are no
guarantees that this will be to your liking. 
 
Leo should have commands to move the cursor in various ways. The big advantage
of this way is that key bindings are uniform in both panes. OTOH, one might
rather that some key bindings work differently depending on what pane is active.
In general, I intensely dislike such modes, but other people may disagree. 
 
The temacs and usetemacs plugins go a long way towards bringing all the Emacs
commands into Leo, and it's becoming intolerable not to bring these commands
fully into the fold. I plan to do this by 4.3 final. This would be the
appropriate place to define lots of Emacs-style cursor move commands.</t>
<t tx="ekr.20050712070251.1666">@killcolor

The Left and Right keys move the insertion cursor one character to the left or
right; they also clear any selection in the text.

If Left or Right is typed with the Shift key down, then the insertion cursor
moves and the selection is extended to include the new character.

Control-Left and Control-Right move the insertion cursor by words, and
Control-Shift-Left and Control-Shift-Right move the insertion cursor by words
and also extend the selection.

Control-b and Control-f behave the same as Left and Right, respectively.

Meta-b and Meta-f behave the same as Control-Left and Control-Right,
respectively.</t>
<t tx="ekr.20050712070251.1667"></t>
<t tx="ekr.20050712070251.1668"></t>
<t tx="ekr.20050712070251.1669">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3155657
By: tfer

Enabling the Pie Menu plug-in causes Leo to quit when you re-open it.  It just
draws part of the main window and quits (did not run it from a console to see
what is going on yet).

This was the only plug-in enabled on top of the default set (I was curious asw
to what the menus looked like).

Tom</t>
<t tx="ekr.20050712070251.1670">Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 763, in openWithFileName
    c,frame = app.gui.newLeoCommanderAndFrame(fileName)
  File "C:\prog\leoCVS\leo\src\leoGui.py", line 133, in newLeoCommanderAndFrame
    frame.finishCreate(c)
  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 154, in finishCreate
    frame.canvas = self.createCanvas(self.split2Pane1)
  File "C:\prog\leoCVS\leo\plugins\pie_menus.py", line 477, in addPMenu
    fa = PieMenu( can, c )
  File "C:\prog\leoCVS\leo\plugins\pie_menus.py", line 77, in __init__
    self.construct()
  File "C:\prog\leoCVS\leo\plugins\pie_menus.py", line 104, in construct
    f = tkFont.Font( weight = tkFont.BOLD, size = -15, family = 'courier')

NameError: name 'tkFont' is not defined</t>
<t tx="ekr.20050712070251.1671"># added new checks and new error messages.</t>
<t tx="ekr.20050712070251.1672">Select only a section name (no following lines)

Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 177, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 2055, in extractSection
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
IndexError: list index out of range</t>
</tnodes>
</leo_file>
