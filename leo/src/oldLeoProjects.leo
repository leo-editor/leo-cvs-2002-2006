<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="4089" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="127" height="827" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20040801060323" a="E"><vh>Old Projects</vh>
<v t="ekr.20031218072017.1924"><vh> Waiting for help from Linux people</vh>
<v t="ekr.20031218072017.1925"><vh>Paste bug (Linux only)</vh>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1926"><vh>Linux headline bug</vh></v>
</v>
<v t="ekr.20050924073836" a="TV"><vh>4.4 projects</vh>
<v t="ekr.20060106104442"><vh>4.4a5 projects</vh>
<v t="ekr.20060106104442.1"><vh>cvs snapshot 1</vh>
<v t="ekr.20060106104442.2"><vh>Bugs fixed</vh>
<v t="ekr.20060106104442.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.7"><vh>Fixed problem with getScript in batch mode</vh>
<v t="ekr.20060106104442.8"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20060106104442.9"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20060106104442.10"><vh>Select text box in goto-line-number command</vh>
<v t="ekr.20060106104442.11"><vh>Report</vh></v>
<v t="ekr.20060106104442.12"><vh>tkinterAskOKCancelNumber.createFrame</vh></v>
</v>
<v t="ekr.20060106104442.13"><vh>Restored headkey hooks</vh>
<v t="ekr.20060106104442.14"><vh>Report</vh></v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18" a="E"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.20"><vh>Restored bodykey hooks</vh>
<v t="ekr.20060106104442.21"><vh>Report</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh>
<v t="ekr.20060106104442.29"><vh>Report &amp; what I did</vh></v>
<v t="ekr.20060106104442.30"><vh>readError</vh></v>
<v t="ekr.20060106104442.31"><vh>atFile.error</vh></v>
<v t="ekr.20060106104442.32"><vh>readOpenFile</vh>
<v t="ekr.20060106104442.33"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.34"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20060106104442.35"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20060106104442.36"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20060106104442.37"><vh>readNormalLine</vh>
<v t="ekr.20060106104442.38"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20060106104442.39"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.40"><vh>start sentinels</vh>
<v t="ekr.20060106104442.41"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20060106104442.42"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20060106104442.43"><vh>readStartLeo</vh></v>
<v t="ekr.20060106104442.44"><vh>readStartMiddle</vh></v>
<v t="ekr.20060106104442.45"><vh>readStartNode (4.x)</vh>
<v t="ekr.20060106104442.46"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20060106104442.47"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20060106104442.48"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.49"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20060106104442.50"><vh>end sentinels</vh>
<v t="ekr.20060106104442.51"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20060106104442.52"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20060106104442.53"><vh>readEndLeo</vh></v>
<v t="ekr.20060106104442.54"><vh>readEndMiddle</vh></v>
<v t="ekr.20060106104442.55"><vh>readEndNode (4.x)</vh>
<v t="ekr.20060106104442.56"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20060106104442.57"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.58"><vh>readEndOthers</vh></v>
<v t="ekr.20060106104442.59"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060106104442.60"><vh>Unpaired sentinels</vh>
<v t="ekr.20060106104442.61"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20060106104442.62"><vh>readAfterRef</vh></v>
<v t="ekr.20060106104442.63"><vh>readClone</vh></v>
<v t="ekr.20060106104442.64"><vh>readComment</vh></v>
<v t="ekr.20060106104442.65"><vh>readDelims</vh></v>
<v t="ekr.20060106104442.66"><vh>readDirective (@@)</vh>
<v t="ekr.20060106104442.67"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20060106104442.68"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.69"><vh>readNl</vh></v>
<v t="ekr.20060106104442.70"><vh>readNonl</vh></v>
<v t="ekr.20060106104442.71"><vh>readRef</vh></v>
<v t="ekr.20060106104442.72"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20060106104442.73"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20060106104442.74"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20060106104442.75"><vh>Fixed minor headline problems</vh>
<v t="ekr.20060106104442.76"><vh>Report</vh></v>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20060106104442.82"><vh>Investigated secondary ratio problems</vh>
<v t="ekr.20060106104442.83"><vh>Notes</vh></v>
<v t="ekr.20060106104442.84"><vh>initialRatios</vh></v>
</v>
<v t="ekr.20060106104442.85"><vh>Installed LeoUsers patch for the Read @file Nodes command</vh>
<v t="ekr.20060106104442.86"><vh>What I did</vh></v>
<v t="ekr.20060106104442.87"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20060106104442.88"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.89"><vh>createThinChild4</vh></v>
<v t="ekr.20060106104442.90"><vh>atFile.__init__ and initIvars NEW</vh>
<v t="ekr.20060106104442.91"><vh> define the dispatch dictionary used by scanText4</vh></v>
</v>
<v t="ekr.20060106104442.92"><vh>createThinChild4 NEW</vh></v>
</v>
<v t="ekr.20060106104442.93"><vh>Fixed bug: clicking in the expand/contract box didn't save the headline</vh>
<v t="ekr.20060106104442.94"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060106104442.95"><vh>Installed LeoUser's patch for Read derived files</vh>
<v t="ekr.20060106104442.96"><vh>atFile.forceGnxOnPosition</vh></v>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.100"><vh>New features</vh>
<v t="ekr.20060106104442.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20060106104442.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20060106104442.103"><vh>Added 'insert' keyword to setTextSelection methods</vh>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.105"><vh>(Revised cursor movement commands and added selection-extension commands)</vh>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.125"><vh>Code changes</vh>
<v t="ekr.20060106104442.126"><vh>(Rewrote cut/copy/paste code)</vh>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.127"><vh>(Revised headline handlers)</vh>
<v t="ekr.20060106104442.128"><vh> What I did</vh>
<v t="ekr.20060106104442.129"><vh>Replaced calls to onHeadChanged by calls to c.endEditing</vh>
<v t="ekr.20060106104442.130"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.132"><vh>renameBuffer</vh></v>
</v>
</v>
<v t="ekr.20060106104442.133"><vh>Notes</vh></v>
<v t="ekr.20060106104442.134"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
<v t="ekr.20060106104442.136"><vh>editLabel</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.143"><vh>tree.set...LabelState</vh>
<v t="ekr.20060106104442.144"><vh>setEditLabelState</vh></v>
<v t="ekr.20060106104442.145"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060106104442.146"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060106104442.147"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060106104442.148"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060106104442.149"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060106104442.150"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20060106104442.151"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18" a="E"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.152"><vh>Calls to tree.endEditLabel</vh>
<v t="ekr.20060106104442.153"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.154"><vh>Icon Box...</vh>
<v t="ekr.20060106104442.155"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060106104442.156"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060106104442.157"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060106104442.158"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060106104442.159"><vh>Calls to onHeadChanged</vh>
<v t="ekr.20060106104442.160"><vh>toggleAngleBrackets</vh></v>
<v t="ekr.20060106104442.161"><vh>changeSelection</vh></v>
<v t="ekr.20060106104442.162"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20060106104442.163"><vh>Should *not* call onHeadChanged</vh>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060106104442.164"><vh>(Restored c.begin/endUpdate)</vh>
<v t="ekr.20060106104442.165"><vh>What I did</vh></v>
<v t="ekr.20060106104442.166"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20060106104442.167"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20060106104442.168"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20060106104442.169"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20060106104442.170"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060106104442.171" a="M"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.172"><vh>c.bringToFront</vh></v>
<v t="ekr.20060106104442.173"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060106104442.174"><vh>c.recolor_now</vh></v>
<v t="ekr.20060106104442.175"><vh>c.redraw_now</vh></v>
</v>
<v t="ekr.20060106104442.176"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20060106104442.177"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.178"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060106104442.179"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060106104442.180"><vh>idle_second_redraw</vh></v>
<v t="ekr.20060106104442.181"><vh>drawX...</vh>
<v t="ekr.20060106104442.182"><vh>drawBox</vh></v>
<v t="ekr.20060106104442.183"><vh>drawClickBox</vh>
<v t="ekr.20060106104442.184"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.185"><vh>drawIcon</vh>
<v t="ekr.20060106104442.186"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.187"><vh>drawLine</vh></v>
<v t="ekr.20060106104442.188"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20060106104442.189"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20060106104442.190"><vh>drawText</vh>
<v t="ekr.20060106104442.191"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.192"><vh>drawUserIcons</vh></v>
<v t="ekr.20060106104442.193"><vh>drawUserIcon</vh>
<v t="ekr.20060106104442.194"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20060106104442.195"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20060106104442.196"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.197"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.198"><vh>drawTopTree</vh></v>
<v t="ekr.20060106104442.199"><vh>drawTree</vh></v>
</v>
<v t="ekr.20060106104442.200"><vh>Helpers...</vh>
<v t="ekr.20060106104442.201"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20060106104442.202"><vh>getIconImage</vh></v>
<v t="ekr.20060106104442.203"><vh>scrollTo</vh>
<v t="ekr.20060106104442.204"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20060106104442.205"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.206"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20060106104442.207"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20060106104442.208"><vh>@@button insert begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20060106104442.209"><vh>(Revised key binding code)</vh>
<v t="ekr.20060106104442.210"><vh>Notes</vh>
<v t="ekr.20060106104442.211"><vh>Create commands for all Tk defaults key</vh></v>
<v t="ekr.20060106104442.212"><vh>Create selection mode</vh>
<v t="ekr.20060106104442.213"><vh>Posting</vh></v>
</v>
<v t="ekr.20060106104442.214"><vh>Problems</vh>
<v t="ekr.20060106104442.215"><vh>forward-sentence-extend-selection doesn't work when invoked by long name</vh></v>
<v t="ekr.20060106104442.216"><vh>Backspace  deletes 2 chars everywhere</vh></v>
</v>
<v t="ekr.20060106104442.217"><vh>Make arrow keys work properly both in the canvas and in headlines</vh></v>
</v>
<v t="ekr.20060106104442.218"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060106104442.219"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060106104442.220"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060106104442.221"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060106104442.222"><vh>Dialog</vh>
<v t="ekr.20060106104442.223"><vh>get_window_info</vh></v>
<v t="ekr.20060106104442.224"><vh>center_dialog</vh></v>
<v t="ekr.20060106104442.225"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060106104442.226"><vh>Focus</vh>
<v t="ekr.20060106104442.227"><vh>get_focus</vh></v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20060106104442.229"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20060106104442.230"><vh>Font</vh>
<v t="ekr.20060106104442.231"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060106104442.232"><vh>Icons</vh>
<v t="ekr.20060106104442.233"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060106104442.234"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060106104442.235"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060106104442.236"><vh>Idle Time</vh>
<v t="ekr.20060106104442.237"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060106104442.238"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060106104442.239"><vh>Indices (Tk)</vh>
<v t="ekr.20060106104442.240"><vh>firstIndex</vh></v>
<v t="ekr.20060106104442.241"><vh>lastIndex</vh></v>
<v t="ekr.20060106104442.242"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060106104442.243"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060106104442.244"><vh>compareIndices</vh></v>
<v t="ekr.20060106104442.245"><vh>getindex</vh></v>
</v>
<v t="ekr.20060106104442.246"><vh>Insert Point</vh>
<v t="ekr.20060106104442.247"><vh>getInsertPoint</vh></v>
<v t="ekr.20060106104442.248"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060106104442.249"><vh>Selection</vh>
<v t="ekr.20060106104442.250"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20060106104442.251"><vh>getSelectedText</vh></v>
<v t="ekr.20060106104442.252"><vh>getTextSelection</vh></v>
<v t="ekr.20060106104442.253"><vh>hasSelection</vh></v>
<v t="ekr.20060106104442.254"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.255"><vh>Text</vh>
<v t="ekr.20060106104442.256"><vh>getAllText</vh></v>
<v t="ekr.20060106104442.257"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060106104442.258"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060106104442.259"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060106104442.260"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060106104442.261"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060106104442.262"><vh>Visibility</vh>
<v t="ekr.20060106104442.263"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.265"><vh>class editCommandsClass</vh>
<v t="ekr.20060106104442.266" a="E"><vh> birth</vh>
<v t="ekr.20060106104442.267"><vh> ctor</vh></v>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20060106104442.268"><vh>capitalization &amp; case</vh>
<v t="ekr.20060106104442.269"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20060106104442.270" a="M"><vh>changePreviousWord</vh></v>
<v t="ekr.20060106104442.271"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20060106104442.272"><vh>color &amp; font</vh>
<v t="ekr.20060106104442.273"><vh>show-colors</vh>
<v t="ekr.20060106104442.274"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20060106104442.275"><vh>createColorPicker</vh>
<v t="ekr.20060106104442.276"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20060106104442.277"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.278"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20060106104442.279"><vh>createFontPicker</vh>
<v t="ekr.20060106104442.280"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20060106104442.281"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.282"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20060106104442.283"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.284"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20060106104442.285"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20060106104442.286"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.287" a="M"><vh>getFont</vh></v>
<v t="ekr.20060106104442.288"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20060106104442.289"><vh>comment column...</vh>
<v t="ekr.20060106104442.290"><vh>setCommentColumn</vh></v>
<v t="ekr.20060106104442.291"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20060106104442.292"><vh>dynamic abbreviation...</vh>
<v t="ekr.20060106104442.293"><vh>dynamicExpansion</vh></v>
<v t="ekr.20060106104442.294"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20060106104442.295"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20060106104442.296"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20060106104442.297"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20060106104442.298"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20060106104442.299"><vh>evalExpression</vh></v>
<v t="ekr.20060106104442.300"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20060106104442.301"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20060106104442.302"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20060106104442.303"><vh>fill column and centering</vh>
<v t="ekr.20060106104442.304"><vh>centerLine</vh></v>
<v t="ekr.20060106104442.305"><vh>setFillColumn</vh></v>
<v t="ekr.20060106104442.306"><vh>centerRegion</vh></v>
<v t="ekr.20060106104442.307"><vh>setFillPrefix</vh></v>
<v t="ekr.20060106104442.308"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060106104442.309"><vh>goto...</vh>
<v t="ekr.20060106104442.310"><vh>gotoCharacter</vh></v>
<v t="ekr.20060106104442.311"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20060106104442.312"><vh>indent... (To do: undo)</vh>
<v t="ekr.20060106104442.313"><vh>backToIndentation</vh></v>
<v t="ekr.20060106104442.314"><vh>deleteIndentation</vh></v>
<v t="ekr.20060106104442.315"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20060106104442.316"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20060106104442.317" a="E"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.326"><vh>info...</vh>
<v t="ekr.20060106104442.327"><vh>howMany</vh></v>
<v t="ekr.20060106104442.328"><vh>lineNumber</vh></v>
<v t="ekr.20060106104442.329"><vh>viewLossage</vh></v>
<v t="ekr.20060106104442.330"><vh>whatLine</vh></v>
</v>
<v t="ekr.20060106104442.331"><vh>line...</vh>
<v t="ekr.20060106104442.332"><vh>flushLines</vh></v>
<v t="ekr.20060106104442.333"><vh>keepLines</vh></v>
<v t="ekr.20060106104442.334"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20060106104442.335"><vh>measure</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.336"><vh>paragraph...</vh>
<v t="ekr.20060106104442.337"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20060106104442.338"><vh>fillParagraph</vh></v>
<v t="ekr.20060106104442.339"><vh>fillRegion</vh></v>
<v t="ekr.20060106104442.340"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20060106104442.341"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20060106104442.342"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20060106104442.343"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.344"><vh>region...</vh>
<v t="ekr.20060106104442.345"><vh>setRegion</vh>
<v t="ekr.20060106104442.346"><vh>down</vh></v>
<v t="ekr.20060106104442.347"><vh>extend</vh></v>
<v t="ekr.20060106104442.348"><vh>truncate</vh></v>
<v t="ekr.20060106104442.349"><vh>up</vh></v>
</v>
<v t="ekr.20060106104442.350"><vh>indentRegion</vh></v>
<v t="ekr.20060106104442.351"><vh>tabIndentRegion</vh></v>
<v t="ekr.20060106104442.352"><vh>countRegion</vh></v>
<v t="ekr.20060106104442.353"><vh>reverseRegion</vh></v>
<v t="ekr.20060106104442.354"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060106104442.355"><vh>replace...</vh>
<v t="ekr.20060106104442.356"><vh>replaceString</vh>
<v t="ekr.20060106104442.357"><vh>&lt;&lt; do the replace &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.358"><vh>activateReplaceRegex</vh></v>
</v>
<v t="ekr.20060106104442.359"><vh>scrollUp/Down</vh></v>
<v t="ekr.20060106104442.360"><vh>sort...</vh>
<v t="ekr.20060106104442.361"><vh>sortLines</vh></v>
<v t="ekr.20060106104442.362"><vh>sortColumns</vh></v>
<v t="ekr.20060106104442.363"><vh>sortFields</vh></v>
</v>
<v t="ekr.20060106104442.364"><vh>swap/transpose...</vh>
<v t="ekr.20060106104442.365"><vh>transposeLines</vh></v>
<v t="ekr.20060106104442.366"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20060106104442.367"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20060106104442.368"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.317"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.369"><vh>tkTtree.setBindings</vh></v>
</v>
<v t="ekr.20060106104442.370"><vh>(Revised general text widget handlers)</vh>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.372"><vh>k.onTextWidgetKey &amp; insertString</vh></v>
</v>
<v t="ekr.20060106104442.373"><vh>(Moved headline coloring code out of endEditLabel and into select)</vh>
<v t="ekr.20060106104442.374"><vh>What I did</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.375"><vh>Bugs</vh>
<v t="ekr.20060106104442.376"><vh>Installed Brian's patch for Import Derived files</vh>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
<v t="ekr.20060106104442.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060106104442.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060106104442.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh>
<v t="ekr.20060106104442.380"><vh>prettyPrintKey</vh></v>
<v t="ekr.20060106104442.381"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060106104442.382"><vh>Suppressed crash undoing a clone followed by a drag</vh>
<v t="ekr.20060106104442.383"><vh>trace</vh></v>
<v t="ekr.20060106104442.384"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20060106104442.385"><vh>Code level</vh>
<v t="ekr.20060106104442.386"><vh>Removed calls to update followed by xWantsFocus</vh></v>
<v t="ekr.20060106104442.387"><vh>Added g.app.gui.isTextWidget</vh>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.388"><vh>(Moving focus out of limbo)</vh>
<v t="ekr.20060106104442.389"><vh>Focus</vh>
<v t="ekr.20060106104442.390"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20060106104442.391" a="M"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20060106104442.392"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060106104442.393"><vh>Find methods</vh>
<v t="ekr.20060106104442.394"><vh>restore</vh></v>
<v t="ekr.20060106104442.395"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060106104442.396"><vh>class leoTkinterLog</vh>
<v t="ekr.20060106104442.397"><vh>tkLog Birth</vh>
<v t="ekr.20060106104442.398"><vh>tkLog.__init__</vh></v>
<v t="ekr.20060106104442.399"><vh>tkLog.createControl</vh></v>
<v t="ekr.20060106104442.400"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20060106104442.401"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20060106104442.402"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20060106104442.403"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20060106104442.404"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20060106104442.405"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20060106104442.406"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20060106104442.407"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20060106104442.408"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20060106104442.409"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20060106104442.410"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20060106104442.411"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20060106104442.412"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20060106104442.413"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.414"><vh>putnl</vh></v>
</v>
<v t="ekr.20060106104442.415"><vh>Tab (TkLog)</vh>
<v t="ekr.20060106104442.416"><vh>clearTab</vh></v>
<v t="ekr.20060106104442.417" a="M"><vh>createTab</vh>
<v t="ekr.20060106104442.418"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20060106104442.419"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.420" a="M"><vh>deleteTab</vh></v>
<v t="ekr.20060106104442.421"><vh>getSelectedTab</vh></v>
<v t="ekr.20060106104442.422" a="M"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060106104442.423"><vh>renameTab</vh></v>
<v t="ekr.20060106104442.424" a="M"><vh>selectTab</vh></v>
<v t="ekr.20060106104442.425"><vh>setTabBindings</vh></v>
<v t="ekr.20060106104442.426"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060106104442.427"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060106104442.428"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060106104442.429"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060106104442.430"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060106104442.431"><vh>New features</vh>
<v t="ekr.20060106104442.432"><vh>*** Allow multiple bindings to the same command</vh>
<v t="ekr.20060106104442.433"><vh>To do</vh></v>
<v t="ekr.20060106104442.434"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.435"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20060106104442.436"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060106104442.437"><vh>doShortcut</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
<v t="ekr.20060106104442.439"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20060106104442.440"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20060106104442.441"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060106104442.442"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060106104442.443"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.444"><vh>bindKey</vh>
<v t="ekr.20060106104442.445"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.446"><vh>bindOpenWith</vh></v>
<v t="ekr.20060106104442.447"><vh>bindShortcut</vh></v>
<v t="ekr.20060106104442.448"><vh>checkBindings</vh></v>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.451"><vh>makeHardBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.455"><vh>canonicalizeShortcut</vh>
<v t="ekr.20060106104442.456"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20060106104442.457"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20060106104442.458"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20060106104442.459"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.460"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.461"><vh>Calls to getShortcut</vh>
<v t="ekr.20060106104442.462" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060106104442.463" a="M"><vh>createBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20060106104442.464"><vh>createMenuEntries</vh>
<v t="ekr.20060106104442.465"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060106104442.466"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060106104442.467"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.468"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.469"><vh>Settings command is now the same as open-leoettings-leo</vh>
<v t="ekr.20060106104442.470"><vh>defineEditMenuTop2Table</vh></v>
<v t="ekr.20060106104442.471"><vh>preferences</vh></v>
</v>
</v>
<v t="ekr.20060106104442.472"><vh>Full input modes</vh>
<v t="ekr.20060106104442.473"><vh>To do</vh></v>
<v t="ekr.20060106104442.474"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.475"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.481"><vh>createModeCommand</vh></v>
<v t="ekr.20060106104442.482"><vh>doMode</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060106104442.483"><vh>From leoKeys.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.484"><vh>finishCreate (keyHandler) &amp; helpers</vh>
<v t="ekr.20060106104442.485"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.486"><vh>keyboardQuit</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.487"><vh>Dispatching...</vh>
<v t="ekr.20060106104442.488"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20060106104442.489"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060106104442.490"><vh>callStateFunction</vh></v>
<v t="ekr.20060106104442.491"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060106104442.492"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060106104442.493"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060106104442.494"><vh>quickCommand  (ctrl-c) &amp; helpers</vh>
<v t="ekr.20060106104442.495"><vh>rCommand</vh></v>
<v t="ekr.20060106104442.496"><vh>processKey</vh>
<v t="ekr.20060106104442.497"><vh>processAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20060106104442.498"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060106104442.499"><vh>matchKeys</vh></v>
<v t="ekr.20060106104442.500"><vh>enterNamedMode &amp;helpers</vh>
<v t="ekr.20060106104442.501"><vh>generalModeHandler</vh></v>
<v t="ekr.20060106104442.502"><vh>modeHelp/Helper</vh>
<v t="ekr.20060106104442.503"><vh>modeHelpHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.504"><vh>set(ignore, insert, overwrite)Mode</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="ekr.20031218072017.843">def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
</t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20031218072017.1322"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20031218072017.1325"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1331"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20031218072017.1924"></t>
<t tx="ekr.20031218072017.1925"></t>
<t tx="ekr.20031218072017.1926">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2257820
By: wtrenker

When I edit a Headline and select the existing text, then I paste in some other
text, the original selected text remains instead of being overwritten by the
newly pasted text.

Here's a simple, repeatable example.  Start a new Leo file.  As expected, the
new file is initialized with a single node with a headline containing the text
"NewHeadline".  The text is pre-selected, ready to edit.  Now do a copy and
then paste.  The text will now read "NewHeadlineNewHeadline".  The original
text was not overwritten.

Here's my configuration:

Leo Log Window...
Leo 4.0.3, build  1.99 , October 25, 2003
Python 2.3.2, Tk 8.3.3

Linux 2.4.19; libc.so.6 2.2.5; gcc 2.95.3
KDE: 3.0.0 Qt: 3.0.4
GNU ld version 2.13.90.0.4 20020814
GNU Make 3.80
pkg-config 0.14.0
Python 2.3.2 (#1, Oct 27 2003, 10:19:56) [GCC 2.95.3 20010315 (release)]

Regards,
Bill
</t>
<t tx="ekr.20040801060323">@ This file contains seldom-used project nodes.

I created this file by copying project nodes from leoPy.leo and pasting them
with the Paste Retaining Clones command.</t>
<t tx="ekr.20050526080309">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050526081024">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050526081024.1"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20060106104442"></t>
<t tx="ekr.20060106104442.1"></t>
<t tx="ekr.20060106104442.2"></t>
<t tx="ekr.20060106104442.3"></t>
<t tx="ekr.20060106104442.4"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20060106104442.5">if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
</t>
<t tx="ekr.20060106104442.6">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="ekr.20060106104442.7"></t>
<t tx="ekr.20060106104442.8">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="ekr.20060106104442.9">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20060106104442.10"></t>
<t tx="ekr.20060106104442.11">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3464874
By: davidmcnab

* The 'goto line number' dialog pops up without the text field active, so I'm
forced into a Compulsory Mouse Click to activate the field before I can type
in the line number (I'm one who regards unnecessary Compulsory Mouse Clicks as bugs).</t>
<t tx="ekr.20060106104442.12">def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    f = self.frame
    
    lab = Tk.Label(f,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = t = Tk.Entry(f,width=20)
    t.pack(side="left")
    
    g.app.gui.set_focus(self.c,t)</t>
<t tx="ekr.20060106104442.13">@

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headling, and ch is always '\r', regardless of
platform.</t>
<t tx="ekr.20060106104442.14">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3466412
By: ktenney

&gt;Use the read_only_nodes plugin. 

It has a great feature list, but I can't get it to
update after the file changes on the filesystem.

I then looked at at_view.py, and the @view node
plugin. (which I worked on way back when :-])

It also doesn't work.
I put a g.es(..) at the top of the icondclick2 method which is registered in
the onCreate method
of at_view.py;

leoPlugins.registerHandler("icondclick2", myView.icondclick2)

It seems that the method does not get called
when the icon is doubleclicked.

Could this behaviour be related to recent changes
in Leo?
</t>
<t tx="ekr.20060106104442.15"></t>
<t tx="ekr.20060106104442.16">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060106104442.17">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060106104442.18"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060106104442.19"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.20"></t>
<t tx="ekr.20060106104442.21">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3462294
By: nobody

apparently the bodykey hooks are no longer used
is why trace_keys plugin doesn't work.
in leoKeys.py I see this trace can be turned on:
.   if c.config.getBool('trace_masterCommand'):</t>
<t tx="ekr.20060106104442.22">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','replace'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060106104442.23">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'replace':   w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060106104442.24">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060106104442.25">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060106104442.26"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060106104442.27">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060106104442.28"></t>
<t tx="ekr.20060106104442.29">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3467558
By: ktenney

Current CVS, W2K

I open a small Leo file, and from File-&gt;Open, select
..\src\LeoPyRef.py. the log pane shows;

----- error reading @file: ../doc/leoToDo.txt
Ignoring @-node sentinel. Expecting @-all

At this point Leo locks up tight, must kill process.

What I did:

** atFile.readError delete's root's entire subtree.
** atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20060106104442.30">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
        
    # g.trace(self.root,g.callers())
    
    self.error(message)
    
    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None
    
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20060106104442.31">def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)</t>
<t tx="ekr.20060106104442.32">def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;</t>
<t tx="ekr.20060106104442.33">try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s</t>
<t tx="ekr.20060106104442.34">def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20060106104442.35"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20060106104442.36">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20060106104442.37">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20060106104442.38">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20060106104442.39">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20060106104442.40"></t>
<t tx="ekr.20060106104442.41">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20060106104442.42">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20060106104442.43">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20060106104442.44">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.45">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20060106104442.46"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20060106104442.47"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20060106104442.48">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20060106104442.49">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20060106104442.50"></t>
<t tx="ekr.20060106104442.51">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20060106104442.52">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20060106104442.53">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20060106104442.54">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.55">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20060106104442.56">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20060106104442.57"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20060106104442.58">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20060106104442.59">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20060106104442.60"></t>
<t tx="ekr.20060106104442.61">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20060106104442.62">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20060106104442.63">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20060106104442.64">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20060106104442.65">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20060106104442.66">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20060106104442.67"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.68">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.69">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20060106104442.70">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20060106104442.71">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20060106104442.72">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20060106104442.73">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20060106104442.74">def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList</t>
<t tx="ekr.20060106104442.75"></t>
<t tx="ekr.20060106104442.76">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3461068
By: vpe

1) Strange behaviour after pasting in headlines:
Start editing a headline in outline pane. Let's say it's 'Settings and
buttons'.
Select all text and copy (ctrl+c).
Place cursor at the end and paste (ctrl+v). What I see is 'Settings and
buttonsSetti'. That is text area does not expand to accomodate new text length.
And I cannot move beyond that point.
If I move to another headline I see that pasting was done correctly. 

2) (done) I always make these changes without any problems:
Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt;Config
&amp; Measuring...--&gt;headWidth &amp; widthInPixels
return max(self.minimum_headline_width,5 + len(s))  ##change to 1

Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt; Birth...
(tkTree)--&gt;__init__--&gt;&lt;&lt; define drawing constants &gt;&gt;
self.minimum_headline_width = 20 # In characters. ##change to 2


Leo 4.4 alpha 4, build  1.346 , December 5, 2005
Python 2.4.2, Tk 8.4.7, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4    &lt;--- nice!
</t>
<t tx="ekr.20060106104442.77"></t>
<t tx="ekr.20060106104442.78">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060106104442.79">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060106104442.80">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060106104442.81">@nocolor

The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20060106104442.82"></t>
<t tx="ekr.20060106104442.83">@nocolor

I've just investigated how Leo handles pane settings, and I believe all is
working as intended. This is somewhat confusing, but there has been no change in
this code for a long time: it has nothing whatever to do with the 4.4 code
base.

The so-called 'primary' ratio is the ratio between the body pane and the pane
containing the other two panes. The so-called secondary ratio is the ratio
between sizes of the log pane and the outline pane.

The thing to keep in mind is that Leo saves *only* the primary ratio in .leo
files. Leo does not save the so-called 'secondary' ratio in .leo files, because
doing so would change Leo's file format.

Because Leo **does** save the primary ratio in .leo files, Leo will open a file
with the same primary ratio that you had when you last saved the file.

Because Leo does **not** save the secondary ratio in the .leo file Leo
determines the relative sizes of the log and outline panes from settings in
leoSettings.leo. One of the two settings is used:

- initial_horizontal_secondary_ratio or

- initial_vertical_secondary_ratio

Which one is used depends on the initial_splitter_orientation setting.

**Important** If you change these settings you must restart Leo for them to take effect.

I have been able to set the secondary ratio as I please from leoSettings.leo,
and have observed that Leo properly saves and restores the primary ratio in .leo
files.

In short, everything works as it should.</t>
<t tx="ekr.20060106104442.84">def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2</t>
<t tx="ekr.20060106104442.85"># From Brian re Read @file nodes w/o creating copy of root node</t>
<t tx="ekr.20060106104442.86">@nocolor

- self._forcedGnxPositionList = [] in ctor.

- </t>
<t tx="ekr.20060106104442.87">def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.
    
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20060106104442.88">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.89">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.90">def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    leoBaseAtFile.__init__( self )
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self._forcedGnxPositionList = [] #This has to be here, puttin it in initReadIvars renders it useless

    c.checksums = {}
    self.md5 = None
    @others</t>
<t tx="ekr.20060106104442.91">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.92">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
        
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.93"></t>
<t tx="ekr.20060106104442.94">def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.95">@

This handles the root node properly so that Leo draws no duplicate node. The
code is from LeoUser; thanks Brian.

I also fixed a recent bugs: the screen was not being redrawn afterwards.</t>
<t tx="ekr.20060106104442.96">def forceGnxOnPosition (self,p):
    
    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.97">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.98">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20060106104442.99">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.100"></t>
<t tx="ekr.20060106104442.101"></t>
<t tx="ekr.20060106104442.102"></t>
<t tx="ekr.20060106104442.103">@
The change was logical, but it caused problems.

The new 'insert' keyword arg must have the value 'sel.end' for compatibility with old code.</t>
<t tx="ekr.20060106104442.104">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20060106104442.105"></t>
<t tx="ekr.20060106104442.106">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060106104442.107"></t>
<t tx="ekr.20060106104442.108"></t>
<t tx="ekr.20060106104442.109">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=True)
    spot = w.index(spot) # Capture initial value.
    ins = w.index('insert')
    w.mark_set('insert',spot)
    if extend or self.extendMode:
        if w.compare(spot,'&lt;=',i):
            g.app.gui.setTextSelection (w,spot,j,insert=None)
        else:
            g.app.gui.setTextSelection (w,i,spot,insert=None)
    w.see(spot)</t>
<t tx="ekr.20060106104442.110">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060106104442.111">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.112">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.113">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.114">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.115">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.116">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060106104442.117">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060106104442.118">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060106104442.119">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060106104442.120">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20060106104442.121">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.122">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.123">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.124">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060106104442.125"></t>
<t tx="ekr.20060106104442.126"></t>
<t tx="ekr.20060106104442.127"></t>
<t tx="ekr.20060106104442.128">@nocolor

- As before, tree.select always sets tree.revertHeadline.  This is the revert point.

- endEditLabel now simply unselects the widget.  It has *no* responsibility for keeping the headline in synch with p.headString.  This is a major advance in reliability.

- tree.onHeadChanged sets changed = s != oldRevert.  This is more reliable than previously.</t>
<t tx="ekr.20060106104442.129"></t>
<t tx="ekr.20060106104442.130">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20060106104442.131">def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.132">def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.frame.tree.editLabel(p)
        w = p.edit_widget()
        if w:
            w.delete("1.0","end")
            w.insert("1.0",name)
            c.endEditing()
            ### c.frame.tree.onHeadChanged(p,'rename-buffer %s' % p.headString())</t>
<t tx="ekr.20060106104442.133">@nocolor

Bug 1: OnActivateBody *must* call onHeadChanged: select is not always called!

But 2: c.endEditing and tree.endEditLabel **must** call tree.onHeadChanged.</t>
<t tx="ekr.20060106104442.134"></t>
<t tx="ekr.20060106104442.135">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20060106104442.136">def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20060106104442.137">@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20060106104442.138"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20060106104442.139"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20060106104442.140">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20060106104442.141"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20060106104442.142">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.143"></t>
<t tx="ekr.20060106104442.144">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060106104442.145">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20060106104442.146">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20060106104442.147">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.148">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.149">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.150"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20060106104442.151">def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag</t>
<t tx="ekr.20060106104442.152"></t>
<t tx="ekr.20060106104442.153"># Ends the editing in the outline.

def endEditing(self):

    self.frame.tree.endEditLabel()
</t>
<t tx="ekr.20060106104442.154"></t>
<t tx="ekr.20060106104442.155">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060106104442.156">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.157">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060106104442.158">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.159"></t>
<t tx="ekr.20060106104442.160">def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')</t>
<t tx="ekr.20060106104442.161"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20060106104442.162">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20060106104442.163"></t>
<t tx="ekr.20060106104442.164"></t>
<t tx="ekr.20060106104442.165">@nocolor

To do:

- Test abortEditLabelCommand.

- c.redraw() redraws conditionally.
- Create c.xxx methods that call the corresponding c.frame.tree methods.

** Find is not selecting headlines properly.
- Test drags.

What I did:

- Made c.begin/endUpdate and tree.begin/endUpdate functional again.
- Created a script to add c.begin/endUpdate().
- Removed redraw_flag from deleteOutline.
- Tested undo/redo delete node.
- Removed redraw_flag from insertHeadline.
- Removed redraw_flag from onBodyChanged.
- c.redraw_now() redraws undconditionally: it is used seldom.
- Replaced c.redraw_now by c.redraw or c.begin/endUpdate.
- Removed redraw_flag from c.selectPosition, tree.select, tree.onHeadChanged, body.onBodyChanged.

</t>
<t tx="ekr.20060106104442.166"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20060106104442.167">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20060106104442.168">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20060106104442.169">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20060106104442.170"></t>
<t tx="ekr.20060106104442.171">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060106104442.172">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20060106104442.173">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20060106104442.174">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060106104442.175">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20060106104442.176"></t>
<t tx="ekr.20060106104442.177">def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now()
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount")</t>
<t tx="ekr.20060106104442.178"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060106104442.179">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060106104442.180">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20060106104442.181"></t>
<t tx="ekr.20060106104442.182">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20060106104442.183">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20060106104442.184">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.185">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20060106104442.186">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20060106104442.187">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20060106104442.188">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20060106104442.189">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20060106104442.190">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20060106104442.191"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.192">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20060106104442.193">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20060106104442.194">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20060106104442.195">pass</t>
<t tx="ekr.20060106104442.196">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20060106104442.197">pass</t>
<t tx="ekr.20060106104442.198">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20060106104442.199">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20060106104442.200"></t>
<t tx="ekr.20060106104442.201">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20060106104442.202">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20060106104442.203">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20060106104442.204">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20060106104442.205">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20060106104442.206">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20060106104442.207">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20060106104442.208">u = c.undoer ; w = c.frame.body.bodyCtrl

s1 = '''\
    c.beginUpdate()
    try:'''
s2 = '''\
    finally:
        c.endUpdate()'''

b = u.beforeChangeNodeContents(p)

i, j = g.app.gui.getTextSelection(w)
if i != j:
    s = w.get(i,j)
    s = ''.join(['\t'+line for line in g.splitLines(s)])
    w.delete(i,j)
    w.insert(i,s1+'\n'+s+'\n'+s2)
else:
    w.insert(i,s1+'\n\t\t\n'+s2)

c.recolor()
u.afterChangeNodeContents(p,'add-begin/endUpdate',b)</t>
<t tx="ekr.20060106104442.209">No change was actually needed, just new bindings.

What I did:
    
- fixed a bug in copyBindingsToWidget
- textBindingsRedirectionCallback now returns 'break', not None.</t>
<t tx="ekr.20060106104442.210">@nocolor

Key bindings

Leo must have commands to do what Tk text widgets do for all their standard bindings.  This is the only way I know of to allow users to choose different bindings for those actions.

Therefore, Leo should pass *no* key events to Tk for 'default' handling.  That is, all of Leo's key handlers will return 'break', not None.  In particular, all text widgets must have something like selfInsertCommand so they can handle ordinary keystrokes.

Typing in headlines *still* does not always stick.  The present event handlers for headlines have way too many paths through them.  The problems are caused in large part by the abort-edit-headline command: it requires state info.  I may add a beginEditHeadline command that will remember the state.  This will allow Leo to save the headline text on *every* keystroke, rather than only at the end.  This is *much* safer than trying to ensure that endEditHeadline gets called on every path.  The new endEditHeadline will have no responsibility for state except to clear the info set by beginEditHeadline.  Nothing much bad will ever happen if endEditHeadline doesn't get called once in a while.

I hope to get all the necessary bindings and commands done this week.

Undo

Undo is well defined only for headlines and body text.  There is little or no use, alas, for event.widget in leoEditCommands.py.  Brian's suggestion of having beginUndo/endUndo markers makes a lot of sense: such markers simplify the code and hide implementation and policy details that should be hidden.

Focus

Getting focus exactly right is crucial: some of the present commands in leoEditCommands.py don't work if they are invoked by their long name rather than from a keystroke.

In short, the combination of bindings, undo and focus creates a lot of problems that must be handled with extreme care.  It's frustrating to rewrite essentially every line of Brian's temacs code, but I believe it must be done.

And we are not done yet.  Leo creates an environment different from Emacs:  incremental search must be expanded to move from node to node, the notion of the 'mark' must be generalized (in some, but not all situations), etc.  Sometimes, though, the generalization is also a simplification: as I have said before, Leo's nodes can and should be treated as exactly synonymous with Emacs's buffers.

Edward
</t>
<t tx="ekr.20060106104442.211"></t>
<t tx="ekr.20060106104442.212"></t>
<t tx="ekr.20060106104442.213">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3464605
leouser

You really need to think about using Ctrl-Space for starting selection mode.
Its a wonderful thing.  Once in selection mode you just move around with your
arrows and things get selected.  Or if you want to move quickly you can do stuff
like Ctrl-a or Ctrl-e or Ctrl-&lt; or Ctrl-&gt;.  Combining selection mode and fast
movement keystrokes is good...</t>
<t tx="ekr.20060106104442.214"></t>
<t tx="ekr.20060106104442.215"></t>
<t tx="ekr.20060106104442.216"></t>
<t tx="ekr.20060106104442.217">make the default bindings work differently when editing
the headline as opposed to when traversing the tree with the arrow keys.</t>
<t tx="ekr.20060106104442.218"></t>
<t tx="ekr.20060106104442.219">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20060106104442.220">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20060106104442.221">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20060106104442.222"></t>
<t tx="ekr.20060106104442.223"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.224">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.225"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20060106104442.226"></t>
<t tx="ekr.20060106104442.227">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20060106104442.228">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20060106104442.229">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20060106104442.230"></t>
<t tx="ekr.20060106104442.231">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.232"></t>
<t tx="ekr.20060106104442.233">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20060106104442.234">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20060106104442.235"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20060106104442.236"></t>
<t tx="ekr.20060106104442.237">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.238">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.239"></t>
<t tx="ekr.20060106104442.240">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20060106104442.241">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20060106104442.242">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20060106104442.243">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20060106104442.244">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20060106104442.245">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20060106104442.246"></t>
<t tx="ekr.20060106104442.247">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20060106104442.248">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20060106104442.249"></t>
<t tx="ekr.20060106104442.250">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20060106104442.251">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None</t>
<t tx="ekr.20060106104442.252">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20060106104442.253">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20060106104442.254">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20060106104442.255"></t>
<t tx="ekr.20060106104442.256">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.257">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.258">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.259">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.260">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.261">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20060106104442.262"></t>
<t tx="ekr.20060106104442.263">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20060106104442.264">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060106104442.265">class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others</t>
<t tx="ekr.20060106104442.266"></t>
<t tx="ekr.20060106104442.267">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060106104442.268"></t>
<t tx="ekr.20060106104442.269">def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')</t>
<t tx="ekr.20060106104442.270">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.271">def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
</t>
<t tx="ekr.20060106104442.272"></t>
<t tx="ekr.20060106104442.273">def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    &lt;&lt; define colors &gt;&gt;
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
</t>
<t tx="ekr.20060106104442.274">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20060106104442.275">def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;</t>
<t tx="ekr.20060106104442.276">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20060106104442.277">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)</t>
<t tx="ekr.20060106104442.278">def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)</t>
<t tx="ekr.20060106104442.279">def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;</t>
<t tx="ekr.20060106104442.280">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')</t>
<t tx="ekr.20060106104442.281">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.282">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20060106104442.283">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.284">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.285">sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)</t>
<t tx="ekr.20060106104442.286">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)</t>
<t tx="ekr.20060106104442.287">def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.288">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)</t>
<t tx="ekr.20060106104442.289"></t>
<t tx="ekr.20060106104442.290">def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2</t>
<t tx="ekr.20060106104442.291">def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 &gt;= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')</t>
<t tx="ekr.20060106104442.292"></t>
<t tx="ekr.20060106104442.293">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20060106104442.294">def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)</t>
<t tx="ekr.20060106104442.295">def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)</t>
<t tx="ekr.20060106104442.296"></t>
<t tx="ekr.20060106104442.297">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)</t>
<t tx="ekr.20060106104442.298">def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)</t>
<t tx="ekr.20060106104442.299">def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)</t>
<t tx="ekr.20060106104442.300"></t>
<t tx="ekr.20060106104442.301">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()</t>
<t tx="ekr.20060106104442.302">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)</t>
<t tx="ekr.20060106104442.303">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others</t>
<t tx="ekr.20060106104442.304">def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) &gt;= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)</t>
<t tx="ekr.20060106104442.305">def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()</t>
<t tx="ekr.20060106104442.306">def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1</t>
<t tx="ekr.20060106104442.307">def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt</t>
<t tx="ekr.20060106104442.308">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt</t>
<t tx="ekr.20060106104442.309"></t>
<t tx="ekr.20060106104442.310">def gotoCharacter (self,event):

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.311">def gotoLine (self,event):

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.312"></t>
<t tx="ekr.20060106104442.313">def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)</t>
<t tx="ekr.20060106104442.314">def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.315">def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
</t>
<t tx="ekr.20060106104442.316">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.317"></t>
<t tx="ekr.20060106104442.318">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060106104442.319">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060106104442.320">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20060106104442.321">def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20060106104442.322">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060106104442.323">def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
</t>
<t tx="ekr.20060106104442.324">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)</t>
<t tx="ekr.20060106104442.325">def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20060106104442.326"></t>
<t tx="ekr.20060106104442.327">def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))</t>
<t tx="ekr.20060106104442.328">def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))</t>
<t tx="ekr.20060106104442.329">def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)</t>
<t tx="ekr.20060106104442.330">def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)</t>
<t tx="ekr.20060106104442.331"></t>
<t tx="ekr.20060106104442.332">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.333">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.334">def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.335">def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom</t>
<t tx="ekr.20060106104442.336">@others</t>
<t tx="ekr.20060106104442.337">def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.338">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20060106104442.339">def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','&gt;',s2):
            break
        self.fillParagraph(event)</t>
<t tx="ekr.20060106104442.340">def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)</t>
<t tx="ekr.20060106104442.341">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.342">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20060106104442.343">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20060106104442.344">@others</t>
<t tx="ekr.20060106104442.345">def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('&lt;Right&gt;',extend,'+')
    w.bind('&lt;Left&gt;',truncate,'+')
    w.bind('&lt;Up&gt;',up,'+')
    w.bind('&lt;Down&gt;',down,'+')

    return 'break'</t>
<t tx="ekr.20060106104442.346">def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'</t>
<t tx="ekr.20060106104442.347">def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

</t>
<t tx="ekr.20060106104442.348">def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'</t>
<t tx="ekr.20060106104442.349">def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'</t>
<t tx="ekr.20060106104442.350">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.351">def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)</t>
<t tx="ekr.20060106104442.352">def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))</t>
<t tx="ekr.20060106104442.353">def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()</t>
<t tx="ekr.20060106104442.354">def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.355"></t>
<t tx="ekr.20060106104442.356">def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    prompt = 'Replace ' + g.choose(self._useRegex,'Regex','String')

    if state == 0:
        self.widget = event.widget
        self._sString = self._rpString = ''
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        self._rpString = k.arg ; w = self.widget
        &lt;&lt; do the replace &gt;&gt;
        k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
        self._useRegex = False</t>
<t tx="ekr.20060106104442.357"># g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.358">def activateReplaceRegex( self ):
    
    '''This method turns regex replace on for replaceString'''

    self._useRegex = True
    return True</t>
<t tx="ekr.20060106104442.359">def scrollDown (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) + chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')

def scrollUp (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) - chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')</t>
<t tx="ekr.20060106104442.360">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20060106104442.361">def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.362">def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.363">def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.364"></t>
<t tx="ekr.20060106104442.365">def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')</t>
<t tx="ekr.20060106104442.366">def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060106104442.367">def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters</t>
<t tx="ekr.20060106104442.368">def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.369"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20060106104442.370"></t>
<t tx="ekr.20060106104442.371">def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('&lt;Key&gt;',k.onTextWidgetKey)</t>
<t tx="ekr.20060106104442.372">def onTextWidgetKey (self,event):
    
    '''This is the default key handler for all text widgets.
    It should never be called for keys bound to any command.'''

    ch = event and event.char or ''
    w  = event and event.widget

    if w and ch:
        i,j = g.app.gui.getTextSelection(w)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)

    return 'break'</t>
<t tx="ekr.20060106104442.373"></t>
<t tx="ekr.20060106104442.374">@nocolor

- &lt;&lt; unselect the old node &gt;&gt; in tree.select now calls
    self.setUnselectedLabelState(old_p)

- tree.endEditLabel no longer calls setUnselectedLabelState.
    (This is important)</t>
<t tx="ekr.20060106104442.375"></t>
<t tx="ekr.20060106104442.376"></t>
<t tx="ekr.20060106104442.377">Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function keyCallback2 at 0x01378630&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x034905D0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 814, in keyCallback2
    def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1143, in masterCommand
    if stroke == k.abortAllModesKey: # 'Control-g'
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 811, in menuFuncCallback
    def menuFuncCallback (event,command=command):
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 2250, in backwardDeleteCharacter
    oldText = w.get('1.0','end')
AttributeError: Canvas instance has no attribute 'get'

</t>
<t tx="ekr.20060106104442.378"></t>
<t tx="ekr.20060106104442.379"></t>
<t tx="ekr.20060106104442.380">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    if not key:
        return ''
        
    ch = key[-2]

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20060106104442.381">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20060106104442.382"># The reason for this assert is unclear.</t>
<t tx="ekr.20060106104442.383">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 239, in doCommand
    val = command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1579, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1729, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2767, in moveToNthChildOf
    p.unlink()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3310, in unlink
    assert(parent.v in p.v.directParents())
AssertionError</t>
<t tx="ekr.20060106104442.384">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20060106104442.385"></t>
<t tx="ekr.20060106104442.386"></t>
<t tx="ekr.20060106104442.387"></t>
<t tx="ekr.20060106104442.388">@ Ripping focus away from widgets is odious and bug prone.

A much better solution: call update *after* log-pane operations.</t>
<t tx="ekr.20060106104442.389"></t>
<t tx="ekr.20060106104442.390">@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.</t>
<t tx="ekr.20060106104442.391">def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
</t>
<t tx="ekr.20060106104442.392"># New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '&lt;no name&gt;'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060106104442.393"></t>
<t tx="ekr.20060106104442.394"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20060106104442.395">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20060106104442.396">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20060106104442.397"></t>
<t tx="ekr.20060106104442.398">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20060106104442.399">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20060106104442.400">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20060106104442.401">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20060106104442.402"></t>
<t tx="ekr.20060106104442.403">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20060106104442.404">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20060106104442.405">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20060106104442.406">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20060106104442.407">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20060106104442.408">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20060106104442.409"></t>
<t tx="ekr.20060106104442.410">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20060106104442.411">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20060106104442.412">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20060106104442.413">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20060106104442.414">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20060106104442.415"></t>
<t tx="ekr.20060106104442.416">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')</t>
<t tx="ekr.20060106104442.417">def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    &lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;
    &lt;&lt; Create the tab's text widget &gt;&gt;
    self.setTabBindings(tabName)
    
    # New in 4.4b1: call update explicitly.
    textWidget and textWidget.update()</t>
<t tx="ekr.20060106104442.418">menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20060106104442.419">textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("&lt;Button-1&gt;",self.onActivateLog)
textWidget.tag_config('black',foreground='black')</t>
<t tx="ekr.20060106104442.420">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.421">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20060106104442.422">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        logCtrl and logCtrl.update()
        self.c.frame.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            logCtrl.update()
            self.c.frame.widgetWantsFocus(logCtrl)</t>
<t tx="ekr.20060106104442.423">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20060106104442.424">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    
    # New in 4.4b1: call update *after* creating the tab.
    tabFrame and tabFrame.update()

    return tabFrame</t>
<t tx="ekr.20060106104442.425">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)</t>
<t tx="ekr.20060106104442.426"></t>
<t tx="ekr.20060106104442.427">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20060106104442.428">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20060106104442.429">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20060106104442.430">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20060106104442.431"></t>
<t tx="ekr.20060106104442.432"></t>
<t tx="ekr.20060106104442.433"></t>
<t tx="ekr.20060106104442.434"></t>
<t tx="ekr.20060106104442.435">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'mode':         self.doMode, # New in 4.4b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20060106104442.436">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)</t>
<t tx="ekr.20060106104442.437">def doShortcut(self,p,kind,name,val):
    
    # Note:  kind,name,val are as returned from self.parseHeadline(p.headString())

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20060106104442.438">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    # g.trace(self.c.fileName(),p.headString(),g.callers())
    
    d = self.shortcutsDict # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                # New in 4.4a5:
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)</t>
<t tx="ekr.20060106104442.439">def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)</t>
<t tx="ekr.20060106104442.440">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.
    
    if 1:
        bunchList = self.get(c,key,"shortcut")
        if bunchList:
            bunchList = [bunch for bunch in bunchList
                if bunch.val and bunch.val.lower() != 'none']
            return key,bunchList
        else:
            return key,[]
    else:
        bunch = self.get(c,key,"shortcut")
        if bunch and bunch.val:
            # g.trace(bunch.pane,key,repr(bunch.val))
            if bunch.val.lower() == 'none':
                return key,None
            else:
                return key,bunch
        else:
            return key,None</t>
<t tx="ekr.20060106104442.441"></t>
<t tx="ekr.20060106104442.442">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20060106104442.443">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20060106104442.444">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c 

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    ## if shortcut == '&lt;None&gt;': return
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        # g.trace('Not bound',shortcut)
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return
        
    # g.trace(pane,shortcut,commandName)

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20060106104442.445"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20060106104442.446">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20060106104442.447">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20060106104442.448">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060106104442.449">def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.addModeCommands()
    k.checkBindings()</t>
<t tx="ekr.20060106104442.450">def addModeCommands (self):
    
    '''Add commands created by @mode settings..'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060106104442.451">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '&lt;Control-t&gt;':  c.editCommands.transposeLines,
        '&lt;Control-u&gt;':  c.editCommands.upCaseRegion,
        '&lt;Control-l&gt;':  c.editCommands.downCaseRegion,
        '&lt;Control-o&gt;':  c.editCommands.removeBlankLines,
        '&lt;Control-i&gt;':  c.editFileCommands.insertFile,
        '&lt;Control-s&gt;':  c.editFileCommands.saveFile,
        '&lt;Control-x&gt;':  c.editCommands.exchangePointMark,
        '&lt;Control-c&gt;':  c.controlCommands.shutdown,
        '&lt;Control-b&gt;':  c.bufferCommands.listBuffers,
        '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
        '&lt;Delete&gt;':     c.killBufferCommands.backwardKillSentence,
    }</t>
<t tx="ekr.20060106104442.452">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20060106104442.453">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(stroke,accel,shortcut,func.__name__)
    if pane == 'mini' and func != k.keyboardQuit:
        # Call a strange callback that bypasses k.masterCommand.
        def minibufferKeyCallback(event,func=func,shortcut=shortcut):
            k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

        k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
        # Create two-levels of callbacks.
        def specialCallback (event,func=func):
            return func(event)

        def keyCallback (event,func=specialCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)

        k.bindKey(pane,shortcut,keyCallback,commandName)

    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20060106104442.454">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20060106104442.455">@ This code "canonicalizes" both the shortcuts that appear in menus and the
arguments to bind, mostly ignoring case and the order in which special keys are
specified.

For example, Ctrl+Shift+a is the same as Shift+Control+A. Each generates
Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print repr(shortcut),repr(bind_shortcut),repr(menu_shortcut)
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20060106104442.456">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20060106104442.457">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20060106104442.458"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20060106104442.459"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9</t>
<t tx="ekr.20060106104442.460">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20060106104442.461"></t>
<t tx="ekr.20060106104442.462">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)
</t>
<t tx="ekr.20060106104442.463">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
                    
                </t>
<t tx="ekr.20060106104442.464">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20060106104442.465">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060106104442.466"># First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunchList = c.config.getShortcut(commandName)
bunch = bunchList and bunchList[0]
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    &lt;&lt; compute emacs_name &gt;&gt;
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunchList = c.config.getShortcut(emacs_name)
        bunch = bunchList and bunchList[0]
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060106104442.467">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060106104442.468">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20060106104442.469">@ This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20060106104442.470">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20060106104442.471">def preferences(self):
    
    '''Handle the preferences command.'''
    
    c = self
    c.openLeoSettings()</t>
<t tx="ekr.20060106104442.472"></t>
<t tx="ekr.20060106104442.473">@nocolor

- set-insert, set-replace commands.
- Fancier mode-help.
- Use tabs in print-commands &amp; print-bindings.

Docs
- Document @mode and how to use it.
- Move most settings docs to Customizing chapter.

Cleanup
- Default modes should set the label.
- Create tkinterKeyHandler.
- Complete vim emulation</t>
<t tx="ekr.20060106104442.474"></t>
<t tx="ekr.20060106104442.475"></t>
<t tx="ekr.20060106104442.476">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20060106104442.477">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20060106104442.478">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
&lt;&lt; set self.unboundKeyAction &gt;&gt;</t>
<t tx="ekr.20060106104442.479">defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
defaultAction.lower()
if defaultAction in ('insert','replace','ignore'):
    self.unboundKeyAction = defaultAction
else:
    g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
    self.unboundKeyAction = 'insert'</t>
<t tx="ekr.20060106104442.480"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0</t>
<t tx="ekr.20060106104442.481">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060106104442.482">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060106104442.483"></t>
<t tx="ekr.20060106104442.484">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20060106104442.485">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20060106104442.486">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return
        
    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.487"></t>
<t tx="ekr.20060106104442.488">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060106104442.489"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060106104442.490">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060106104442.491">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060106104442.492">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060106104442.493">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20060106104442.494">def quickCommand (self,event):
    
    '''Handle 'quick-command' (control-c) mode.'''
    
    k = self ; stroke = k.stroke ; state = k.getState('quick-command')
    
    if state == 0:
        k.setState('quick-command',1,handler=k.quickCommand)
        k.setLabelBlue('quick command: ',protect=True)
    else:
        k.previous.insert(0,event.keysym)
        if len(k.previous) &gt; 10: k.previous.pop()
        
        # g.trace('stroke',stroke,event.keysym)
        if stroke == '&lt;Key&gt;' and event.keysym == 'r':
            k.rCommand(event)
        elif stroke in ('&lt;Key&gt;','&lt;Escape&gt;'):
            if k.processKey(event): # Weird command-specific stuff.
                k.clearState()
        elif stroke in k.xcommands:
            k.clearState()
            k.xcommands [stroke](event)

        k.endCommand(event,stroke)
        
    return 'break'</t>
<t tx="ekr.20060106104442.495">def rCommand (self,event):
    
    k = self ; state = k.getState('r-command') ; ch = event.keysym
    if state == 0:
        k.setLabel ('quick-command r: ',protect=True)
        k.setState('r-command',1,k.rCommand)
    elif ch in ('Control_L','Alt_L','Shift_L'):
        return
    else:
        k.clearState()
        
        # g.trace(repr(ch))
        func = k.rCommandDict.get(ch)
        if func:
            k.commandName = 'quick-command r: '
            k.resetLabel()
            func(event)
        else:
            k.setLabelGrey('Unknown r command: %s' % repr(ch))</t>
<t tx="ekr.20060106104442.496">def processKey (self,event):
    
    '''Handle special keys in quickCommand mode.
    Return True if we should exit quickCommand mode.'''

    k = self ; c = k.c ; previous = k.previous
    
    if event.keysym in ('Shift_L','Shift_R'): return False
    # g.trace(event.keysym)

    func = k.variety_commands.get(event.keysym)
    if func:
        k.keyboardQuit(event)
        func(event)
        return True

    if event.keysym in ('a','i','e'):
        if k.processAbbreviation(event):
            return False # 'a e' or 'a i e' typed.
        
    if event.keysym == 'g': # Execute the abbreviation in the minibuffer.
        s = k.getLabel(ignorePrompt=True)
        if k.abbreviationFuncDict.has_key(s):
            k.clearState()
            k.keyboardQuit(event)
            k.abbreviationFuncDict [s](event)
            return True
    
    if event.keysym == 'e': # Execute the last macro.
        k.keyboardQuit(event)
        c.macroCommands.callLastKeyboardMacro(event)
        return True

    if event.keysym == 'x' and previous [1] not in ('Control_L','Control_R'):
        event.keysym = 's'
        k.setState('quick-command',1)
        c.registerCommands.setNextRegister(event)
        return True

    if event.keysym == 'Escape' and len(previous) &gt; 1 and previous [1] == 'Escape':
        k.repeatComplexCommand(event)
        return True
        
    else:
        return False</t>
<t tx="ekr.20060106104442.497">def processAbbreviation (self,event):
    
    '''Handle a e or a i e.
    Return True when the 'e' has been seen.'''
    
    k = self ; char = event.char

    if k.getLabel() != 'a' and event.keysym == 'a':
        k.setLabel('a')
        return False

    elif k.getLabel() == 'a':

        if char == 'i':
            k.setLabel('a i')
            return False
        elif char == 'e':
            event.char = ''
            k.expandAbbrev(event)
            return True
            
    return False</t>
<t tx="ekr.20060106104442.498">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060106104442.499">def matchKeys (self,event,shortcut):
    
    '''Return true if a binding matches the key specified by the event.'''
    
    k = self ; c = k.c
    
    if not k.stroke or not event: return False
    
    stroke = k.stroke ; keysym = event.keysym
    shortcut2, junk = c.frame.menu.canonicalizeShortcut(shortcut)
    
    if stroke == '&lt;Key&gt;':
        val = shortcut == keysym or shortcut.startswith('Key-') and shortcut.endswith(keysym)
    else:
        val = stroke == shortcut2
        
    if 0:
        g.trace('returns',val,
            'stroke',stroke,'keysym',keysym,
            'shortcut',shortcut,'shortcuts',shortcut2)
        
    return val</t>
<t tx="ekr.20060106104442.500">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName)
</t>
<t tx="ekr.20060106104442.501">def generalModeHandler (self,event,name=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ; f = c.frame
    modeName = name or k.inputModeName
    commandName = 'enter-' + modeName
    state = k.getState(modeName)
    keysym = event and event.keysym or ''
    # g.trace(modeName,'state',state)
    
    d = g.app.config.modeCommandsDict.get(commandName)
    if not d:
        g.trace("can't happen")
    elif state == 0:
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(name,1,handler=k.generalModeHandler)
        k.setLabelBlue(name,protect=True)
        k.modeCompletionList = d.keys()
    else:
        for key in d.keys():
            bunchList = d.get(key)
            for bunch in bunchList:
                if k.matchKeys(event,bunch.val):
                    func = c.commandsDict.get(key)
                    # g.trace('calling',func)
                    if key != 'mode-help':
                        # This must be done first because commands can change windows.
                        k.clearState()
                        k.resetLabel()
                        k.endCommand(event,k.stroke)
                        k.inputModeName = None
                        c.frame.log.deleteTab('Mode')
                        c.frame.widgetWantsFocus(k.modeWidget)
                    func(event)
                    return 'break'
        k.modeHelpHelper(d)
        f.minibufferWantsFocus()
        
    return 'break'</t>
<t tx="ekr.20060106104442.502">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        g.es('Not in any mode')





</t>
<t tx="ekr.20060106104442.503">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    
    for key in d.keys():
        bunchList = d.get(key)
        bunch = bunchList and bunchList[0]
        shortcut = bunch.val
        if shortcut not in (None,'None'):
            if shortcut.startswith('Key-'):
                shortcut = shortcut[4:]
                if len(shortcut) == 1:
                    ch = shortcut[0]
                    if ch in string.ascii_uppercase:
                        shortcut = 'Shift-%s' % ch.lower()
            g.es('%s\t%s' % (shortcut,key),tabName='Mode')</t>
<t tx="ekr.20060106104442.504">def setIgnoreMode (self,event):
    
    self.unboundKeyAction = 'ignore'

def setInsertMode (self,event):
    
    self.unboundKeyAction = 'insert'
    
def setOverwriteMode (self,event):
    
    self.unboundKeyAction = 'replace'</t>
</tnodes>
</leo_file>
