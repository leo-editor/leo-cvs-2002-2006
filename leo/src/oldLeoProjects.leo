<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="4407" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="127" height="827" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20040801060323" a="E"><vh>Old Projects</vh>
<v t="ekr.20031218072017.1924"><vh> Waiting for help from Linux people</vh>
<v t="ekr.20031218072017.1925"><vh>Paste bug (Linux only)</vh>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1926"><vh>Linux headline bug</vh></v>
</v>
<v t="ekr.20050924073836" a="E"><vh>4.4 projects</vh>
<v t="ekr.20060106104442"><vh>4.4a5 projects</vh>
<v t="ekr.20060106104442.1"><vh>cvs snapshot 1</vh>
<v t="ekr.20060106104442.2"><vh>Bugs fixed</vh>
<v t="ekr.20060106104442.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.7"><vh>Fixed problem with getScript in batch mode</vh>
<v t="ekr.20060106104442.8"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20060106104442.9"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20060106104442.10"><vh>Select text box in goto-line-number command</vh>
<v t="ekr.20060106104442.11"><vh>Report</vh></v>
<v t="ekr.20060106104442.12"><vh>tkinterAskOKCancelNumber.createFrame</vh></v>
</v>
<v t="ekr.20060106104442.13"><vh>Restored headkey hooks</vh>
<v t="ekr.20060106104442.14"><vh>Report</vh></v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18" a="E"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.20"><vh>Restored bodykey hooks</vh>
<v t="ekr.20060106104442.21"><vh>Report</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh>
<v t="ekr.20060106104442.29"><vh>Report &amp; what I did</vh></v>
<v t="ekr.20060106104442.30"><vh>readError</vh></v>
<v t="ekr.20060106104442.31"><vh>atFile.error</vh></v>
<v t="ekr.20060106104442.32"><vh>readOpenFile</vh>
<v t="ekr.20060106104442.33"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.34"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20060106104442.35"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20060106104442.36"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20060106104442.37"><vh>readNormalLine</vh>
<v t="ekr.20060106104442.38"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20060106104442.39"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.40"><vh>start sentinels</vh>
<v t="ekr.20060106104442.41"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20060106104442.42"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20060106104442.43"><vh>readStartLeo</vh></v>
<v t="ekr.20060106104442.44"><vh>readStartMiddle</vh></v>
<v t="ekr.20060106104442.45"><vh>readStartNode (4.x)</vh>
<v t="ekr.20060106104442.46"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20060106104442.47"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20060106104442.48"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.49"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20060106104442.50"><vh>end sentinels</vh>
<v t="ekr.20060106104442.51"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20060106104442.52"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20060106104442.53"><vh>readEndLeo</vh></v>
<v t="ekr.20060106104442.54"><vh>readEndMiddle</vh></v>
<v t="ekr.20060106104442.55"><vh>readEndNode (4.x)</vh>
<v t="ekr.20060106104442.56"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20060106104442.57"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.58"><vh>readEndOthers</vh></v>
<v t="ekr.20060106104442.59"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060106104442.60"><vh>Unpaired sentinels</vh>
<v t="ekr.20060106104442.61"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20060106104442.62"><vh>readAfterRef</vh></v>
<v t="ekr.20060106104442.63"><vh>readClone</vh></v>
<v t="ekr.20060106104442.64"><vh>readComment</vh></v>
<v t="ekr.20060106104442.65"><vh>readDelims</vh></v>
<v t="ekr.20060106104442.66"><vh>readDirective (@@)</vh>
<v t="ekr.20060106104442.67"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20060106104442.68"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.69"><vh>readNl</vh></v>
<v t="ekr.20060106104442.70"><vh>readNonl</vh></v>
<v t="ekr.20060106104442.71"><vh>readRef</vh></v>
<v t="ekr.20060106104442.72"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20060106104442.73"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20060106104442.74"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20060106104442.75"><vh>Fixed minor headline problems</vh>
<v t="ekr.20060106104442.76"><vh>Report</vh></v>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20060106104442.82"><vh>Investigated secondary ratio problems</vh>
<v t="ekr.20060106104442.83"><vh>Notes</vh></v>
<v t="ekr.20060106104442.84"><vh>initialRatios</vh></v>
</v>
<v t="ekr.20060106104442.85"><vh>Installed LeoUsers patch for the Read @file Nodes command</vh>
<v t="ekr.20060106104442.86"><vh>What I did</vh></v>
<v t="ekr.20060106104442.87"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20060106104442.88"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.89"><vh>createThinChild4</vh></v>
<v t="ekr.20060106104442.90"><vh>atFile.__init__ and initIvars NEW</vh>
<v t="ekr.20060106104442.91"><vh> define the dispatch dictionary used by scanText4</vh></v>
</v>
<v t="ekr.20060106104442.92"><vh>createThinChild4 NEW</vh></v>
</v>
<v t="ekr.20060106104442.93"><vh>Fixed bug: clicking in the expand/contract box didn't save the headline</vh>
<v t="ekr.20060106104442.94"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060106104442.95"><vh>Installed LeoUser's patch for Read derived files</vh>
<v t="ekr.20060106104442.96"><vh>atFile.forceGnxOnPosition</vh></v>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.100"><vh>New features</vh>
<v t="ekr.20060106104442.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20060106104442.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20060106104442.103"><vh>Added 'insert' keyword to setTextSelection methods</vh>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.105"><vh>(Revised cursor movement commands and added selection-extension commands)</vh>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.125"><vh>Code changes</vh>
<v t="ekr.20060106104442.126"><vh>(Rewrote cut/copy/paste code)</vh>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.127"><vh>(Revised headline handlers)</vh>
<v t="ekr.20060106104442.128"><vh> What I did</vh>
<v t="ekr.20060106104442.129"><vh>Replaced calls to onHeadChanged by calls to c.endEditing</vh>
<v t="ekr.20060106104442.130"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.132"><vh>renameBuffer</vh></v>
</v>
</v>
<v t="ekr.20060106104442.133"><vh>Notes</vh></v>
<v t="ekr.20060106104442.134"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
<v t="ekr.20060106104442.136"><vh>editLabel</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.143"><vh>tree.set...LabelState</vh>
<v t="ekr.20060106104442.144"><vh>setEditLabelState</vh></v>
<v t="ekr.20060106104442.145"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060106104442.146"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060106104442.147"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060106104442.148"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060106104442.149"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060106104442.150"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20060106104442.151"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18" a="E"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.152"><vh>Calls to tree.endEditLabel</vh>
<v t="ekr.20060106104442.153"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.154"><vh>Icon Box...</vh>
<v t="ekr.20060106104442.155"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060106104442.156"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060106104442.157"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060106104442.158"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060106104442.159"><vh>Calls to onHeadChanged</vh>
<v t="ekr.20060106104442.160"><vh>toggleAngleBrackets</vh></v>
<v t="ekr.20060106104442.161"><vh>changeSelection</vh></v>
<v t="ekr.20060106104442.162"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20060106104442.163"><vh>Should *not* call onHeadChanged</vh>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060106104442.164"><vh>(Restored c.begin/endUpdate)</vh>
<v t="ekr.20060106104442.165"><vh>What I did</vh></v>
<v t="ekr.20060106104442.166"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20060106104442.167"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20060106104442.168"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20060106104442.169"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20060106104442.170"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060106104442.171" a="M"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.172"><vh>c.bringToFront</vh></v>
<v t="ekr.20060106104442.173"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060106104442.174"><vh>c.recolor_now</vh></v>
<v t="ekr.20060106104442.175"><vh>c.redraw_now</vh></v>
</v>
<v t="ekr.20060106104442.176"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20060106104442.177"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.178"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060106104442.179"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060106104442.180"><vh>idle_second_redraw</vh></v>
<v t="ekr.20060106104442.181"><vh>drawX...</vh>
<v t="ekr.20060106104442.182"><vh>drawBox</vh></v>
<v t="ekr.20060106104442.183"><vh>drawClickBox</vh>
<v t="ekr.20060106104442.184"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.185"><vh>drawIcon</vh>
<v t="ekr.20060106104442.186"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.187"><vh>drawLine</vh></v>
<v t="ekr.20060106104442.188"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20060106104442.189"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20060106104442.190"><vh>drawText</vh>
<v t="ekr.20060106104442.191"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.192"><vh>drawUserIcons</vh></v>
<v t="ekr.20060106104442.193"><vh>drawUserIcon</vh>
<v t="ekr.20060106104442.194"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20060106104442.195"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20060106104442.196"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.197"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.198"><vh>drawTopTree</vh></v>
<v t="ekr.20060106104442.199"><vh>drawTree</vh></v>
</v>
<v t="ekr.20060106104442.200"><vh>Helpers...</vh>
<v t="ekr.20060106104442.201"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20060106104442.202"><vh>getIconImage</vh></v>
<v t="ekr.20060106104442.203"><vh>scrollTo</vh>
<v t="ekr.20060106104442.204"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20060106104442.205"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.206"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20060106104442.207"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20060106104442.208"><vh>@@button insert begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20060106104442.209"><vh>(Revised key binding code)</vh>
<v t="ekr.20060106104442.210"><vh>Notes</vh>
<v t="ekr.20060106104442.211"><vh>Create commands for all Tk defaults key</vh></v>
<v t="ekr.20060106104442.212"><vh>Create selection mode</vh>
<v t="ekr.20060106104442.213"><vh>Posting</vh></v>
</v>
<v t="ekr.20060106104442.214"><vh>Problems</vh>
<v t="ekr.20060106104442.215"><vh>forward-sentence-extend-selection doesn't work when invoked by long name</vh></v>
<v t="ekr.20060106104442.216"><vh>Backspace  deletes 2 chars everywhere</vh></v>
</v>
<v t="ekr.20060106104442.217"><vh>Make arrow keys work properly both in the canvas and in headlines</vh></v>
</v>
<v t="ekr.20060106104442.218"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060106104442.219"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060106104442.220"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060106104442.221"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060106104442.222"><vh>Dialog</vh>
<v t="ekr.20060106104442.223"><vh>get_window_info</vh></v>
<v t="ekr.20060106104442.224"><vh>center_dialog</vh></v>
<v t="ekr.20060106104442.225"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060106104442.226"><vh>Focus</vh>
<v t="ekr.20060106104442.227"><vh>get_focus</vh></v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20060106104442.229"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20060106104442.230"><vh>Font</vh>
<v t="ekr.20060106104442.231"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060106104442.232"><vh>Icons</vh>
<v t="ekr.20060106104442.233"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060106104442.234"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060106104442.235"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060106104442.236"><vh>Idle Time</vh>
<v t="ekr.20060106104442.237"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060106104442.238"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060106104442.239"><vh>Indices (Tk)</vh>
<v t="ekr.20060106104442.240"><vh>firstIndex</vh></v>
<v t="ekr.20060106104442.241"><vh>lastIndex</vh></v>
<v t="ekr.20060106104442.242"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060106104442.243"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060106104442.244"><vh>compareIndices</vh></v>
<v t="ekr.20060106104442.245"><vh>getindex</vh></v>
</v>
<v t="ekr.20060106104442.246"><vh>Insert Point</vh>
<v t="ekr.20060106104442.247"><vh>getInsertPoint</vh></v>
<v t="ekr.20060106104442.248"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060106104442.249"><vh>Selection</vh>
<v t="ekr.20060106104442.250"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20060106104442.251"><vh>getSelectedText</vh></v>
<v t="ekr.20060106104442.252"><vh>getTextSelection</vh></v>
<v t="ekr.20060106104442.253"><vh>hasSelection</vh></v>
<v t="ekr.20060106104442.254"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.255"><vh>Text</vh>
<v t="ekr.20060106104442.256"><vh>getAllText</vh></v>
<v t="ekr.20060106104442.257"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060106104442.258"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060106104442.259"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060106104442.260"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060106104442.261"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060106104442.262"><vh>Visibility</vh>
<v t="ekr.20060106104442.263"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.265"><vh>class editCommandsClass</vh>
<v t="ekr.20060106104442.266" a="E"><vh> birth</vh>
<v t="ekr.20060106104442.267"><vh> ctor</vh></v>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20060106104442.268"><vh>capitalization &amp; case</vh>
<v t="ekr.20060106104442.269"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20060106104442.270" a="M"><vh>changePreviousWord</vh></v>
<v t="ekr.20060106104442.271"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20060106104442.272"><vh>color &amp; font</vh>
<v t="ekr.20060106104442.273"><vh>show-colors</vh>
<v t="ekr.20060106104442.274"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20060106104442.275"><vh>createColorPicker</vh>
<v t="ekr.20060106104442.276"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20060106104442.277"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.278"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20060106104442.279"><vh>createFontPicker</vh>
<v t="ekr.20060106104442.280"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20060106104442.281"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.282"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20060106104442.283"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.284"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20060106104442.285"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20060106104442.286"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.287" a="M"><vh>getFont</vh></v>
<v t="ekr.20060106104442.288"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20060106104442.289"><vh>comment column...</vh>
<v t="ekr.20060106104442.290"><vh>setCommentColumn</vh></v>
<v t="ekr.20060106104442.291"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20060106104442.292"><vh>dynamic abbreviation...</vh>
<v t="ekr.20060106104442.293"><vh>dynamicExpansion</vh></v>
<v t="ekr.20060106104442.294"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20060106104442.295"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20060106104442.296"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20060106104442.297"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20060106104442.298"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20060106104442.299"><vh>evalExpression</vh></v>
<v t="ekr.20060106104442.300"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20060106104442.301"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20060106104442.302"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20060106104442.303"><vh>fill column and centering</vh>
<v t="ekr.20060106104442.304"><vh>centerLine</vh></v>
<v t="ekr.20060106104442.305"><vh>setFillColumn</vh></v>
<v t="ekr.20060106104442.306"><vh>centerRegion</vh></v>
<v t="ekr.20060106104442.307"><vh>setFillPrefix</vh></v>
<v t="ekr.20060106104442.308"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060106104442.309"><vh>goto...</vh>
<v t="ekr.20060106104442.310"><vh>gotoCharacter</vh></v>
<v t="ekr.20060106104442.311"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20060106104442.312"><vh>indent... (To do: undo)</vh>
<v t="ekr.20060106104442.313"><vh>backToIndentation</vh></v>
<v t="ekr.20060106104442.314"><vh>deleteIndentation</vh></v>
<v t="ekr.20060106104442.315"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20060106104442.316"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20060106104442.317" a="E"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.326"><vh>info...</vh>
<v t="ekr.20060106104442.327"><vh>howMany</vh></v>
<v t="ekr.20060106104442.328"><vh>lineNumber</vh></v>
<v t="ekr.20060106104442.329"><vh>viewLossage</vh></v>
<v t="ekr.20060106104442.330"><vh>whatLine</vh></v>
</v>
<v t="ekr.20060106104442.331"><vh>line...</vh>
<v t="ekr.20060106104442.332"><vh>flushLines</vh></v>
<v t="ekr.20060106104442.333"><vh>keepLines</vh></v>
<v t="ekr.20060106104442.334"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20060106104442.335"><vh>measure</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.336"><vh>paragraph...</vh>
<v t="ekr.20060106104442.337"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20060106104442.338"><vh>fillParagraph</vh></v>
<v t="ekr.20060106104442.339"><vh>fillRegion</vh></v>
<v t="ekr.20060106104442.340"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20060106104442.341"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20060106104442.342"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20060106104442.343"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.344"><vh>region...</vh>
<v t="ekr.20060106104442.345"><vh>setRegion</vh>
<v t="ekr.20060106104442.346"><vh>down</vh></v>
<v t="ekr.20060106104442.347"><vh>extend</vh></v>
<v t="ekr.20060106104442.348"><vh>truncate</vh></v>
<v t="ekr.20060106104442.349"><vh>up</vh></v>
</v>
<v t="ekr.20060106104442.350"><vh>indentRegion</vh></v>
<v t="ekr.20060106104442.351"><vh>tabIndentRegion</vh></v>
<v t="ekr.20060106104442.352"><vh>countRegion</vh></v>
<v t="ekr.20060106104442.353"><vh>reverseRegion</vh></v>
<v t="ekr.20060106104442.354"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060106104442.355"><vh>replace...</vh>
<v t="ekr.20060106104442.356"><vh>replaceString</vh>
<v t="ekr.20060106104442.357"><vh>&lt;&lt; do the replace &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.358"><vh>activateReplaceRegex</vh></v>
</v>
<v t="ekr.20060106104442.359"><vh>scrollUp/Down</vh></v>
<v t="ekr.20060106104442.360"><vh>sort...</vh>
<v t="ekr.20060106104442.361"><vh>sortLines</vh></v>
<v t="ekr.20060106104442.362"><vh>sortColumns</vh></v>
<v t="ekr.20060106104442.363"><vh>sortFields</vh></v>
</v>
<v t="ekr.20060106104442.364"><vh>swap/transpose...</vh>
<v t="ekr.20060106104442.365"><vh>transposeLines</vh></v>
<v t="ekr.20060106104442.366"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20060106104442.367"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20060106104442.368"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.317"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.369"><vh>tkTtree.setBindings</vh></v>
</v>
<v t="ekr.20060106104442.370"><vh>(Revised general text widget handlers)</vh>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.372"><vh>k.onTextWidgetKey &amp; insertString</vh></v>
</v>
<v t="ekr.20060106104442.373"><vh>(Moved headline coloring code out of endEditLabel and into select)</vh>
<v t="ekr.20060106104442.374"><vh>What I did</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.375"><vh>Bugs</vh>
<v t="ekr.20060106104442.376"><vh>Installed Brian's patch for Import Derived files</vh>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
<v t="ekr.20060106104442.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060106104442.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060106104442.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh>
<v t="ekr.20060106104442.380"><vh>prettyPrintKey</vh></v>
<v t="ekr.20060106104442.381"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060106104442.382"><vh>Suppressed crash undoing a clone followed by a drag</vh>
<v t="ekr.20060106104442.383"><vh>trace</vh></v>
<v t="ekr.20060106104442.384"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20060106104442.385"><vh>Code level</vh>
<v t="ekr.20060106104442.386"><vh>Removed calls to update followed by xWantsFocus</vh></v>
<v t="ekr.20060106104442.387"><vh>Added g.app.gui.isTextWidget</vh>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.388"><vh>(Moving focus out of limbo)</vh>
<v t="ekr.20060106104442.389"><vh>Focus</vh>
<v t="ekr.20060106104442.390"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20060106104442.391" a="M"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20060106104442.392"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060106104442.393"><vh>Find methods</vh>
<v t="ekr.20060106104442.394"><vh>restore</vh></v>
<v t="ekr.20060106104442.395"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060106104442.396"><vh>class leoTkinterLog</vh>
<v t="ekr.20060106104442.397"><vh>tkLog Birth</vh>
<v t="ekr.20060106104442.398"><vh>tkLog.__init__</vh></v>
<v t="ekr.20060106104442.399"><vh>tkLog.createControl</vh></v>
<v t="ekr.20060106104442.400"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20060106104442.401"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20060106104442.402"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20060106104442.403"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20060106104442.404"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20060106104442.405"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20060106104442.406"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20060106104442.407"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20060106104442.408"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20060106104442.409"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20060106104442.410"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20060106104442.411"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20060106104442.412"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20060106104442.413"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.414"><vh>putnl</vh></v>
</v>
<v t="ekr.20060106104442.415"><vh>Tab (TkLog)</vh>
<v t="ekr.20060106104442.416"><vh>clearTab</vh></v>
<v t="ekr.20060106104442.417" a="M"><vh>createTab</vh>
<v t="ekr.20060106104442.418"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20060106104442.419"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.420" a="M"><vh>deleteTab</vh></v>
<v t="ekr.20060106104442.421"><vh>getSelectedTab</vh></v>
<v t="ekr.20060106104442.422" a="M"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060106104442.423"><vh>renameTab</vh></v>
<v t="ekr.20060106104442.424" a="M"><vh>selectTab</vh></v>
<v t="ekr.20060106104442.425"><vh>setTabBindings</vh></v>
<v t="ekr.20060106104442.426"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060106104442.427"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060106104442.428"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060106104442.429"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060106104442.430"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060106104442.431"><vh>New features</vh>
<v t="ekr.20060106104442.432"><vh>*** Allow multiple bindings to the same command</vh>
<v t="ekr.20060106104442.433"><vh>To do</vh></v>
<v t="ekr.20060106104442.434"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.435"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20060106104442.436"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060106104442.437"><vh>doShortcut</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
<v t="ekr.20060106104442.439"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20060106104442.440"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20060106104442.441"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060106104442.442"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060106104442.443"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.444"><vh>bindKey</vh>
<v t="ekr.20060106104442.445"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.446"><vh>bindOpenWith</vh></v>
<v t="ekr.20060106104442.447"><vh>bindShortcut</vh></v>
<v t="ekr.20060106104442.448"><vh>checkBindings</vh></v>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.451"><vh>makeHardBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.455"><vh>canonicalizeShortcut</vh>
<v t="ekr.20060106104442.456"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20060106104442.457"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20060106104442.458"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20060106104442.459"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.460"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.461"><vh>Calls to getShortcut</vh>
<v t="ekr.20060106104442.462" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060106104442.463" a="M"><vh>createBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20060106104442.464"><vh>createMenuEntries</vh>
<v t="ekr.20060106104442.465"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060106104442.466"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060106104442.467"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.468"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.469"><vh>Settings command is now the same as open-leoettings-leo</vh>
<v t="ekr.20060106104442.470"><vh>defineEditMenuTop2Table</vh></v>
<v t="ekr.20060106104442.471"><vh>preferences</vh></v>
</v>
</v>
<v t="ekr.20060106104442.472"><vh>Full input modes</vh>
<v t="ekr.20060106104442.473"><vh>To do</vh></v>
<v t="ekr.20060106104442.474"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.475"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.481"><vh>createModeCommand</vh></v>
<v t="ekr.20060106104442.482"><vh>doMode</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060106104442.483"><vh>From leoKeys.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.484"><vh>finishCreate (keyHandler) &amp; helpers</vh>
<v t="ekr.20060106104442.485"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.486"><vh>keyboardQuit</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.487"><vh>Dispatching...</vh>
<v t="ekr.20060106104442.488"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20060106104442.489"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060106104442.490"><vh>callStateFunction</vh></v>
<v t="ekr.20060106104442.491"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060106104442.492"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060106104442.493"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060106104442.494"><vh>quickCommand  (ctrl-c) &amp; helpers</vh>
<v t="ekr.20060106104442.495"><vh>rCommand</vh></v>
<v t="ekr.20060106104442.496"><vh>processKey</vh>
<v t="ekr.20060106104442.497"><vh>processAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20060106104442.498"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060106104442.499"><vh>matchKeys</vh></v>
<v t="ekr.20060106104442.500"><vh>enterNamedMode &amp;helpers</vh>
<v t="ekr.20060106104442.501"><vh>generalModeHandler</vh></v>
<v t="ekr.20060106104442.502"><vh>modeHelp/Helper</vh>
<v t="ekr.20060106104442.503"><vh>modeHelpHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.504"><vh>set(ignore, insert, overwrite)Mode</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136" a="TV"><vh>4.4b1 projects</vh>
<v t="ekr.20060120105136.1"><vh>Bugs fixed</vh>
<v t="ekr.20060120105136.2"><vh>Fixed minor headline problems</vh>
<v t="ekr.20060120105136.3"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060120105136.4"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.5"><vh>deleteNextChar</vh></v>
<v t="ekr.20060120105136.6"><vh>begin/endCommand</vh>
<v t="ekr.20060120105136.7"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20060120105136.8"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20060120105136.9"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060120105136.10"><vh>head key handlers</vh>
<v t="ekr.20060120105136.11"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060120105136.12"><vh>updateHead</vh></v>
<v t="ekr.20060120105136.13"><vh>onHeadChanged</vh>
<v t="ekr.20060120105136.14"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.15"><vh>Removed all calls to g.top() from Leo's core</vh>
<v t="ekr.20060120105136.16"><vh>Changed</vh>
<v t="ekr.20060120105136.17"><vh>createFrame (tkComparePanel)</vh>
<v t="ekr.20060120105136.18"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20060120105136.19"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20060120105136.20"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20060120105136.21"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20060120105136.22"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20060120105136.23"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.24"><vh>From leoGlobals.py</vh>
<v t="ekr.20060120105136.25"><vh>callers</vh></v>
<v t="ekr.20060120105136.26"><vh>createTopologyList</vh></v>
<v t="ekr.20060120105136.27"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20060120105136.28"><vh>g.scanDirectives</vh>
<v t="ekr.20060120105136.29"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.30"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20060120105136.31"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20060120105136.32"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20060120105136.33"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20060120105136.34"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20060120105136.35"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.36"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20060120105136.37"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.38"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20060120105136.39"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="ekr.20060120105136.40"><vh>From leoTest.py</vh>
<v t="ekr.20060120105136.41"><vh>doTests...</vh>
<v t="ekr.20060120105136.42"><vh>class generalTestCase</vh>
<v t="ekr.20060120105136.43"><vh>__init__</vh></v>
<v t="ekr.20060120105136.44"><vh> fail</vh></v>
<v t="ekr.20060120105136.45"><vh>setUp</vh></v>
<v t="ekr.20060120105136.46"><vh>tearDown</vh></v>
<v t="ekr.20060120105136.47"><vh>runTest</vh></v>
<v t="ekr.20060120105136.48"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20060120105136.49"><vh>makeTestSuite</vh></v>
<v t="ekr.20060120105136.50"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20060120105136.51"><vh>runTimerOnNode</vh></v>
<v t="ekr.20060120105136.52"><vh>numberOfClonesInOutline</vh></v>
<v t="ekr.20060120105136.53"><vh>numberOfNodesInOutline</vh></v>
<v t="ekr.20060120105136.54"><vh>leoTest.runLeoTest</vh></v>
<v t="ekr.20060120105136.55"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20060120105136.56"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20060120105136.57"><vh>runPerfectImportTest</vh></v>
</v>
<v t="ekr.20060120105136.58"><vh>From leoNodes.py</vh>
<v t="ekr.20060120105136.59"><vh>p.__init__</vh></v>
<v t="ekr.20060120105136.60"><vh>p.copy</vh></v>
</v>
<v t="ekr.20060120105136.61"><vh>scanError</vh></v>
</v>
</v>
<v t="ekr.20060120105136.62"><vh>Fixed undo problems</vh>
<v t="ekr.20060120105136.63"><vh>Report</vh></v>
<v t="ekr.20060120105136.64"><vh>top level</vh>
<v t="ekr.20060120105136.65"><vh>new</vh></v>
<v t="ekr.20060120105136.66"><vh>open</vh>
<v t="ekr.20060120105136.67"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.68"><vh>openWith and allies</vh>
<v t="ekr.20060120105136.69"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060120105136.70"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060120105136.71"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060120105136.72"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060120105136.73"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060120105136.74"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060120105136.75"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060120105136.76"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.77"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060120105136.78"><vh>close</vh></v>
<v t="ekr.20060120105136.79"><vh>save</vh></v>
<v t="ekr.20060120105136.80"><vh>saveAs</vh></v>
<v t="ekr.20060120105136.81"><vh>saveTo</vh></v>
<v t="ekr.20060120105136.82"><vh>revert</vh></v>
</v>
<v t="ekr.20060120105136.83"><vh>g.openWithFileName</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060120105136.85"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060120105136.86"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060120105136.87"><vh>Fix crash: tab in minibuffer</vh>
<v t="ekr.20060120105136.88"><vh>traceback</vh></v>
</v>
<v t="ekr.20060120105136.89"><vh>Installed patch for headline width</vh>
<v t="ekr.20060120105136.90"><vh>Report</vh></v>
<v t="ekr.20060120105136.91"><vh>__init__</vh>
<v t="ekr.20060120105136.92"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060120105136.93"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.94"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.95"><vh>headWidth &amp; widthInPixels</vh></v>
</v>
<v t="ekr.20060120105136.96"><vh>Redraw screen properly after Move To Next Dirty</vh>
<v t="ekr.20060120105136.97"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20060120105136.98"><vh>goToNextMarkedHeadline</vh></v>
</v>
<v t="ekr.20060120105136.99"><vh>Fixed focus bug</vh>
<v t="ekr.20060120105136.100"><vh>Report</vh></v>
<v t="ekr.20060120105136.101"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060120105136.102"><vh>Made sure to bring proper window on top in settings.leo button</vh>
<v t="ekr.20060120105136.83"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20060120105136.103"><vh>Fixed problem with arrow keys</vh>
<v t="ekr.20060120105136.104"><vh>Report</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
</v>
<v t="ekr.20060120105136.106"><vh>Investigated cut/paste problem</vh>
<v t="ekr.20060120105136.107"><vh>Report</vh></v>
<v t="ekr.20060120105136.108"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060120105136.109"><vh>copyText</vh></v>
<v t="ekr.20060120105136.110"><vh>cutText</vh></v>
<v t="ekr.20060120105136.111"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060120105136.112"><vh>Fixed several bugs</vh></v>
<v t="ekr.20060120105136.113"><vh>Fixed recent bug: text in new headline was not selected</vh>
<v t="ekr.20060120105136.114"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060120105136.101"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060120105136.115"><vh>Fixed problem with Mac enter key</vh>
<v t="ekr.20060120105136.116"><vh>Report</vh></v>
</v>
<v t="ekr.20060120105136.117"><vh>Fixed problems with plugins</vh>
<v t="ekr.20060120105136.118"><vh>Report</vh></v>
<v t="ekr.20060120105136.119"><vh>Report 2</vh></v>
</v>
<v t="ekr.20060120105136.120"><vh>Installed patch to cleo plugin</vh></v>
<v t="ekr.20060120105136.121"><vh>Fixed old file handling bug</vh>
<v t="ekr.20060120105136.122"><vh>Report</vh></v>
<v t="ekr.20060120105136.123"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060120105136.124"><vh>Use shutil.move in g.utils_rename</vh>
<v t="ekr.20060120105136.125"><vh>Report</vh></v>
<v t="ekr.20060120105136.126"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20060120105136.127"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20060120105136.128"><vh>test_g_utils_rename</vh></v>
</v>
</v>
<v t="ekr.20060120105136.129"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh>
<v t="ekr.20060120105136.130"><vh>Notes</vh></v>
<v t="ekr.20060120105136.131"><vh>Dispatching...</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.137"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060120105136.138"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060120105136.139"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060120105136.140"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060120105136.141"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060120105136.142"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.148"><vh>bindOpenWith</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.150"><vh>checkBindings</vh></v>
<v t="ekr.20060120105136.151"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.154"><vh>isPlainKey</vh></v>
<v t="ekr.20060120105136.155"><vh>makeAllBindings</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.157"><vh>makeHardBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.160"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060120105136.161"><vh>setTabBindings</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060120105136.162"><vh>Made sure that focus stays in body during tab completion</vh>
<v t="ekr.20060120105136.163"><vh>Notes</vh></v>
<v t="ekr.20060120105136.164"><vh>clearTab</vh></v>
</v>
<v t="ekr.20060120105136.165"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060120105136.166"><vh>Fixed many binding problems</vh>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.168"><vh>All uses of prettyPrintKey</vh>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.170"><vh>printCommands</vh></v>
<v t="ekr.20060120105136.171"><vh>k.registerCommand</vh></v>
<v t="ekr.20060120105136.172"><vh>prettyPrintKey</vh></v>
</v>
<v t="ekr.20060120105136.173"><vh>All uses of inverseCommandsDict</vh>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.174"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060120105136.175"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.176"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
<v t="ekr.20060120105136.177" a="M"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060120105136.178"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.179"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20060120105136.171"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060120105136.180"><vh>All uses of inverseBindingDict</vh>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.170"><vh>printCommands</vh></v>
<v t="ekr.20060120105136.181"><vh>computeCompletionList</vh></v>
<v t="ekr.20060120105136.182"><vh>computeInverseBindingDict</vh></v>
</v>
<v t="ekr.20060120105136.183"><vh>All uses of bindingsDict</vh>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.184"><vh>_executeMacro (revise)</vh></v>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.185"><vh>executeNTimes</vh></v>
<v t="ekr.20060120105136.182"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20060120105136.186"><vh>getShortcutForCommand/Name (should return lists)</vh></v>
</v>
</v>
<v t="ekr.20060120105136.187"><vh>Fixed extend-selection problems</vh>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060120105136.189"><vh>Fixed per-pane bindings!</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.190"><vh>traceBinding</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.191"><vh>All calls to copyBindingsToWidget</vh>
<v t="ekr.20060120105136.161"><vh>setTabBindings</vh></v>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.192"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060120105136.193"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20060120105136.194"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20060120105136.195"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.196"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060120105136.197"><vh>Code level</vh>
<v t="ekr.20060120105136.198"><vh>Added support for plugin menu commands</vh>
<v t="ekr.20060120105136.199"><vh>defineMenuCallback</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060120105136.200"><vh>Removed g.top from all plugins</vh></v>
<v t="ekr.20060120105136.201"><vh>Created c.exists ivar and related logic</vh>
<v t="ekr.20060120105136.202"><vh> c.Birth &amp; death</vh>
<v t="ekr.20060120105136.203"><vh>c.__init__</vh></v>
<v t="ekr.20060120105136.204"><vh>c.initIvars</vh>
<v t="ekr.20060120105136.205"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.206"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20060120105136.207"><vh>c.hash</vh></v>
<v t="ekr.20060120105136.208"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20060120105136.209"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060120105136.210"><vh>destroySelf (tkFrame)</vh></v>
<v t="ekr.20060120105136.211"><vh>app.destroyWindow</vh></v>
<v t="ekr.20060120105136.212"><vh>callTagHandler</vh></v>
</v>
<v t="ekr.20060120105136.213"><vh>Cleaned up code</vh>
<v t="ekr.20060120105136.214"><vh>Won't do</vh></v>
</v>
<v t="ekr.20060120105136.215"><vh>Call c.setLog in all entries into code</vh>
<v t="ekr.20060120105136.216"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="ekr.20060120105136.217"><vh>c.setLog</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.218"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20060120105136.219"><vh>Helpers</vh>
<v t="ekr.20060120105136.220"><vh>checkWidgetList</vh></v>
<v t="ekr.20060120105136.221"><vh>dumpWidgetList</vh></v>
<v t="ekr.20060120105136.222"><vh>edit_widget</vh></v>
<v t="ekr.20060120105136.223"><vh>eventToPosition</vh></v>
<v t="ekr.20060120105136.224"><vh>findEditWidget</vh></v>
<v t="ekr.20060120105136.225"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20060120105136.226"><vh>Click Box...</vh>
<v t="ekr.20060120105136.227"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060120105136.228"><vh>Dragging</vh>
<v t="ekr.20060120105136.229"><vh>endDrag</vh>
<v t="ekr.20060120105136.230"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060120105136.231"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.232"><vh>startDrag</vh></v>
<v t="ekr.20060120105136.233"><vh>onContinueDrag</vh>
<v t="ekr.20060120105136.234"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.235"><vh>onDrag</vh></v>
<v t="ekr.20060120105136.236"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060120105136.10"><vh>head key handlers</vh>
<v t="ekr.20060120105136.11"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060120105136.12"><vh>updateHead</vh></v>
<v t="ekr.20060120105136.13"><vh>onHeadChanged</vh>
<v t="ekr.20060120105136.14"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060120105136.237"><vh>Icon Box...</vh>
<v t="ekr.20060120105136.238"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060120105136.239"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060120105136.240"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060120105136.241"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060120105136.242"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.243"><vh>onTreeClick</vh></v>
<v t="ekr.20060120105136.244"><vh>Text Box...</vh>
<v t="ekr.20060120105136.245"><vh>configureTextState</vh></v>
<v t="ekr.20060120105136.246"><vh>onCtontrolT</vh></v>
<v t="ekr.20060120105136.247"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060120105136.248"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060120105136.249"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20060120105136.250"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20060120105136.251"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20060120105136.252"><vh>createPopupMenu</vh>
<v t="ekr.20060120105136.253"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.254"><vh>enablePopupMenuItems</vh>
<v t="ekr.20060120105136.255"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.256"><vh>showPopupMenu</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.257"><vh>Generalized doCommand</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
<v t="ekr.20060120105136.174"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060120105136.175"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
</v>
</v>
<v t="ekr.20060120105136.258"><vh>Documentation</vh>
<v t="ekr.20060120105136.259"><vh>Updated docs with warnings about deleting children of clones</vh></v>
</v>
<v t="ekr.20060120105136.260"><vh>New features</vh>
<v t="ekr.20060120105136.261"><vh>Installed new standard bindings</vh>
<v t="ekr.20060120105136.262"><vh>From Manfred</vh></v>
<v t="ekr.20060120105136.263"><vh>From Speed</vh></v>
</v>
<v t="ekr.20060120105136.264"><vh>Added script check bindings in leoSettings.leo</vh></v>
<v t="ekr.20060120105136.265"><vh>Scripts now maintain original focus</vh>
<v t="ekr.20060120105136.266"><vh>Report</vh></v>
<v t="ekr.20060120105136.267"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20060120105136.268"><vh>writeFromString (new in 4.3 beta2)</vh></v>
</v>
<v t="ekr.20060120105136.269"><vh>Added scroll-up/down-extend-selection commands</vh>
<v t="ekr.20060120105136.270"><vh>Notes</vh></v>
<v t="ekr.20060120105136.271"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.272"><vh>scrollUp/Down/extendSelection</vh>
<v t="ekr.20060120105136.273"><vh>scrollHelper</vh></v>
</v>
</v>
<v t="ekr.20060120105136.274"><vh>Improved cursor move/extend commands</vh>
<v t="ekr.20060120105136.275"><vh>What I did</vh></v>
<v t="ekr.20060120105136.276"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20060120105136.277"><vh>tree.moveUpDown (Reference)</vh></v>
<v t="ekr.20060120105136.278"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060120105136.279"><vh> helpers</vh>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
<v t="ekr.20060120105136.280"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.281"><vh>moveWordHelper</vh></v>
<v t="ekr.20060120105136.282"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060120105136.283"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060120105136.284"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060120105136.285"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060120105136.286"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060120105136.287"><vh>exchangePointMark</vh></v>
<v t="ekr.20060120105136.288"><vh>extendMode</vh></v>
<v t="ekr.20060120105136.289"><vh>buffers</vh></v>
<v t="ekr.20060120105136.290"><vh>characters</vh></v>
<v t="ekr.20060120105136.291"><vh>lines</vh></v>
<v t="ekr.20060120105136.292"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060120105136.293"><vh>paragraphs</vh></v>
<v t="ekr.20060120105136.294"><vh>sentences</vh></v>
<v t="ekr.20060120105136.295"><vh>words</vh></v>
</v>
<v t="ekr.20060120105136.291"><vh>lines</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.280"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060120105136.273"><vh>scrollHelper</vh></v>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060120105136.296"><vh>Made edit command keys work in headlines</vh></v>
<v t="ekr.20060120105136.297"><vh>Use pretty keys in tab completion tab</vh></v>
<v t="ekr.20060120105136.298"><vh>Finish support for @mode nodes</vh>
<v t="ekr.20060120105136.299"><vh>Notes</vh></v>
<v t="ekr.20060120105136.177" a="M"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060120105136.300"><vh>From leoConfig</vh>
<v t="ekr.20060120105136.301"><vh>createModeCommand</vh></v>
<v t="ekr.20060120105136.302"><vh>doMode</vh></v>
</v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.140"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060120105136.141"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060120105136.142"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.148"><vh>bindOpenWith</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.150"><vh>checkBindings</vh></v>
<v t="ekr.20060120105136.151"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.154"><vh>isPlainKey</vh></v>
<v t="ekr.20060120105136.155"><vh>makeAllBindings</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.157"><vh>makeHardBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.160"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060120105136.303"><vh>Modes</vh>
<v t="ekr.20060120105136.304"><vh>enterNamedMode</vh></v>
<v t="ekr.20060120105136.305"><vh>modeHelp &amp; helper</vh>
<v t="ekr.20060120105136.306"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060120105136.307"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060120105136.308"><vh>badMode</vh></v>
<v t="ekr.20060120105136.309"><vh>createModeBindings</vh>
<v t="ekr.20060120105136.310"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060120105136.311"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.312"><vh>initMode</vh></v>
<v t="ekr.20060120105136.313"><vh>endMode</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.314"><vh>keyboard-quit restores default input mode</vh>
<v t="ekr.20060120105136.315"><vh>keyboardQuit</vh></v>
<v t="ekr.20060120105136.316"><vh>set-xxx-Mode</vh></v>
<v t="ekr.20060120105136.317"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="ekr.20031218072017.843">def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
</t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20031218072017.1322"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20031218072017.1325"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1331"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20031218072017.1924"></t>
<t tx="ekr.20031218072017.1925"></t>
<t tx="ekr.20031218072017.1926">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2257820
By: wtrenker

When I edit a Headline and select the existing text, then I paste in some other
text, the original selected text remains instead of being overwritten by the
newly pasted text.

Here's a simple, repeatable example.  Start a new Leo file.  As expected, the
new file is initialized with a single node with a headline containing the text
"NewHeadline".  The text is pre-selected, ready to edit.  Now do a copy and
then paste.  The text will now read "NewHeadlineNewHeadline".  The original
text was not overwritten.

Here's my configuration:

Leo Log Window...
Leo 4.0.3, build  1.99 , October 25, 2003
Python 2.3.2, Tk 8.3.3

Linux 2.4.19; libc.so.6 2.2.5; gcc 2.95.3
KDE: 3.0.0 Qt: 3.0.4
GNU ld version 2.13.90.0.4 20020814
GNU Make 3.80
pkg-config 0.14.0
Python 2.3.2 (#1, Oct 27 2003, 10:19:56) [GCC 2.95.3 20010315 (release)]

Regards,
Bill
</t>
<t tx="ekr.20040801060323">@ This file contains seldom-used project nodes.

I created this file by copying project nodes from leoPy.leo and pasting them
with the Paste Retaining Clones command.</t>
<t tx="ekr.20050526080309">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050526081024">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050526081024.1"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20060106104442"></t>
<t tx="ekr.20060106104442.1"></t>
<t tx="ekr.20060106104442.2"></t>
<t tx="ekr.20060106104442.3"></t>
<t tx="ekr.20060106104442.4"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20060106104442.5">if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
</t>
<t tx="ekr.20060106104442.6">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="ekr.20060106104442.7"></t>
<t tx="ekr.20060106104442.8">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="ekr.20060106104442.9">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20060106104442.10"></t>
<t tx="ekr.20060106104442.11">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3464874
By: davidmcnab

* The 'goto line number' dialog pops up without the text field active, so I'm
forced into a Compulsory Mouse Click to activate the field before I can type
in the line number (I'm one who regards unnecessary Compulsory Mouse Clicks as bugs).</t>
<t tx="ekr.20060106104442.12">def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    f = self.frame
    
    lab = Tk.Label(f,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = t = Tk.Entry(f,width=20)
    t.pack(side="left")
    
    g.app.gui.set_focus(self.c,t)</t>
<t tx="ekr.20060106104442.13">@

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headling, and ch is always '\r', regardless of
platform.</t>
<t tx="ekr.20060106104442.14">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3466412
By: ktenney

&gt;Use the read_only_nodes plugin. 

It has a great feature list, but I can't get it to
update after the file changes on the filesystem.

I then looked at at_view.py, and the @view node
plugin. (which I worked on way back when :-])

It also doesn't work.
I put a g.es(..) at the top of the icondclick2 method which is registered in
the onCreate method
of at_view.py;

leoPlugins.registerHandler("icondclick2", myView.icondclick2)

It seems that the method does not get called
when the icon is doubleclicked.

Could this behaviour be related to recent changes
in Leo?
</t>
<t tx="ekr.20060106104442.15"></t>
<t tx="ekr.20060106104442.16">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060106104442.17">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060106104442.18"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060106104442.19"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.20"></t>
<t tx="ekr.20060106104442.21">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3462294
By: nobody

apparently the bodykey hooks are no longer used
is why trace_keys plugin doesn't work.
in leoKeys.py I see this trace can be turned on:
.   if c.config.getBool('trace_masterCommand'):</t>
<t tx="ekr.20060106104442.22">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','replace'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060106104442.23">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'replace':   w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060106104442.24">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060106104442.25">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060106104442.26"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060106104442.27">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060106104442.28"></t>
<t tx="ekr.20060106104442.29">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3467558
By: ktenney

Current CVS, W2K

I open a small Leo file, and from File-&gt;Open, select
..\src\LeoPyRef.py. the log pane shows;

----- error reading @file: ../doc/leoToDo.txt
Ignoring @-node sentinel. Expecting @-all

At this point Leo locks up tight, must kill process.

What I did:

** atFile.readError delete's root's entire subtree.
** atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20060106104442.30">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
        
    # g.trace(self.root,g.callers())
    
    self.error(message)
    
    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None
    
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20060106104442.31">def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)</t>
<t tx="ekr.20060106104442.32">def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;</t>
<t tx="ekr.20060106104442.33">try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s</t>
<t tx="ekr.20060106104442.34">def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20060106104442.35"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20060106104442.36">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20060106104442.37">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20060106104442.38">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20060106104442.39">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20060106104442.40"></t>
<t tx="ekr.20060106104442.41">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20060106104442.42">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20060106104442.43">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20060106104442.44">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.45">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20060106104442.46"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20060106104442.47"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20060106104442.48">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20060106104442.49">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20060106104442.50"></t>
<t tx="ekr.20060106104442.51">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20060106104442.52">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20060106104442.53">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20060106104442.54">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.55">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20060106104442.56">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20060106104442.57"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20060106104442.58">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20060106104442.59">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20060106104442.60"></t>
<t tx="ekr.20060106104442.61">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20060106104442.62">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20060106104442.63">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20060106104442.64">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20060106104442.65">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20060106104442.66">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20060106104442.67"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.68">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.69">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20060106104442.70">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20060106104442.71">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20060106104442.72">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20060106104442.73">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20060106104442.74">def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList</t>
<t tx="ekr.20060106104442.75"></t>
<t tx="ekr.20060106104442.76">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3461068
By: vpe

1) Strange behaviour after pasting in headlines:
Start editing a headline in outline pane. Let's say it's 'Settings and
buttons'.
Select all text and copy (ctrl+c).
Place cursor at the end and paste (ctrl+v). What I see is 'Settings and
buttonsSetti'. That is text area does not expand to accomodate new text length.
And I cannot move beyond that point.
If I move to another headline I see that pasting was done correctly. 

2) (done) I always make these changes without any problems:
Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt;Config
&amp; Measuring...--&gt;headWidth &amp; widthInPixels
return max(self.minimum_headline_width,5 + len(s))  ##change to 1

Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt; Birth...
(tkTree)--&gt;__init__--&gt;&lt;&lt; define drawing constants &gt;&gt;
self.minimum_headline_width = 20 # In characters. ##change to 2


Leo 4.4 alpha 4, build  1.346 , December 5, 2005
Python 2.4.2, Tk 8.4.7, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4    &lt;--- nice!
</t>
<t tx="ekr.20060106104442.77"></t>
<t tx="ekr.20060106104442.78">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060106104442.79">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060106104442.80">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060106104442.81">@nocolor

The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20060106104442.82"></t>
<t tx="ekr.20060106104442.83">@nocolor

I've just investigated how Leo handles pane settings, and I believe all is
working as intended. This is somewhat confusing, but there has been no change in
this code for a long time: it has nothing whatever to do with the 4.4 code
base.

The so-called 'primary' ratio is the ratio between the body pane and the pane
containing the other two panes. The so-called secondary ratio is the ratio
between sizes of the log pane and the outline pane.

The thing to keep in mind is that Leo saves *only* the primary ratio in .leo
files. Leo does not save the so-called 'secondary' ratio in .leo files, because
doing so would change Leo's file format.

Because Leo **does** save the primary ratio in .leo files, Leo will open a file
with the same primary ratio that you had when you last saved the file.

Because Leo does **not** save the secondary ratio in the .leo file Leo
determines the relative sizes of the log and outline panes from settings in
leoSettings.leo. One of the two settings is used:

- initial_horizontal_secondary_ratio or

- initial_vertical_secondary_ratio

Which one is used depends on the initial_splitter_orientation setting.

**Important** If you change these settings you must restart Leo for them to take effect.

I have been able to set the secondary ratio as I please from leoSettings.leo,
and have observed that Leo properly saves and restores the primary ratio in .leo
files.

In short, everything works as it should.</t>
<t tx="ekr.20060106104442.84">def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2</t>
<t tx="ekr.20060106104442.85"># From Brian re Read @file nodes w/o creating copy of root node</t>
<t tx="ekr.20060106104442.86">@nocolor

- self._forcedGnxPositionList = [] in ctor.

- </t>
<t tx="ekr.20060106104442.87">def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.
    
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20060106104442.88">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.89">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.90">def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    leoBaseAtFile.__init__( self )
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self._forcedGnxPositionList = [] #This has to be here, puttin it in initReadIvars renders it useless

    c.checksums = {}
    self.md5 = None
    @others</t>
<t tx="ekr.20060106104442.91">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.92">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
        
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.93"></t>
<t tx="ekr.20060106104442.94">def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.95">@

This handles the root node properly so that Leo draws no duplicate node. The
code is from LeoUser; thanks Brian.

I also fixed a recent bugs: the screen was not being redrawn afterwards.</t>
<t tx="ekr.20060106104442.96">def forceGnxOnPosition (self,p):
    
    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.97">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.98">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20060106104442.99">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.100"></t>
<t tx="ekr.20060106104442.101"></t>
<t tx="ekr.20060106104442.102"></t>
<t tx="ekr.20060106104442.103">@
The change was logical, but it caused problems.

The new 'insert' keyword arg must have the value 'sel.end' for compatibility with old code.</t>
<t tx="ekr.20060106104442.104">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20060106104442.105"></t>
<t tx="ekr.20060106104442.106">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060106104442.107"></t>
<t tx="ekr.20060106104442.108"></t>
<t tx="ekr.20060106104442.109">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=True)
    spot = w.index(spot) # Capture initial value.
    ins = w.index('insert')
    w.mark_set('insert',spot)
    if extend or self.extendMode:
        if w.compare(spot,'&lt;=',i):
            g.app.gui.setTextSelection (w,spot,j,insert=None)
        else:
            g.app.gui.setTextSelection (w,i,spot,insert=None)
    w.see(spot)</t>
<t tx="ekr.20060106104442.110">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060106104442.111">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.112">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.113">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.114">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.115">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.116">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060106104442.117">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060106104442.118">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060106104442.119">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060106104442.120">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20060106104442.121">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.122">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.123">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.124">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060106104442.125"></t>
<t tx="ekr.20060106104442.126"></t>
<t tx="ekr.20060106104442.127"></t>
<t tx="ekr.20060106104442.128">@nocolor

- As before, tree.select always sets tree.revertHeadline.  This is the revert point.

- endEditLabel now simply unselects the widget.  It has *no* responsibility for keeping the headline in synch with p.headString.  This is a major advance in reliability.

- tree.onHeadChanged sets changed = s != oldRevert.  This is more reliable than previously.</t>
<t tx="ekr.20060106104442.129"></t>
<t tx="ekr.20060106104442.130">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20060106104442.131">def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.132">def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.frame.tree.editLabel(p)
        w = p.edit_widget()
        if w:
            w.delete("1.0","end")
            w.insert("1.0",name)
            c.endEditing()
            ### c.frame.tree.onHeadChanged(p,'rename-buffer %s' % p.headString())</t>
<t tx="ekr.20060106104442.133">@nocolor

Bug 1: OnActivateBody *must* call onHeadChanged: select is not always called!

But 2: c.endEditing and tree.endEditLabel **must** call tree.onHeadChanged.</t>
<t tx="ekr.20060106104442.134"></t>
<t tx="ekr.20060106104442.135">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20060106104442.136">def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20060106104442.137">@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20060106104442.138"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20060106104442.139"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20060106104442.140">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20060106104442.141"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20060106104442.142">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.143"></t>
<t tx="ekr.20060106104442.144">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060106104442.145">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20060106104442.146">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20060106104442.147">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.148">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.149">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.150"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20060106104442.151">def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag</t>
<t tx="ekr.20060106104442.152"></t>
<t tx="ekr.20060106104442.153"># Ends the editing in the outline.

def endEditing(self):

    self.frame.tree.endEditLabel()
</t>
<t tx="ekr.20060106104442.154"></t>
<t tx="ekr.20060106104442.155">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060106104442.156">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.157">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060106104442.158">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.159"></t>
<t tx="ekr.20060106104442.160">def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')</t>
<t tx="ekr.20060106104442.161"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20060106104442.162">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20060106104442.163"></t>
<t tx="ekr.20060106104442.164"></t>
<t tx="ekr.20060106104442.165">@nocolor

To do:

- Test abortEditLabelCommand.

- c.redraw() redraws conditionally.
- Create c.xxx methods that call the corresponding c.frame.tree methods.

** Find is not selecting headlines properly.
- Test drags.

What I did:

- Made c.begin/endUpdate and tree.begin/endUpdate functional again.
- Created a script to add c.begin/endUpdate().
- Removed redraw_flag from deleteOutline.
- Tested undo/redo delete node.
- Removed redraw_flag from insertHeadline.
- Removed redraw_flag from onBodyChanged.
- c.redraw_now() redraws undconditionally: it is used seldom.
- Replaced c.redraw_now by c.redraw or c.begin/endUpdate.
- Removed redraw_flag from c.selectPosition, tree.select, tree.onHeadChanged, body.onBodyChanged.

</t>
<t tx="ekr.20060106104442.166"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20060106104442.167">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20060106104442.168">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20060106104442.169">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20060106104442.170"></t>
<t tx="ekr.20060106104442.171">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060106104442.172">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20060106104442.173">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20060106104442.174">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060106104442.175">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20060106104442.176"></t>
<t tx="ekr.20060106104442.177">def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now()
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount")</t>
<t tx="ekr.20060106104442.178"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060106104442.179">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060106104442.180">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20060106104442.181"></t>
<t tx="ekr.20060106104442.182">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20060106104442.183">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20060106104442.184">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.185">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20060106104442.186">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20060106104442.187">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20060106104442.188">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20060106104442.189">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20060106104442.190">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20060106104442.191"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.192">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20060106104442.193">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20060106104442.194">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20060106104442.195">pass</t>
<t tx="ekr.20060106104442.196">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20060106104442.197">pass</t>
<t tx="ekr.20060106104442.198">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20060106104442.199">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20060106104442.200"></t>
<t tx="ekr.20060106104442.201">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20060106104442.202">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20060106104442.203">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20060106104442.204">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20060106104442.205">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20060106104442.206">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20060106104442.207">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20060106104442.208">u = c.undoer ; w = c.frame.body.bodyCtrl

s1 = '''\
    c.beginUpdate()
    try:'''
s2 = '''\
    finally:
        c.endUpdate()'''

b = u.beforeChangeNodeContents(p)

i, j = g.app.gui.getTextSelection(w)
if i != j:
    s = w.get(i,j)
    s = ''.join(['\t'+line for line in g.splitLines(s)])
    w.delete(i,j)
    w.insert(i,s1+'\n'+s+'\n'+s2)
else:
    w.insert(i,s1+'\n\t\t\n'+s2)

c.recolor()
u.afterChangeNodeContents(p,'add-begin/endUpdate',b)</t>
<t tx="ekr.20060106104442.209">No change was actually needed, just new bindings.

What I did:
    
- fixed a bug in copyBindingsToWidget
- textBindingsRedirectionCallback now returns 'break', not None.</t>
<t tx="ekr.20060106104442.210">@nocolor

Key bindings

Leo must have commands to do what Tk text widgets do for all their standard bindings.  This is the only way I know of to allow users to choose different bindings for those actions.

Therefore, Leo should pass *no* key events to Tk for 'default' handling.  That is, all of Leo's key handlers will return 'break', not None.  In particular, all text widgets must have something like selfInsertCommand so they can handle ordinary keystrokes.

Typing in headlines *still* does not always stick.  The present event handlers for headlines have way too many paths through them.  The problems are caused in large part by the abort-edit-headline command: it requires state info.  I may add a beginEditHeadline command that will remember the state.  This will allow Leo to save the headline text on *every* keystroke, rather than only at the end.  This is *much* safer than trying to ensure that endEditHeadline gets called on every path.  The new endEditHeadline will have no responsibility for state except to clear the info set by beginEditHeadline.  Nothing much bad will ever happen if endEditHeadline doesn't get called once in a while.

I hope to get all the necessary bindings and commands done this week.

Undo

Undo is well defined only for headlines and body text.  There is little or no use, alas, for event.widget in leoEditCommands.py.  Brian's suggestion of having beginUndo/endUndo markers makes a lot of sense: such markers simplify the code and hide implementation and policy details that should be hidden.

Focus

Getting focus exactly right is crucial: some of the present commands in leoEditCommands.py don't work if they are invoked by their long name rather than from a keystroke.

In short, the combination of bindings, undo and focus creates a lot of problems that must be handled with extreme care.  It's frustrating to rewrite essentially every line of Brian's temacs code, but I believe it must be done.

And we are not done yet.  Leo creates an environment different from Emacs:  incremental search must be expanded to move from node to node, the notion of the 'mark' must be generalized (in some, but not all situations), etc.  Sometimes, though, the generalization is also a simplification: as I have said before, Leo's nodes can and should be treated as exactly synonymous with Emacs's buffers.

Edward
</t>
<t tx="ekr.20060106104442.211"></t>
<t tx="ekr.20060106104442.212"></t>
<t tx="ekr.20060106104442.213">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3464605
leouser

You really need to think about using Ctrl-Space for starting selection mode.
Its a wonderful thing.  Once in selection mode you just move around with your
arrows and things get selected.  Or if you want to move quickly you can do stuff
like Ctrl-a or Ctrl-e or Ctrl-&lt; or Ctrl-&gt;.  Combining selection mode and fast
movement keystrokes is good...</t>
<t tx="ekr.20060106104442.214"></t>
<t tx="ekr.20060106104442.215"></t>
<t tx="ekr.20060106104442.216"></t>
<t tx="ekr.20060106104442.217">make the default bindings work differently when editing
the headline as opposed to when traversing the tree with the arrow keys.</t>
<t tx="ekr.20060106104442.218"></t>
<t tx="ekr.20060106104442.219">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20060106104442.220">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20060106104442.221">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20060106104442.222"></t>
<t tx="ekr.20060106104442.223"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.224">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.225"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20060106104442.226"></t>
<t tx="ekr.20060106104442.227">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20060106104442.228">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20060106104442.229">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20060106104442.230"></t>
<t tx="ekr.20060106104442.231">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.232"></t>
<t tx="ekr.20060106104442.233">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20060106104442.234">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20060106104442.235"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20060106104442.236"></t>
<t tx="ekr.20060106104442.237">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.238">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.239"></t>
<t tx="ekr.20060106104442.240">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20060106104442.241">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20060106104442.242">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20060106104442.243">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20060106104442.244">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20060106104442.245">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20060106104442.246"></t>
<t tx="ekr.20060106104442.247">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20060106104442.248">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20060106104442.249"></t>
<t tx="ekr.20060106104442.250">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20060106104442.251">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None</t>
<t tx="ekr.20060106104442.252">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20060106104442.253">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20060106104442.254">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20060106104442.255"></t>
<t tx="ekr.20060106104442.256">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.257">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.258">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.259">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.260">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.261">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20060106104442.262"></t>
<t tx="ekr.20060106104442.263">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20060106104442.264">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060106104442.265">class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others</t>
<t tx="ekr.20060106104442.266"></t>
<t tx="ekr.20060106104442.267">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060106104442.268"></t>
<t tx="ekr.20060106104442.269">def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')</t>
<t tx="ekr.20060106104442.270">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.271">def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
</t>
<t tx="ekr.20060106104442.272"></t>
<t tx="ekr.20060106104442.273">def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    &lt;&lt; define colors &gt;&gt;
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
</t>
<t tx="ekr.20060106104442.274">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20060106104442.275">def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;</t>
<t tx="ekr.20060106104442.276">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20060106104442.277">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)</t>
<t tx="ekr.20060106104442.278">def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)</t>
<t tx="ekr.20060106104442.279">def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;</t>
<t tx="ekr.20060106104442.280">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')</t>
<t tx="ekr.20060106104442.281">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.282">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20060106104442.283">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.284">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.285">sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)</t>
<t tx="ekr.20060106104442.286">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)</t>
<t tx="ekr.20060106104442.287">def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.288">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)</t>
<t tx="ekr.20060106104442.289"></t>
<t tx="ekr.20060106104442.290">def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2</t>
<t tx="ekr.20060106104442.291">def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 &gt;= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')</t>
<t tx="ekr.20060106104442.292"></t>
<t tx="ekr.20060106104442.293">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20060106104442.294">def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)</t>
<t tx="ekr.20060106104442.295">def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)</t>
<t tx="ekr.20060106104442.296"></t>
<t tx="ekr.20060106104442.297">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)</t>
<t tx="ekr.20060106104442.298">def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)</t>
<t tx="ekr.20060106104442.299">def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)</t>
<t tx="ekr.20060106104442.300"></t>
<t tx="ekr.20060106104442.301">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()</t>
<t tx="ekr.20060106104442.302">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)</t>
<t tx="ekr.20060106104442.303">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others</t>
<t tx="ekr.20060106104442.304">def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) &gt;= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)</t>
<t tx="ekr.20060106104442.305">def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()</t>
<t tx="ekr.20060106104442.306">def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1</t>
<t tx="ekr.20060106104442.307">def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt</t>
<t tx="ekr.20060106104442.308">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt</t>
<t tx="ekr.20060106104442.309"></t>
<t tx="ekr.20060106104442.310">def gotoCharacter (self,event):

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.311">def gotoLine (self,event):

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.312"></t>
<t tx="ekr.20060106104442.313">def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)</t>
<t tx="ekr.20060106104442.314">def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.315">def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
</t>
<t tx="ekr.20060106104442.316">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.317"></t>
<t tx="ekr.20060106104442.318">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060106104442.319">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060106104442.320">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20060106104442.321">def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20060106104442.322">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060106104442.323">def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
</t>
<t tx="ekr.20060106104442.324">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)</t>
<t tx="ekr.20060106104442.325">def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20060106104442.326"></t>
<t tx="ekr.20060106104442.327">def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))</t>
<t tx="ekr.20060106104442.328">def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))</t>
<t tx="ekr.20060106104442.329">def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)</t>
<t tx="ekr.20060106104442.330">def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)</t>
<t tx="ekr.20060106104442.331"></t>
<t tx="ekr.20060106104442.332">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.333">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.334">def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.335">def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom</t>
<t tx="ekr.20060106104442.336">@others</t>
<t tx="ekr.20060106104442.337">def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.338">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20060106104442.339">def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','&gt;',s2):
            break
        self.fillParagraph(event)</t>
<t tx="ekr.20060106104442.340">def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)</t>
<t tx="ekr.20060106104442.341">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.342">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20060106104442.343">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20060106104442.344">@others</t>
<t tx="ekr.20060106104442.345">def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('&lt;Right&gt;',extend,'+')
    w.bind('&lt;Left&gt;',truncate,'+')
    w.bind('&lt;Up&gt;',up,'+')
    w.bind('&lt;Down&gt;',down,'+')

    return 'break'</t>
<t tx="ekr.20060106104442.346">def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'</t>
<t tx="ekr.20060106104442.347">def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

</t>
<t tx="ekr.20060106104442.348">def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'</t>
<t tx="ekr.20060106104442.349">def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'</t>
<t tx="ekr.20060106104442.350">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.351">def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)</t>
<t tx="ekr.20060106104442.352">def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))</t>
<t tx="ekr.20060106104442.353">def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()</t>
<t tx="ekr.20060106104442.354">def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.355"></t>
<t tx="ekr.20060106104442.356">def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    prompt = 'Replace ' + g.choose(self._useRegex,'Regex','String')

    if state == 0:
        self.widget = event.widget
        self._sString = self._rpString = ''
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        self._rpString = k.arg ; w = self.widget
        &lt;&lt; do the replace &gt;&gt;
        k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
        self._useRegex = False</t>
<t tx="ekr.20060106104442.357"># g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.358">def activateReplaceRegex( self ):
    
    '''This method turns regex replace on for replaceString'''

    self._useRegex = True
    return True</t>
<t tx="ekr.20060106104442.359">def scrollDown (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) + chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')

def scrollUp (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) - chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')</t>
<t tx="ekr.20060106104442.360">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20060106104442.361">def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.362">def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.363">def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.364"></t>
<t tx="ekr.20060106104442.365">def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')</t>
<t tx="ekr.20060106104442.366">def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060106104442.367">def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters</t>
<t tx="ekr.20060106104442.368">def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.369"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20060106104442.370"></t>
<t tx="ekr.20060106104442.371">def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('&lt;Key&gt;',k.onTextWidgetKey)</t>
<t tx="ekr.20060106104442.372">def onTextWidgetKey (self,event):
    
    '''This is the default key handler for all text widgets.
    It should never be called for keys bound to any command.'''

    ch = event and event.char or ''
    w  = event and event.widget

    if w and ch:
        i,j = g.app.gui.getTextSelection(w)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)

    return 'break'</t>
<t tx="ekr.20060106104442.373"></t>
<t tx="ekr.20060106104442.374">@nocolor

- &lt;&lt; unselect the old node &gt;&gt; in tree.select now calls
    self.setUnselectedLabelState(old_p)

- tree.endEditLabel no longer calls setUnselectedLabelState.
    (This is important)</t>
<t tx="ekr.20060106104442.375"></t>
<t tx="ekr.20060106104442.376"></t>
<t tx="ekr.20060106104442.377">Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function keyCallback2 at 0x01378630&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x034905D0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 814, in keyCallback2
    def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1143, in masterCommand
    if stroke == k.abortAllModesKey: # 'Control-g'
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 811, in menuFuncCallback
    def menuFuncCallback (event,command=command):
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 2250, in backwardDeleteCharacter
    oldText = w.get('1.0','end')
AttributeError: Canvas instance has no attribute 'get'

</t>
<t tx="ekr.20060106104442.378"></t>
<t tx="ekr.20060106104442.379"></t>
<t tx="ekr.20060106104442.380">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    if not key:
        return ''
        
    ch = key[-2]

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20060106104442.381">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20060106104442.382"># The reason for this assert is unclear.</t>
<t tx="ekr.20060106104442.383">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 239, in doCommand
    val = command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1579, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1729, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2767, in moveToNthChildOf
    p.unlink()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3310, in unlink
    assert(parent.v in p.v.directParents())
AssertionError</t>
<t tx="ekr.20060106104442.384">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20060106104442.385"></t>
<t tx="ekr.20060106104442.386"></t>
<t tx="ekr.20060106104442.387"></t>
<t tx="ekr.20060106104442.388">@ Ripping focus away from widgets is odious and bug prone.

A much better solution: call update *after* log-pane operations.</t>
<t tx="ekr.20060106104442.389"></t>
<t tx="ekr.20060106104442.390">@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.</t>
<t tx="ekr.20060106104442.391">def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
</t>
<t tx="ekr.20060106104442.392"># New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '&lt;no name&gt;'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060106104442.393"></t>
<t tx="ekr.20060106104442.394"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20060106104442.395">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20060106104442.396">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20060106104442.397"></t>
<t tx="ekr.20060106104442.398">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20060106104442.399">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20060106104442.400">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20060106104442.401">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20060106104442.402"></t>
<t tx="ekr.20060106104442.403">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20060106104442.404">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20060106104442.405">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20060106104442.406">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20060106104442.407">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20060106104442.408">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20060106104442.409"></t>
<t tx="ekr.20060106104442.410">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20060106104442.411">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20060106104442.412">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20060106104442.413">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20060106104442.414">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20060106104442.415"></t>
<t tx="ekr.20060106104442.416">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')</t>
<t tx="ekr.20060106104442.417">def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    &lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;
    &lt;&lt; Create the tab's text widget &gt;&gt;
    self.setTabBindings(tabName)
    
    # New in 4.4b1: call update explicitly.
    textWidget and textWidget.update()</t>
<t tx="ekr.20060106104442.418">menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20060106104442.419">textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("&lt;Button-1&gt;",self.onActivateLog)
textWidget.tag_config('black',foreground='black')</t>
<t tx="ekr.20060106104442.420">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.421">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20060106104442.422">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        logCtrl and logCtrl.update()
        self.c.frame.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            logCtrl.update()
            self.c.frame.widgetWantsFocus(logCtrl)</t>
<t tx="ekr.20060106104442.423">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20060106104442.424">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    
    # New in 4.4b1: call update *after* creating the tab.
    tabFrame and tabFrame.update()

    return tabFrame</t>
<t tx="ekr.20060106104442.425">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)</t>
<t tx="ekr.20060106104442.426"></t>
<t tx="ekr.20060106104442.427">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20060106104442.428">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20060106104442.429">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20060106104442.430">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20060106104442.431"></t>
<t tx="ekr.20060106104442.432"></t>
<t tx="ekr.20060106104442.433"></t>
<t tx="ekr.20060106104442.434"></t>
<t tx="ekr.20060106104442.435">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'mode':         self.doMode, # New in 4.4b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20060106104442.436">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)</t>
<t tx="ekr.20060106104442.437">def doShortcut(self,p,kind,name,val):
    
    # Note:  kind,name,val are as returned from self.parseHeadline(p.headString())

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20060106104442.438">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    # g.trace(self.c.fileName(),p.headString(),g.callers())
    
    d = self.shortcutsDict # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                # New in 4.4a5:
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)</t>
<t tx="ekr.20060106104442.439">def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)</t>
<t tx="ekr.20060106104442.440">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.
    
    if 1:
        bunchList = self.get(c,key,"shortcut")
        if bunchList:
            bunchList = [bunch for bunch in bunchList
                if bunch.val and bunch.val.lower() != 'none']
            return key,bunchList
        else:
            return key,[]
    else:
        bunch = self.get(c,key,"shortcut")
        if bunch and bunch.val:
            # g.trace(bunch.pane,key,repr(bunch.val))
            if bunch.val.lower() == 'none':
                return key,None
            else:
                return key,bunch
        else:
            return key,None</t>
<t tx="ekr.20060106104442.441"></t>
<t tx="ekr.20060106104442.442">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20060106104442.443">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20060106104442.444">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c 

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    ## if shortcut == '&lt;None&gt;': return
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        # g.trace('Not bound',shortcut)
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return
        
    # g.trace(pane,shortcut,commandName)

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20060106104442.445"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20060106104442.446">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20060106104442.447">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20060106104442.448">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060106104442.449">def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.addModeCommands()
    k.checkBindings()</t>
<t tx="ekr.20060106104442.450">def addModeCommands (self):
    
    '''Add commands created by @mode settings..'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060106104442.451">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '&lt;Control-t&gt;':  c.editCommands.transposeLines,
        '&lt;Control-u&gt;':  c.editCommands.upCaseRegion,
        '&lt;Control-l&gt;':  c.editCommands.downCaseRegion,
        '&lt;Control-o&gt;':  c.editCommands.removeBlankLines,
        '&lt;Control-i&gt;':  c.editFileCommands.insertFile,
        '&lt;Control-s&gt;':  c.editFileCommands.saveFile,
        '&lt;Control-x&gt;':  c.editCommands.exchangePointMark,
        '&lt;Control-c&gt;':  c.controlCommands.shutdown,
        '&lt;Control-b&gt;':  c.bufferCommands.listBuffers,
        '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
        '&lt;Delete&gt;':     c.killBufferCommands.backwardKillSentence,
    }</t>
<t tx="ekr.20060106104442.452">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20060106104442.453">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(stroke,accel,shortcut,func.__name__)
    if pane == 'mini' and func != k.keyboardQuit:
        # Call a strange callback that bypasses k.masterCommand.
        def minibufferKeyCallback(event,func=func,shortcut=shortcut):
            k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

        k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
        # Create two-levels of callbacks.
        def specialCallback (event,func=func):
            return func(event)

        def keyCallback (event,func=specialCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)

        k.bindKey(pane,shortcut,keyCallback,commandName)

    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20060106104442.454">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20060106104442.455">@ This code "canonicalizes" both the shortcuts that appear in menus and the
arguments to bind, mostly ignoring case and the order in which special keys are
specified.

For example, Ctrl+Shift+a is the same as Shift+Control+A. Each generates
Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print repr(shortcut),repr(bind_shortcut),repr(menu_shortcut)
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20060106104442.456">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20060106104442.457">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20060106104442.458"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20060106104442.459"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9</t>
<t tx="ekr.20060106104442.460">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20060106104442.461"></t>
<t tx="ekr.20060106104442.462">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)
</t>
<t tx="ekr.20060106104442.463">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
                    
                </t>
<t tx="ekr.20060106104442.464">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20060106104442.465">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060106104442.466"># First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunchList = c.config.getShortcut(commandName)
bunch = bunchList and bunchList[0]
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    &lt;&lt; compute emacs_name &gt;&gt;
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunchList = c.config.getShortcut(emacs_name)
        bunch = bunchList and bunchList[0]
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060106104442.467">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060106104442.468">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20060106104442.469">@ This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20060106104442.470">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20060106104442.471">def preferences(self):
    
    '''Handle the preferences command.'''
    
    c = self
    c.openLeoSettings()</t>
<t tx="ekr.20060106104442.472"></t>
<t tx="ekr.20060106104442.473">@nocolor

- set-insert, set-replace commands.
- Fancier mode-help.
- Use tabs in print-commands &amp; print-bindings.

Docs
- Document @mode and how to use it.
- Move most settings docs to Customizing chapter.

Cleanup
- Default modes should set the label.
- Create tkinterKeyHandler.
- Complete vim emulation</t>
<t tx="ekr.20060106104442.474"></t>
<t tx="ekr.20060106104442.475"></t>
<t tx="ekr.20060106104442.476">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20060106104442.477">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20060106104442.478">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
&lt;&lt; set self.unboundKeyAction &gt;&gt;</t>
<t tx="ekr.20060106104442.479">defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
defaultAction.lower()
if defaultAction in ('insert','replace','ignore'):
    self.unboundKeyAction = defaultAction
else:
    g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
    self.unboundKeyAction = 'insert'</t>
<t tx="ekr.20060106104442.480"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0</t>
<t tx="ekr.20060106104442.481">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060106104442.482">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060106104442.483"></t>
<t tx="ekr.20060106104442.484">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20060106104442.485">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20060106104442.486">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return
        
    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.487"></t>
<t tx="ekr.20060106104442.488">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060106104442.489"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060106104442.490">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060106104442.491">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060106104442.492">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060106104442.493">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20060106104442.494">def quickCommand (self,event):
    
    '''Handle 'quick-command' (control-c) mode.'''
    
    k = self ; stroke = k.stroke ; state = k.getState('quick-command')
    
    if state == 0:
        k.setState('quick-command',1,handler=k.quickCommand)
        k.setLabelBlue('quick command: ',protect=True)
    else:
        k.previous.insert(0,event.keysym)
        if len(k.previous) &gt; 10: k.previous.pop()
        
        # g.trace('stroke',stroke,event.keysym)
        if stroke == '&lt;Key&gt;' and event.keysym == 'r':
            k.rCommand(event)
        elif stroke in ('&lt;Key&gt;','&lt;Escape&gt;'):
            if k.processKey(event): # Weird command-specific stuff.
                k.clearState()
        elif stroke in k.xcommands:
            k.clearState()
            k.xcommands [stroke](event)

        k.endCommand(event,stroke)
        
    return 'break'</t>
<t tx="ekr.20060106104442.495">def rCommand (self,event):
    
    k = self ; state = k.getState('r-command') ; ch = event.keysym
    if state == 0:
        k.setLabel ('quick-command r: ',protect=True)
        k.setState('r-command',1,k.rCommand)
    elif ch in ('Control_L','Alt_L','Shift_L'):
        return
    else:
        k.clearState()
        
        # g.trace(repr(ch))
        func = k.rCommandDict.get(ch)
        if func:
            k.commandName = 'quick-command r: '
            k.resetLabel()
            func(event)
        else:
            k.setLabelGrey('Unknown r command: %s' % repr(ch))</t>
<t tx="ekr.20060106104442.496">def processKey (self,event):
    
    '''Handle special keys in quickCommand mode.
    Return True if we should exit quickCommand mode.'''

    k = self ; c = k.c ; previous = k.previous
    
    if event.keysym in ('Shift_L','Shift_R'): return False
    # g.trace(event.keysym)

    func = k.variety_commands.get(event.keysym)
    if func:
        k.keyboardQuit(event)
        func(event)
        return True

    if event.keysym in ('a','i','e'):
        if k.processAbbreviation(event):
            return False # 'a e' or 'a i e' typed.
        
    if event.keysym == 'g': # Execute the abbreviation in the minibuffer.
        s = k.getLabel(ignorePrompt=True)
        if k.abbreviationFuncDict.has_key(s):
            k.clearState()
            k.keyboardQuit(event)
            k.abbreviationFuncDict [s](event)
            return True
    
    if event.keysym == 'e': # Execute the last macro.
        k.keyboardQuit(event)
        c.macroCommands.callLastKeyboardMacro(event)
        return True

    if event.keysym == 'x' and previous [1] not in ('Control_L','Control_R'):
        event.keysym = 's'
        k.setState('quick-command',1)
        c.registerCommands.setNextRegister(event)
        return True

    if event.keysym == 'Escape' and len(previous) &gt; 1 and previous [1] == 'Escape':
        k.repeatComplexCommand(event)
        return True
        
    else:
        return False</t>
<t tx="ekr.20060106104442.497">def processAbbreviation (self,event):
    
    '''Handle a e or a i e.
    Return True when the 'e' has been seen.'''
    
    k = self ; char = event.char

    if k.getLabel() != 'a' and event.keysym == 'a':
        k.setLabel('a')
        return False

    elif k.getLabel() == 'a':

        if char == 'i':
            k.setLabel('a i')
            return False
        elif char == 'e':
            event.char = ''
            k.expandAbbrev(event)
            return True
            
    return False</t>
<t tx="ekr.20060106104442.498">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060106104442.499">def matchKeys (self,event,shortcut):
    
    '''Return true if a binding matches the key specified by the event.'''
    
    k = self ; c = k.c
    
    if not k.stroke or not event: return False
    
    stroke = k.stroke ; keysym = event.keysym
    shortcut2, junk = c.frame.menu.canonicalizeShortcut(shortcut)
    
    if stroke == '&lt;Key&gt;':
        val = shortcut == keysym or shortcut.startswith('Key-') and shortcut.endswith(keysym)
    else:
        val = stroke == shortcut2
        
    if 0:
        g.trace('returns',val,
            'stroke',stroke,'keysym',keysym,
            'shortcut',shortcut,'shortcuts',shortcut2)
        
    return val</t>
<t tx="ekr.20060106104442.500">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName)
</t>
<t tx="ekr.20060106104442.501">def generalModeHandler (self,event,name=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ; f = c.frame
    modeName = name or k.inputModeName
    commandName = 'enter-' + modeName
    state = k.getState(modeName)
    keysym = event and event.keysym or ''
    # g.trace(modeName,'state',state)
    
    d = g.app.config.modeCommandsDict.get(commandName)
    if not d:
        g.trace("can't happen")
    elif state == 0:
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(name,1,handler=k.generalModeHandler)
        k.setLabelBlue(name,protect=True)
        k.modeCompletionList = d.keys()
    else:
        for key in d.keys():
            bunchList = d.get(key)
            for bunch in bunchList:
                if k.matchKeys(event,bunch.val):
                    func = c.commandsDict.get(key)
                    # g.trace('calling',func)
                    if key != 'mode-help':
                        # This must be done first because commands can change windows.
                        k.clearState()
                        k.resetLabel()
                        k.endCommand(event,k.stroke)
                        k.inputModeName = None
                        c.frame.log.deleteTab('Mode')
                        c.frame.widgetWantsFocus(k.modeWidget)
                    func(event)
                    return 'break'
        k.modeHelpHelper(d)
        f.minibufferWantsFocus()
        
    return 'break'</t>
<t tx="ekr.20060106104442.502">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        g.es('Not in any mode')





</t>
<t tx="ekr.20060106104442.503">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    
    for key in d.keys():
        bunchList = d.get(key)
        bunch = bunchList and bunchList[0]
        shortcut = bunch.val
        if shortcut not in (None,'None'):
            if shortcut.startswith('Key-'):
                shortcut = shortcut[4:]
                if len(shortcut) == 1:
                    ch = shortcut[0]
                    if ch in string.ascii_uppercase:
                        shortcut = 'Shift-%s' % ch.lower()
            g.es('%s\t%s' % (shortcut,key),tabName='Mode')</t>
<t tx="ekr.20060106104442.504">def setIgnoreMode (self,event):
    
    self.unboundKeyAction = 'ignore'

def setInsertMode (self,event):
    
    self.unboundKeyAction = 'insert'
    
def setOverwriteMode (self,event):
    
    self.unboundKeyAction = 'replace'</t>
<t tx="ekr.20060120105136"></t>
<t tx="ekr.20060120105136.1"></t>
<t tx="ekr.20060120105136.2">A 'backward' delete at the start of a headline deletes the first character.
delete-char does not work in headlines.</t>
<t tx="ekr.20060120105136.3">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060120105136.4">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060120105136.5">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20060120105136.6"></t>
<t tx="ekr.20060120105136.7">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)</t>
<t tx="ekr.20060120105136.8">def beginCommandHelper (self,ch,undoType,w):

    p = self.c.currentPosition()
    name = g.app.gui.widget_name(w)
    
    # Bug fix 1/6/06 (after a5 released): don't do this in headlines!
    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
        
    return w</t>
<t tx="ekr.20060120105136.9">def endCommand(self,label=None,changed=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b:
        name = b.name
        if name.startswith('body'):
            if changed:
                c.frame.body.onBodyChanged(undoType=b.undoType,
                    oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        elif name.startswith('head'):
            g.trace('Should not happen: endCommand does not support undo in headlines')
        else: pass
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    if label:
        k.setLabelGrey(label)
    else:
        k.resetLabel()</t>
<t tx="ekr.20060120105136.10"></t>
<t tx="ekr.20060120105136.11">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060120105136.12">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060120105136.13"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060120105136.14"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060120105136.15"># Every call was a potential bug.</t>
<t tx="ekr.20060120105136.16"></t>
<t tx="ekr.20060120105136.17">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)</t>
<t tx="ekr.20060120105136.18">outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="ekr.20060120105136.19">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)
    
    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)
    
    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")</t>
<t tx="ekr.20060120105136.20">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="ekr.20060120105136.21">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")
    
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")
    
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20060120105136.22">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)
    
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20060120105136.23">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)</t>
<t tx="ekr.20060120105136.24"></t>
<t tx="ekr.20060120105136.25">def callers (n=5,excludeCaller=True):
    
    '''Return a list containing the callers of the function that called g.callerList.
    
    By default, the function that called g.callerList is not on the list,
    which is what is wanted when using g.trace.'''
    
    result = []
    while n &gt; 0:
        s = g.callerName(n)
        if s == 'callers':
            if excludeCaller and result:
                del result [-1]
            break
        elif s:
            result.append(s)
        n -= 1
        
    return ','.join(result)
</t>
<t tx="ekr.20060120105136.26">def createTopologyList (c,root=None,useHeadlines=False):
    
    """Creates a list describing a node and all its descendents"""

    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(),v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c,child,useHeadlines))
        child = child.next()
    return aList</t>
<t tx="ekr.20060120105136.27">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20060120105136.28">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20060120105136.29">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")</t>
<t tx="ekr.20060120105136.30"># 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20060120105136.31">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
</t>
<t tx="ekr.20060120105136.32">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
</t>
<t tx="ekr.20060120105136.33">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20060120105136.34">if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20060120105136.35">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20060120105136.36">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20060120105136.37">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20060120105136.38">def initScriptFind(c,findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
        
    __pychecker__ = '--no-argsused' # firstNode is not used.
    
    import leoTest
    import leoGlobals as g

    # Find the scripts.
    p = c.currentPosition()
    u = leoTest.testUtils(c)
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()</t>
<t tx="ekr.20060120105136.39">def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):
    
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(c,headline):
    
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20060120105136.40"></t>
<t tx="ekr.20060120105136.41">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    
    g.app.unitTesting = True
    try:
        g.app.unitTestDict["fail"] = False
    
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()
        
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
    
        for p in theIter:
            if isTestNode(p):
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p):
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
    
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
        c.setChanged(changed) # Restore changed state.
        # Restore the selected node unless overridden.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.selectPosition(p1)
    finally:
        g.app.unitTesting = False
        </t>
<t tx="ekr.20060120105136.42">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20060120105136.43">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20060120105136.44">def fail (self,msg=None):

    """Mark a unit test as having failed."""
    
    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20060120105136.45">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)</t>
<t tx="ekr.20060120105136.46">def tearDown (self):

    pass

    # To do: restore the outline.</t>
<t tx="ekr.20060120105136.47">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # Execute the script. Let unit test handle any errors!
    
    if define_g:
        # Execute the test in an environment containing c, g &amp; p.
        exec script + '\n' in {'c':c,'g':g,'p':p}
    else:
        # Execute the test in a totally pristine environment.
        exec script + '\n' in {}</t>
<t tx="ekr.20060120105136.48">def shortDescription (self):

    return self.p.headString() + '\n'</t>
<t tx="ekr.20060120105136.49">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""
    
    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None</t>
<t tx="ekr.20060120105136.50">def makeTestCase (c,p):
    
    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None</t>
<t tx="ekr.20060120105136.51"># A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'
    
    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p}
    
    # This looks like the best we can do.
    setup = 'import leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        print "count: %d time/count: %f %s" % (count,result/count,p.headString())
    except:
        t.print_exc()</t>
<t tx="ekr.20060120105136.52">def numberOfClonesInOutline (self):

    """Returns the number of cloned nodes in an outline"""

    c = self.c ; n = 0
    for p in c.allNodes_iter():
        if p.isCloned():
            n += 1
    return n</t>
<t tx="ekr.20060120105136.53">def numberOfNodesInOutline (self):

    """Returns the total number of nodes in an outline"""

    return len([p for p in self.c.allNodes_iter()])</t>
<t tx="ekr.20060120105136.54">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    try:
        g.app.unitTesting = True
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.top.update()
        g.app.unitTesting = True

    if not ok: raise</t>
<t tx="ekr.20060120105136.55">def makeEditBodySuite(c):

    """Create an Edit Body test for every descendant of testParentHeadline.."""

    p = c.currentPosition()
    u = testUtils(c)
    assert p.exists(c)
    data_p = u.findNodeInTree(p,"editBodyTests")
    assert(data_p)
    temp_p = u.findNodeInTree(data_p,"tempNode")
    assert(temp_p)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in data_p.children_iter():
        if p.headString()=="tempNode": continue # TempNode now in data tree.
        before = u.findNodeInTree(p,"before")
        after  = u.findNodeInTree(p,"after")
        sel    = u.findNodeInTree(p,"selection")
        ins    = u.findNodeInTree(p,"insert")
        if before and after:
            test = editBodyTestCase(c,p,before,after,sel,ins,temp_p)
            suite.addTest(test)
        else:
            print 'missing "before" or "after" for', p.headString()

    return suite</t>
<t tx="ekr.20060120105136.56">def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite</t>
<t tx="ekr.20060120105136.57">def runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=False):
        
    __pychecker__ = '--no-shadowbuiltin' # input is a builtin.

    # The contents of the "-input" and "-input-after" nodes define the changes.

    p = c.currentPosition()
    u = testUtils(c)
    input           = u.findNodeInTree(p,"-input")              # i file: before the change.
    input_ins       = u.findNodeInTree(p,"-input-after")        # j file: after the change.
    output_sent     = u.findNodeInTree(p,"-output-sent")        # fat file -&gt; i file.
    out_after_sent  = u.findNodeInTree(p,"-output-after-sent")  # Should match result.
    result          = u.findNodeInTree(p,"-result")
    ilines          = u.findNodeInTree(p,"-i_lines")
    jlines          = u.findNodeInTree(p,"-j_lines")

    # Create the output nodes containing sentinels from the original input.
    u.writeNodesToNode(c,input,output_sent,sentinels=True)
    u.writeNodesToNode(c,input_ins,out_after_sent,sentinels=True)

    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension("foo.py")

    fat_lines = g.splitLines(output_sent.bodyString())
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    if input_ins.hasChildren():
        # Get the lines by stripping sentinels from -output-after-sent node.
        lines = g.splitLines(out_after_sent.bodyString()) 
        j_lines = mu.removeSentinelsFromLines(lines,delims)
    else:
        j_lines = g.splitLines(input_ins.bodyString()) 

    # For viewing...
    ilines.scriptSetBodyString(''.join(i_lines))
    jlines.scriptSetBodyString(''.join(j_lines))
    if ilines.bodyString() != input.bodyString():
        if not ignoreSentinelsInCompare:
            print "i_lines != input !"

    # Put the resulting lines (with sentinels) into the -result node.
    lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
    result.scriptSetBodyString(''.join(lines))

    if ignoreSentinelsInCompare:
        sList = []
        for s in (result.bodyString(),out_after_sent.bodyString()):
            lines = g.splitLines(s)
            lines = mu.removeSentinelsFromLines(lines,delims)
            sList.append(''.join(lines))
        return sList[0] == sList[1]
    else:
        return u.compareIgnoringNodeNames(
            result.bodyString(),
            out_after_sent.bodyString(),
            delims,verbose=True)</t>
<t tx="ekr.20060120105136.58"></t>
<t tx="ekr.20060120105136.59">def __init__ (self,c,v,stack,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    self.c = c
    self.v = v
    # assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.
    g.app.positions += 1
    
    # if g.app.tracePositions and trace:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20060120105136.60"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.c,self.v,self.stack,trace=False)</t>
<t tx="ekr.20060120105136.61"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    """Bump the error count in the tangle command."""
    
    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es(s)</t>
<t tx="ekr.20060120105136.62"></t>
<t tx="ekr.20060120105136.63">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3465251
By: e

(fixed) after a save, undo last typing event
doesn't mark leo changed.
you can go up and down the undo redo list
and still the leo is not marked changed.
the changes in the body do stick.
didn't try other undo like insert node.

**Important**: the follows was likely due to improper calls to g.top()

(can't duplicate) I had a weird undo that I wasn't able to repeat
after a reboot, when I had 2 leos open and
and the undo after a save in one would display
the last undo in a node body from the other leo.
</t>
<t tx="ekr.20060120105136.64"></t>
<t tx="ekr.20060120105136.65">def new (self):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20060120105136.66">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.67">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20060120105136.68">def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20060120105136.69">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20060120105136.70">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20060120105136.71">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20060120105136.72">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20060120105136.73">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20060120105136.74">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20060120105136.75">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20060120105136.76">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20060120105136.77">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20060120105136.78">def close(self):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20060120105136.79">def save(self):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060120105136.80">def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060120105136.81">def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20060120105136.82">def revert(self):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20060120105136.83">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            frame.bodyWantsFocus()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20060120105136.84">def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self
    c.setLog()
    p = c.currentPosition()
    #g.trace(command.__name__,label)
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            if event is None:
                val = command() # Call legacy command
                if c and c.exists: # Be careful: the command could destroy c.
                    c.keyHandler.funcReturn = val
            else:
                command(event) # Call minibuffer command.
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            if c and c.exists and hasattr(c,'frame'):
                c.redraw_now()

    # Be careful there: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20060120105136.85">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3495741
By: stano_paska

Hi.

In plugin word_export encoding is defined:

encoding = dict.get("encoding",None)
if encoding == None:
    encoding = c.config.default_derived_file_encoding

I have default_derived_file_encoding set to UTF-8 but when exporting to word
some national characters are not encoded correctly (Slovak).

I think it is better get encoding for word from somewhere else.

In Slovak environment word uses cp1250.

When I used:

import sys
encoding = sys.getdefaultencoding() # 'cp1250'

everything goes fine.</t>
<t tx="ekr.20060120105136.86">This could have been the source of weird find behavior.</t>
<t tx="ekr.20060120105136.87">The fix was to have x.getSelectedText return '' instead of None.</t>
<t tx="ekr.20060120105136.88">
AttributeError Exception in Tk callback
  Function: &lt;function allKeysCallback at 0x03463730&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x046801C0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 647, in allKeysCallback
    return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 763, in masterCommand
    k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 799, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 530, in stateHandler
    self.doTabCompletion()
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 457, in doTabCompletion
    if s.startswith(self.prefix) and self.tabList:
AttributeError: 'NoneType' object has no attribute 'startswith'

================================================
  Event contents:
    char:
    delta: 9
    height: ??
    keycode: 9
    keysym: Tab
    keysym_num: 65289
    num: ??
    serial: 197812
    state: 8
    time: 7154627
    type: 2
    widget: .62497976.62497136.17871136.17871376.body-pane
    width: ??
    x: 307
    x_root: 688
    y: 58
    y_root: 624</t>
<t tx="ekr.20060120105136.89"></t>
<t tx="ekr.20060120105136.90">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3510983
By: vpe

I realized it's not necessary to do int-float-int conversion to calculate width.
The result will be the same. So it's really simple:

width = font.measure(p.headString())/font.measure('0')+1

If font is not fixed-width, trailing space in headlines will vary between 0
pixels and width of char '0'.</t>
<t tx="ekr.20060120105136.91">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.expanded_click_area = c.config.getBool("expanded_click_area")
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
        # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.trace = False
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.useBindtags = True
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20060120105136.92">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20060120105136.93"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20060120105136.94"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20060120105136.95">def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""
    
    if p: s = p.headString()

    return self.font.measure(s)/self.font.measure('0')+1

    
def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)
    
    return self.font.measure(s)</t>
<t tx="ekr.20060120105136.96"></t>
<t tx="ekr.20060120105136.97">def goToNextDirtyHeadline (self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isDirty():
        p.moveToThreadNext()

    if not p:
        # Wrap around.
        p = c.rootPosition()
        while p and not p.isDirty():
            p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060120105136.98">def goToNextMarkedHeadline(self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isMarked():
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060120105136.99"></t>
<t tx="ekr.20060120105136.100">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3514627
By: nobody

&lt;quote&gt;I suspect what you want is to elimate all the !text specifications in
the @shortcuts nodes. (just the !text part, not the whole binding!)&lt;/quote&gt;

Not neccessarialy, I just want to hinder that the body pane looses the focus
as soon as you press Ctrl-S for safe, or if you press ALT-DnArrow to skip to
the next node in the tree pane.The focus should stay in the body pane without
the need to explicitly give it back to it by mouse-click or Ctrl-T, but maybe
in the case of Ctrl-s that is a bug ?
Why should the body pane loose the focus by pressing Ctrl-S ?</t>
<t tx="ekr.20060120105136.101">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    w = g.app.gui.get_focus(c.frame)
    c.afterUpdateWidgetStack.append(w)
    # g.trace(g.app.gui.widget_name(w),g.callers(5))
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True,restoreFocus=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)
    w = c.afterUpdateWidgetStack.pop()
    if c.exists and not c.afterUpdateWidgetStack and restoreFocus:
        # We are at the top-level endUpdate.
        c.frame.widgetWantsFocus(w)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060120105136.102"></t>
<t tx="ekr.20060120105136.103"></t>
<t tx="ekr.20060120105136.104">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514755

Leo Log Window...
Leo 4.4 alpha 5, build  1.358 , January 5, 2006
Python 2.3.4, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 1

When I hit Ctrl-H to edit a headline, the entire headline is selected. Fine.
However, when I use an arrow key to move the cursor, the headline is _still_
selected. This is NOT Windows-standard action. What's happened?</t>
<t tx="ekr.20060120105136.105">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
  
    # Move to the spot.
    w.mark_set('insert',spot)
    spot = w.index('insert')

    # Handle the selection.
    self.extendHelper(w,extend,ins1,spot)
    w.see(spot)</t>
<t tx="ekr.20060120105136.106"># The report was mistaken.</t>
<t tx="ekr.20060120105136.107">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514816

the cut&amp;paste doesn't mark leo dirty.
a cut then change of focus, does
an undo cleans up the mark again?</t>
<t tx="ekr.20060120105136.108"></t>
<t tx="ekr.20060120105136.109">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060120105136.110">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060120105136.111">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060120105136.112">@tabwidth 4

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=3515341
By: nobody

from latest cvs. post g.top disable.

inconsistent use of tabs and spaces
leo\src\leoUndo.py: 
leo\src\leoCommands.py:
leo\src\leoTkinterTree.py: 
@tabwidth 4
	
Library creating: default
problem starting Library: default
not sure where this is comming from.
I though Library did nothing untill first used.
the 2nd run of Leo, the db is already created
so no error reported. 
ok if have an existing db in the default place.

leo\plugins\rClick.py", line 244, in rClicker
    commandList=[
UnboundLocalError: local variable 'rc_selectAllCallback' referenced before
assignment

a lambda would work here.
or the callback has to be moved
outside the if startswith body

leo\src\leoTkinterGui.py", line 677, in getTextSelection
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine
instead!!
AttributeError: Entry instance has no attribute 'tag_ranges'
when paste into Entry widget of search box or button.
paste only understands Text widget?
and then only from Edit-Paste
keyboard paste is ok.

in dyna_menu
TypeError: cmd_flip_Leo_debug() takes no arguments (1 given)
thanks for adding the callback in plugin_menu, 
but now any plugin that has cmd_* functions 
needs a c or dummy parameter in all of them.

'help' in 139i should be copied from 
my website version 139j from last year.
this one fails on modules if you have epydoc,
that should fix the only crasher 
in the dyna version included with Leo.

pylint call might need to have the import
lines tweaked, depending on which version.
they stupidly changed logilab directorys
from version 6 to 7 and then again 7+.
Im not going to try and guess which if
any version of pylint someone has installed.
if you want it, then you can edit it in.

otherwise everything so far seems to work.
with other noted anomalies omited for brevity.
movement keys not  unselecting text the main one.

alpha testers, remember if there is a
traceback error in a plugin, although
Leo recovers often other plugins will
stop working 100% correctly in every case.
exit Leo and python and restart 
maybe with the offending plugin disabled,
to be sure other problems are real problems.

docutils 0.4 was released today.
has a new html slideshow writer.

e</t>
<t tx="ekr.20060120105136.113"></t>
<t tx="ekr.20060120105136.114">def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.endEditing()
        c.editPosition(p)
    finally:
        c.endUpdate(restoreFocus=False)

    return p # for mod_labels plugin.</t>
<t tx="ekr.20060120105136.115"></t>
<t tx="ekr.20060120105136.116">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3514294
By: sergio_101

i just started using Leo toinght, but i am having problems with the enter key..

unless i hit ctl-enter, i cannot get a lf/cr.. it seems almost like the enter
key is not active at all unless i hit ctl..</t>
<t tx="ekr.20060120105136.117"></t>
<t tx="ekr.20060120105136.118">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3509141
By: rich_ries

CLEO still does not remove markings. I set Priority -&gt; High, then tried Priority
-&gt; Clear. Arrow is still showing. Tried Clear All. Arrow is still showing.

FastGotoNode not working w/ ^SPC

Group Operations NEEDS the old KEY-BASED version -- try tagging a dozen nodes,
making a Mark, and cloning them using a mouse!!

Need How-to for Labels:
..Label to subnode
..label to subnodes
..labels to subnodes

may be clear to the programmer, but not to anyone else.
</t>
<t tx="ekr.20060120105136.119">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3515025
By: nobody

From: Rich

&gt;&gt;  Rich, are you still having any problems with plugins? (except for problems
with the initial dynamic enabling of plugins).
 
I have a nimber of plugins turned on. Here are my findings:

I've had troubles with the following:

-  cleo.pyc
....Markers are not cleared. 
....Pressing Priority --&gt; clear gives:
---------------------------------------------------
........Error: 1
........AttributeError Exception in Tk callback
........  Function: &lt;function &lt;lambda&gt; at 0x0173BAB0&gt; (type: &lt;type 'function'&gt;)
........  Args: ()
........Traceback (innermost last):
........  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py",
line 1747, in __call__
............return apply(self.func, args)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 700,
in &lt;lambda&gt;
............command=lambda:self.priority_clear(p.v),underline=0)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 742,
in priority_clear
............self.changed_redraw()
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 325,
in changed_redraw
............c.setChanged(True)
........  File "c:\softwa~1\leo\leo4~1.4\src\leoCommands.py", line 5966, in
setChanged
............if not c.frame: return
........AttributeError: Commands instance has no attribute 'frame'
---------------------------------------------------
(FWIW, I like the error window that pops up.)

...."Clear All" does NOT clear ALL(nodes) but restores the node colors to their
default values

....CLEO does not pick up Leo's colors. I use Antique White for the backgrounds,
but until I changed CLEO's "White" to "Antique White" it was a nuisance. Newbies
wouldn't want to / shouldn't need to go in and change the source code.


-  fastGotoNode.pyc
....Ctrl-Spc does not work to bring up the menu

~  groupOperations.pyc
....(Image) is not a very helpful name -- To me, 'image' has to do with graphics.
"GrpOps" would be better.

....I found using the old-time key combinations a LOT easier than mousing
around:
........Shift+Alt+M........Mark
........Shift+Alt+V........moVe (Remember Turbo Pascal?)
........Shift+Alt+C........Copy
........Shift+Alt+`........clone
........Shift+Alt+T........Tag
........Shift+Alt+R........Remove tag

....... and I'd rather have a multitude of operations (as above) than a multitude
of markings (mark for Move|Copy|Clone).

The following work as expected:
+  add_directives.pyc
+  color_markup.pyc
+  hoist.pyc
+  nav_buttons.pyc
+  open_with.pyc - even with my editor!
+  rClick.pyc
+  startfile.pyc
+  UniversalScrolling.pyc

Untried-until-I-get-a-chance:
?  ConceptualSort.pyc
?  labels.pyc
?  Scripts
?  timestamp.pyc
?  UNL.pyc

HTH,
--Rich
</t>
<t tx="ekr.20060120105136.120">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517080</t>
<t tx="ekr.20060120105136.121"></t>
<t tx="ekr.20060120105136.122">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3518722
By: nobody

I'm using Leo 4.3.1, build  1.266 , June 20, 2005.

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt

maks.romih@snt.si</t>
<t tx="ekr.20060120105136.123">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return
        
    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []</t>
<t tx="ekr.20060120105136.124"></t>
<t tx="ekr.20060120105136.125">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803</t>
<t tx="ekr.20060120105136.126">&lt;&lt; about os.rename &gt;&gt;

def utils_rename (src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False</t>
<t tx="ekr.20060120105136.127">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.</t>
<t tx="ekr.20060120105136.128">def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)</t>
<t tx="ekr.20060120105136.129"># These should be considered bug fixes.</t>
<t tx="ekr.20060120105136.130">@nocolor

1. copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

2. Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.</t>
<t tx="ekr.20060120105136.131"></t>
<t tx="ekr.20060120105136.132">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '&lt;Key&gt;'
    
    if trace and interesting:
        g.trace(
            'c',c,
            'stroke:',stroke,'ch:',repr(ch),'keysym:',repr(keysym),
            'widget:',w and g.app.gui.widget_name(w),'func',func,
            g.callers())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060120105136.133"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060120105136.134">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060120105136.135">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060120105136.136">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060120105136.137">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060120105136.138">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20060120105136.139">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060120105136.140"></t>
<t tx="ekr.20060120105136.141">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20060120105136.142">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20060120105136.143">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20060120105136.144">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060120105136.145">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)</t>
<t tx="ekr.20060120105136.146">def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
    if shortcut == '&lt;Key&gt;':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    elif k.isPlainKey(shortcut):
        # Put the binding in a plain-key bindtag specific to this commander.
        tag = k.plainKeyTag()
        # g.trace('bindtags',tag,shortcut)
        body.bind_class(tag,shortcut,callback)
    else:
        for w in widgets:
            # if shortcut == '&lt;Return&gt;': g.trace(g.app.gui.widget_name(w),shortcut,callback)
            w.bind(shortcut,callback)
        # Get rid of the default binding in the menu. (E.g., Alt-f)
        menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20060120105136.147">def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())</t>
<t tx="ekr.20060120105136.148">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20060120105136.149">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20060120105136.150">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060120105136.151">def computeKeysym_numDicts (self,shortcut):
    
    k = self
    
    if shortcut == '&lt;Key&gt;': return
    
    n = k.keysym_numberInverseDict.get(shortcut)
    if n is not None:
        # print 'keysym_num for %s = %d' % (shortcut,n)
        return
        
    def callback (event,shortcut=shortcut):
        n = event.keysym_num
        # Trace causes problems.
        print '%5d = %s' % (n,shortcut)
        k.keysym_numberDict [n] = shortcut
        k.keysym_numberInverseDict [shortcut] = n
        
    if 0:  # This causes all sorts of problems.
        t = Tk.Text(k.c.frame.outerFrame)
        t = k.c.frame.body.bodyCtrl
        t.bind(shortcut,callback)
        t.event_generate(shortcut)
        # t.update()
        # t.unbind(shortcut)</t>
<t tx="ekr.20060120105136.152">def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w))

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        shortcutsBunchList = []
        for pane in panes:
            old_panes = bindings.get(shortcut,[])
            assert(type(old_panes)==type([]))
            if old_panes and pane in old_panes:
                # This should have been caught earlier, but another check doesn't hurt.
                g.trace('*** redefining %s in %s' % (shortcut,pane))
            else:
                bunchList = d.get(shortcut,[])
                for bunch in bunchList:
                    if bunch.pane == pane:
                        shortcutsBunchList.append(bunch)
                        old_panes.append(pane)
                        bindings [shortcut] = old_panes
        # Create bindings for the shortcut in all panes.
        if shortcutsBunchList:
            self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='&lt;Key&gt;',commandName=None)

    w.bind('&lt;Key&gt;',generalTextKeyCallback)</t>
<t tx="ekr.20060120105136.153">def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)</t>
<t tx="ekr.20060120105136.154">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]
    return len(shortcut) == 1</t>
<t tx="ekr.20060120105136.155">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    # k.makeHardBindings()
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    # k.add_ekr_altx_commands()
    k.checkBindings()
    
    if 0:
    
        # Print the keysym_num dicts.
        d = k.keysym_numberInverseDict
        keys = d.keys() ; keys.sort()
        for key in key():
            n = d.get(key)
            # print 'keysym_num for %s = %d' % (key,n)</t>
<t tx="ekr.20060120105136.156">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060120105136.157">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
        
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }</t>
<t tx="ekr.20060120105136.158">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20060120105136.159">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20060120105136.160">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20060120105136.161">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['log','text','all'],w)</t>
<t tx="ekr.20060120105136.162"></t>
<t tx="ekr.20060120105136.163">@nocolor

Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().</t>
<t tx="ekr.20060120105136.164">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    if t:
        t.delete('1.0','end')
        # Necessary to allow focus to move *out* of t.
        t.update()</t>
<t tx="ekr.20060120105136.165"></t>
<t tx="ekr.20060120105136.166"></t>
<t tx="ekr.20060120105136.167"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['text','tree','all'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20060120105136.168"></t>
<t tx="ekr.20060120105136.169">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        bunchList = k.bindingsDict.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
            if k.unboundKeyAction == 'ignore' or not k.isPlainKey(key):
                s = k.prettyPrintKey(key) + pane
                g.es('%-30s\t%s' % (s,b.commandName),
                    tabName='Command')</t>
<t tx="ekr.20060120105136.170">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c
    
    c.frame.log.clearTab('Command')
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            g.es('%-30s\t%s' % (commandName,k.prettyPrintKey(shortcut)),
                tabName='Command')</t>
<t tx="ekr.20060120105136.171">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20060120105136.172">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    k = self ; c = k.c
    
    if not key: return ''
    if len(key) == 1: return key
    if key.startswith('&lt;'):
        key = key[1:]
    if key.endswith('&gt;'):
        key = key[:-1]
    if not key: return ''
    ch = key[-1]
    if not ch: return ''
    
    if len(ch) &gt; 1:
        ch,junk = c.frame.menu.canonicalizeShortcut(ch)

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20060120105136.173"></t>
<t tx="ekr.20060120105136.174">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            # g.trace(f,name)
            return self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20060120105136.175">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-find-dialog':            c.dismissFindPanel, # Deprecated.
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-dialog-change':           c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':       c.replaceAll,           # Deprecated.
    'find-dialog-find-next':        c.findNext,             # Deprecated.
    'find-dialog-find-previous':    c.findPrevious,         # Deprecated.
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'replace':                      c.replace,
    'replace-then-find':            c.replaceThenFind,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.viewAllCharacters,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20060120105136.176">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060120105136.177">@nocolor
@

ivars:

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are *lists* of g.bunch(func,name,warningGiven)

g.app.keysym_numberDict:
    Keys are keysym_num's.  Values are strokes.

g.app.keysym_numberInverseDict
    Keys are strokes, values are keysym_num's.

not an ivar (computed by computeInverseBindingDict):

inverseBindingDict
    keys are emacs command names, values are *lists* of shortcuts.</t>
<t tx="ekr.20060120105136.178">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.keysym_numberDict = {}
    # Keys are keysym_num's.  Values are strokes.
self.keysym_numberInverseDict = {}
    # Keys are strokes, values are keysym_num's.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
</t>
<t tx="ekr.20060120105136.179">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20060120105136.180"></t>
<t tx="ekr.20060120105136.181"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcutList = inverseBindingDict.get(commandName,[''])
            for shortcut in shortcutList:
                g.es('%s %s' % (commandName,k.prettyPrintKey(shortcut)),tabName='Completion')

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.182">def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                # g.trace(shortcut,repr(b.pane))
                pane = g.choose(b.pane=='all','','[%s]' % (b.pane))
                s = '%s %s' % (k.prettyPrintKey(shortcut),pane)
                if s not in shortcutList:
                    shortcutList.append(s)
            d [b.commandName] = shortcutList

    return d</t>
<t tx="ekr.20060120105136.183">@ To do:
    
- inverseCommandsDict should be a list too.
- getShortcutForCommandName should return a list.</t>
<t tx="ekr.20060120105136.184">def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = z [0].lstrip('&lt;').rstrip('&gt;')
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'&lt;%s&gt;' % meth)</t>
<t tx="ekr.20060120105136.185">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = stroke.lstrip('&lt;').rstrip('&gt;')
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)</t>
<t tx="ekr.20060120105136.186">def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return key
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                    return key
    return ''</t>
<t tx="ekr.20060120105136.187">@nocolor

The fix is easy: extensionHelper resets movePoint any time there is no selection.

@color
</t>
<t tx="ekr.20060120105136.188">def extendHelper (self,w,extend,ins1,spot):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'&lt;',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        self.moveSpot = spot
        self.moveCol = int(spot.split('.')[1])
        g.app.gui.setTextSelection(w,spot,spot,insert=None)</t>
<t tx="ekr.20060120105136.189"></t>
<t tx="ekr.20060120105136.190">def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c

    if not c.config.getBool('trace_bindings'): return
    
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    
    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,k.prettyPrintKey(shortcut),bunch.commandName,w._name)</t>
<t tx="ekr.20060120105136.191"></t>
<t tx="ekr.20060120105136.192">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-all', self.changeAllCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20060120105136.193">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget(['text','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20060120105136.194">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget(['text','all'],t) # Text *must* be in the list.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("&lt;Control-t&gt;",self.onControlT)

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t</t>
<t tx="ekr.20060120105136.195">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
    t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
    t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("&lt;Button-4&gt;", PropagateButton4)
    t.bind("&lt;Button-5&gt;", PropagateButton5)
    t.bind("&lt;MouseWheel&gt;", PropagateMouseWheel)

</t>
<t tx="ekr.20060120105136.196">@nocolor

The fix was simply to call endUpdate() rather than endUpdate(changed) in onHeadChanged.
This should be safe: The change-all command could always enclose the code in begin/endUpdate.</t>
<t tx="ekr.20060120105136.197"></t>
<t tx="ekr.20060120105136.198"></t>
<t tx="ekr.20060120105136.199">def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback</t>
<t tx="ekr.20060120105136.200"></t>
<t tx="ekr.20060120105136.201"></t>
<t tx="ekr.20060120105136.202"></t>
<t tx="ekr.20060120105136.203">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = False
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20060120105136.204">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20060120105136.205">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For saving and restoring focus.
self.afterUpdateWidgetStack = []

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20060120105136.206">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20060120105136.207">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20060120105136.208">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20060120105136.209">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20060120105136.210">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20060120105136.211">def destroyWindow (self,frame):
    
    # g.trace(frame in g.app.windowList,frame)
        
    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        g.app.windowList.remove(frame)
        # g.trace(g.app.windowList)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()</t>
<t tx="ekr.20060120105136.212">def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    print 'skipping tag: c does not exists or does not have a frame.'
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result</t>
<t tx="ekr.20060120105136.213">@nocolor


- 
</t>
<t tx="ekr.20060120105136.214">The following would be major changes, with little benefit.

- Make leoGlobals a subclass of the commander.
    - There are many calls to to g.es in leoGlobals.py.

- Eliminate g.app.log.
    - It is dangerous, but g.es requires it.

- Eliminate g.scanErrors.
    - A laudable goal, but it's real messy.</t>
<t tx="ekr.20060120105136.215"># This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060120105136.216">def setLog (self,log):

    """set the frame to which log messages will go"""
    
    # print "setLog:",tag,"locked:",self.logIsLocked,log
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True
    
def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False</t>
<t tx="ekr.20060120105136.217">def setLog (self):
    
    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass</t>
<t tx="ekr.20060120105136.218"></t>
<t tx="ekr.20060120105136.219"></t>
<t tx="ekr.20060120105136.220">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20060120105136.221">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20060120105136.222">def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.</t>
<t tx="ekr.20060120105136.223">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    # 7/28/04: Not doing this translation was the real bug.
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId: return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20060120105136.224"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if p and c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20060120105136.225">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
        
    
</t>
<t tx="ekr.20060120105136.226"></t>
<t tx="ekr.20060120105136.227">def onClickBoxClick (self,event):
    
    c = self.c
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
            if p.isExpanded(): p.contract()
            else:              p.expand()
            self.active = True
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060120105136.228"></t>
<t tx="ekr.20060120105136.229">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.</t>
<t tx="ekr.20060120105136.230">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20060120105136.231"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20060120105136.232"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    c.setLog()
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20060120105136.233">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20060120105136.234"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20060120105136.235">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060120105136.236">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060120105136.237"></t>
<t tx="ekr.20060120105136.238">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060120105136.239">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20060120105136.240">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060120105136.241">def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20060120105136.242">if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus()
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True</t>
<t tx="ekr.20060120105136.243">def onTreeClick (self,event=None):
    
    c = self.c
    
    c.setLog()
    self.frame.treeWantsFocus()

    return 'break'</t>
<t tx="ekr.20060120105136.244"></t>
<t tx="ekr.20060120105136.245">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20060120105136.246"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20060120105136.247">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    c.setLog()
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")

    return "continue"</t>
<t tx="ekr.20060120105136.248">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20060120105136.249">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        c.beginUpdate()
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        finally:
            c.endUpdate(False)</t>
<t tx="ekr.20060120105136.250">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20060120105136.251">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20060120105136.252">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20060120105136.253">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20060120105136.254">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20060120105136.255">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20060120105136.256">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.frame.widgetWantsFocus(menu)</t>
<t tx="ekr.20060120105136.257"># Leo now calls doCommand on all commands, so the 'command' hooks always get done.
# In addition, the normal processing in doCommand catches errors, etc.</t>
<t tx="ekr.20060120105136.258"></t>
<t tx="ekr.20060120105136.259">See this node in leoDocs.leo.

Users Guide--&gt;FAQ--&gt;@rst html\FAQ.html--&gt;Learning to use Leo--&gt;When is deleting a node dangerous?</t>
<t tx="ekr.20060120105136.260"></t>
<t tx="ekr.20060120105136.261">@nocolor</t>
<t tx="ekr.20060120105136.262">I use SciTE, but these keystrokes are quite common.
http://www.scintilla.org/SciTE.html

These now exist in 'EKR bindings: a mix...'

back-word                               ! text = Ctrl-LtArrow
back-word-extend-selection              ! text = Ctrl-Shift-LtArrow
beginning-of-line                       ! text = Home
beginning-of-line-extend-selection      ! text = Shift-Home
end-of-line                             ! text = End
end-of-line-extend-selection            ! text = Shift-End
forward-word                            ! text = Ctrl-RtArrow
forward-word-extend-selection           ! text = Ctrl-Shift-RtArrow
scroll-down                             ! text = PageDn
scroll-up                               ! text = PageUp

I added these, but the commands don't exist yet:

beginning-of-text                       ! text = Ctrl-Home
beginning-of-text-extend-selection      ! text = Ctrl-Shift-Home
end-of-text                             ! text = Ctrl-End
end-of-text-extend-selection            ! text = Ctrl-Shift-End
scroll-down-extend-selection            ! text = Shift-PageDn
scroll-up-extend-selection              ! text = Shift-PageUp

Manfred
marl@pragmatis.de
www.pragmatis.de</t>
<t tx="ekr.20060120105136.263">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518387

Here are the changes I made to get back to my old Leo:

back-word                               = Ctrl-LtArrow
back-word-extend-selection              = Shift-Ctrl-LtArrow
beginning-of-buffer                     = Ctrl-Home
beginning-of-buffer-extend-selection    = Shift-Ctrl-Home
beginning-of-line                       = Home
beginning-of-line-extend-selection      = Shift-Home
delete-char                             = Delete
end-of-buffer                           = Ctrl-End
end-of-buffer-extend-selection          = Shift-Ctrl-End
end-of-line                             = End
end-of-line-extend-selection            = Shift-End
forward-word                            = Ctrl-RtArrow
forward-word-extend-selection           = Shift-Ctrl-RtArrow
scroll-down                             = PageDn
scroll-up                               = PageUp
</t>
<t tx="ekr.20060120105136.264"></t>
<t tx="ekr.20060120105136.265"></t>
<t tx="ekr.20060120105136.266">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.</t>
<t tx="ekr.20060120105136.267"># Ends the editing in the outline.

def endEditing(self,restoreFocus=False):
    
    c = self ; tree = c.frame.tree
    
    if restoreFocus:
        w = g.app.gui.get_focus(c.frame)
        tree.endEditLabel()
        c.frame.widgetWantsFocus(w)
    else:
        tree.endEditLabel()</t>
<t tx="ekr.20060120105136.268"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing(restoreFocus=True) # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput</t>
<t tx="ekr.20060120105136.269"></t>
<t tx="ekr.20060120105136.270">@nocolor

Later

open-outline-by-name

https://sourceforge.net/forum/message.php?msg_id=3519444

write-rst
execute-unit-tests</t>
<t tx="ekr.20060120105136.271">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060120105136.272">def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)</t>
<t tx="ekr.20060120105136.273">def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)
    w.see('insert')</t>
<t tx="ekr.20060120105136.274"></t>
<t tx="ekr.20060120105136.275">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.</t>
<t tx="ekr.20060120105136.276">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060120105136.277">def moveUpDown (self,direction):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2: x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    g.trace("entry:  %s.%s" % (lines,char),'result',result,'insert',body.index('insert'))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20060120105136.278"></t>
<t tx="ekr.20060120105136.279"></t>
<t tx="ekr.20060120105136.280">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y &gt;= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col &gt;= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)</t>
<t tx="ekr.20060120105136.281">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060120105136.282">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.283">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.284">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.285">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060120105136.286">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060120105136.287">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060120105136.288">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060120105136.289">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060120105136.290">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060120105136.291">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=False)
    # self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=True)
    #self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=False)
    #self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=True)
    #self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20060120105136.292">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.293">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.294">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.295">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060120105136.296">The fix was to add the 'text' specifier to the call to copyBindingsToWidget in tree.setTabBindings.</t>
<t tx="ekr.20060120105136.297"></t>
<t tx="ekr.20060120105136.298"></t>
<t tx="ekr.20060120105136.299">Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?</t>
<t tx="ekr.20060120105136.300"></t>
<t tx="ekr.20060120105136.301">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict
    
    # g.trace(modeDict.keys())

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060120105136.302">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Change the pane of all entries to 'mode-name'.
    # This will disable warnings about duplicate bindings.
    for key in d2.keys():
        bunchList = d2.get(key,[])
        for bunch in bunchList:
            bunch.pane = name
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060120105136.303"></t>
<t tx="ekr.20060120105136.304">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20060120105136.305">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        k.printBindings(event)

    return 'break'




</t>
<t tx="ekr.20060120105136.306">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    lines = []
    for key in d.keys():
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                lines.append('%-30s\t%s' % (key,k.prettyPrintKey(shortcut)))
    lines.sort()
    for line in lines:
        g.es(line,tabName='Mode')</t>
<t tx="ekr.20060120105136.307">def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    # modeName = modeName or k.inputModeName or ''
    state = k.getState(modeName)
   
    if state == 0:
        # g.trace(modeName,state)
        k.modeWidget = event and event.widget
        if c.config.getBool('showHelpWhenEnteringModes'):
            d = g.app.config.modeCommandsDict.get('enter-'+modeName)
            k.modeHelpHelper(d)
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
    elif not func:
        g.trace('No func: improper key binding')
    else:
        # g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
</t>
<t tx="ekr.20060120105136.308">def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)</t>
<t tx="ekr.20060120105136.309">def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    &lt;&lt; define modeCallback &gt;&gt;
        else:
            g.trace('No such command: %s' % commandName)

    &lt;&lt; define modeHelpCallback &gt;&gt;</t>
<t tx="ekr.20060120105136.310"># g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)
</t>
<t tx="ekr.20060120105136.311">def modeHelpCallback (event,k=k,d=d):
    
    if event and event.char != '': # and not special:
        return k.modeHelpHelper(d)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'&lt;Key&gt;',modeHelpCallback)</t>
<t tx="ekr.20060120105136.312">def initMode (self,event,modeName):

    k = self ; c = k.c
    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
        
    t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    c.frame.minibufferWantsFocus()</t>
<t tx="ekr.20060120105136.313">def endMode(self,event):
    
    k = self ; c = k.c

    # Restore the bind tags.
    t = c.frame.body.bodyCtrl
    t.bindtags(k.savedBindtags)

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    # k.setLabelGrey('top-level mode')
    c.frame.widgetWantsFocus(k.modeWidget)</t>
<t tx="ekr.20060120105136.314"></t>
<t tx="ekr.20060120105136.315">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    c.endEditing()
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.316">def setIgnoreMode (self,event):

    self.setMode('ignore')

def setInsertMode (self,event):

    self.setMode('insert')

def setOverwriteMode (self,event):

    self.setMode('overwrite')

def setMode (self,mode):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    tag = k.plainKeyTag()
    try: # Will fail for nullBody.
        w = g.app.gui.get_focus(c.frame)
        tags = t.bindtags()
        tags = list(tags)
        # g.trace('1',mode,'plain-keys:',tag in tags)
    except AttributeError:
        tags = []
        w = None
        
    if tags:
        if mode == 'ignore':
            if tag not in tags:
                tags.insert(0,tag)
                t.bindtags(tuple(tags))
        else:
            if tag in tags:
                tags.remove(tag)
                t.bindtags(tuple(tags))
    # g.trace('2',mode,'plain-keys:',tag in tags)

    self.unboundKeyAction = mode
    frame = self.c.frame
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        frame.putStatusLine('input mode: ',color='blue')
        frame.putStatusLine(mode)
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060120105136.317">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setMode(self.unboundKeyAction)</t>
</tnodes>
</leo_file>
