#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            << Do auto indent >>
        elif ch == '\t' and tab_width < 0:
            << convert tab to blanks >>
        elif ch in (chr(8)) and tab_width < 0:
            << handle backspace with negative tab_width >>
    << set s to widget text, removing trailing newlines if necessary >>
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (called from core)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (called from core)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char
    
    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        << update p >>
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.92:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20040803072955.92:<< set head to vnode text >>
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20031218072017.1319:(Key handlers)
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline()
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory() # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory() # May return "".

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    language = c.target_language
    self.language = language # 2/2/03
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language # 2/2/03

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set dict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set dict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return dict
#@nonl
#@+node:ekr.20031218072017.1261:<< set dict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set dict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (lineending = None):
    
    """Convert the name of a line ending to the line ending itself.
    Use the output_newline configuration option if no lineending is given.
    """
    
    if lineending:
        s = lineending
    else:
        s = app.config.output_newline

    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,dict):
    
    """Scan the @encoding directive at s[dict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = dict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,dict):
    
    """Scan the @lineending directive at s[dict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = dict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[dict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[dict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ã
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20040929081120:4.3 a1 projects
#@+node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20040701152235:(Fixed shawdow warnings)
@killcolor

The following are all Python global functions:

(done) cmp -> compare
(done) dict -> theDict
(done) dir -> theDir
(done) file -> theFile
(done) id -> theId
(done) type -> theType
(done) input  (suppressed the warning)
(done) iter -> theIter
#@nonl
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20040701152235.2:leoApp (done)
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:209: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:224: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:368: (dir) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:401: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.2:leoApp (done)
#@+node:ekr.20040701152235.3:leoPlugins (done)
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:40: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:53: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:67: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:72: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:74: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.3:leoPlugins (done)
#@+node:ekr.20040701152235.4:leoColor (done)
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:1948: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:2059: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.4:leoColor (done)
#@+node:ekr.20040701152235.5:leoNodes (done)
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:578: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1372: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1394: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1411: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1412: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1419: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1443: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1446: (id) shadows builtin
#@nonl
#@-node:ekr.20040701152235.5:leoNodes (done)
#@+node:ekr.20040701152235.6:leoCompare (done)
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:44: (cmp) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:397: (cmp) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:468: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.6:leoCompare (done)
#@+node:ekr.20040701152235.8:leoFind (done)
(fixed) c:\prog\leoCVS\leo\src\leoFind.py:864: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.8:leoFind (done)
#@+node:ekr.20040701152235.9:leoMenu (done)
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:656: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:700: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.9:leoMenu (done)
#@+node:ekr.20040701152235.10:leoTkinterTree (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:949: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:162: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:167: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:586: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:639: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:783: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:844: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:911: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1390: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1588: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1590: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:883: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:893: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.10:leoTkinterTree (done)
#@+node:ekr.20040701152235.11:leoTkinterFrame (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:807: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:566: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1233: (file) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:522: (type) shadows builtin
#@-node:ekr.20040701152235.11:leoTkinterFrame (done)
#@+node:ekr.20040701152235.12:leoTkinterPrefs (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterPrefs.py:295: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.12:leoTkinterPrefs (done)
#@+node:ekr.20040701152235.13:leoTkinterGui (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterGui.py:78: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.13:leoTkinterGui (done)
#@+node:ekr.20040701152235.14:leoAtFile (done)
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:336: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:490: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2157: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:473: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:549: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:551: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2142: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2278: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2280: (dir) shadows builtin
#@-node:ekr.20040701152235.14:leoAtFile (done)
#@+node:ekr.20040701152235.15:leoFileCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:90: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:866: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1191: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1318: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1756: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:990: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2018: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1228: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1269: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.15:leoFileCommands (done)
#@+node:ekr.20040701152235.16:leoImport (done)
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2792: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:52: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:273: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2348: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2371: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2398: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2426: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2476: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:473: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1626: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1648: (id) shadows builtin
(fixed) :\prog\leoCVS\leo\src\leoImport.py:1650: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2303: (type) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2727: (type) shadows builtin

#@-node:ekr.20040701152235.16:leoImport (done)
#@+node:ekr.20040701152235.17:leoTangle (done)
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:718: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:911: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:924: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3563: (dict) shadows builtin

c:\prog\leoCVS\leo\src\leoTangle.py:540: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:541: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:666: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3656: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3667: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3780: (dir) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:2038: (type) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3865: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.17:leoTangle (done)
#@+node:ekr.20040701152235.18:leoCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:324: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:340: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:346: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:468: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:480: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1677: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1721: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1770: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1800: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:2280: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:465: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:495: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:734: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1238: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.18:leoCommands (done)
#@-node:ekr.20040701152235:(Fixed shawdow warnings)
#@+node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20040929100426:Report
@killcolor

When I start leo from the command line (linux) with e.g.

[davides@icarus utilities]$ leodev test.leo

(leodev is an alias to the latest cvs version)

and "test.leo" does not exist, the Log pane says

File not found: /localstore/computer/davides/SW/test/utilities/test.leo

but then I would expect that the current file name were set to "test.leo", so that when I do a save, "test.leo" gets saved. It is set to "untitled" instead, so that in essence in this case Leo ignores my command line argument. I would also change the log message to say something like "New file" or similar. Cf. what happens when you do e.g. "vi newfile.txt" (or "emacs", or even "edit" in ms-dos).

Davide 
#@nonl
#@-node:ekr.20040929100426:Report
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@-node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041001075258:Traceback
exception executing command
Traceback (most recent call last):

File "C:\prog\leoCVS\leo\src\leoNodes.py", line 3044, in moveToParent
if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'
#@nonl
#@-node:ekr.20041001075258:Traceback
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p # 10/30/04

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@-node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041007081134.3:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2792616
By: e

The recursion was happening in nullLog put & write.

EKR:  The problem is that nullLog.write calls print, and if print is redirected we end up calling nullLog.write again.

sys.stdout.write() doesn't work any better than print
but inside g.app.log.disable/enable doesn't error.

redirect_execute_script_output_to_log_pane = 1
is not good in batch mode!

should that should be always zeroed in batch mode?
set to 0 and both sys.stdout.write and print works.
no recursion.
#@-node:ekr.20041007081134.3:Report
#@+node:ekr.20041012082437.6:What I did
@killcolor

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.
#@nonl
#@-node:ekr.20041012082437.6:What I did
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    import sys

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    import sys

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g

print "stdout isRedirected:", g.stdOutIsRedirected()
print "stderr isRedirected:", g.stdErrIsRedirected()

g.redirectStderr()
g.redirectStdout()

print "stdout isRedirected:", g.stdOutIsRedirected()
print "stderr isRedirected:", g.stdErrIsRedirected()

g.restoreStderr()

print "stdout isRedirected:", g.stdOutIsRedirected()
print "stderr isRedirected:", g.stdErrIsRedirected()

g.restoreStdout()

print "stdout isRedirected:", g.stdOutIsRedirected()
print "stderr isRedirected:", g.stdErrIsRedirected()
#@nonl
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@+node:ekr.20031218072017.3695:leoLog.__init__
def __init__ (self,frame,parentFrame):
    
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.3695:leoLog.__init__
#@+node:ekr.20031218072017.2232:class nullLog
class nullLog (leoLog):
    
    @others
#@nonl
#@+node:ekr.20041012083237:nullLog.__init__
def __init__ (self,frame=None,parentFrame=None):
        
    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)
#@nonl
#@-node:ekr.20041012083237:nullLog.__init__
#@+node:ekr.20041012083237.1:createControl
def createControl (self,parentFrame):
    
    return None
#@nonl
#@-node:ekr.20041012083237.1:createControl
#@+node:ekr.20041012083237.2:oops
def oops(self):

    g.trace("nullLog:", g.callerName(2))
    
#@-node:ekr.20041012083237.2:oops
#@+node:ekr.20041012083237.3:put and putnl
def put (self,s,color=None):
    if self.enabled:
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")
#@nonl
#@-node:ekr.20041012083237.3:put and putnl
#@+node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
def setFontFromConfig (self):
    pass
    
def setColorFromConfig (self):
    pass
#@nonl
#@-node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
#@-node:ekr.20031218072017.2232:class nullLog
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self,*args,**keys):
    pass
    
def lift (self,*args,**keys):
    pass
    
def update (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry(self,w,h,x,y):
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
    
    
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
@

The old code assumed that the error is always in the script itself.  Not true!  The error could happen in methods called by the script.

This code works with Python 2.3.4: it may be version dependent.
#@nonl
#@+node:ekr.20041007080346:Report from e
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2792394

I've narrowed down when the IndexError happens,
probably any similar error would be the same.

import leoGlobals as g
c = g.top() 
p = c.currentPosition()
cv = c.currentVnode()
cv.moveOutlineRight()  #error

gives this error
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------

and this  additional traceback from 
leoCommands.py", line 1171, in executeScript
    s = "line %d: %s" % (n,lines[n-1])
IndexError: list index out of range

when run this script inside a def wrapper,

import leoGlobals as g
def x():
....c = g.top() 
....p = c.currentPosition()
....cv = c.currentVnode()  #insert sets the current node
....cv.moveOutlineRight()  #error
x()

all you get is
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------
so it appears the frame in the code that determines the 
line number n is off at least one.
in neither case is the line number of the error correct, so no error line
shows.

maybe getLastTracebackLineNumber needs to check for ValueError?
there is still a piece missing, how to tell what frame your in.

in #@+node: getLastTracebackLineNumber leoGlobals.py
data = traceback.extract_tb(tb, 2) seems like a good idea
and seems to fix the IndexError error shown above.
but now with error inside a def you get the function name
instead of the line the error is on. not good enough.

change to:
data = traceback.extract_tb(tb)
item = data[-2] or data[-1] 

this seems to work w/ error code indented 0 from far left, 
or nested inside a def inside another def or another,
I'll leave it in and see if there are additional problems.
the line number still doesn't match with row,col display.
thats confusing if you don't account for the sentinals.
maybe the line number minus a simple count of sentinal lines?

#@-node:ekr.20041007080346:Report from e
#@+node:ekr.20041007080346.1:Report 2 from e
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2792620

not a trivial simple count after all.
if the error is inside a node then would need to 
start count from the previous +node sentinal.
I didn't attempt to fix that,

lets see if the line number is always right first.

item = data[-2] or data[-1]

isn't fixing all cases.

this works better:

item = data[-1]
if not item[-1] is None:
    item = data[-2]
#@-node:ekr.20041007080346.1:Report 2 from e
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except:
            << unredirect output >>
            g.es("exception executing script ")
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.trace(data)
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        import pdb ; pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@-node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
#@+node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041013061250.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2802138
By: rogererens

Using Leo4.2 on WinXP, control-clicking on a section reference:
instead of going to the section definition, I get the following log message:

exception handling , hypercclick,  event
AttributeError

and in the console:

unknown position attribute: redraw
Traceback (most recent call last):
  File "C:\Leo\src\leoTkinterTree.py", line 351, in OnHyperLinkControlClick
    self.redraw()
  File "C:\Leo\src\leoNodes.py", line 1534, in __getattr__
    raise AttributeError
AttributeError

Commenting out the line
self.redraw
in onHyperLinkControlClick
seems to work, but the comment above puts some doubts on the correctness of
this adaptation.

Also, the documentation w.r.t. hyperlinks seems outdated to me, since with the
'Recent' button one can quite easily navigate backward and forward like in web
browsers.
#@-node:ekr.20041013061250.1:Report
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            # New in recycled nodes code:
            # Call self.redraw to inhibit calls to setLabelState.
            c.frame.tree.redraw()
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
        
onHyperLinkControlClick = OnHyperLinkControlClick
#@nonl
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@-node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except:
            << unredirect output >>
            g.es("exception executing script ")
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,useSelectedText=True):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # Allow p not to be the present position.
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
            script = at.stringOutput
            # g.trace(script)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@-node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041017050700:This file wasn't being read correctly
@language c

/*@+leo-ver=4*/
/*@+node:@file cat.c*/

/*@@language C*/
#ifdef COMMENT
/*@@comment /* */*/
#endif /* COMMENT */
/*@@path C:\Vlib\Src*/
/*@@tabwidth 4*/
/*@@markup wiki*/


/*@+doc*/
/*
 * Copies STDIN to STDOUT.
 * The basis for all filters.
*/
/*@-doc*/
/*@@code*/
/*@<< Header >>*/
/*@+node:<< Header >>*/

#include <stdio.h>
#include <easy.h>

void filecopy(FILE *fp);
/*@-node:<< Header >>*/
/*@nl*/
/*@<< Main >>*/
/*@+node:<< Main >>*/

void main(int argc, char *argv[])
begin
FILE *fp,
    *fopen();

   if(argc == 1) then
      filecopy(stdin);
   orelse
      while(--argc > 0)
      begin
         if((fp = fopen(*++argv, "r")) == NULL) then
            fprintf( stderr,"cat: can't open %s\n", *argv);
            exit(1);
         orelse
            filecopy(fp);
            fclose(fp);
         endif
      endwhile
   endif
   exit(0);
end
/*@-node:<< Main >>*/
/*@nl*/
/*@<< File Copy >>*/
/*@+node:<< File Copy >>*/

void filecopy(FILE *fp)
begin
int c;
   while( (c = getc(fp)) != EOF)
      putc(c, stdout);
end
/*@-node:<< File Copy >>*/
/*@nl*/
/*@-node:@file cat.c*/
/*@-leo*/
#@-node:ekr.20041017050700:This file wasn't being read correctly
#@+node:ekr.20041017094552:Posting re POSSIBLE fix
@nocolor

I think I have found the problem.   The readDirective method is changing the comment delimiters as the result of seeing the sentinels corresponding to @language or @comment directives.

But in general this makes no sense!  Comment delimiters should be set once and for all in the @+leo sentinel: there is no compiler in the world that tolerates mixed comment delimiters.  BTW, the way to set javascript "inner" comments is to use @delims, not @comment.  N.B.  The @language and @comment delimiters _will_ have an effect, and that effect is in the _write_ logic, not the read logic.  The effect is to set the comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective, like this:

@color

if 0: # New in 4.2.1: never change comment delims here...
....if g.match_word(s,i,"@language"):
........<< handle @language >>
....elif g.match_word(s,i,"@comment"):
........<< handle @comment >>

@nocolor

Does anyone have any idea why it may have been useful?

I'm kinda freaked out by this.  The number of file reading and writing options in the various versions of Leo has definitely passed the point at which I can understand them all myself.  Fortunately (I think), the new atFile code has simplified matters.

I just hope that the transition to the new code isn't going to be too painful.  Leo now requires gnx's for all nodes, which is a step in the right direction.  Alas, Leo actually doesn't read thin derived files that were written with gnx's disabled.  My _guess_ is that this has always been a hole in the read logic and that hardly anyone fell into the hole because use_gnx was the default.  The new code plugs this code by making sure all nodes get written with gnx's.

In short, my advice is to comment out the code as shown above and see what happens. This is a _speculative_ fix, although all unit tests pass (so much for unit tests :-)  Please let me know if this "fix" causes problems.  If so, the problems should tell me what, if anything, I was thinking about when I wrote the code above ;-)
#@nonl
#@-node:ekr.20041017094552:Posting re POSSIBLE fix
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041018190736.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2805807
By: Ivan

In baseCommands.openWith(), the case for "openType == 'os.spawnv'" appears to
be broken. The two problems I see are that it actually invokes os.spawnl, and
that it does not allow the passing of a variable length list of parameters.

@color

# Replace the body of the os.spawnv case:

filename = g.os_path_basename(arg)
command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
apply(os.spawnl,(os.P_NOWAIT,arg,filename,path)))
 
# with:
    
filename = os.path.basename(arg[0])
vtuple = arg[1:]
vtuple.append(path)
command = "os.spawnv("+arg[0]+","+`vtuple`+")"
apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))

# This requires calls on openWith like
openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
#@nonl
#@-node:ekr.20041018190736.1:Report
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the "Open With..." menu.
    openWithMenu = Tk.Menu(parent,tearoff=0)
    self.setMenu("Open With...",openWithMenu)
    parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
    # Populate the "Open With..." menu.
    shortcut_table = []
    for triple in table:
        if len(triple) == 3: # 6/22/03
            shortcut_table.append(triple)
        else:
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
            
    # for i in shortcut_table: print i
    self.createMenuItemsFromTable("Open &With...",shortcut_table,openWith=True)
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; v = c.currentVnode()
    if not data or len(data) != 3: return # 6/22/03
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=v,v=v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=v,v=v,openType=openType,arg=arg,ext=ext)
    except:
        g.es("exception in openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(v,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to v.t >>
searchPath = c.openWithTempFilePath(v,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if v == theDict.get("v") and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both v and the temp file:

- If only v's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = v.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(v,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        command = "os.system(%s)" % (arg+shortPath)
        os.system(arg+path)
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {} # 12/11/02
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        if 1: # New code allows args to spawnv.
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:] 
            vtuple.append(path)
            command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
            apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple)) 
        else:
            filename = g.os_path_basename(arg)
            command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
            apply(os.spawnl,(os.P_NOWAIT,arg,(filename,path)))
    else:
        command="bad command:"+str(openType)
    # This seems a bit redundant.
    # g.es(command)
except:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self, v, ext):
    
    c = self
    path = c.openWithTempFilePath(v,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # 3/7/03: convert s to whatever encoding is in effect.
        s = v.bodyString()
        theDict = g.scanDirectives(c,p=v)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # 4/22/03: add body and encoding entries to dict for later comparisons.
        theDict = {"body":s, "c":c, "encoding":encoding, "f":theFile, "path":path, "time":time, "v":v}
        << remove previous entry from app.openWithFiles if it exists >> # 4/22/03
        g.app.openWithFiles.append(theDict)
        return path
    except:
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]: # 6/30/03
    v2 = d.get("v")
    if v.t == v2.t:
        print "removing previous entry in g.app.openWithFiles for",v
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:openWithTempFilePath
def openWithTempFilePath (self,v,ext):
    
    """Return the path to the temp file corresponding to v and ext."""

    name = "LeoTemp_" + str(id(v.t)) + '_' + g.sanitize_filename(v.headString()) + ext
    name = g.toUnicode(name,g.app.tkEncoding) # 10/20/03

    td = g.os_path_abspath(tempfile.gettempdir())
    path = g.os_path_join(td,name)
    
    # print "openWithTempFilePath",path
    return path
#@nonl
#@-node:ekr.20031218072017.2832:openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019080519:what I did
@killcolor

- Added g.app.failedPlugins list.
- Added moduleName arg to g.cantImport.
- Removed redundant print from cantImport.
- cantImport only writes one failure message per named plugin.
#@nonl
#@-node:ekr.20041019080519:what I did
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@-node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041019085841.1:What I did
@killcolor 

The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding  to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.
#@nonl
#@-node:ekr.20041019085841.1:What I did
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"" + theDir + "\" does not exist")
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and theDict.has_key("comment"):
    k = theDict["comment"]
    # 11/14/02: Similar to fix below.
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and theDict.has_key("language"):
    k = theDict["language"]
    # 11/14/02: Fix bug reported by J.M.Gilligan.
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory() # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    assert(self.outputFile is None)
    
    if self.toString:
        return False
    
    self.fileChangedFlag = False
    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            << delete the output file >>
        else:
            << report if the files differ only in line endings >>
            << replace the target file with the output file >>
            return True # bwm
    else:
        << rename the output file to be the target file >>
        return False
#@nonl
#@+node:ekr.20041005105605.213:<< delete the output file >>
try: # Just delete the temp file.
    os.remove(self.outputFileName)
except:
    g.es("exception deleting:" + self.outputFileName)
    g.es_exception()

g.es("unchanged: " + self.shortFileName)
#@nonl
#@-node:ekr.20041005105605.213:<< delete the output file >>
#@+node:ekr.20041005105605.214:<< replace the target file with the output file >>
try:
    # 10/6/02: retain the access mode of the previous file,
    # removing any setuid, setgid, and sticky bits.
    mode = (os.stat(self.targetFileName))[0] & 0777
except:
    mode = None

try: # Replace target file with temp file.
    os.remove(self.targetFileName)
    try:
        g.utils_rename(self.outputFileName,self.targetFileName)
        if mode != None: # 10/3/02: retain the access mode of the previous file.
            try:
                os.chmod(self.targetFileName,mode)
            except:
                g.es("exception in os.chmod(%s)" % (self.targetFileName))
        g.es("writing: " + self.shortFileName)
        self.fileChangedFlag = True
    except:
        # 6/28/03
        self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
        g.es_exception()
except:
    self.writeError("exception removing:" + self.targetFileName)
    g.es_exception()
    try: # Delete the temp file when the deleting the target file fails.
        os.remove(self.outputFileName)
    except:
        g.es("exception deleting:" + self.outputFileName)
        g.es_exception()
#@nonl
#@-node:ekr.20041005105605.214:<< replace the target file with the output file >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@+node:ekr.20041005105605.215:<< rename the output file to be the target file >>
try:
    g.utils_rename(self.outputFileName,self.targetFileName)
    g.es("creating: " + self.targetFileName)
    self.fileChangedFlag = True
except:
    self.writeError("exception renaming:" + self.outputFileName +
        " to " + self.targetFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.215:<< rename the output file to be the target file >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041020104517.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2807391
By: spboulet

Running the File->Export->Remove Sentinels command on a file derived from an
@file node, I get "Can not open D" in the log window (the file is on my D partition).
I do have permission to write the file; tangling works fine.

-------

The fix was to add multiple=True in the call to g.app.gui.runOpenFileDialog in removeSentinels.

Apparently there is a Python bug in askopenfilename, but this fix avoids that.
#@nonl
#@-node:ekr.20041020104517.1:Report
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths):
    
    c = self.c

    self.setEncoding()

    for fileName in paths:

        path, self.fileName = g.os_path_split(fileName)
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        << Write s into newFileName >>
#@nonl
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@nonl
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@nonl
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@-node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041020101401.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2813280
By: e

@file-nosent has sentinals.

The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.

Like this:

at.initWriteIvars(root,at.targetFileName,
    nosentinels=nosentinels,thinFile=thinFile,
    scriptWrite=scriptWrite,toString=toString)
#@-node:ekr.20041020101401.1:Report
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.4:class atFile
class atFile:
    
    << define class constants >>
    << define sentinelDict >>
    
    """The class implementing the atFile subcommander."""

    @others
#@nonl
#@+node:ekr.20041005105605.5:<< define class constants >>
# These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @<space> or @<newline>
codeDirective	  =  5 # @code
cDirective		    =  6 # @c<space> or @c<newline>
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
endAt			 = 21 # @-at
endBody			 = 22 # @-body
# not used   = 23
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @< < ... > >
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)
#@nonl
#@-node:ekr.20041005105605.5:<< define class constants >>
#@+node:ekr.20041005105605.6:<< define sentinelDict >>
sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}
#@nonl
#@-node:ekr.20041005105605.6:<< define sentinelDict >>
#@+node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):
    
    at = self
    
    at.c = c
    at.fileCommands = c.fileCommands
    at.testing = True # True: enable additional checks.

    << define the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
at.dispatch_dict = {
    # Plain line.
    at.noSentinel: at.readNormalLine,
    # Starting sentinels...
    at.startAll:    at.readStartAll,
    at.startAt:     at.readStartAt,
    at.startDoc:    at.readStartDoc,
    at.startLeo:    at.readStartLeo,
    at.startMiddle: at.readStartMiddle,
    at.startNode:   at.readStartNode,
    at.startOthers: at.readStartOthers,
    # Ending sentinels...
    at.endAll:    at.readEndAll,
    at.endAt:     at.readEndAt,
    at.endDoc:    at.readEndDoc,
    at.endLeo:    at.readEndLeo,
    at.endMiddle: at.readEndMiddle,
    at.endNode:   at.readEndNode,
    at.endOthers: at.readEndOthers,
    # Non-paired sentinels.
    at.startAfterRef:  at.readAfterRef,
    at.startClone:     at.readClone,
    at.startComment:   at.readComment,
    at.startDelims:    at.readDelims,
    at.startDirective: at.readDirective,
    at.startNl:        at.readNl,
    at.startNonl:      at.readNonl,
    at.startRef:       at.readRef,
    at.startVerbatim:  at.readVerbatim,
    # Ignored 3.x sentinels
    at.endBody:               at.ignoreOldSentinel,
    at.startBody:             at.ignoreOldSentinel,
    at.startVerbatimAfterRef: at.ignoreOldSentinel }
#@nonl
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20041005105605.10:initCommonIvars
def initCommonIvars (self):
    
    """Init ivars common to both reading and writing.
    
    The defaults set here may be changed later."""
    
    at = self ; c = at.c
    
    if self.testing:
        # Save "permanent" ivars
        fileCommands = at.fileCommands
        dispatch_dict = at.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        at.testing = True
        at.c = c
        at.fileCommands = fileCommands
        at.dispatch_dict = dispatch_dict

    << set defaults for arguments and options >>
    << init common ivars >>
#@nonl
#@+node:ekr.20041005105605.11:<< set defaults for arguments and options >>
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline()

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
#@nonl
#@-node:ekr.20041005105605.11:<< set defaults for arguments and options >>
#@+node:ekr.20041005105605.12:<< init common ivars >>
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
#@nonl
#@-node:ekr.20041005105605.12:<< init common ivars >>
#@-node:ekr.20041005105605.10:initCommonIvars
#@+node:ekr.20041005105605.13:initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    thinFile=False):
        
    importing = importFileName is not None

    self.initCommonIvars()
    
    << init ivars for reading >>
    
    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = thinFile
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.cloneSibCount = 0 # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.out = None
self.outStack = []
self.tnodeList = []
self.tnodeListIndex = 0
self.t = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@-node:ekr.20041005105605.13:initReadIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.18:Reading (top level)
@

All reading happens in the readOpenFile logic, so plugins should need to
override only this method.
#@nonl
#@+node:ekr.20041005105605.19:openFileForReading
def openFileForReading(self,fileName,fromString=False):
    
    at = self
    
    if fromString:
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_join(at.default_directory,fileName)
        fn = g.os_path_normpath(fn)
        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            at.inputFile = self.openForRead(fn,'rb') #bwm
            << warn on read-only file >>
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
#@nonl
#@+node:ekr.20041005105605.20:<< warn on read-only file >>
# os.access() may not exist on all platforms.
try:
    read_only = not os.access(fn,os.W_OK)
except AttributeError:
    read_only = False 
    
if read_only:
    g.es("read only: " + fn,color="red")
#@nonl
#@-node:ekr.20041005105605.20:<< warn on read-only file >>
#@-node:ekr.20041005105605.19:openFileForReading
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.26:readAll
def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20041005105605.26:readAll
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@nonl
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:bwmulder.20041231170726:openForRead
def openForRead(self, *args, **kw):
    """
    Hook for the mod_shadow plugin.
    """
    return open(*args, **kw)
#@nonl
#@-node:bwmulder.20041231170726:openForRead
#@+node:bwmulder.20050101094804:openForWrite
def openForWrite(self, *args, **kw):
    """
    Hook for the mod_shadow plugin
    """
    return open(*args, **kw)

#@-node:bwmulder.20050101094804:openForWrite
#@-node:ekr.20041005105605.18:Reading (top level)
#@+node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.30:createNthChild3
@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild3(self,n,parent,headline):
    
    """Create the nth child of the parent."""

    at = self
    assert(n > 0)
    
    if at.importing:
        return at.createImportedNode(at.root,at.c,headline)

    # Create any needed dummy children.
    dummies = n - parent.numberOfChildren() - 1
    if dummies > 0:
        if 0: # CVS produces to many errors for this to be useful.
            g.es("dummy created")
        at.errors += 1
    while dummies > 0:
        dummies -= 1
        dummy = parent.insertAsLastChild(leoNodes.tnode())
        # The user should never see this headline.
        dummy.initHeadString("Dummy")

    if n <= parent.numberOfChildren():
        << check the headlines >>
    else:
        # This is using a dummy; we should already have bumped errors.
        result = parent.insertAsLastChild(leoNodes.tnode())
    result.initHeadString(headline)
    
    result.setVisited() # Suppress all other errors for this node.
    result.t.setVisited() # Suppress warnings about unvisited nodes.
    return result
#@nonl
#@+node:ekr.20041005105605.31:<< check the headlines >>
# 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
    start = at.startSentinelComment
    end = at.endSentinelComment
    if end and len(end) > 0:
        # 1/25/03: The kludgy fix.
        # Compare the headlines without the delims.
        h1 =   headline.replace(start,"").replace(end,"")
        h2 = resulthead.replace(start,"").replace(end,"")
        if h1.strip() == h2.strip():
            # 1/25/03: Another kludge: use the headline from the outline, not the derived file.
            headline = resulthead
        else:
            at.errors += 1
    else:
        at.errors += 1
#@-node:ekr.20041005105605.31:<< check the headlines >>
#@-node:ekr.20041005105605.30:createNthChild3
#@+node:ekr.20041005105605.32:handleLinesFollowingSentinel
def handleLinesFollowingSentinel (self,lines,sentinel,comments = True):
    
    """convert lines following a sentinel to a single line"""
    
    at = self
    m = " following" + sentinel + " sentinel"
    start = at.startSentinelComment
    end   = at.endSentinelComment
    
    if len(lines) == 1: # The expected case.
        s = lines[0]
    elif len(lines) == 5:
        at.readError("potential cvs conflict" + m)
        s = lines[1]
        g.es("using " + s)
    else:
        at.readError("unexpected lines" + m)
        g.es(len(lines), " lines" + m)
        s = "bad " + sentinel
        if comments: s = start + ' ' + s

    if comments:
        << remove the comment delims from s >>
        
    # Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
    if start[-1:] == '@':
        s = s.replace('@@','@')

    return s
#@nonl
#@+node:ekr.20041005105605.33:<< remove the comment delims from s >>
# Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if g.match(s,0,comment):
    s = s[len(comment):]
else:
    at.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
    s = string.strip(s[:-1])
else:
    k = s.rfind(end)
    s = string.strip(s[:k]) # works even if k == -1
#@nonl
#@-node:ekr.20041005105605.33:<< remove the comment delims from s >>
#@-node:ekr.20041005105605.32:handleLinesFollowingSentinel
#@+node:ekr.20041005105605.34:readLinesToNextSentinel
# We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,theFile):
    
    """	read lines following multiline sentinels"""
    
    at = self
    lines = []
    start = at.startSentinelComment + '@ '
    nextLine = at.readLine(theFile)
    while nextLine and len(nextLine) > 0:
        if len(lines) == 0:
            lines.append(nextLine)
            nextLine = at.readLine(theFile)
        else:
            # 5/1/03: looser test then calling sentinelKind3.
            s = nextLine ; i = g.skip_ws(s,0)
            if g.match(s,i,start):
                lines.append(nextLine)
                nextLine = at.readLine(theFile)
            else: break

    return nextLine,lines
#@nonl
#@-node:ekr.20041005105605.34:readLinesToNextSentinel
#@+node:ekr.20041005105605.35:scanDoc3
# Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc3(self,theFile,s,i,out,kind):
    
    at = self
    endKind = g.choose(kind ==at.startDoc,at.endDoc,at.endAt)
    single = len(at.endSentinelComment) == 0
    << Skip the opening sentinel >>
    << Skip an opening block delim >>
    nextLine = None ; kind = at.noSentinel
    while len(s) > 0:
        << set kind, nextLine >>
        if kind == endKind: break
        << Skip the leading stuff >>
        << Append s to out >>
        if nextLine:
            s = nextLine ; nextLine = None
        else: s = at.readLine(theFile)
    if kind != endKind:
        at.readError("Missing " + at.sentinelName(endKind) + " sentinel")
    << Remove a closing block delim from out >>
#@nonl
#@+node:ekr.20041005105605.36:<< Skip the opening sentinel >>
assert(g.match(s,i,g.choose(kind == at.startDoc, "+doc", "+at")))

out.append(g.choose(kind == at.startDoc, "@doc", "@"))
s = at.readLine(theFile)
#@-node:ekr.20041005105605.36:<< Skip the opening sentinel >>
#@+node:ekr.20041005105605.37:<< Skip an opening block delim >>
if not single:
    j = g.skip_ws(s,0)
    if g.match(s,j,at.startSentinelComment):
        s = at.readLine(theFile)
#@nonl
#@-node:ekr.20041005105605.37:<< Skip an opening block delim >>
#@+node:ekr.20041005105605.38:<< set kind, nextLine >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    j = g.skip_ws(s,0)
    blankLine = s[j] == '\n'
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
    if blankLine and nextKind == endKind:
        kind = endKind # stop the scan now
#@-node:ekr.20041005105605.38:<< set kind, nextLine >>
#@+node:ekr.20041005105605.39:<< Skip the leading stuff >>
# Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0, at.indent)
#@-node:ekr.20041005105605.39:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.40:<< Append s to out >>
# Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    out.append(line + '\n')
else:
    # trailing whitespace: the newline is not real.
    out.append(line)
#@-node:ekr.20041005105605.40:<< Append s to out >>
#@+node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
# This code will typically only be executed for HTML files.

if not single:

    delim = at.endSentinelComment
    n = len(delim)
    
    # Remove delim and possible a leading newline.
    s = string.join(out,"")
    s = s.rstrip()
    if s[-n:] == delim:
        s = s[:-n]
    if s[-1] == '\n':
        s = s[:-1]
        
    # Rewrite out in place.
    del out[:]
    out.append(s)
#@-node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
#@-node:ekr.20041005105605.35:scanDoc3
#@+node:ekr.20041005105605.42:scanText3
def scanText3 (self,theFile,p,out,endSentinelKind,nextLine=None):
    
    """Scan a 3.x derived file recursively."""

    at = self
    lastLines = [] # The lines after @-leo
    lineIndent = 0 ; linep = 0 # Changed only for sentinels.
    while 1:
        << put the next line into s >>
        << set kind, nextKind >>
        if kind != at.noSentinel:
            << set lineIndent, linep and leading_ws >>
            i = at.skipSentinelStart3(s,0)
        << handle the line in s >>
    << handle unexpected end of text >>
    assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
    return lastLines # We get here only if there are problems.
#@nonl
#@+node:ekr.20041005105605.43:<< put the next line into s >>
if nextLine:
    s = nextLine ; nextLine = None
else:
    s = at.readLine(theFile)
    if len(s) == 0: break
#@nonl
#@-node:ekr.20041005105605.43:<< put the next line into s >>
#@+node:ekr.20041005105605.44:<< set kind, nextKind >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
else:
    nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText3 returns.
#@nonl
#@-node:ekr.20041005105605.44:<< set kind, nextKind >>
#@+node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if at.raw: # 10/15/02
    linep =0
else:
    linep = at.skipIndent(s,0,at.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i < len(s):
    if s[i] == '\t': lineIndent += (abs(at.tab_width) - (lineIndent % abs(at.tab_width)))
    elif s[i] == ' ': lineIndent += 1
    else: break
    i += 1
# g.trace("lineIndent,s:",lineIndent,s)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]
#@nonl
#@-node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
#@+node:ekr.20041005105605.46:<< handle the line in s >>
if kind == at.noSentinel:
    << append non-sentinel line >>
<< handle common sentinels >>
<< handle rare sentinels >>
else:
    << warn about unknown sentinel >>
#@nonl
#@+node:ekr.20041005105605.47:<< append non-sentinel line >>
# We don't output the trailing newline if the next line is a sentinel.
if at.raw: # 10/15/02
    i = 0
else:
    i = at.skipIndent(s,0,at.indent)

assert(nextLine != None)

if nextKind == at.noSentinel:
    line = s[i:]
    out.append(line)
else:
    line = s[i:-1] # don't output the newline
    out.append(line)
#@-node:ekr.20041005105605.47:<< append non-sentinel line >>
#@+node:ekr.20041005105605.48:<< handle common sentinels >>
elif kind in (at.endAt, at.endBody,at.endDoc,at.endLeo,at.endNode,at.endOthers):
        << handle an ending sentinel >>
elif kind == at.startBody:
    << scan @+body >>
elif kind == at.startNode:
    << scan @+node >>
elif kind == at.startRef:
    << scan old ref >>
elif kind == at.startAt:
    << scan @+at >>
elif kind == at.startDoc:
    << scan @+doc >>
elif kind == at.startOthers:
    << scan @+others >>
#@nonl
#@+node:ekr.20041005105605.49:<< handle an ending sentinel >>
# g.trace("end sentinel:", at.sentinelName(kind))

if kind == endSentinelKind:
    if kind == at.endLeo:
        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(theFile)
            if len(s) == 0: break
            lastLines.append(s) # Capture all trailing lines, even if empty.
    elif kind == at.endBody:
        at.raw = False
    # nextLine != None only if we have a non-sentinel line.
    # Therefore, nextLine == None whenever scanText3 returns.
    assert(nextLine==None)
    return lastLines # End the call to scanText3.
else:
    # Tell of the structure error.
    name = at.sentinelName(kind)
    expect = at.sentinelName(endSentinelKind)
    at.readError("Ignoring " + name + " sentinel.  Expecting " + expect)
#@nonl
#@-node:ekr.20041005105605.49:<< handle an ending sentinel >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@nonl
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.51:<< scan @+node >>
assert(g.match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
<< Set childIndex >>
<< Set cloneIndex >>
headline = ""
<< Set headline and ref >>

# print childIndex,headline

if childIndex == 0: # The root node.
    if not at.importing:
        << Check the filename in the sentinel >>
    # Put the text of the root node in the current node.
    at.scanText3(theFile,p,out,at.endNode)
    p.v.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("clone index:",cloneIndex,p)
else:
    # NB: this call to createNthChild3 is the bottleneck!
    child = at.createNthChild3(childIndex,p,headline)
    child.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("cloneIndex,child:"cloneIndex,child)
    at.scanText3(theFile,child,out,at.endNode)

<< look for sentinels that may follow a reference >>
#@nonl
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i] in string.digits:
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@nonl
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20041005105605.53:<< Set cloneIndex >>
while i < len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i < len(s) and s[i] in string.digits:
            i += 1
        if j < i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
#@nonl
#@-node:ekr.20041005105605.53:<< Set cloneIndex >>
#@+node:ekr.20041005105605.54:<< Set headline and ref >>
# Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    # 10/24/02: search from the right, not the left.
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1
    
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')

# Set reference if it exists.
i = g.skip_ws(s,i)

if 0: # no longer used
    if g.match(s,i,"<<"):
        k = s.find(">>",i)
        if k != -1: ref = s[i:k+2]
#@nonl
#@-node:ekr.20041005105605.54:<< Set headline and ref >>
#@+node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
h = headline.strip()

if h[:5] == "@file":
    i,junk,junk = g.scanAtFileOptions(h)
    fileName = string.strip(h[i:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
    fileName = string.strip(h[8:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
else:
    at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
#@+node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
s = at.readLine(theFile)
kind = at.sentinelKind3(s)

if len(s) > 1 and kind == at.startVerbatimAfterRef:
    s = at.readLine(theFile)
    # g.trace("verbatim:",repr(s))
    out.append(s)
elif len(s) > 1 and at.sentinelKind3(s) == at.noSentinel:
    out.append(s)
else:
    nextLine = s # Handle the sentinel or blank line later.

#@-node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
#@-node:ekr.20041005105605.51:<< scan @+node >>
#@+node:ekr.20041005105605.57:<< scan old ref >> (3.0)
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(g.match(s,i,"<<"))

if len(at.endSentinelComment) == 0:
    line = s[i:-1] # No trailing newline
else:
    k = s.find(at.endSentinelComment,i)
    line = s[i:k] # No trailing newline, whatever k is.
        
# 10/30/02: undo cweb hack here
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    line = line.replace('@@','@')

out.append(line)
#@nonl
#@-node:ekr.20041005105605.57:<< scan old ref >> (3.0)
#@+node:ekr.20041005105605.58:<< scan @+at >>
assert(g.match(s,i,"+at"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.58:<< scan @+at >>
#@+node:ekr.20041005105605.59:<< scan @+doc >>
assert(g.match(s,i,"+doc"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.59:<< scan @+doc >>
#@+node:ekr.20041005105605.60:<< scan @+others >>
assert(g.match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

at.scanText3(theFile,p,out,at.endOthers)
#@nonl
#@-node:ekr.20041005105605.60:<< scan @+others >>
#@-node:ekr.20041005105605.48:<< handle common sentinels >>
#@+node:ekr.20041005105605.61:<< handle rare sentinels >>
elif kind == at.startComment:
    << scan @comment >>
elif kind == at.startDelims:
    << scan @delims >>
elif kind == at.startDirective:
    << scan @@ >>
elif kind == at.startLeo:
    << scan @+leo >>
elif kind == at.startVerbatim:
    << scan @verbatim >>
#@nonl
#@+node:ekr.20041005105605.62:<< scan @comment >>
assert(g.match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
#@-node:ekr.20041005105605.62:<< scan @comment >>
#@+node:ekr.20041005105605.63:<< scan @delims >>
assert(g.match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = g.skip_ws(s,i-1+7)
    
# Get the first delim.
j = i
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1

if j < i:
    at.startSentinelComment = s[j:i]
    # print "delim1:", at.startSentinelComment

    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    end = g.choose(j<i,s[j:i],"")
    i2 = g.skip_ws(s,i)
    if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
        at.endSentinelComment = "" # Not really two params.
        line = s[i0:j]
        line = line.rstrip()
        out.append(line+'\n')
    else:
        at.endSentinelComment = end
        # print "delim2:",end
        line = s[i0:i]
        line = line.rstrip()
        out.append(line+'\n')
else:
    at.readError("Bad @delims")
    # Append the bad @delims line to the body text.
    out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.63:<< scan @delims >>
#@+node:ekr.20041005105605.64:<< scan @@ >>
# The first '@' has already been eaten.
assert(g.match(s,i,"@"))

if g.match_word(s,i,"@raw"):
    at.raw = True
elif g.match_word(s,i,"@end_raw"):
    at.raw = False

e = at.endSentinelComment
s2 = s[i:]
if len(e) > 0:
    k = s.rfind(e,i)
    if k != -1:
        s2 = s[i:k] + '\n'
    
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    s2 = s2.replace('@@','@')
out.append(s2)
# g.trace(s2)
#@nonl
#@-node:ekr.20041005105605.64:<< scan @@ >>
#@+node:ekr.20041005105605.65:<< scan @+leo >>
assert(g.match(s,i,"+leo"))
at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.65:<< scan @+leo >>
#@+node:ekr.20041005105605.66:<< scan @verbatim >>
assert(g.match(s,i,"verbatim"))

# Skip the sentinel.
s = at.readLine(theFile) 

# Append the next line to the text.
i = at.skipIndent(s,0,at.indent)
out.append(s[i:])
#@-node:ekr.20041005105605.66:<< scan @verbatim >>
#@-node:ekr.20041005105605.61:<< handle rare sentinels >>
#@+node:ekr.20041005105605.67:<< warn about unknown sentinel >>
j = i
i = g.skip_line(s,i)
line = s[j:i]
at.readError("Unknown sentinel: " + line)
#@nonl
#@-node:ekr.20041005105605.67:<< warn about unknown sentinel >>
#@-node:ekr.20041005105605.46:<< handle the line in s >>
#@+node:ekr.20041005105605.68:<< handle unexpected end of text >>
# Issue the error.
name = at.sentinelName(endSentinelKind)
at.readError("Unexpected end of file. Expecting " + name + "sentinel" )
#@-node:ekr.20041005105605.68:<< handle unexpected end of text >>
#@-node:ekr.20041005105605.42:scanText3
#@+node:ekr.20041005105605.69:sentinelKind3
def sentinelKind3(self,s):

    """This method tells what kind of sentinel appears in line s.
    
    Typically s will be an empty line before the actual sentinel,
    but it is also valid for s to be an actual sentinel line.
    
    Returns (kind, s, emptyFlag), where emptyFlag is True if
    kind == at.noSentinel and s was an empty line on entry."""
    
    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # 10/30/02: locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        # g.trace("found:",key)
        return at.sentinelDict[key]
    else:
        # g.trace("not found:",key)
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.69:sentinelKind3
#@+node:ekr.20041005105605.70:skipSentinelStart3
def skipSentinelStart3(self,s,i):
    
    """Skip the start of a sentinel."""
    
    at = self
    start = at.startSentinelComment
    assert(start and len(start)>0)

    if g.is_nl(s,i): i = g.skip_nl(s,i)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.70:skipSentinelStart3
#@-node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #g.trace("last",last,last.t.fileIndex)
    #g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace("creating node",child,gnx)

    return child
#@nonl
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@nonl
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        if verbose:
            g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)
#@nonl
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)
#@nonl
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(at.endAll)
#@nonl
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@nonl
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20041005105605.114:sentinelKind4
def sentinelKind4(self,s):
    
    """Return the kind of sentinel at s."""
    
    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')
        
    # 4.0: Look ahead for @[ws]@others and @[ws]<<
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.114:sentinelKind4
#@+node:ekr.20041005105605.115:skipSentinelStart4
def skipSentinelStart4(self,s,i):
    
    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)>0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.115:skipSentinelStart4
#@-node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.116:Reading utils...
#@+node:ekr.20041005105605.117:completeFirstDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@-node:ekr.20041005105605.117:completeFirstDirectives
#@+node:ekr.20041005105605.118:completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@nonl
#@-node:ekr.20041005105605.118:completeLastDirectives
#@+node:ekr.20041005105605.119:createImportedNode
def createImportedNode (self,root,c,headline):
    
    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
        
    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p
#@nonl
#@-node:ekr.20041005105605.119:createImportedNode
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@nonl
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 1 # 6/8/04
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        g.es_error("----- error reading @file " + self.targetFileName)
        self.error(message) # 9/10/02: we must increment self.errors!
    else:
        print message

    if 0: # CVS conflicts create too many messages.
        self.error(message)
    
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""
    
    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in " + fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20041005105605.131:skipIndent
# Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i < n and ws < width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i
#@nonl
#@-node:ekr.20041005105605.131:skipIndent
#@-node:ekr.20041005105605.116:Reading utils...
#@-node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.134:Don't override in plugins
# Plugins probably should not need to override these methods.
#@nonl
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@nonl
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.136:norefWrite
def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        << write root's tree >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
rawWrite = norefWrite
#@+node:ekr.20041005105605.137:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
    << Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20041005105605.138:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20041005105605.138:<< put all @first lines in root >>
#@+node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)> 0:
            at.putSentinel("@comment " + line)
#@-node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
#@+node:ekr.20041005105605.140:<< Write p's node >>
at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) > 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20041005105605.140:<< Write p's node >>
#@+node:ekr.20041005105605.141:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.141:<< put all @last lines in root >>
#@-node:ekr.20041005105605.137:<< write root's tree >>
#@-node:ekr.20041005105605.136:norefWrite
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None
    
    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName,toString)

    if at.outputFile:
        root.clearOrphan()
    else:
        root.setOrphan()
        root.setDirty()
    
    return at.outputFile is not None
#@nonl
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName,toString):
    
    at = self

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            at.writeError("path does not exist: " + path)
            return
    except:
        at.exception("exception creating path:" + fn)
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@nonl
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.147:writeAll
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@nonl
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@nonl
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@nonl
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll
#@+node:ekr.20041005105605.151:writeMissing
def writeMissing(self,p,toString=False):

    at = self
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            missing = False ; valid = True
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = g.os_path_join(self.default_directory,at.targetFileName)
                at.targetFileName = g.os_path_normpath(at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    at.openFileForWriting(p,at.targetFileName,toString)
                    if at.outputFile:
                        << write the @file node >>
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles > 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.
#@nonl
#@+node:ekr.20041005105605.152:<< write the @file node >>
if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True
#@nonl
#@-node:ekr.20041005105605.152:<< write the @file node >>
#@-node:ekr.20041005105605.151:writeMissing
#@-node:ekr.20041005105605.134:Don't override in plugins
#@+node:ekr.20041005105605.153:Override in plugins...
@

All writing eventually goes through the asisWrite or writeOpenFile methods, so
plugins should need only to override these two methods.

In particular, plugins should not need to override the write, writeAll or
writeMissing methods.
#@nonl
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
silentWrite = asisWrite # Compatibility with old scripts.
#@nonl
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@nonl
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.bodyString()

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@nonl
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.

def writeOpenFile(self,root,nosentinels=False,toString=False):

    """Do all writes except asis writes."""
    
    at = self ; c = at.c

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    << put all @first lines in root >>

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    << put all @last lines in root >>
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@+node:ekr.20041005105605.158:<< put all @first lines in root >> (4.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.os(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20041005105605.158:<< put all @first lines in root >> (4.x)
#@+node:ekr.20041005105605.159:<< put all @last lines in root >> (4.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        at.os(line[i:])
#@nonl
#@-node:ekr.20041005105605.159:<< put all @last lines in root >> (4.x)
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20041005105605.153:Override in plugins...
#@-node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used.

def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.166:putAtAllLine
def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.166:putAtAllLine
#@+node:ekr.20041005105605.167:putatAllBody
def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
#@-node:ekr.20041005105605.167:putatAllBody
#@+node:ekr.20041005105605.169:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)
#@nonl
#@-node:ekr.20041005105605.169:putAtAllChild
#@-node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.171:inAtOthers
def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@nonl
#@-node:ekr.20041005105605.171:inAtOthers
#@+node:ekr.20041005105605.172:putAtOthersChild
def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20041005105605.172:putAtOthersChild
#@+node:ekr.20041005105605.173:putAtOthersLine
def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.173:putAtOthersLine
#@-node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.174:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20041005105605.174:putCodeLine
#@+node:ekr.20041005105605.175:putRefLine & allies
#@+node:ekr.20041005105605.176:putRefLine
def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
#@-node:ekr.20041005105605.176:putRefLine
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20041005105605.177:putRefAt
#@+node:ekr.20041005105605.178:putAfterLastRef
def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j < len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.178:putAfterLastRef
#@+node:ekr.20041005105605.179:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start < end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.179:putAfterMiddleef
#@-node:ekr.20041005105605.175:putRefLine & allies
#@-node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.180:writing doc lines...
#@+node:ekr.20041005105605.181:putBlankDocLine
def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
#@nonl
#@-node:ekr.20041005105605.181:putBlankDocLine
#@+node:ekr.20041005105605.182:putStartDocLine
def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
#@nonl
#@-node:ekr.20041005105605.182:putStartDocLine
#@+node:ekr.20041005105605.183:putDocLine
def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        << append words to pending line, splitting the line if needed >>
#@+node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i < len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i < len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) >= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)
#@nonl
#@-node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
#@-node:ekr.20041005105605.183:putDocLine
#@+node:ekr.20041005105605.185:putEndDocLine
def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
#@nonl
#@-node:ekr.20041005105605.185:putEndDocLine
#@+node:ekr.20041005105605.186:putPending
def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.186:putPending
#@-node:ekr.20041005105605.180:writing doc lines...
#@-node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.188:nodeSentinelText 4.x
def nodeSentinelText(self,p):
    
    """Return the text of a @+node or @-node sentinel for p."""
    
    at = self ; h = p.headString()
    << remove comment delims from h if necessary >>
    
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h
#@nonl
#@+node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
#@nonl
#@-node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
#@-node:ekr.20041005105605.188:nodeSentinelText 4.x
#@+node:ekr.20041005105605.190:putLeadInSentinel 4.x
def putLeadInSentinel (self,s,i,j,delta):
    
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    
    Set at.leadingWs as needed for @+others and @+<< sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.
#@nonl
#@-node:ekr.20041005105605.190:putLeadInSentinel 4.x
#@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    at = self
    
    s = self.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
#@nonl
#@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
#@+node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):
    
    """Write @+leo sentinel."""

    at = self
    
    if not at.sentinels:
        return # Handle @nosentinelsfile.
        
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    
    at.putSentinel(s)
#@nonl
#@-node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)
    
    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        at.root.v.t.tnodeList.append(p.v.t)
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
# This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."
    
    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    << apply the cweb hack to s >>
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
#@nonl
#@+node:ekr.20041005105605.195:<< apply the cweb hack to s >>
@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
#@nonl
#@-node:ekr.20041005105605.195:<< apply the cweb hack to s >>
#@-node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
#@-node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.196:Writing 4.x utils...
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.198:directiveKind4
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 >= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            at.noDirective,at.atDirective)

    # @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1>= n or s[i+1] not in string.ascii_letters):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@nonl
#@-node:ekr.20041005105605.198:directiveKind4
#@+node:ekr.20041005105605.199:hasSectionName
def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)

    return -1 < n1 < n2, n1, n2
#@nonl
#@-node:ekr.20041005105605.199:hasSectionName
#@+node:ekr.20041005105605.200:isSectionName
# returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"<<"):
        return False, -1
    i = g.find_on_line(s,i,">>")
    if i:
        return True, i + 2
    else:
        return False, -1
#@nonl
#@-node:ekr.20041005105605.200:isSectionName
#@+node:ekr.20041005105605.201:os and allies
# Note:  self.outputFile may be either a fileLikeObject or a real file.

#@+node:ekr.20041005105605.202:oblank, oblanks & otabs
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))
#@nonl
#@-node:ekr.20041005105605.202:oblank, oblanks & otabs
#@+node:ekr.20041005105605.203:onl & onl_sent
def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
#@nonl
#@-node:ekr.20041005105605.203:onl & onl_sent
#@+node:ekr.20041005105605.204:os
def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    at = self
    
    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except:
            at.exception("exception writing:" + s)
#@nonl
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20041005105605.201:os and allies
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    self.os(s.replace('\n',self.output_newline))
#@nonl
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@nonl
#@-node:ekr.20041005105605.210:putIndent
#@+node:ekr.20041005105605.211:putInitialComment
def putInitialComment (self):
    
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)> 0:
                self.putSentinel("@comment " + line)
#@nonl
#@-node:ekr.20041005105605.211:putInitialComment
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    assert(self.outputFile is None)
    
    if self.toString:
        return False
    
    self.fileChangedFlag = False
    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            << delete the output file >>
        else:
            << report if the files differ only in line endings >>
            << replace the target file with the output file >>
            return True # bwm
    else:
        << rename the output file to be the target file >>
        return False
#@nonl
#@+node:ekr.20041005105605.213:<< delete the output file >>
try: # Just delete the temp file.
    os.remove(self.outputFileName)
except:
    g.es("exception deleting:" + self.outputFileName)
    g.es_exception()

g.es("unchanged: " + self.shortFileName)
#@nonl
#@-node:ekr.20041005105605.213:<< delete the output file >>
#@+node:ekr.20041005105605.214:<< replace the target file with the output file >>
try:
    # 10/6/02: retain the access mode of the previous file,
    # removing any setuid, setgid, and sticky bits.
    mode = (os.stat(self.targetFileName))[0] & 0777
except:
    mode = None

try: # Replace target file with temp file.
    os.remove(self.targetFileName)
    try:
        g.utils_rename(self.outputFileName,self.targetFileName)
        if mode != None: # 10/3/02: retain the access mode of the previous file.
            try:
                os.chmod(self.targetFileName,mode)
            except:
                g.es("exception in os.chmod(%s)" % (self.targetFileName))
        g.es("writing: " + self.shortFileName)
        self.fileChangedFlag = True
    except:
        # 6/28/03
        self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
        g.es_exception()
except:
    self.writeError("exception removing:" + self.targetFileName)
    g.es_exception()
    try: # Delete the temp file when the deleting the target file fails.
        os.remove(self.outputFileName)
    except:
        g.es("exception deleting:" + self.outputFileName)
        g.es_exception()
#@nonl
#@-node:ekr.20041005105605.214:<< replace the target file with the output file >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@+node:ekr.20041005105605.215:<< rename the output file to be the target file >>
try:
    g.utils_rename(self.outputFileName,self.targetFileName)
    g.es("creating: " + self.targetFileName)
    self.fileChangedFlag = True
except:
    self.writeError("exception renaming:" + self.outputFileName +
        " to " + self.targetFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.215:<< rename the output file to be the target file >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):
    
    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.isCloned() and p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())
                
    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()
#@nonl
#@-node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.218:writeException
def writeException (self,root=None):
    
    g.es("exception writing:" + self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None
    
    if self.outputFileName != None:
        try: # Just delete the temp file.
            os.remove(self.outputFileName)
        except:
            g.es("exception deleting:" + self.outputFileName,color="red")
            g.es_exception()

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()
#@nonl
#@-node:ekr.20041005105605.218:writeException
#@-node:ekr.20041005105605.196:Writing 4.x utils...
#@-node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.219:Uilites...
#@+node:ekr.20041005105605.220:error
def error(self,message):

    g.es_error(message)
    # print
    print message
    # print
    self.errors += 1
#@nonl
#@-node:ekr.20041005105605.220:error
#@+node:ekr.20041005105605.221:exception
def exception (self,message):
    
    self.error(message)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"" + theDir + "\" does not exist")
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and theDict.has_key("comment"):
    k = theDict["comment"]
    # 11/14/02: Similar to fix below.
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and theDict.has_key("language"):
    k = theDict["language"]
    # 11/14/02: Fix bug reported by J.M.Gilligan.
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory() # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"" + theDir + "\" does not exist")
#@nonl
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory() # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: " + path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: " + path)
#@nonl
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory() # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:scanDefaultDirectory
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@nonl
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@nonl
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites...
#@-node:ekr.20041005105605.4:class atFile
#@-node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072759:What I did
@killcolor

This method should do noting if at.toString is True.
#@nonl
#@-node:ekr.20041021072759:What I did
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    assert(self.outputFile is None)
    
    if self.toString:
        return False
    
    self.fileChangedFlag = False
    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            << delete the output file >>
        else:
            << report if the files differ only in line endings >>
            << replace the target file with the output file >>
            return True # bwm
    else:
        << rename the output file to be the target file >>
        return False
#@nonl
#@+node:ekr.20041005105605.213:<< delete the output file >>
try: # Just delete the temp file.
    os.remove(self.outputFileName)
except:
    g.es("exception deleting:" + self.outputFileName)
    g.es_exception()

g.es("unchanged: " + self.shortFileName)
#@nonl
#@-node:ekr.20041005105605.213:<< delete the output file >>
#@+node:ekr.20041005105605.214:<< replace the target file with the output file >>
try:
    # 10/6/02: retain the access mode of the previous file,
    # removing any setuid, setgid, and sticky bits.
    mode = (os.stat(self.targetFileName))[0] & 0777
except:
    mode = None

try: # Replace target file with temp file.
    os.remove(self.targetFileName)
    try:
        g.utils_rename(self.outputFileName,self.targetFileName)
        if mode != None: # 10/3/02: retain the access mode of the previous file.
            try:
                os.chmod(self.targetFileName,mode)
            except:
                g.es("exception in os.chmod(%s)" % (self.targetFileName))
        g.es("writing: " + self.shortFileName)
        self.fileChangedFlag = True
    except:
        # 6/28/03
        self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
        g.es_exception()
except:
    self.writeError("exception removing:" + self.targetFileName)
    g.es_exception()
    try: # Delete the temp file when the deleting the target file fails.
        os.remove(self.outputFileName)
    except:
        g.es("exception deleting:" + self.outputFileName)
        g.es_exception()
#@nonl
#@-node:ekr.20041005105605.214:<< replace the target file with the output file >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@+node:ekr.20041005105605.215:<< rename the output file to be the target file >>
try:
    g.utils_rename(self.outputFileName,self.targetFileName)
    g.es("creating: " + self.targetFileName)
    self.fileChangedFlag = True
except:
    self.writeError("exception renaming:" + self.outputFileName +
        " to " + self.targetFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.215:<< rename the output file to be the target file >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,ignored):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    if 0: # Wrong: must check all parents.
        ignored = ignored or p.isAtIgnoreNode()
    else:
        for p2 in p.self_and_parents_iter():
            if p2.isAtIgnoreNode():
                isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,ignored)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20041022063506:(Fixed file association in leoDist.leo)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2816347
By: osuchw

I have came upon a small bug related to how *.leo files are registered to be
open with windows.

Currently the command looks like.
<pythondir>\pythonw.exe "<leodir>\src\leo.py" %1
and it should be
"<pythondir>\pythonw.exe" "<leodir>\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.
For example rst2.py plugin fails if it is called from a leo file that has spaces
in it is path.
#@-node:ekr.20041022063506:(Fixed file association in leoDist.leo)
#@+node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20041023055452.1:Report
From Leo User

I forgot to mention that I had this happen twice today:
1. Copy node.
2. Paste Retaining Clone

...seemed to enter endless node creation loop.
#@-node:ekr.20041023055452.1:Report
#@+node:ekr.20041023055452.2:What I did
@killcolor

1. In << recreate tnodesDict >>

    - Set self.tnodesDict ={}
    - Changed all_tnodes_iter to all_unique_tnodes_iter.

2. Set self.forbiddenTnodes in get_vnodes.  Also added reassignIndices keyword param.

3. Raise invalidPaste in get_vnode if the tnode (to be generated later) would be in self.forbiddenTnodes.

3. Fixed bugs:  tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!

4. Report exceptions in getLeoOutline rather than pasteOutline.
#@nonl
#@-node:ekr.20041023055452.2:What I did
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self
    
    return c.pasteOutline(reassignIndices=False)
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; current = c.currentPosition()
    
    s = g.app.gui.getTextFromClipboard()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)

    if isLeo:
        p = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        p = c.importCommands.convertMoreStringToOutlineAfter(s,current)
        
    if p:
        c.endEditing()
        c.beginUpdate()
        if 1: # inside update...
            c.validateOutline()
            c.selectVnode(p)
            p.setDirty()
            c.setChanged(True)
            # paste as first child if back is expanded.
            back = p.back()
            if back and back.isExpanded():
                p.moveToNthChildOf(back,0)
            c.undoer.setUndoParams("Paste Node",p)
        c.endUpdate()
        c.recolor()
#@nonl
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
# This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []
    
    if not reassignIndices:
        << recreate tnodesDict >>

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("<leo_file>") # <leo_file/> is not valid.
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        v = self.finishPaste(reassignIndices)
    except invalidPaste:
        v = None
        g.es("Invalid Paste Retaining Clones",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@nonl
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)
    else:
        << set current and top positions >>

    self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
    c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@nonl
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@-node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20041215102907:(Removed invalid assert in lastVisible)
# Leo looped after this assert failed.
#@nonl
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    if 0: # This assert is invalid.
        assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@-node:ekr.20041215102907:(Removed invalid assert in lastVisible)
#@+node:ekr.20041228060059:(Better handling of duplicate shortcuts)
@nocolor

The code now clears previous shortcut, and tells what the previous entry was.

What I did:
    - Added init keyword param to createMenuEntries.
    - All calls to createMenuEntries from createMenusFromTables set init = True.
    - Changed << handle bind_shorcut >> in createMenuEntries:
        - Changed menuShortcuts to a dict containing g.Bunch items.
    - Added clearAccel methods to leoMenu and leoTkinterMenu classes.

@color
#@nonl
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@nonl
#@-node:ekr.20041228063406:clearAccel
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                << handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20041228060059:(Better handling of duplicate shortcuts)
#@+node:ekr.20041231083430:(Fixed crasher with invalid path)
Directory "c:\test" does not exist
exception writing:C:\prog\leoCVS\leo\test
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2756, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3020, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3752, in putOpenLeoSentinel
    if not at.sentinels:
AttributeError: atFile instance has no attribute 'sentinels'
saved: test.leo
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041231083430:(Fixed crasher with invalid path)
#@+node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20041231102453.5:Notes
@killcolor

There is a bug in how Leo writes adjacent @doc parts in @file trees.  This is the first serious bug in the atFile read/write logic reported in several years. As I write this I realize I don't know whether the @thin logic is affected as well.  I suspect it may be.

The bug happens if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo fails to write the closing #@-at sentinel that would finish the first @doc part.  (Another fix would be not to write the second #@+at sentinel.)  As a result of this bug, Leo fails to read the @file node properly and 'reverts' to the version of the code found in the .leo file.
#@nonl
#@-node:ekr.20041231102453.5:Notes
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used.

def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@-node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
@nocolor

c:\python24\lib\pickle.py:202: DeprecationWarning:
    The 'bin' argument to Pickler() is deprecated

@color
#@nonl
#@+node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@-node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            try:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            except TypeError:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)
        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@+node:EKR.20040526204036.1:getUnknownAttribute
def getUnknownAttribute(self,nodeType):
    
    """Parse an unknown attribute in a <v> or <t> element."""
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
#@nonl
#@-node:EKR.20040526204036.1:getUnknownAttribute
#@-node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
#@-node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
@

Replace the try/except code with

    if multiple and g.CheckVersion(sys.version,"2.3") and g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4"):
#@nonl
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@-node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
#@+node:ekr.20040720073339:Removed use_gnx
#@-node:ekr.20040720073339:Removed use_gnx
#@+node:ekr.20040929102351:Removed write_old_format_derived_files
This implies:
    
- Deprecating old-style file formats.
- Removing commands that write old-style formats.
#@nonl
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
#@+node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
def writeNewDerivedFiles (self):
    
    c = self
    autoSave = c.atFileCommands.writeNewDerivedFiles()
    if autoSave:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to preserve tnodeList.
    
def writeOldDerivedFiles (self):
    
    c = self
    c.atFileCommands.writeOldDerivedFiles()
    g.es("auto-saving outline",color="blue")
    c.save() # Must be done to clear tnodeList.
#@nonl
#@-node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
#@-node:ekr.20040929102351:Removed write_old_format_derived_files
#@+node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041005112818.2:What I did
@killcolor

- Made sense of initialization:
    - ctor inits only permanent ivars.
    - All initing for reads and writes happens explicitly.
    - Separate initiing for reads and writes.
    - All non-permanent ivars deleted before all reads and writes (when testing).

- Move all constants into class.  No more module-level constants.

- All code is now in a single class.
    - This is _so_ much clearer than before.
    - There were only a few name conflicts:  resolved by renaming x to x3 or x4.

- Use methods rather than sections where possible.

- Removed unused oneNodeOnly args, except for putBody method.

- Tested reading 3.x files.  This passes simple tests.  I doubt if anyone actually using these old files....

- Added fromString arg to g.fileLikeObject ctor.

- Not much new is needed to support read/write from string.
    - Official methods that plugins can override:
        read, asisWrite, writeOpenFile
#@nonl
#@-node:ekr.20041005112818.2:What I did
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,useSelectedText=True):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # Allow p not to be the present position.
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
            script = at.stringOutput
            # g.trace(script)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041019125831:Notes
@killcolor

- (to do) doc parts are reformatted improperly.

    - This is going to be even trickier when Python allows '@' characters.
    - The present code make no attempt to discover @doc parts;
      it simply preserves whitespace after @ signs!

- (fixed) doc strings were messed up.

    - The bug was improperly use a as a synonym for self.array.
#@nonl
#@-node:ekr.20041019125831:Notes
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val

    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
@ 

Save As & Save To are broken with new .leo files

c.mFileName was '.'  That should never happen.

I recently added code that set

c.mFileName = g.os_path_norm(fileName) in the ctor, but this converts an empty name to '.' (!!)

I removed g.os_path_norm and g.os_path_normabs.  These caused more problems than they solved.
#@+node:ekr.20041216060139:Traceback
exception creating backup file: ..bak
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoFileCommands.py", line 2015, in write_Leo_file
    g.utils_rename(fileName,backupName)
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1604, in utils_rename
    os.rename(src,dst)
OSError: [Errno 13] Permission denied

--------------

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 154, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 626, in saveTo
    defaultextension=".leo")
  File "C:\prog\leoCVS\leo\src\leoTkinterGui.py", line 228, in runSaveFileDialog
    filetypes=filetypes)
  File "c:\python23\lib\lib-tk\tkFileDialog.py", line 131, in asksaveasfilename
    return SaveAs(**options).show()
  File "c:\python23\lib\lib-tk\tkCommonDialog.py", line 52, in show
    s = w.tk.call(self.command, *w._options(self.options))
TclError: invalid filename "."
#@-node:ekr.20041216060139:Traceback
#@-node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
#@-node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20041115111203:Config...
# 2004
#@nonl
#@+node:ekr.20041124094427.1: What I did
@nocolor

- leo.py:
    - Create nodeIndices early in starup logic.
    - Set g.app.config early in startup logic.
    
- leoCommands.py:
    - Added class configSettings to hold per-commander settings.

- leoFileCommands.py
    - putFindSettings and putPrefs write empty xml elements.
    - getFindPanelSettings and getPrefs ignore whatever settings they see.

@color
#@nonl
#@-node:ekr.20041124094427.1: What I did
#@+node:ekr.20041228053248:Diary
#@+node:ekr.20041118130101:11/17 Prepared for new code
@killcolor

- Disabled ill-fated Apply Settings command.
- Removed call to config.update from leoFileCommands.write code.
- Write only vestigial <find settings/>
- Write only vestigial <preferences/>
    - Will store prefs in @settings trees.
*** NO changes to the read code.  This ensures compatibility.
- Created computeHomeDir, computeGlobalConfig and startupEncoding in leo.py.
- Set g.app.homeDir and g.app.globalConfigDir in leo.py.
- Generalized g.app.setLeoID()
- Called g.app.setLeoID() _before_ loading plugins.
#@nonl
#@-node:ekr.20041118130101:11/17 Prepared for new code
#@+node:ekr.20041118130101.1:11/18 Modified core for new code
@nocolor

- Create configSettings class in leoCommands.py.

This is needed because the old g.app.ivars won't work with per-file settings.  So now each commander has its own settings.

    - c.config now points to a configSettings instance for each commander.
    - The configSettings class has convenience methods to get and set settings.

- Removed config.update.  One reference still exists.

The code accesses config ivar x via c.config.x

- Removed all section-specific getters from Leo's core and leoPlugins.leo.

- Changed g.app.config to c.config in these plugins: FileActions.py, word_export.py, rst.py, rst2.py

- Remove all references to configExists and configExists itself.

- Removed most references to g.app.config.x:  The main remaining refs are:
    g.app.config.use_plugins
#@nonl
#@+node:ekr.20041118135701:Removed old spellings of config getters
getBoolColorsPref = getBool
getBoolComparePref = getBool
getBoolFindPref = getBool
getBoolPref = getBool
getBoolWindowPref = getBool

getIntComparePref = getInt
getIntPref = getInt
getIntWindowPref = getInt

getFloatWindowPref = getFloat

getStringColorsPref = getString
getStringComparePref = getString
getStringFindPref = getString
getStringPref = getString
getStringWindowPref = getString

# Generic prefs are strings too.
getColorsPref = getString
getComparePref = getString
getFindPref = getString
getPref = getString
getWindowPref = getString
#@nonl
#@-node:ekr.20041118135701:Removed old spellings of config getters
#@-node:ekr.20041118130101.1:11/18 Modified core for new code
#@+node:ekr.20041120134118:11/19 Wrote first draft of new code
#@-node:ekr.20041120134118:11/19 Wrote first draft of new code
#@+node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041120160454:Added gui param to fram
Not sure this did anything.  However, using g.app.gui in the code should be replaced by c.frame.gui.
#@nonl
#@-node:ekr.20041120160454:Added gui param to fram
#@+node:ekr.20041120160454.1:Added destroySelf method to nullFram
This allows g.app.destroyWindow to work on nullFrame's.
#@nonl
#@-node:ekr.20041120160454.1:Added destroySelf method to nullFram
#@+node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
use_psyco can no longer be a config param:  it is used too early in the load process.
#@nonl
#@-node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
#@+node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
This is needed because loading .leo files requires g.app.leoID.

To make this work, I had to create an emergency "startup" gui in setLeoID. This in turn creates g.app.root, so I also changed
createNullGuiWithScript so it only creates the Tk root if it doesn't already exist.

Clearly, using g.app.gui is wrong.
#@nonl
#@-node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
#@+node:ekr.20041120160454.4:Removed use_psycho option
#@-node:ekr.20041120160454.4:Removed use_psycho option
#@+node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041121125616.1:11/21 Multiple find panels
@killcolor

- Implemented @if-gui
- Implemented @ratio.
- Fixed bug:  getBool was returning True for both True and False ;-)

- Removed g.app.globalWindows.
- Removed destroyAllGlobalWindows()
- Destroy find panel in frame.destroySelf.
#@nonl
#@-node:ekr.20041121125616.1:11/21 Multiple find panels
#@+node:ekr.20041124094427:11/24 Improved how names get munged
@killcolor

canonicalizeSettingsName (munge) delete whitespace, underscores and '-' in settings names.

dictionary keys are munged names.
#@nonl
#@-node:ekr.20041124094427:11/24 Improved how names get munged
#@+node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.hash(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@-node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@-node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041123075848:What I did
@killcolor

- Added updateRecentFiles keyword option to newLeoCommanderAndFrame.
    Default is True, but set to false when opening leoSettings.leo files on startup.
    Note: this will be False, then True when opening leoSettings.leo explicitly.

- Removed g.app.config.setRecentFiles.
    All work done in c.config.setRecentFiles.
    moved recentFiles ivar to configParser class.

- Moved call to c.config.setRecentFiles from c.updateRecentFiles to g.openWithFileName.

- settingsRoot, canonicalizeSettingName and findSettingsPosition now defined only in config class.
    These are always accessed via g.app.config.
    These seems better than defining functions in leoGlobals.py
#@nonl
#@-node:ekr.20041123075848:What I did
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    # Update the recent files list in all windows.
    if fileName:
        absFileName = g.os_path_abspath(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if absFileName == g.os_path_abspath(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    # Create a full normalized path name.
    # Display the file name with case intact.
    fileName = g.os_path_join(os.getcwd(), fileName)
    fileName = g.os_path_normpath(fileName)
    oldFileName = fileName 
    fileName = g.os_path_normcase(fileName)

    # If the file is already open just bring its window to the front.
    list = app.windowList
    for frame in list:
        fn = g.os_path_normcase(frame.c.mFileName)
        fn = g.os_path_normpath(fn)
        if fileName == fn:
            frame.deiconify()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
            
    fileName = oldFileName # Use the idiosyncratic file name.

    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        if theFile:
            c,frame = app.gui.newLeoCommanderAndFrame(fileName)
            frame.log.enable(enableLog)
            if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
                app.setLog(frame.log,"openWithFileName")
                app.lockLog()
                frame.c.fileCommands.open(theFile,fileName,readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
            return True, frame
        else:
            g.es("can not open: " + fileName,color="red")
            return False, None
    except IOError:
        g.es("can not open: " + fileName, color="blue")
        return False, None
    except:
        if 1:
            print "exceptions opening:", fileName
            traceback.print_exc()
        else:
            g.es("exceptions opening: " + fileName,color="red")
            g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    # Finish creating the frame
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    g.doHook("after-create-leo-frame",c=c)
    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for ivar in g.app.config.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)
        
    for ivar in g.app.config.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,ivarName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.ivarsDict.get(munge(ivarName))
    ivar = bunch.ivar ; val = bunch.val

    # g.trace(self.c.hash(),bunch.toString())

    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,encodingName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.encodingIvarsDict.get(munge(encodingName))
    ivar = bunch.ivar ; encoding = bunch.encoding

    # g.trace(bunch.toString())
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
# Sets config ivars from c.
def setConfigIvars (self):
    
    c = self.c
    config = g.app.config
    
    g.trace()
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"

    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setPref("batch",str(c.batch_flag))
    self.setPref("ignore_case",str(c.ignore_case_flag))
    self.setPref("mark_changes",str(c.mark_changes_flag))
    self.setPref("mark_finds",str(c.mark_finds_flag))
    self.setPref("pattern_match",str(c.pattern_match_flag))
    self.setPref("reverse",str(c.reverse_flag))
    self.setPref("script_change",str(c.script_change_flag))
    self.setPref("script_search",str(c.script_search_flag))
    self.setPref("search_body",str(c.search_body_flag))
    self.setPref("search_headline",str(c.search_headline_flag))
    self.setPref("selection_only",str(c.selection_only_flag))
    self.setPref("suboutline_only",str(c.suboutline_only_flag))
    self.setPref("wrap",str(c.wrap_flag))
    self.setPref("whole_word",str(c.whole_word_flag))
    
    self.setPref("change_string",c.change_text)
    self.setPref("find_string",c.find_text)
#@nonl
#@-node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if p:
        pass
        # g.trace("updating @recent-files for ",c.mFileName)
    else:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # Update the @recent-files entry, leaving c's changed status untouched.
    changed = c.isChanged()
    body = '\n'.join(files)
    p.setBodyStringOrPane (body,encoding=g.app.tkEncoding)
    c.setChanged(changed)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if p:
        pass
        # g.trace("updating @recent-files for ",c.mFileName)
    else:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # Update the @recent-files entry, leaving c's changed status untouched.
    changed = c.isChanged()
    body = '\n'.join(files)
    p.setBodyStringOrPane (body,encoding=g.app.tkEncoding)
    c.setChanged(changed)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@-node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041124081632:(Problems overriding defaults)
@nocolor
Problem 1: a simple blunder in settingsParser.set.

Problem 2: use_plugin didn't get changed until after plugins get loaded.

Solution:  Read .leo files specified on the command line twice:
    
- Once before loading plugins, _without_ loading @file nodes.
- Once after (normal load)

What I did:

- Created completeFileName (does not depend on config).
- Added local file to list of files to be scanned in readSettingsFiles.
- Don't don't scan for settings in local file in createFrame.
    - Added readAtFileNodesFlag keyword arg to openWithFileName.
@color
#@nonl
#@+node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    frame.c.fileCommands.open(theFile,path,readAtFileNodesFlag=False) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                # A print statement here is clearest.
                print "reading settings in %s" % path
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    hash = c.hash()
                    d['_hash'] = hash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[hash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s",color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [file.strip() for file in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for file in files:
                print file
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.mFileName)
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    # Create a full normalized path name.
    # Display the file name with case intact.
    fileName = g.os_path_join(os.getcwd(), fileName)
    fileName = g.os_path_normpath(fileName)
    oldFileName = fileName 
    fileName = g.os_path_normcase(fileName)

    # If the file is already open just bring its window to the front.
    list = app.windowList
    for frame in list:
        fn = g.os_path_normcase(frame.c.mFileName)
        fn = g.os_path_normpath(fn)
        if fileName == fn:
            frame.deiconify()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
            
    fileName = oldFileName # Use the idiosyncratic file name.

    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        if theFile:
            c,frame = app.gui.newLeoCommanderAndFrame(fileName)
            frame.log.enable(enableLog)
            if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
                app.setLog(frame.log,"openWithFileName")
                app.lockLog()
                frame.c.fileCommands.open(theFile,fileName,readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
            return True, frame
        else:
            g.es("can not open: " + fileName,color="red")
            return False, None
    except IOError:
        g.es("can not open: " + fileName, color="blue")
        return False, None
    except:
        if 1:
            print "exceptions opening:", fileName
            traceback.print_exc()
        else:
            g.es("exceptions opening: " + fileName,color="red")
            g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    << compute directories >>
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.config()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416:<< compute directories >>
g.app.loadDir = computeLoadDir()
    # Depends on g.app.tkEncoding: uses utf-8 for now.

g.app.homeDir = computeHomeDir()

g.app.extensionsDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','extensions'))

g.app.globalConfigDir = computeGlobalConfigDir()
#@nonl
#@-node:ekr.20041219072416:<< compute directories >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
     print "Error importing leoNodes.py"

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog("Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    import leoGlobals as g
    
    encoding = startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=dotDir)
    if len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=dotDir)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,dir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,dir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2297:open
def open(self,theFile,fileName,readAtFileNodesFlag=True):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:open
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20041124081632:(Problems overriding defaults)
#@+node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
# The window titel problem was in completeFileName.

# The munging needs was done in doType and settingsParser.set.
#@nonl
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
#@+node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20041126035808:(Problems importing Pmw files)
@

- The Pmw source files contain mixed tabs/spaces, which caused most of the problems.
    - A _single_ blank was spanning two indentations.
    - That is always going to be hard for Leo unless heroic measures are taken.

- Created self.tab_width ivar (set by getTabWidth) so import directives honor @tabwidth directives.
#@nonl
#@+node:ekr.20031218072017.3207:import.__init__
def __init__ (self,c):

    self.c = c
    
    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in < < x methods > > =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline()
    
    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
#@nonl
#@-node:ekr.20031218072017.3207:import.__init__
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@+node:ekr.20031218072017.2256:Python scanners
#@+node:ekr.20031218072017.2257:scanPythonClass
def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace("self.tab_width",self.tab_width)
    # g.trace(g.get_line(s,i))
    classIndent = self.getLeadingIndent(s,i)
    << set classname and headline, or return i >>
    i = g.skip_line(s,i) # Skip the class line.
    << create class_vnode >>
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=True)
    << create nodes for all defs of the class >>
    << append any other class material >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    classname = s[j:i]
    headline = "class " + classname
else:
    return i
#@nonl
#@-node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
#@+node:ekr.20031218072017.2259:<< create class_vnode  >>
# Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# i points just after the class line.

# Add a docstring to the class node.
docStringSeen = False
j = g.skip_ws_and_nl(s,i)
if g.match(s,j,'"""') or g.match(s,j,"'''"):
    j = g.skip_python_string(s,j)
    if j != len(s): # No scanning error.
        i = j ; docStringSeen = True

body = s[start:i]
body = self.undentBody(body)
if docStringSeen: body = body + '\n'
class_vnode = self.createHeadline(parent,prefix + body,headline)
#@nonl
#@-node:ekr.20031218072017.2259:<< create class_vnode  >>
#@+node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
indent =  self.getLeadingIndent(s,i)
start = i = g.skip_blank_lines(s,i)
parent_vnode = None
# g.trace(classIndent)
while i < len(s) and indent > classIndent:
    progress = i
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        j = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,j)
            if indent > classIndent: i = j
            else: break
        else: i = j
    elif g.match_c_word(s,i,"def"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonDef(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif g.match_c_word(s,i,"class"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonClass(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
    elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@+node:ekr.20031218072017.2261:<< create parent_vnode >>
# This must be done after the declaration reference is generated.
if self.treeType == "@file":
    class_vnode.appendStringToBody("\t@others\n")
else:
    ref = g.angleBrackets(" class " + classname + " methods ")
    class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode
#@nonl
#@-node:ekr.20031218072017.2261:<< create parent_vnode >>
#@-node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
#@+node:ekr.20031218072017.2262:<< append any other class material >>
s2 = s[start:i]
if s2:
    class_vnode.appendStringToBody(s2)
#@nonl
#@-node:ekr.20031218072017.2262:<< append any other class material >>
#@-node:ekr.20031218072017.2257:scanPythonClass
#@+node:ekr.20031218072017.2263:scanPythonDef
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    << skip the Python def >>
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2264:<< set headline or return i >>
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@nonl
#@-node:ekr.20031218072017.2264:<< set headline or return i >>
#@+node:ekr.20031218072017.2265:<< skip the Python def >>
# Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = g.skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
#g.trace(defIndent,indent)
#g.trace(g.get_line(s,i))
while i < len(s) and indent > defIndent:
    progress = i
    ch = s[i]
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        i = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,i)
            if indent <= defIndent:
                break
    elif ch == '#':
        i = g.skip_to_end_of_line(s,i) # 7/29/02
    elif ch == '"' or ch == '\'':
        i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@-node:ekr.20031218072017.2265:<< skip the Python def >>
#@+node:ekr.20031218072017.2266:<< Create def node >>
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20031218072017.2266:<< Create def node >>
#@-node:ekr.20031218072017.2263:scanPythonDef
#@+node:ekr.20031218072017.2267:scanPythonDecls
def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    done = False ; start = i
    while not done and i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent <= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << break on def or class >>
        else: i += 1
        assert(progress < i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j < i:
        << Create a child node for declarations >>
    return i
#@nonl
#@+node:ekr.20031218072017.2268:<< break on def or class >>
if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2268:<< break on def or class >>
#@+node:ekr.20031218072017.2269:<< Create a child node for declarations >>
headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
#@nonl
#@-node:ekr.20031218072017.2269:<< Create a child node for declarations >>
#@-node:ekr.20031218072017.2267:scanPythonDecls
#@+node:ekr.20031218072017.2270:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@nonl
#@+node:ekr.20031218072017.2271:<< handle possible Python function or class >>
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file": # 7/29/02
            parent.appendStringToBody("@others\n") # 7/29/02
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2271:<< handle possible Python function or class >>
#@+node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    parent.appendStringToBody(
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@nonl
#@-node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
#@+node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    parent.appendStringToBody(s[start:])
#@nonl
#@-node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20031218072017.2270:scanPythonText
#@-node:ekr.20031218072017.2256:Python scanners
#@-node:ekr.20041126035808:(Problems importing Pmw files)
#@+node:ekr.20041124164305:(Eliminated alarming warning message)
@

The fix really should be in putDescendentAttributes and putUnknownAttributes.

These methods shouldn't write gnx's that don't exist.
#@nonl
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())

    for theList,tag in ((marks,"marks="),(expanded,"expanded=")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            self.put('\n' + tag)
            self.put_in_dquotes(s)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            try:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            except TypeError:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)
        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:ekr.20041124164305:(Eliminated alarming warning message)
#@+node:ekr.20041127055549:(Don't call plugins for null gui's)
# Added isNullGui ivar to gui classes.
#@nonl
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0"
            print s ; g.es(s,color="blue")
        return None

    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
            
    # Get the hook handler function.  Usually this is doPlugins.
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    if 0: # Don't use trace here!
        if 1:
            old_c = keywords.get('old_c')
            if old_c: print 'doHook %24s %s' % (tag,old_c.shortFileName())
        else:
            if tag != "idle": print 'doHook %24s old_c: %s' % (tag,c and c.shortFileName())
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20041127055549:(Don't call plugins for null gui's)
#@+node:ekr.20041127094814:(Mods to drawTopTree)
@

I haven't been able to use the base drawTopTree method.

Don't know just why: some problem with the canvas, probably.
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount,c.rootPosition())

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        p,junk = c.hoistStack[-1]
        self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c ; v = p.v
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t
#@nonl
#@-node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
#@+node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@nonl
#@-node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
#@+node:ekr.20040305171133:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:p.allNodes_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    redraw_flag = False
    
    # g.trace(p)

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20041127094814:(Mods to drawTopTree)
#@+node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self,*args,**keys):
    pass
    
def lift (self,*args,**keys):
    pass
    
def update (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry(self,w,h,x,y):
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
    
    
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    c.frame = frame
    c.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    # initialize the sub-commanders
    c.fileCommands = leoFileCommands.fileCommands(c)
    c.atFileCommands = leoAtFile.atFile(c)
    c.importCommands = leoImport.leoImportCommands(c)
    c.tangleCommands = leoTangle.tangleCommands(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# 4.1: for hoist/dehoist commands.
self.hoistStack = [] # Stack of nodes to be root of drawn tree.  Affects only drawing routines.

self.recentFiles = [] # 4.1: moved to commands class.  List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.hash(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies
#@-node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20041201075146:(Updated recent files properly)
#@+node:ekr.20041201083311:What I did
@killcolor

- g.openWithFileName now calls:
    frame.c.config.setRecentFiles(g.app.config.recentFiles)

That is, all new files get the global file list.

- Created config.appendToRecentFiles.

- c.ConfigParser.setRecentFiles calls config.appendToRecentFiles.

That is, we never remove files from the recent files list, we only add files.

- Added << update recent files from d >> to config.readSettingsFiles.

This calls config.appendToRecentFiles(files) to actually set the files.
#@nonl
#@-node:ekr.20041201083311:What I did
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for ivar in g.app.config.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)
        
    for ivar in g.app.config.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,ivarName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.ivarsDict.get(munge(ivarName))
    ivar = bunch.ivar ; val = bunch.val

    # g.trace(self.c.hash(),bunch.toString())

    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,encodingName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.encodingIvarsDict.get(munge(encodingName))
    ivar = bunch.ivar ; encoding = bunch.encoding

    # g.trace(bunch.toString())
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
# Sets config ivars from c.
def setConfigIvars (self):
    
    c = self.c
    config = g.app.config
    
    g.trace()
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"

    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setPref("batch",str(c.batch_flag))
    self.setPref("ignore_case",str(c.ignore_case_flag))
    self.setPref("mark_changes",str(c.mark_changes_flag))
    self.setPref("mark_finds",str(c.mark_finds_flag))
    self.setPref("pattern_match",str(c.pattern_match_flag))
    self.setPref("reverse",str(c.reverse_flag))
    self.setPref("script_change",str(c.script_change_flag))
    self.setPref("script_search",str(c.script_search_flag))
    self.setPref("search_body",str(c.search_body_flag))
    self.setPref("search_headline",str(c.search_headline_flag))
    self.setPref("selection_only",str(c.selection_only_flag))
    self.setPref("suboutline_only",str(c.suboutline_only_flag))
    self.setPref("wrap",str(c.wrap_flag))
    self.setPref("whole_word",str(c.whole_word_flag))
    
    self.setPref("change_string",c.change_text)
    self.setPref("find_string",c.find_text)
#@nonl
#@-node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if p:
        pass
        # g.trace("updating @recent-files for ",c.mFileName)
    else:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # Update the @recent-files entry, leaving c's changed status untouched.
    changed = c.isChanged()
    body = '\n'.join(files)
    p.setBodyStringOrPane (body,encoding=g.app.tkEncoding)
    c.setChanged(changed)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041201080436.1:Notes
@killcolor

Leo writes the recent files node correctly, but does not init them correctly.
#@nonl
#@-node:ekr.20041201080436.1:Notes
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    # Create a full normalized path name.
    # Display the file name with case intact.
    fileName = g.os_path_join(os.getcwd(), fileName)
    fileName = g.os_path_normpath(fileName)
    oldFileName = fileName 
    fileName = g.os_path_normcase(fileName)

    # If the file is already open just bring its window to the front.
    list = app.windowList
    for frame in list:
        fn = g.os_path_normcase(frame.c.mFileName)
        fn = g.os_path_normpath(fn)
        if fileName == fn:
            frame.deiconify()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
            
    fileName = oldFileName # Use the idiosyncratic file name.

    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        if theFile:
            c,frame = app.gui.newLeoCommanderAndFrame(fileName)
            frame.log.enable(enableLog)
            if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
                app.setLog(frame.log,"openWithFileName")
                app.lockLog()
                frame.c.fileCommands.open(theFile,fileName,readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
            return True, frame
        else:
            g.es("can not open: " + fileName,color="red")
            return False, None
    except IOError:
        g.es("can not open: " + fileName, color="blue")
        return False, None
    except:
        if 1:
            print "exceptions opening:", fileName
            traceback.print_exc()
        else:
            g.es("exceptions opening: " + fileName,color="red")
            g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20041123092357:config.findSettingsPosition
def findSettingsPosition (self,c,setting):
    
    """Return the position for the setting in the @settings tree for c."""
    
    munge = self.munge
    
    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()
        
    setting = munge(setting)
        
    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()
    
    return c.nullPosition()
#@nonl
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041201080436:config.appendToRecentFiles
def appendToRecentFiles (self,files):
    
    for file in files:
        if file in self.recentFiles:
            self.recentFiles.remove(file)
        # g.trace(file)
        self.recentFiles.append(file)
#@nonl
#@-node:ekr.20041201080436:config.appendToRecentFiles
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                # A print statement here is clearest.
                print "reading settings in %s" % path
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    hash = c.hash()
                    d['_hash'] = hash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[hash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s",color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [file.strip() for file in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for file in files:
                print file
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@-node:ekr.20041201075146:(Updated recent files properly)
#@-node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041211051934.1:12/11
#@+node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2866490

I've noticed that even if the mod_speling.ini is changed, the language is alway
set as en_US !

to Correct this and being able to launch the correct language, i've changed
he following code :

''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir)

by :
''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir, lang=local_language_code)

..................
This seem to work on my install !

BUT
the hardcodding of the aspell_dir in the plugin code is UGLY !!!

It should also be fine to add a directive or a menu under the plugins_menu"
to change the language and reinitialise the spell_checker for spelling multilingual
documents.....
#@-node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
#@-node:ekr.20041211051934.1:12/11
#@+node:ekr.20041216052925:12/17
#@+node:ekr.20041211043135:(Fix problems with c.ivars)
@

What ivars get changed--local (c) or global(g.app.config) ??

Presently, only g.app.config.page_width and g.app.config.tab_width get changed.
#@nonl
#@+node:ekr.20041211050623:From 4.2
@ignore
#@nonl
#@+node:ekr.20041211050623.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20041211050623.1:defaultsDict
#@+node:ekr.20041211050623.2:initialize ivars that may be set by config options
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False

# TO BE REMOVED:
self.write_old_format_derived_files = False # Use new format if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.2:initialize ivars that may be set by config options
#@+node:ekr.20041211050623.3:set in c.__init__
# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.3:set in c.__init__
#@-node:ekr.20041211050623:From 4.2
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the ivar with the same name.
ivarsDict = {'_hash':'ivarsDict'}

if 0: # From c.__init__
    # Global options
    c.tangle_batch_flag = False
    c.untangle_batch_flag = False
    # Default Tangle options
    c.tangle_directory = ""
    c.use_header_flag = False
    c.output_doc_flag = False
    # Default Target Language
    c.target_language = "python" # Required if leoConfig.txt does not exist.

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",False),
        # Should never be True here!
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@+node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    frame.c.fileCommands.open(theFile,path,readAtFileNodesFlag=False) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                # A print statement here is clearest.
                print "reading settings in %s" % path
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    hash = c.hash()
                    d['_hash'] = hash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[hash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s",color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [file.strip() for file in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for file in files:
                print file
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.mFileName)
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@-node:ekr.20041211043135:(Fix problems with c.ivars)
#@+node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041213082558.1:parseFont
def parseFont (self,p):
    
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(p,line,d)
        
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
        
    return d
#@nonl
#@-node:ekr.20041213082558.1:parseFont
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,p,line,d):
    
    s = line.strip()
    if not s: return
    
    try:
        s = str(s)
    except UnicodeError:
        pass
    
    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip() ; val = s[i+1:].strip()

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@nonl
#@-node:ekr.20041213082558.2:parseFontLine
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@nonl
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.hash(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies
#@-node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
@ It is essential to retain a link to a font.  Otherwise changes to one font may affect other fonts.

This appears to be a bug in Tk or Tkinter.
#@nonl
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize, tag = "log")

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@+node:ekr.20031218072017.2183:tkBody.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; body = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "body")
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    body.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@nonl
#@-node:ekr.20031218072017.2183:tkBody.setFontFromConfig
#@+node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font
        
# Called by leoFontPanel.
def setFont (self,font=None, fontName=None):
    
    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")
    
    self.setFont(font)
#@nonl
#@-node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041217041016:setFontFromConfig
def setFontFromConfig (self):
    
    c = self.c
    
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold")
    
    if self.bold_font:
        self.bold_font.configure(weight="bold")
    
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer italic")
        
    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")
    
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold italic")
        
    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")
        
    self.color_tags_list = []
    self.image_references = []
#@nonl
#@-node:ekr.20041217041016:setFontFromConfig
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    
    d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        t = Tk.Text(canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)
            t.bind("<Control-t>",self.onControlT)
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # Bug fix 7/31/04:  We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString(),tag="newText")
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # New in 4.2 b3: entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList

    # g.trace(p,t)
    return t
#@nonl
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
#@+node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                # A print statement here is clearest.
                print "reading settings in %s" % path
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    hash = c.hash()
                    d['_hash'] = hash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[hash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s",color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [file.strip() for file in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for file in files:
                print file
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083141:get & allies
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.hash(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies
#@-node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041217135735.3:(Update all colors immediately)
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20040803072955.30:tkTree.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        self.canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.30:tkTree.setColorFromConfig
#@-node:ekr.20041217135735.3:(Update all colors immediately)
#@-node:ekr.20041216052925:12/17
#@+node:ekr.20041221070525.1:12/18
#@+node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@+node:ekr.20031218072017.3098:class Bunch
@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared > threshold:
        point.isok = True
@c

import operator

class Bunch:
    
    """A class that represents a colection of things.
    
    Especially useful for representing a collection of related variables."""
    
    def __init__(self,**keywords):
        self.__dict__.update (keywords)
        
    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()
        
    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    if 0:
        def __setitem__ (self,key,value):
            '''Support aBunch[key] = val'''
            return operator.setitem(self.__dict__,key,value)
            
        def __getitem__ (self,key):
            '''Support aBunch[key]'''
            return operator.getitem(self.__dict__,key)
        
bunch = Bunch
#@nonl
#@-node:ekr.20031218072017.3098:class Bunch
#@+node:ekr.20041117083141:get & allies
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.hash(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [file.strip() for file in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for file in files:
                print file
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for ivar in g.app.config.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)
        
    for ivar in g.app.config.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,ivarName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.ivarsDict.get(munge(ivarName))
    ivar = bunch.ivar ; val = bunch.val

    # g.trace(self.c.hash(),bunch.toString())

    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,encodingName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.encodingIvarsDict.get(munge(encodingName))
    ivar = bunch.ivar ; encoding = bunch.encoding

    # g.trace(bunch.toString())
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@-node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@-node:ekr.20041221070525.1:12/18
#@+node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    if use_Pmw and Pmw:
        # g.trace(ratio,ratio2)
        self.ratio = ratio
        self.secondary_ratio = ratio2
        splitter1 = self.component('splitter1').getObject()
        splitter2 = self.component('splitter2').getObject()

        if self.splitVerticalFlag:
            # Use ratio to set splitter2 height.
            size = ratio * float(splitter1.winfo_height())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline width.
            size = ratio2 * float(splitter2.winfo_width())
            splitter2.configurepane('outline',size=int(size))
        else:
            # Use ratio to set splitter2 width.
            size = ratio * float(splitter1.winfo_width())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline height.
            size = ratio2 * float(splitter2.winfo_height())
            splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes(self):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    if use_Pmw and Pmw:
        # g.trace(ratio,ratio2)
        self.ratio = ratio
        self.secondary_ratio = ratio2
        splitter1 = self.component('splitter1').getObject()
        splitter2 = self.component('splitter2').getObject()

        if self.splitVerticalFlag:
            # Use ratio to set splitter2 height.
            size = ratio * float(splitter1.winfo_height())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline width.
            size = ratio2 * float(splitter2.winfo_width())
            splitter2.configurepane('outline',size=int(size))
        else:
            # Use ratio to set splitter2 width.
            size = ratio * float(splitter1.winfo_width())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline height.
            size = ratio2 * float(splitter2.winfo_height())
            splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,outerFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)
self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3689:initialRatios
def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","orientation")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@nonl
#@-node:ekr.20031218072017.3689:initialRatios
#@-node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041222092032:(Tried using place to show widgets)
@

This did not work: _tkinter.TclError: can't place

.24597368.24598448.24610776.24610936 relative to
.24597368.24598448.24598768.24599008.24608856.24609096
#@nonl
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)
        
    self.canvas = canvas

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
import threading
import time

way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('<Shift Button-3>',exe)
    canvas.bind_all('<Shift Button-1>',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('<Shift ButtonRelease-1>', off)
    canvas.bind_all('<Shift ButtonRelease-3>', off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>', exe)
    canvas.bind_all( '<Button-1>', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '<ButtonRelease-1>', off)
    canvas.bind_all( '<ButtonRelease-3>', off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,outerFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)
self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@-node:ekr.20041222092032:(Tried using place to show widgets)
#@+node:ekr.20041224100539:(Replacing body pane)
#@+node:ekr.20041223130609:class componentBaseClass
class componentBaseClass:

    @others
#@nonl
#@+node:ekr.20041223154028: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    self.c = c
    self.frame = frame    # The Tk.Frame containing the component.
    self.isVisible = False # True if the component is visible.
    self.name = name      # The component's name: the key for c.frame.componentsDict.
    self.obj = obj        # Optional object (typically not a Tk.Frame.)
    self.packer = packer
    self.unpacker = unpacker

    c.frame.componentsDict[name] = self
#@nonl
#@-node:ekr.20041223154028: ctor
#@+node:ekr.20041223124910:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223124910:__repr__
#@+node:ekr.20041223154028.1:oops
def oops (self):
    
    print ("componentBaseClass oops:",
        g.callerName(2),
        "must be overridden in subclass")
#@-node:ekr.20041223154028.1:oops
#@+node:ekr.20041223154028.2:getters
# Getters...
def getFrame    (self): return self.frame
def getObject   (self): return self.obj
def getPacker   (self): return self.packer
def getUnpacker (self): return self.unpacker
#@-node:ekr.20041223154028.2:getters
#@+node:ekr.20041223154028.3:must be defined in subclasses
def destroy (self):
    self.oops()
#@nonl
#@-node:ekr.20041223154028.3:must be defined in subclasses
#@+node:ekr.20041224072245:show & hide, pack & unpack
# Pack always packs the widget, which can make it visble in two places.
# Show packs a new widget only if it is not visible.

def hide (self):
    if self.isVisible:
        self.isVisible = False
        self.unpack()

def pack (self):
    self.oops()
    
def show (self):
    if not self.isVisible:
        self.isVisible = True
        self.pack()
    
def unpack (self):
    self.oops()
    
#@-node:ekr.20041224072245:show & hide, pack & unpack
#@-node:ekr.20041223130609:class componentBaseClass
#@+node:ekr.20041223095751:class componentClass (componentBaseClass)
class componentClass (leoFrame.componentBaseClass):
    
    '''A class to manage components of Leo windows'''
    
    @others
#@nonl
#@+node:ekr.20041223095751.1: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    # Init the base class.
    leoFrame.componentBaseClass.__init__(
        self,c,name,frame,obj,packer,unpacker)
    
    self.setPacker(packer)
    self.setUnpacker(unpacker)
#@nonl
#@-node:ekr.20041223095751.1: ctor
#@+node:ekr.20041223154028.4:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223154028.4:__repr__
#@+node:ekr.20041223124022:destroy
def destroy (self):
    
    try:
        del c.frame.componentsDict[self.name]
    except KeyError:
        g.es("No component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041223124022:destroy
#@+node:ekr.20041223124022.1:getters & setters
# Setters...
def setPacker (self,packer):
    if not packer: # Define default packer.
        def packer():
            if self.frame:
                self.frame.pack(side='top',expand=1,fill='both')
    self.packer = packer

def setUnpacker (self,unpacker):
    if not unpacker: # Define default unpacker.
        def unpacker():
            if self.frame:
                self.frame.pack_forget()
    self.unpacker = unpacker
#@nonl
#@-node:ekr.20041223124022.1:getters & setters
#@+node:ekr.20041223095751.2:pack & unpack
def pack (self):

    self.packer()
    
def unpack (self):

    self.unpacker()
#@nonl
#@-node:ekr.20041223095751.2:pack & unpack
#@-node:ekr.20041223095751:class componentClass (componentBaseClass)
#@+node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223160653:pane packers
if 0: # placeSplitter and divideAnySplitter.
    << reference code >>

def placePane1(self,verticalFlag,pane1,frac):
    if verticalFlag:
        pane1.place(relx=0.5,rely=0,anchor="n",relwidth=1.0,relheight=frac)
    else:
        pane1.place(rely=0.5,relx=0,anchor="w",relheight=1.0,relwidth=frac)
        
def placePane2(self,verticalFlag,pane2,frac):
    if verticalFlag:
        pane2.place(relx=0.5,rely=1.0,anchor="s",relwidth=1.0,relheight=1-frac)
    else:
        pane2.place(rely=0.5,relx=1.0,anchor="e",relheight=1.0,relwidth=1-frac)

# These are the packers of the corresponding components.
# These are called from, packComponent('body'), etc.
def packBody (self):
    # Pane 2 of primary splitter.
    self.placePane2(self.splitVerticalFlag,self.split1Pane2,self.ratio)
def packLog (self):
    # Pane 2 of secondary splitter.
    self.placePane2(not self.splitVerticalFlag,self.split2Pane2,self.secondary_ratio)
def packTree (self):
    # Pane 1 of secondary splitter.
    self.placePane1(not self.splitVerticalFlag,self.split2Pane1,self.secondary_ratio)
#@nonl
#@+node:ekr.20041223165701:<< reference code >>
@ Reference code.  The placer code is a combination of these...
Most args come from placeSplitter.
The relheight/width args come from divideAnySplitter.
@c

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):
    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)

def placeSplitter (self,bar,pane1,pane2,verticalFlag):
    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@-node:ekr.20041223165701:<< reference code >>
#@-node:ekr.20041223160653:pane packers
#@+node:ekr.20041224102942:pane replacers
#@+node:ekr.20041224105456.1:replaceBodyPaneWithComponent
def replaceBodyPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packBody)
            component.setUnpacker(self.unpackBody)
            self.unpackComponent('body')
            self.split1Pane2 = f
            self.packBody()
#@nonl
#@-node:ekr.20041224105456.1:replaceBodyPaneWithComponent
#@+node:ekr.20041224105456.3:replaceLogPaneWithComponent
def replaceLogPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packLog)
            component.setUnpacker(self.unpackLog)
            self.unpackComponent('log')
            self.split2Pane2 = f
            self.packLog()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.3:replaceLogPaneWithComponent
#@+node:ekr.20041224105456.4:replaceTreePaneWithComponent
def replaceTreePaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packTree)
            component.setUnpacker(self.unpackTree)
            self.unpackComponent('tree')
            self.split2Pane1 = f
            self.packTree()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.4:replaceTreePaneWithComponent
#@-node:ekr.20041224102942:pane replacers
#@+node:ekr.20041223162512:pane unpackers
# These are the packers of the corresponding components.

def unpackBody(self):
    self.split1Pane2.place_forget()
    
def unpackLog(self):
    self.split2Pane2.place_forget()

def unpackTree(self):
    self.split2Pane1.place_forget()
#@nonl
#@-node:ekr.20041223162512:pane unpackers
#@+node:ekr.20041222061439:pack/unpackComponent
# Note: the 'packers' for the 'body', 'log' and 'tree' components are actually placers,
# so packing twice does not duplicate those component.

def packComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.pack()
    elif verbose:
        g.es("packComponent: no component named %s" % name,color='blue')

def unpackComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.unpack()
    elif verbose:
        g.es("unpackComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041222061439:pack/unpackComponent
#@+node:ekr.20041224072631:show/hideComponent
def hideComponent (self,name):
    component = self.component(name)
    if component:
        component.hide()
    else:
        g.es("hideComponent: no component named %s" % name,color='blue')

def showComponent (self,name):
    component = self.component(name)
    if component:
        component.show()
    else:
        g.es("showComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041224072631:show/hideComponent
#@+node:ekr.20041222061331:pack/unpack/FrameWidgets
if 0: # This obscure the generality of components.

    def packFrameWidgets (self):
        for name in ('splitter1','statusLine'):
            component = self.component(name)
            if component:
                component.pack()
                
    def unpackFrameWidgets (self):
        for name in ('splitter1','statusLine'):
            component = self.component(name)
            if component:
                component.unpack()
#@nonl
#@-node:ekr.20041222061331:pack/unpack/FrameWidgets
#@+node:ekr.20041222061331.1:unpackFrameWidgets


#@-node:ekr.20041222061331.1:unpackFrameWidgets
#@-node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@nonl
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    
def enable (self,background="white"):
    
    g.trace()
    t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@nonl
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@nonl
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20031218072017.3963:put
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put
#@+node:EKR.20040424154804:setFocus
def setFocus (self):
    
    t = self.textWidget
    if t:
        t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocus
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack
#@nonl
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@nonl
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update
def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col > 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)

    if self.enabled:
        self.setFocus()
#@nonl
#@-node:ekr.20031218072017.1733:update
#@-node:ekr.20041223104933:class statusLineClass
#@+node:ekr.20031218072017.3953:Icon area methods (compatibility)
def getIconBarObject(self):
    component = self.component(self.iconBarComponentName)
    if not component: return g.trace("No iconBar component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.iconBarComponentName))
                
def callIconBar(self,name,*args,**keys):
    obj = self.getIconBarObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.iconBarComponentName,name))

def addIconButton (self,*args,**keys):
    return self.callIconBar('add',*args,**keys)

def clearIconBar (self):
    return self.callIconBar('clear')

def createIconBar (self):
    self.callIconBar('show')
    return self.getIconBarObject() # For compatibility.

def hideIconBar (self):
    return self.callIconBar('hide')
#@nonl
#@-node:ekr.20031218072017.3953:Icon area methods (compatibility)
#@+node:ekr.20041223105114.1:Status line methods (compatibility)
def getStatusObject(self):
    component = self.component(self.statusLineComponentName)
    if not component: return g.trace("No statusLine component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.statusLineComponentName))
                
def callStatus(self,name,*args,**keys):
    obj = self.getStatusObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.statusLineComponentName,name))

def createStatusLine (self):
    self.callStatus('show')
    return self.getStatusObject() # For compatibility.

def clearStatusLine (self):
    return self.callStatus('clear')
    
def disableStatusLine (self,background=None):
    return self.callStatus('disable',background)

def enableStatusLine (self,background="white"):
    return self.callStatus('enable',background)

def getStatusLine (self):
    return self.callStatus('get')
    
def putStatusLine (self,s,color=None):
    return self.callStatus('put',s,color)
    
def setFocusStatusLine (self):
    return self.callStatus('setFocus')

def statusLineIsEnabled(self):
    return self.callStatus('isEnabled')
#@nonl
#@-node:ekr.20041223105114.1:Status line methods (compatibility)
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# Created in createLeoFrame and its allies.
self.top = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyCtrl = None
self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None 
self.iconFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.findPanel = None

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.controlKeyIsDown = False # For control-drags
self.revertHeadline = None # Previous headline text for abortEditLabel.
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,outerFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)
self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)
        
    self.canvas = canvas

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
import threading
import time

way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('<Shift Button-3>',exe)
    canvas.bind_all('<Shift Button-1>',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('<Shift ButtonRelease-1>', off)
    canvas.bind_all('<Shift ButtonRelease-3>', off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>', exe)
    canvas.bind_all( '<Button-1>', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '<ButtonRelease-1>', off)
    canvas.bind_all( '<ButtonRelease-3>', off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    if use_Pmw and Pmw:
        # g.trace(ratio,ratio2)
        self.ratio = ratio
        self.secondary_ratio = ratio2
        splitter1 = self.component('splitter1').getObject()
        splitter2 = self.component('splitter2').getObject()

        if self.splitVerticalFlag:
            # Use ratio to set splitter2 height.
            size = ratio * float(splitter1.winfo_height())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline width.
            size = ratio2 * float(splitter2.winfo_width())
            splitter2.configurepane('outline',size=int(size))
        else:
            # Use ratio to set splitter2 width.
            size = ratio * float(splitter1.winfo_width())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline height.
            size = ratio2 * float(splitter2.winfo_height())
            splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:ekr.20041224100539:(Replacing body pane)
#@-node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041228052058:12/28
#@+node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20041122094813:<<  baseConfig data >>
@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@nonl
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","unicode-encoding","utf-8"),
    ("new_leo_file_encoding","unicode-encoding","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","unicode-encoding",None),
        # Defaults to None so it doesn't override better defaults.
)
#@nonl
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the ivar with the same name.
ivarsDict = {'_hash':'ivarsDict'}

if 0: # From c.__init__
    # Global options
    c.tangle_batch_flag = False
    c.untangle_batch_flag = False
    # Default Tangle options
    c.tangle_directory = ""
    c.use_header_flag = False
    c.output_doc_flag = False
    # Default Target Language
    c.target_language = "python" # Required if leoConfig.txt does not exist.

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",False),
        # Should never be True here!
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  baseConfig data >>
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for ivar in g.app.config.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)
        
    for ivar in g.app.config.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,ivarName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.ivarsDict.get(munge(ivarName))
    ivar = bunch.ivar ; val = bunch.val

    # g.trace(self.c.hash(),bunch.toString())

    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,encodingName):
    
    munge = g.app.config.canonicalizeSettingName

    bunch = g.app.config.encodingIvarsDict.get(munge(encodingName))
    ivar = bunch.ivar ; encoding = bunch.encoding

    # g.trace(bunch.toString())
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
# Sets config ivars from c.
def setConfigIvars (self):
    
    c = self.c
    config = g.app.config
    
    g.trace()
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"

    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setPref("batch",str(c.batch_flag))
    self.setPref("ignore_case",str(c.ignore_case_flag))
    self.setPref("mark_changes",str(c.mark_changes_flag))
    self.setPref("mark_finds",str(c.mark_finds_flag))
    self.setPref("pattern_match",str(c.pattern_match_flag))
    self.setPref("reverse",str(c.reverse_flag))
    self.setPref("script_change",str(c.script_change_flag))
    self.setPref("script_search",str(c.script_search_flag))
    self.setPref("search_body",str(c.search_body_flag))
    self.setPref("search_headline",str(c.search_headline_flag))
    self.setPref("selection_only",str(c.selection_only_flag))
    self.setPref("suboutline_only",str(c.suboutline_only_flag))
    self.setPref("wrap",str(c.wrap_flag))
    self.setPref("whole_word",str(c.whole_word_flag))
    
    self.setPref("change_string",c.change_text)
    self.setPref("find_string",c.find_text)
#@nonl
#@-node:ekr.20041117062717.20:setConfigIvars  (Not used: Called only from prefs code)
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if p:
        pass
        # g.trace("updating @recent-files for ",c.mFileName)
    else:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # Update the @recent-files entry, leaving c's changed status untouched.
    changed = c.isChanged()
    body = '\n'.join(files)
    p.setBodyStringOrPane (body,encoding=g.app.tkEncoding)
    c.setChanged(changed)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,val):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",val)
#@nonl
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041120113848:doShortcut
def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120113848:doShortcut
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    rawKey = key.replace('&','') # Allow '&' in names.
    val = self.get(c,rawKey,"shortcut")
    if val is None:
         return rawKey,None
    else:
        # g.trace(key,val)
        return rawKey,val
#@nonl
#@-node:ekr.20041117062717.14:getShortcut (config)
#@-node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20041227081942:(Made ivars functional)
#@+node:ekr.20041228050029:What I did
@killcolor

- Created setIvarsFromSettings.
    - Called from end of readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init commmander ivars.

- leoPrefs.py and leoTkinterPrefs are no longer used.
#@nonl
#@-node:ekr.20041228050029:What I did
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        hash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if hash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# 4.1: for hoist/dehoist commands.
self.hoistStack = [] # Stack of nodes to be root of drawn tree.  Affects only drawing routines.

self.recentFiles = [] # 4.1: moved to commands class.  List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@-node:ekr.20041227081942:(Made ivars functional)
#@-node:ekr.20041228052058:12/28
#@-node:ekr.20041228053248:Diary
#@-node:ekr.20041115111203:Config...
#@+node:ekr.20041228052527.2:New features...
#@+node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
enable(menu,"Expand Or Go Right",hasChildren)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@nonl
#@-node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
 
    if v.hasChildren() and v.isExpanded():
        c.contractNode()
    elif v.hasParent():
        c.goToParent()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
    if not v.hasChildren(): return

    if v.isExpanded():
        c.beginUpdate()
        c.selectVnode(v.firstChild())
        c.endUpdate()
    else:
        c.expandNode()
#@nonl
#@-node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
#@-node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self,fromString=None):
        # New in 4.2.1: allow the file to be inited from string s.
        if fromString: self.list = g.splitLines(fromString) # Must preserve newlines!
        else: self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr < len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)
#@nonl
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041025145856.1:What I did
@killcolor

- Tab toggles between the Search to the Replace areas.
- Control-Tab inserts a tab.
- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  (The Enter key activates the Find button.)
- As usual, Alt-F4 dismisses the Find panel.

To do next:  allow all search settings and commands to be activated from the status line.
#@nonl
#@-node:ekr.20041025145856.1:What I did
#@+node:ekr.20041025152343:class underlinedTkButton
class underlinedTkButton(Tk.Checkbutton):
    
    @others
#@nonl
#@+node:ekr.20041025152712:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

	<< set self.hotKey if '&' is in the string >>
    
    # Create the button...
	if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20041025152712:__init__
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.callback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20041025152717:callback
# The hot key has been hit.  Call the button's command.

def callback (self, event):
    
    g.trace(self.text)

	self.button.invoke ()
#@-node:ekr.20041025152717:callback
#@-node:ekr.20041025152343:class underlinedTkButton
#@+node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3899:__init__
def __init__(self,c,resizeable=False,title=None):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,self.title,resizeable)

    << create the tkinter intVars >>
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.init(c) # New in 4.3: init only once.
    
    # g.trace(self.top)
#@nonl
#@+node:ekr.20031218072017.3900:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20031218072017.3900:<< create the tkinter intVars >>
#@-node:ekr.20031218072017.3899:__init__
#@+node:ekr.20031218072017.3901:destroySelf
def destroySelf (self):
    
    self.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3901:destroySelf
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("<1>",  self.resetWrap)
        widget.bind("<Key>", self.resetWrap)
        widget.bind("<Control-a>",self.selectAll)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    for widget in (outer, self.find_ctrl, self.change_ctrl):
        widget.bind("<Key-Return>", self.findButton)
        widget.bind("<Key-Escape>", self.onCloseWindow)
    
    self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)
<< Bind Tab and control-tab >>

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@+node:ekr.20041026092141:<< Bind Tab and control-tab >>
def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20041026092141:<< Bind Tab and control-tab >>
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&Script Search","script-search")]
checkLists[0] = [
    ("Scrip&t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&Whole Word",  self.dict["whole_word"]),
    ("&Ignore Case", self.dict["ignore_case"]),
    ("Wrap &Around", self.dict["wrap"]),
    ("&Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &Headline Text", self.dict["search_headline"]),
    ("Search &Body Text",     self.dict["search_body"]),
    ("&Mark Finds",           self.dict["mark_finds"]),
    ("Mark &Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=self.findButton) # The default.
findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
#@nonl
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting in (
    (self.find_ctrl,"find_text"),
    (self.change_ctrl,"change_text"),
):
    s = c.config.getString(setting)
    if s is None: s = ""
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@-node:ekr.20031218072017.3898:Birth & death
#@-node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
@ It's not clear that this support is so useful for debugging scripts...
#@nonl
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        import pdb ; pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except:
            << unredirect output >>
            g.es("exception executing script ")
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
#@+node:ekr.20041107093219:(Added support for Forth)
@nocolor

Forth support by David McNab, <david@freenet.org.nz>.

Changes by EKR:
    
- Look for extension files in plugins folder.
- Moved data structures into leoColor class.
- Suppress message about extra words during unit testing and in batch mode.
- Created this project node.

@color
#@nonl
#@+node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20041107094252:<< extend forth words from files >>
# Associate files with lists: probably no need to edit this.
forth_items = (
    (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
    (self.forth_keywords, "leo-forthwords.txt", "words"),
    (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
    (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
    (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
    (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
)

# Add entries from files (if they exist) and to the corresponding wordlists.
for (lst, path, typ) in forth_items:
    try:
        extras = []
        path = g.os_path_join(g.app.loadDir,"..","plugins",path) # EKR.
        for line in file(path).read().strip().split("\n"):
            line = line.strip()
            if line and line[0] != '\\':
                extras.append(line)
        if extras:
            if 0: # I find this annoying.  YMMV.
                if not g.app.unitTesting and not g.app.batchMode:
                    print "Found extra forth %s" % typ + ": " + " ".join(extras)
            lst.extend(extras)
    except IOError:
        # print "Not found",path
        pass
#@nonl
#@-node:ekr.20041107094252:<< extend forth words from files >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.1896:doNormalState
## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&<>' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&*()_+-={}|[];':\",./<>?")
    ):
        << handle possible keyword >>
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        << handle at keyword >>
    elif g.match(s,i,self.single_comment_start):
        << handle single-line comment >>
    elif g.match(s,i,self.block_comment_start):
        << start block comment >>
    elif ch == '%' and self.language=="cweb":
        << handle latex line >>
    elif self.language=="latex":
        << handle latex normal character >>
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        << handle string >>
    elif ch == '#' and self.has_pp_directives:
        << handle C preprocessor line >>
    elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        << handle special php keywords >>
    elif ch == ' ':
        << handle blank >>
    elif ch == '\t':
        << handle tab >>
    else:
        << handle normal character >>

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress < i)
    return i,state
#@nonl
#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
    << handle possible latex keyword >>
elif self.language == "html":
    << handle possible html keyword >>
elif self.language == "forth":
    << handle possible forth keyword >>
else:
    << handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
    if g.match(s,i,"<!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
    if g.match(s,i,"</"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,">"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@+node:ekr.20041107093219.3:<< handle possible forth keyword >>
j = self.skip_id(s,i+1,chars="`~!@#$%^&*()-_=+[]{};:'\\\",./<>?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
#@nonl
#@-node:ekr.20041107093219.3:<< handle possible forth keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@<"):
        << handle cweb ref or def >>
    else:
        word = self.getCwebWord(s,i)
        if word:
            << Handle cweb control word >>
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@>",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
    j = s.find("@>",i)
    if j > -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
# g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?>"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@-node:ekr.20031218072017.1896:doNormalState
#@-node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v
#@nonl
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@nonl
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041107094641:scanForthText
def scanForthText (self,s,parent):
    
    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    parent.setBodyStringOrPane("@ignore\n" + "@language forth\n" + self.rootLine + s)
#@nonl
#@-node:ekr.20041107094641:scanForthText
#@-node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@-node:ekr.20041107093219:(Added support for Forth)
#@+node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041111100436:Notes
@killcolor

What I did:

- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without this?

- Added sciptFind ivar and related logic to goToLineNumber and it allies.
#@nonl
#@-node:ekr.20041111100436:Notes
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        import pdb ; pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except:
            << unredirect output >>
            g.es("exception executing script ")
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,useSelectedText=True):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # Allow p not to be the present position.
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
            script = at.stringOutput
            # g.trace(script)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog("Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@-node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041111114148.1:What I did
Added the following back:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event

Added documentation for the following:
    


Added leoPlugins.unregisterHandler and getHandlersFor tag for testing.

#@-node:ekr.20041111114148.1:What I did
#@+node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111124831:getHandlersForTag
def getHandlersForTag(tags):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        result = []
        for tag in tags:
            fn = getHandlersForOneTag(tag)
            result.append((tag,fn),)
        return result
    else:
        return getHandlersForOneTag(tags)

def getHandlersForOneTag (tag):

    global handlers
    
    return handlers.get(tag)
#@nonl
#@-node:ekr.20041111124831:getHandlersForTag
#@+node:ekr.20041111123313:unregisterHandler
def unregisterHandler(tags,fn):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            unregisterOneHandler(tag,fn)
    else:
        unregisterOneHandler(tags,fn)

def unregisterOneHandler (tag,fn):

    global handlers

    fn_list = handlers.get(tag)
    if fn_list:
        while fn in fn_list:
            fn_list.remove(fn)
        handlers[tag] = fn_list
        # g.trace(handlers.get(tag))
#@nonl
#@-node:ekr.20041111123313:unregisterHandler
#@-node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111121907:Changed code
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""
    
    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    << set vdrag, childFlag >>
    if c.config.getBool("allow_clone_drags"):
        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
            self.controlDrag = c.frame.controlKeyIsDown

    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")
    
    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
if self.trace and self.verbose:
    g.trace("*** end drag   ***",\
        theId,x,y,p.headString(),vdrag.headString())
if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    if self.trace and self.verbose:
        g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    
    if self.trace and self.verbose: g.trace()
    p = self.eventToPosition(event)
    if not p: return

    if not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        if p.isExpanded(): p.contract()
        else:              p.expand()
        self.active = True
        # Schedule the redraw _before_ calling select.
        # This disables any call that would configure old text widgets.
        self.redraw()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
        gui.set_focus(c,c.frame.bodyCtrl)
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    tree = self ; canvas = tree.canvas
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivate(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@-node:ekr.20041111121907:Changed code
#@-node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041112062558:Added p=p param to all hooks containing v=v
@killcolor

Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",
#@nonl
#@-node:ekr.20041112062558:Added p=p param to all hooks containing v=v
#@+node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041121121900:What I did
@killcolor

- Removed createGlobalsWindows: Leo has no more global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.

- Ignore all find settings in getFindPanelSettings.  leoFind.init gets these from @settings.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, an allie of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.

@color
#@nonl
#@-node:ekr.20041121121900:What I did
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting in (
    (self.find_ctrl,"find_text"),
    (self.change_ctrl,"change_text"),
):
    s = c.config.getString(setting)
    if s is None: s = ""
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@+node:ekr.20031218072017.1460:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    s = self.find_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = g.toUnicode(s,g.app.tkEncoding)
    self.find_text = s

    s = self.change_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20031218072017.1460:find.update_ivars
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):
    
    if self.getOpenTag("<find_panel_settings"):
        return # <find_panel_settings/> seen.
    
    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag(">"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only <find_string> or <find_string/>
    if self.getOpenTag("<find_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</find_string>")
    # Allow only <change_string> or <change_string/>
    if self.getOpenTag("<change_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</change_string>")
    self.getTag("</find_panel_settings>")
#@nonl
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@-node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041219065925:Notes
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2871977

- (done) created g.app.extensionsDir

- (done) created g.importModule and g.importExtension.

Now you can put Pmw into the extensions directory and have Leo easily import it from there.

Doing so gives you a way to add Pmw easily and any other 3rd party libs Leo ever needs.
#@nonl
#@-node:ekr.20041219065925:Notes
#@+node:ekr.20041219095213:import wrappers
@ Warning:

These functions use imp.load_module, and that is equivalent to reload!

Calling any of these functions to reload Leo files will crash Leo!
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    try:
        theFile = None ; module = None
        import imp
        try:
            data = imp.find_module(moduleName) # This can open the file.
            theFile,pathname,description = data
            module = imp.load_module(moduleName,theFile,pathname,description)
        except ImportError:
            g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
        except:
            g.es("unexpected exception in g.import",color='blue')
            g.es_exception()
    finally:
        if theFile: theFile.close()

    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    # g.trace(verbose,name,pluginName)

    try:
        theFile = None ; data = None ; result = None
        import imp
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                pass
            if data:
                theFile,pathname,description = data
                try:
                    result = imp.load_module(mod_name,theFile,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()
        
    if not result:
        g.cantImport(mod_name,pluginName=pluginName,verbose=verbose)
    return result
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    << compute directories >>
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.config()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416:<< compute directories >>
g.app.loadDir = computeLoadDir()
    # Depends on g.app.tkEncoding: uses utf-8 for now.

g.app.homeDir = computeHomeDir()

g.app.extensionsDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','extensions'))

g.app.globalConfigDir = computeGlobalConfigDir()
#@nonl
#@-node:ekr.20041219072416:<< compute directories >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
     print "Error importing leoNodes.py"

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog("Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    import leoGlobals as g
    
    encoding = startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=dotDir)
    if len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=dotDir)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,dir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,dir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@-node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@+node:ekr.20041231112215.1:Original posting
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2915750
By: cmbanker

The HOME environment variable on windows machines is often a referrence to yet
another environment variable.  i.e.  %HOME% --> %USERENVIRONMENT% --> "C:\Documents
and Settings\...."

The fix: Patch computeHomeDir() to test the first retrieval of the %HOME% var and grab
it's results if it is infact another enviroment variable.

@color

def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    
    home = os.getenv('HOME',default=dotDir)
    
    #verify that we've not got an indirect reference to true home
    if (home[0]=='%') and ( home[-1]=='%'):
	    #yep, must be a win32 machine - get this one
	    home = os.getenv(home[1:-1],default=dotDir)


    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@-node:ekr.20041231112215.1:Original posting
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=dotDir)
    if len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=dotDir)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@-node:ekr.20041228052527.2:New features...
#@+node:ekr.20041228052527.3:Plugins...
#@+node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041002160323:What I did
@

Improved status_line.py in leoPlugins.leo
#@nonl
#@-node:ekr.20041002160323:What I did
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# Created in createLeoFrame and its allies.
self.top = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyCtrl = None
self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None 
self.iconFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.findPanel = None

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.controlKeyIsDown = False # For control-drags
self.revertHeadline = None # Previous headline text for abortEditLabel.
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,outerFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)
self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)
        
    self.canvas = canvas

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
import threading
import time

way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('<Shift Button-3>',exe)
    canvas.bind_all('<Shift Button-1>',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('<Shift ButtonRelease-1>', off)
    canvas.bind_all('<Shift ButtonRelease-3>', off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>', exe)
    canvas.bind_all( '<Button-1>', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '<ButtonRelease-1>', off)
    canvas.bind_all( '<ButtonRelease-3>', off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    if use_Pmw and Pmw:
        # g.trace(ratio,ratio2)
        self.ratio = ratio
        self.secondary_ratio = ratio2
        splitter1 = self.component('splitter1').getObject()
        splitter2 = self.component('splitter2').getObject()

        if self.splitVerticalFlag:
            # Use ratio to set splitter2 height.
            size = ratio * float(splitter1.winfo_height())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline width.
            size = ratio2 * float(splitter2.winfo_width())
            splitter2.configurepane('outline',size=int(size))
        else:
            # Use ratio to set splitter2 width.
            size = ratio * float(splitter1.winfo_width())
            splitter1.configurepane('splitter2Frame',size=int(size))
            # Use ratio2 to set outline height.
            size = ratio2 * float(splitter2.winfo_height())
            splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041022083005:(More flexible plugin manager)
# See @button Configurator in test.leo for the motivating example.
#@nonl
#@+node:ekr.20041114113029:getPluginModule
def getPluginModule (moduleName):
    
    global loadedModules
    
    return loadedModules.get(moduleName)
#@nonl
#@-node:ekr.20041114113029:getPluginModule
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    result = g.importFromPath(moduleName,plugins_path)
    if result:
        loadedModules[moduleName] = result
    
    if verbose:
        if result is None:
            g.es("can not load %s plugin" % moduleName,color="blue")
        else:
            g.es("loaded %s plugin" % moduleName,color="blue")
    
    return result
#@nonl
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20041022083005:(More flexible plugin manager)
#@+node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101065403.1:What I did
@killcolor

*** Alas, using g.importExtension does not seem to work properly with Tkinter.

- plugins_menu.py now checks at runtime to see if the plugin has been successfully loaded before calling the topLevelMenu() function.

- Added pluginName keyword arg to g.importX functions.

    - All such functions now have pluginName and verbose keyword args.

- Used g.cantImport to print all messages in g.importX functions.
#@nonl
#@-node:ekr.20050101065403.1:What I did
#@+node:ekr.20041219095213:import wrappers
@ Warning:

These functions use imp.load_module, and that is equivalent to reload!

Calling any of these functions to reload Leo files will crash Leo!
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    try:
        theFile = None ; module = None
        import imp
        try:
            data = imp.find_module(moduleName) # This can open the file.
            theFile,pathname,description = data
            module = imp.load_module(moduleName,theFile,pathname,description)
        except ImportError:
            g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
        except:
            g.es("unexpected exception in g.import",color='blue')
            g.es_exception()
    finally:
        if theFile: theFile.close()

    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    # g.trace(verbose,name,pluginName)

    try:
        theFile = None ; data = None ; result = None
        import imp
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                pass
            if data:
                theFile,pathname,description = data
                try:
                    result = imp.load_module(mod_name,theFile,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()
        
    if not result:
        g.cantImport(mod_name,pluginName=pluginName,verbose=verbose)
    return result
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@-node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1930, in doHook
    return None # No return value
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 34, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 135, in doHandlersForTag
    ret = handle_fn(tag,keywords)
  File "C:\prog\leoCVS\leo\plugins\at_view.py", line 97, in icondclick2
    hs = self.current.headString()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 5110, in currentPosition
    if c._currentPosition:
AttributeError: Commands instance has no attribute '_currentPosition'
#@nonl
#@+node:ekr.20050101144712:Notes
@killcolor

Created callTagHandler.

This checks 'idle' hooks to make sure that any commander referenced by the 'c','new_c' or 'old_c' keywords still exists.
#@-node:ekr.20050101144712:Notes
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (handler,tag,keywords):
    
    if tag == 'idle':
        # Make sure all commanders exist.
        for key in ('c','old_c','new_c'):
            c = keywords.get(key)
            if c:
                try:
                    if c.frame not in g.app.windowList:
                        return None # c has (or will be) destroyed.
                except AttributeError:
                    # c has been destroyed: c.frame ivar does not exist.
                    return None

    return handler(tag,keywords)
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        handle_fns = handlers[tag]
        handle_fns.sort()
        for handler in handle_fns:
            return callTagHandler(handler,tag,keywords)

    if handlers.has_key("all"):
        handle_fns = handlers["all"]
        handle_fns.sort()
        for handler in handle_fns:
            return callTagHandler(handler,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()
    return doHandlersForTag(tag,keywords)
#@nonl
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0"
            print s ; g.es(s,color="blue")
        return None

    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
            
    # Get the hook handler function.  Usually this is doPlugins.
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    if 0: # Don't use trace here!
        if 1:
            old_c = keywords.get('old_c')
            if old_c: print 'doHook %24s %s' % (tag,old_c.shortFileName())
        else:
            if tag != "idle": print 'doHook %24s old_c: %s' % (tag,c and c.shortFileName())
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
#@-node:ekr.20041228052527.3:Plugins...
#@-node:ekr.20040929081120:4.3 a1 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
