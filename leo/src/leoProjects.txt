#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20051029070945:Pychecker report
# None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found
#@nonl
#@-node:ekr.20051029070945:Pychecker report
#@+node:ekr.20060203112912.1:Initing
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@nonl
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("<Activate>",f.OnActivateLeoEvent)
        f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
        f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
        f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20050920085536.1: Birth (keyHandler)
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
#@nonl
#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20060115195302:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)
#@nonl
#@-node:ekr.20060115195302:setDefaultUnboundKeyAction
#@-node:ekr.20050920085536.1: Birth (keyHandler)
#@-node:ekr.20060203112912.1:Initing
#@+node:ekr.20060204105811:Recent
#@+node:ekr.20060207194124:Commands with recent problems
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False,scroll=True)
        c.editPosition(p)

    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20060207194124:Commands with recent problems
#@+node:ekr.20031218072017.1588:Garbage Collection
# debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
#@+node:ekr.20060127162818:enable_gc_debug
def enable_gc_debug(event=None):
    
    if gc:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            gc.DEBUG_LEAK | # Same as all below.
            gc.DEBUG_COLLECTABLE |
            gc.DEBUG_UNCOLLECTABLE |
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS |
            gc.DEBUG_SAVEALL
        )
        g.app.trace_gc_inited = True
    else:
        es('Can not import gc module',color='blue')
#@nonl
#@-node:ekr.20060127162818:enable_gc_debug
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20060205043324:Called from commands
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage():
    
    if not g.app.trace_gc: return
    
    if not g.app.trace_gc_inited:
        g.enable_gc_debug()
    
    if not g.app.trace_gc_inited:
        g.app.trace_gc = False
    
    try:
        g.es_print('Collecting garbage',color='red')
        gc.collect()
    except: pass
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20060205043324.1:printGcSummary
def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    # g.collectGarbage()
    enable_gc_debug

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()
#@nonl
#@-node:ekr.20060205043324.1:printGcSummary
#@+node:ekr.20060202161935:printGcAll
def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20060127164729.1:printGcObjects
def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        << print number of each type of object >>
        if 0:
            << print added functions >>

    except:
        traceback.print_exc()
#@nonl
#@+node:ekr.20040703065638:<< print added functions >>
import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}
#@nonl
#@-node:ekr.20040703065638:<< print added functions >>
#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}
#@nonl
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@-node:ekr.20060127164729.1:printGcObjects
#@+node:ekr.20060127165509:printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))
#@nonl
#@-node:ekr.20060127165509:printGcVerbose
#@-node:ekr.20060205043324:Called from commands
#@+node:ekr.20060205043324.2:Called from unit tests
#@+node:ekr.20031218072017.1592:printGc
def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))
#@nonl
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1592:printGc
#@-node:ekr.20060205043324.2:Called from unit tests
#@-node:ekr.20031218072017.1588:Garbage Collection
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind (the findHandler)
class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@nonl
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    self.c = c
    self.k = c.k
    self.finder = finder
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@nonl
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:setOption
def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124122844:setOption
#@+node:ekr.20060125082510:getOption
def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        if verbose:
             g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@nonl
#@-node:ekr.20060125082510:getOption
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@nonl
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060124135401:toggleOption
def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124135401:toggleOption
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)
#@nonl
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)
#@nonl
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060124134356: setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@nonl
#@-node:ekr.20060124134356: setupArgs
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@nonl
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@nonl
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        
#@nonl
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel()
    k.getArg(event,tag,1,handler,completion=False,prefix=prefix)
#@nonl
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@nonl
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    self.setupSearchPattern(pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@nonl
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search Backward:',self.reSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search:',self.reSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search Backward: ',self.searchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search: ',self.searchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(event,tag,'Search: ',self.searchWithPresentOptions)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind (the findHandler)
#@+node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
#@nonl
#@+node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.11:__init__
def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    << create the tkinter intVars >>
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20051020120306.12:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20051020120306.12:<< create the tkinter intVars >>
#@-node:ekr.20051020120306.11:__init__
#@+node:ekr.20051023181449:createBindings (findTab)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        k.masterKeyHandler(event)

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    self.findButtonCallback),
        ("<Escape>",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
#@nonl
#@-node:ekr.20051023181449:createBindings (findTab)
#@+node:ekr.20051020120306.13:createFrame (findTab)
def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    
    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole &Word", self.dict["whole_word"]),
    ("&Ignore Case",self.dict["ignore_case"]),
    ("Wrap &Around",self.dict["wrap"]),
    ("&Reverse",    self.dict["reverse"]),
    ('Rege&xp',     self.dict['pattern_match']),
    ("Mark &Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.dict["search_headline"]),
    ("Search &Body",     self.dict["search_body"]),
    ("Mark &Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (findTab)
#@+node:ekr.20051020120306.19:find.init
def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20051020120306.20:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20051020120306.20:<< set find/change widgets >>
#@+node:ekr.20051020120306.21:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
#@nonl
#@-node:ekr.20051020120306.21:<< set radio buttons from ivars >>
#@-node:ekr.20051020120306.19:find.init
#@-node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.22:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20051020120306.22:find.update_ivars
#@+node:ekr.20051023183028:findButtonCallback
def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'
#@nonl
#@-node:ekr.20051023183028:findButtonCallback
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@nonl
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s.endswith('\n'): s = s[:-1]
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@nonl
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
#@nonl
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051020120306.25:hideTab
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@+node:ekr.20051020120306.27:selectAllFindText
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"
#@nonl
#@-node:ekr.20051020120306.27:selectAllFindText
#@+node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@nonl
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@nonl
#@+node:ekr.20050920084036.258: ctor
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
#@nonl
#@-node:ekr.20050920084036.258: ctor
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@nonl
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@nonl
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@nonl
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere     (self, event): return self.setFindScope('entire-outline')
def setFindScopeNodeOnly       (self, event): return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event): return self.setFindScope('suboutline-only')

def setFindScope (self, where): self.getHandler().setFindScope(where)

def showFindOptions      (self,event): self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event): return self.toggleOption('ignore_case')
def toggleMarkChangesOption    (self, event): return self.toggleOption('mark_changes')
def toggleMarkFindsOption      (self, event): return self.toggleOption('mark_finds')
def toggleRegexOption          (self, event): return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event): return self.toggleOption('reverse')
def toggleSearchBodyOption     (self, event): return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event): return self.toggleOption('search_headline')
def toggleWholeWordOption      (self, event): return self.toggleOption('whole_word')
def toggleWrapSearchOption     (self, event): return self.toggleOption('wrap')

def toggleOption (self, ivar): self.getHandler().toggleOption(ivar)
#@nonl
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def cloneFindAll       (self,event): self.getHandler().cloneFindAll(event)
def findAll            (self,event): self.getHandler().findAll(event)

def replaceString      (self,event): self.getHandler().replaceString(event)
def reSearchBackward   (self,event): self.getHandler().reSearchBackward(event)
def reSearchForward    (self,event): self.getHandler().reSearchForward(event)
def searchBackward     (self,event): self.getHandler().searchBackward(event)
def searchForward      (self,event): self.getHandler().searchForward(event)
def wordSearchBackward (self,event): self.getHandler().wordSearchBackward(event)
def wordSearchForward  (self,event): self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    self.getHandler().searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)
#@nonl
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()
#@nonl
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler & helper
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '<Control-s>':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '<Control-r>':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        i = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if i:
            self.searchString = s
        else:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)
#@nonl
#@-node:ekr.20050920084036.264:iSearchStateHandler & helper
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@nonl
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    
    self.searchString = pattern
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
   
    try:
        i = None
        if forward:
            i = w.search(pattern,"insert + 1c",stopindex='end',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the top of the buffer.
                    i = w.search(pattern,'1.0',stopindex='insert',regexp=regexp)
        else:
            i = w.search(pattern,'insert',backwards=True,stopindex='1.0',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the bottom of the buffer.
                    i = w.search(pattern,'end',backwards=True,stopindex='insert',regexp=regexp)
    except: pass
        
    # Don't call endSearch here.  We'll do that when the user hits return.
    if i and not i.isspace():
        w.mark_set('insert',i)
        w.see('insert')
#@nonl
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20060210103358:c.invalidateFocus
def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    
#@-node:ekr.20060210103358:c.invalidateFocus
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@nonl
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@nonl
#@-node:ekr.20060208143543:c.restoreFocus
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))
#@nonl
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060205111103:c.widget_name
def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)
#@nonl
#@-node:ekr.20060205111103:c.widget_name
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@nonl
#@-node:ekr.20050120092028:c.xWantsFocus
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others
#@nonl
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        g.trace()
        self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@nonl
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@nonl
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@nonl
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@nonl
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@nonl
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@nonl
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
        
setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return self.c.get_focus() == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@nonl
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    c = self.c
    
    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
        self.logCtrl.update_idletasks()
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t and t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    << Create the tab's text widget >>

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
t = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: t.configure(bg=bg)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=t)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = t

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
    
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20060204124347:hideTab
def hideTab (self,tabName):
    
    __pychecker__ = '--no-argsused' # tabName
    
    self.selectTab('Log')
#@nonl
#@-node:ekr.20060204124347:hideTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):
    
    return self.tabName
#@nonl
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    text = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClick3Handler),
    ):
        text.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        g.trace()
        self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        g.trace()
        self.onClick(event,tabName)
    
    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@+node:ekr.20060129052538.1:Master event handlers (keyHandler)
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):
    
    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(wname,func and func.__name__)

    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        try:
            i = w.index('@%s,%s' % (event.x,event.y))
            g.app.gui.setTextSelection (w,i,i,insert=i)
            c.editCommands.setMoveCol(w,i)
            c.frame.updateStatusLine()
        except Exception:
            pass

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None
        
masterClick3Handler         = masterClickHandler
masterDoubleClick3Handler   = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@+node:ekr.20060131084938:masterDoubleClickHandler
def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        g.app.gui.setTextSelection(w,i+' wordstart',i+' wordend')
        return 'break'
#@nonl
#@-node:ekr.20060131084938:masterDoubleClickHandler
#@+node:ekr.20060128090219:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    
    if 1:
        if not g.app.unitTesting:
            g.trace(c.widget_name(w))
    
    return k.masterCommand(event,func,stroke,commandName)
#@nonl
#@-node:ekr.20060128090219:masterMenuHandler
#@-node:ekr.20060129052538.1:Master event handlers (keyHandler)
#@-node:ekr.20060204105811:Recent
#@+node:ekr.20060208080524:4.4b2 projects
#@+node:ekr.20060206062108.1:What I did: 2-6-05
@nocolor

- Ran Leo with Python23 to test memory allocation.

- Call update_idletasks when writing to the log.

- Fixed several tree bugs.

- Updated selection point immediately in masterKeyHandler.
  Otherwise, updateStatusLine would be one click behind.
#@nonl
#@-node:ekr.20060206062108.1:What I did: 2-6-05
#@+node:ekr.20060207091145:Fixed undo problem in headlines
#@+node:ekr.20060207110408:Notes
@nocolor

In the new drawing scheme, tree.redraw_now always calls c.endEditing, which
calls tree.onHeadChanged. The effect of this was to reverse the action of
undo/redoNodeContents.

The solution was to change the edit widget directly before calling
tree.redraw_now. To do this, I created the new tree.setHeadline method.
#@nonl
#@-node:ekr.20060207110408:Notes
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.trace_gc:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""
    
    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget'))

    if p and p.edit_widget():
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        if self.trace_edit and not g.app.unitTesting:
            if changed:
                g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@nonl
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.
    
    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@nonl
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20060207101443:tree.setHeadline (new in 4.4b2)
def setHeadline (self,p,s):
    
    '''Set the actual text of the headline widget.
    
    This is called from the undo/redo logic to change the text before redrawing.'''
    
    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete('1.0','end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert('1.0',s)
        self.revertHeadline = s
        # g.trace(repr(s),w.get('1.0','end'))
    else:
        g.trace('-'*20,'oops')
#@nonl
#@-node:ekr.20060207101443:tree.setHeadline (new in 4.4b2)
#@-node:ekr.20060207091145:Fixed undo problem in headlines
#@+node:ekr.20060207135120:Created c.masterFocusHandler and made it work
#@+node:ekr.20060207164200:What I did
@nocolor

* Found the reason why focus was *still* sticking in the outline pane:
    - The click handlers must return 'break', not continue.
    - However, OnActivateHeadline must return 'continue' when the headline is active
      so that Tk will handle the click properly.

- UNL does not seem to be causing problems.

- No need to save/restore focus in status line.

- Added several new traces to tkTree class.

* tree.redraw_now now ends editing properly. This fixes lots of bugs. In
particular, it avoid any chance that p.edit_widget won't correspond to the
present position.

- k.masterClickHandler calls tree.OnDeactivate() if there is no callback function.
  This solves most headline focus problems, provided that all panes bind clicks to k.masterClickHandler.

- toggle-active-pane now ends editing properly.

- insert-headline now calls c.editPosition after calling c.endUpdate().
#@nonl
#@-node:ekr.20060207164200:What I did
#@+node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.16:__init__ (tkTree)
def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    # Configuration and debugging settings.
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')
    self.expanded_click_area    = c.config.getBool("expanded_click_area")
    
    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_gc               = c.config.getBool('trace_gc')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []
#@nonl
#@+node:ekr.20040803072955.17:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@nonl
#@-node:ekr.20040803072955.17:<< define drawing constants >>
#@+node:ekr.20040803072955.18:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw_now)
#@nonl
#@-node:ekr.20040803072955.18:<< old ivars >>
#@+node:ekr.20040803072955.19:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@nonl
#@-node:ekr.20040803072955.19:<< inject callbacks into the position class >>
#@-node:ekr.20040803072955.16:__init__ (tkTree)
#@+node:ekr.20051024102724:tkTtree.setBindings
def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    << make bindings for a common binding widget >>

    self.canvas.bind('<Key>',k.masterKeyHandler)
    self.canvas.bind('<Button-1>',self.onTreeClick)

    << make bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20060131173440:<< make bindings for a common binding widget >>
self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('<Key>',k.masterKeyHandler)

table = (
    ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
    ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()
#@nonl
#@-node:ekr.20060131173440:<< make bindings for a common binding widget >>
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)
#@nonl
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@-node:ekr.20051024102724:tkTtree.setBindings
#@+node:ekr.20040803072955.21:injectCallbacks
def injectCallbacks(self):
    
    << define tkinter callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others

#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""
    
    p = self ; c = p.c
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@nonl
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@nonl
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:injectCallbacks
#@-node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.72:checkWidgetList
def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True
#@nonl
#@-node:ekr.20040803072955.72:checkWidgetList
#@+node:ekr.20040803072955.73:dumpWidgetList
def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t
#@nonl
#@-node:ekr.20040803072955.73:dumpWidgetList
#@+node:ekr.20040803072955.75:edit_widget
def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.
#@nonl
#@-node:ekr.20040803072955.75:edit_widget
#@+node:ekr.20040803072955.74:eventToPosition
def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops: eventToPosition failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None
#@nonl
#@-node:ekr.20040803072955.74:eventToPosition
#@+node:ekr.20040803072955.76:findEditWidget
def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c

    if p and c:
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            t,theId = aTuple
            # if self.trace: g.trace('%4d' % (theId),self.textAddr(t),p.headString())
            return t
        else:
            # g.trace('oops: not found',p)
            return None

    # g.trace(not found',p.headString())
    return None
#@nonl
#@-node:ekr.20040803072955.76:findEditWidget
#@+node:ekr.20040803072955.109:findVnodeWithIconId
def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
#@nonl
#@-node:ekr.20040803072955.109:findVnodeWithIconId
#@-node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event,p=None):
    
    c = self.c ; p1 = c.currentPosition()
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@nonl
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    
    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        if self.trace_edit and not g.app.unitTesting:
            if changed:
                g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):
    
    c = self.c ; tree = self
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return 'break'
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):
    
    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
        
    return returnVal
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.85:configureTextState
def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20040803072955.85:configureTextState
#@+node:ekr.20040803072955.86:onCtontrolT
# This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"
#@nonl
#@-node:ekr.20040803072955.86:onCtontrolT
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@nonl
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.
    return 'continue'
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.108:tree.OnDeactivate
def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    
    # g.trace(g.callers())
   
    c.beginUpdate()
    try:
        tree.endEditLabel()
        tree.dimEditLabel()
    finally:
        c.endUpdate(False)
#@nonl
#@-node:ekr.20040803072955.108:tree.OnDeactivate
#@+node:ekr.20040803072955.110:tree.OnPopup & allies
def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline.
    
    This is *not* an event handler: it is called from other event handlers."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@nonl
#@+node:ekr.20040803072955.111:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()
#@nonl
#@-node:ekr.20040803072955.111:OnPopupFocusLost
#@+node:ekr.20040803072955.112:createPopupMenu
def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    << Create the menu table >>
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
#@nonl
#@+node:ekr.20040803072955.113:<< Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
#@nonl
#@-node:ekr.20040803072955.113:<< Create the menu table >>
#@-node:ekr.20040803072955.112:createPopupMenu
#@+node:ekr.20040803072955.114:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())
#@nonl
#@+node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True
#@nonl
#@-node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20040803072955.114:enablePopupMenuItems
#@+node:ekr.20040803072955.116:showPopupMenu
def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("<FocusOut>",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.widgetWantsFocus(menu)
#@nonl
#@-node:ekr.20040803072955.116:showPopupMenu
#@-node:ekr.20040803072955.110:tree.OnPopup & allies
#@+node:ekr.20051022141020:onTreeClick
def onTreeClick (self,event=None):
    
    '''Handle an event in the tree canvas, outside of any tree widget.'''
    
    c = self.c

    c.treeWantsFocusNow()
    
    return 'break'
#@nonl
#@-node:ekr.20051022141020:onTreeClick
#@-node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20060207135120:Created c.masterFocusHandler and made it work
#@+node:ekr.20060207103936:setInputState is messing with body focus
#@+node:ekr.20031218072017.3995:Tk bindings...
def bringToFront (self):
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl
        
def getTitle (self):
    return self.top.title()
    
def setTitle (self,title):
    return self.top.title(title)
    
def get_window_info(self):
    return g.app.gui.get_window_info(self.top)
    
def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()
    
def lift (self):
    self.top.lift()
    
def update (self):
    self.top.update()
#@nonl
#@-node:ekr.20031218072017.3995:Tk bindings...
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20060120200818:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
#@nonl
#@-node:ekr.20060120200818:setInputState
#@+node:ekr.20060120193743:showStateAndMode
def showStateAndMode(self):
    
    k = self ; c = k.c ; frame = c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
            
        # Restore the focus.
        c.restoreFocus()
#@nonl
#@-node:ekr.20060120193743:showStateAndMode
#@-node:ekr.20060207103936:setInputState is messing with body focus
#@+node:ekr.20060206165304:Fixed focus-after-find bugs
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20060210103358:c.invalidateFocus
def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    
#@-node:ekr.20060210103358:c.invalidateFocus
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@nonl
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@nonl
#@-node:ekr.20060208143543:c.restoreFocus
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))
#@nonl
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060205111103:c.widget_name
def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)
#@nonl
#@-node:ekr.20060205111103:c.widget_name
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@nonl
#@-node:ekr.20050120092028:c.xWantsFocus
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t and t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    << Create the tab's text widget >>

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
t = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: t.configure(bg=bg)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=t)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = t

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
    
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20060204124347:hideTab
def hideTab (self,tabName):
    
    __pychecker__ = '--no-argsused' # tabName
    
    self.selectTab('Log')
#@nonl
#@-node:ekr.20060204124347:hideTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):
    
    return self.tabName
#@nonl
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    text = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClick3Handler),
    ):
        text.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        g.trace()
        self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        g.trace()
        self.onClick(event,tabName)
    
    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.3907:bringToFront
def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()
    c.widgetWantsFocusNow(t)
    
    # Apparently, the text can not be adjusted unless the widget has focus...
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # New in 4.3: don't highlight the stupid added trailing newline!
    gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
#@nonl
#@-node:ekr.20031218072017.3907:bringToFront
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    
    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
    
    #g.trace(c.widget_name(t))
    
    if 1: # I prefer always putting the focus in the body.
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
#@nonl
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20060206165304:Fixed focus-after-find bugs
#@+node:ekr.20060208064636:Fixed recent blunder so click in headline works
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""
    
    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget'))

    if p and p.edit_widget():
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
        
    return returnVal
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@nonl
#@-node:ekr.20040803072955.87:onHeadlineClick
#@-node:ekr.20060208064636:Fixed recent blunder so click in headline works
#@+node:ekr.20060206124634:Fixed tree icon bug
#@+node:ekr.20060208081656:Notes
@nocolor

Backspace in empty body text sometimes moved focus to canvas, and sometimes
improperly drew icon.

Made several fixes to onBodyChanged. There was no test for unchanged text! This
could have created all sorts of problems for undo.
#@nonl
#@-node:ekr.20060208081656:Notes
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    # ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if 0:
        g.trace('removeTrailing',removeTrailing,'changed',changed,
            'ch',repr(ch),'newText',repr(newText),'oldText',repr(oldText),
            g.callers())
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@-node:ekr.20060206124634:Fixed tree icon bug
#@+node:ekr.20060208195315:Added unit tests for key dicts
@ This revealed several problems:
    
- Most find dialog commands do not actually exist. All find commands except
open-find-dialog actuall refer to the find tab.

- Severl other minor shortcut problems.
#@nonl
#@-node:ekr.20060208195315:Added unit tests for key dicts
#@+node:ekr.20060209042734:Improved restore-focus logic when updating status line
#@+node:ekr.20031218072017.2817: doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and (
        c.config.getBool('trace_doCommand') or
        c.config.getBool('trace_gc') and (self.command_count % 10) == 0
    ):
        commandName = command and command.__name__
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            c.inCommand = False
            if c and c.exists: # Be careful: the command could destroy c.
                c.k.funcReturn = val
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()
                    
        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.
#@nonl
#@-node:ekr.20031218072017.2817: doCommand
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20060210103358:c.invalidateFocus
def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    
#@-node:ekr.20060210103358:c.invalidateFocus
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@nonl
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@nonl
#@-node:ekr.20060208143543:c.restoreFocus
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))
#@nonl
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060205111103:c.widget_name
def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)
#@nonl
#@-node:ekr.20060205111103:c.widget_name
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@nonl
#@-node:ekr.20050120092028:c.xWantsFocus
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20060120193743:showStateAndMode
def showStateAndMode(self):
    
    k = self ; c = k.c ; frame = c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
            
        # Restore the focus.
        c.restoreFocus()
#@nonl
#@-node:ekr.20060120193743:showStateAndMode
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@nonl
#@-node:ekr.20060208143543:c.restoreFocus
#@-node:ekr.20060209042734:Improved restore-focus logic when updating status line
#@+node:ekr.20060209083424:Fixed problem with 'spelling' of menu bindings
#@+node:ekr.20060201083154:k.prettyPrintKey
def prettyPrintKey (self,stroke):
    
    s = stroke and stroke.strip().lstrip('<').rstrip('>')
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '<%s>' % s
#@nonl
#@-node:ekr.20060201083154:k.prettyPrintKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('<').rstrip('>')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20060209083424:Fixed problem with 'spelling' of menu bindings
#@+node:ekr.20060122193554:Set remembered column properly in prev-line and next-line
#@+node:ekr.20060209094610:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3549737

for extend selection,
with binding to arrow keys,
if you switch from up to dn arrow,
the selection restarts again.
this should just change extend direction
while still using the same selection.
#@-node:ekr.20060209094610:Report
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):
    
    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(wname,func and func.__name__)

    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        try:
            i = w.index('@%s,%s' % (event.x,event.y))
            g.app.gui.setTextSelection (w,i,i,insert=i)
            c.editCommands.setMoveCol(w,i)
            c.frame.updateStatusLine()
        except Exception:
            pass

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None
        
masterClick3Handler         = masterClickHandler
masterDoubleClick3Handler   = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'<',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        # Don't change the moveCol while extending: that would mess up the selection.
        if setSpot or not moveSpot:
            self.setMoveCol(w,spot)
        g.app.gui.setTextSelection(w,spot,spot,insert=None)
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    self.moveSpot = spot
    self.moveCol = int(spot.split('.')[1])

    # g.trace('spot',self.moveSpot,'col',self.moveCol)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@+node:ekr.20050929114218:move... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'<',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        # Don't change the moveCol while extending: that would mess up the selection.
        if setSpot or not moveSpot:
            self.setMoveCol(w,spot)
        g.app.gui.setTextSelection(w,spot,spot,insert=None)
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'<',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'>',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    self.moveSpot = spot
    self.moveCol = int(spot.split('.')[1])

    # g.trace('spot',self.moveSpot,'col',self.moveCol)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'up',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move... (leoEditCommands)
#@-node:ekr.20060122193554:Set remembered column properly in prev-line and next-line
#@+node:ekr.20060209144933:Fixed bug in k.shortcutFromSetting
# Made sure bindings can end in '+' and '-'
#@nonl
#@+node:ekr.20060128081317:shortcutFromSetting
def shortcutFromSetting (self,setting):

    if not setting:
        return None

    s = setting.strip()
    << define cmd, ctrl, alt, shift >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting
#@nonl
#@+node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0

if sys.platform == "darwin":
    if ctrl and not cmd:
        cmd = True ; ctrl = False
    if alt and not ctrl:
        ctrl = True ; alt = False
#@nonl
#@-node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@nonl
#@-node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
#@+node:ekr.20060128103640.2:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    if shift:
        last = last.upper()
        shift = False
    else:
        last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
#@nonl
#@-node:ekr.20060128103640.2:<< compute the last field >>
#@+node:ekr.20060128103640.4:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Cmnd+'),
    (shift,'Shift+'),
    (True,last),
)
    
shortcut = ''.join([val for flag,val in table if flag])
#@nonl
#@-node:ekr.20060128103640.4:<< compute shortcut >>
#@-node:ekr.20060128081317:shortcutFromSetting
#@-node:ekr.20060209144933:Fixed bug in k.shortcutFromSetting
#@+node:ekr.20060210071428:Fixed vim plugin & openWith
#@-node:ekr.20060210071428:Fixed vim plugin & openWith
#@+node:ekr.20060210120212:Fixed focus problems in spell tab
#@-node:ekr.20060210120212:Fixed focus problems in spell tab
#@+node:ekr.20060210105940.1:Don't abort the minibuffer if the command does not exist
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = c.get_focus()
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@nonl
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@-node:ekr.20060210105940.1:Don't abort the minibuffer if the command does not exist
#@+node:ekr.20060210125025:Restored tree.onTreeClick
# Not having it is confusing.
#@nonl
#@-node:ekr.20060210125025:Restored tree.onTreeClick
#@+node:ekr.20060116083359.1:Added expand/contract/hide-pane/fully-expand commands
#@+node:ekr.20050920084036.53:class editCommandsClass
class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others
#@nonl
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.widget = None # For use by state handlers.
#@nonl
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')
#@nonl
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '<Alt-c>':
        self.capitalizeWord(event)
    elif stroke == '<Alt-u>':
         self.upCaseWord(event)
    elif stroke == '<Alt-l>':
        self.downCaseWord(event)

    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.145:changePreviousWord
#@+node:ekr.20051015114221.1:capitalizeHelper
def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
#@-node:ekr.20051015114221.1:capitalizeHelper
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
@nocolor
@color
@

Commands that simulate clicks in the outline are useful because such events call
hooks. In particular, double-click-icon-box will invoke the vim or xemacs
plugins if they are enabled.

Notes:
- There is no need to simulate clicks in the canvas.  Left and right clicks are handled elsewhere.

- Most clicks are equivent to other commands. There is no need to simulate those clicks here.

- The simulateDrg methods are here for completeness.  They have not been tested.
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    c.set_focus(pane)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    
    self.c.bodyWantsFocus()

def focusToLog (self,event):

    self.c.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.treeWantsFocus()
#@nonl
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)
    
def doubleClickHeadline (self,event=None):
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected headline.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@nonl
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    
    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@nonl
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    << define colors >>
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@nonl
#@-node:ekr.20051019183105.2:<< define colors >>
#@+node:ekr.20051019183105.3:createColorPicker
def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@nonl
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@nonl
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@-node:ekr.20051019183105.3:createColorPicker
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:show-fonts & helpers
def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)
#@nonl
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
#@nonl
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@nonl
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)
#@nonl
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@nonl
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@nonl
#@-node:ekr.20051019201809.7:setFont
#@-node:ekr.20051019201809:show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn
def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 < c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 >= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')
#@nonl
#@-node:ekr.20050920084036.134:indentToCommentColumn
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion
#@+node:ekr.20050920084036.60:dynamicExpansion2
def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@nonl
#@-node:ekr.20050920084036.60:dynamicExpansion2
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@nonl
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@nonl
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@nonl
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others
#@nonl
#@+node:ekr.20050920084036.67:centerLine
def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) >= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)
#@nonl
#@-node:ekr.20050920084036.67:centerLine
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@nonl
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex <= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) >= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1
#@nonl
#@-node:ekr.20050920084036.69:centerRegion
#@+node:ekr.20050920084036.70:setFillPrefix
def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt
#@nonl
#@-node:ekr.20050920084036.70:setFillPrefix
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@nonl
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):
    
    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):
    
    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20050920084036.74:indent... (To do: undo)
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)
#@nonl
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20050920084036.76:deleteIndentation
def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.76:deleteIndentation
#@+node:ekr.20050920084036.77:insertNewLineIndent
def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
#@-node:ekr.20050920084036.77:insertNewLineIndent
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 < 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) <= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent... (To do: undo)
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed,setLabel=False)
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)
#@nonl
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20050920084036.138:insertNewLine (not undoable)
def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (not undoable)
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)
#@nonl
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
#@nonl
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@nonl
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))
#@nonl
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)
#@nonl
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)
#@nonl
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@nonl
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@nonl
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.92:linesHelper
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@nonl
#@-node:ekr.20050920084036.147:measure
#@+node:ekr.20050929114218:move... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'<',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        # Don't change the moveCol while extending: that would mess up the selection.
        if setSpot or not moveSpot:
            self.setMoveCol(w,spot)
        g.app.gui.setTextSelection(w,spot,spot,insert=None)
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'<',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'>',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    self.moveSpot = spot
    self.moveCol = int(spot.split('.')[1])

    # g.trace('spot',self.moveSpot,'col',self.moveCol)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'up',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move... (leoEditCommands)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@nonl
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()
#@nonl
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
#@nonl
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','>',s2):
            break
        self.fillParagraph(event)
#@nonl
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)
#@nonl
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.98:killParagraph (Test)
def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()
#@nonl
#@-node:ekr.20050920084036.98:killParagraph (Test)
#@+node:ekr.20050920084036.96:selectParagraph & helper
def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break
#@nonl
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)
#@nonl
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:selectParagraph & helper
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@nonl
#@+node:ekr.20050920084036.106:setRegion
def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('<Right>',extend,'+')
    w.bind('<Left>',truncate,'+')
    w.bind('<Up>',up,'+')
    w.bind('<Down>',down,'+')

    return 'break'
#@nonl
#@+node:ekr.20051002102410:down
def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'
#@nonl
#@-node:ekr.20051002102410:down
#@+node:ekr.20051002102410.1:extend
def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

#@-node:ekr.20051002102410.1:extend
#@+node:ekr.20051002102410.2:truncate
def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'
#@nonl
#@-node:ekr.20051002102410.2:truncate
#@+node:ekr.20051002102410.3:up
def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'
#@nonl
#@-node:ekr.20051002102410.3:up
#@-node:ekr.20050920084036.106:setRegion
#@+node:ekr.20050920084036.107:indentRegion
def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('<Key>')
        ### w.update_idletasks()
    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion
#@+node:ekr.20050920084036.108:tabIndentRegion
def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
#@nonl
#@-node:ekr.20050920084036.108:tabIndentRegion
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@nonl
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
#@nonl
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)
#@nonl
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
    w.see('insert')
#@nonl
#@-node:ekr.20060113082917:scrollHelper
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i <= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.122:transposeLines
def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')
#@nonl
#@-node:ekr.20050920084036.122:transposeLines
#@+node:ekr.20050920084036.123:swapWords & transposeWords
def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'>',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'<',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20050920084036.123:swapWords & transposeWords
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters
#@nonl
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)
#@nonl
#@-node:ekr.20050920084036.126:tabify & untabify
#@-node:ekr.20050920084036.53:class editCommandsClass
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20060210103358:c.invalidateFocus
def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    
#@-node:ekr.20060210103358:c.invalidateFocus
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@nonl
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20060208143543:c.restoreFocus
def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.
#@nonl
#@-node:ekr.20060208143543:c.restoreFocus
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))
#@nonl
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060205111103:c.widget_name
def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)
#@nonl
#@-node:ekr.20060205111103:c.widget_name
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@nonl
#@-node:ekr.20050120092028:c.xWantsFocus
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    
    f = self ; c = f.c
    
    if c.inCommand:
        g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@nonl
#@-node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
#@+node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
def OnControlKeyDown (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    self.controlKeyIsDown = True
    
def OnControlKeyUp (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.controlKeyIsDown = False
#@nonl
#@-node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):
    
    '''Handle a click anywhere in the Leo window.'''
    
    __pychecker__ = '--no-argsused' # event.

    self.c.setLog()

def OnDeactivateLeoEvent(self,event=None):
    
    pass # This causes problems on the Mac.
#@nonl
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()

        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            c.bodyWantsFocus()
            
    except:
        g.es_event_exception("activate tree")
#@nonl
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@nonl
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            if event: # Prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked.
                w = self.bodyCtrl
                start = w.index(index + " wordstart")
                end   = w.index(index + " wordend")
                self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.
#@nonl
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
# Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

    try:
        if event.delta < 1:
            self.canvas.yview(Tk.SCROLL, 1, Tk.UNITS)
        else:
            self.canvas.yview(Tk.SCROLL, -1, Tk.UNITS)
    except:
        g.es_event_exception("scroll wheel")

    return "break"
#@nonl
#@-node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
#@-node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20060209110128:Minibuffer commands... (tkFrame)

#@+node:ekr.20060209110128.1:contractPane
def contractPane (self,event=None):
    
    f = self ; c = f.c
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.contractBodyPane()
    elif wname.startswith('log'):
        f.contractLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.contractOutlinePane()
#@nonl
#@-node:ekr.20060209110128.1:contractPane
#@+node:ekr.20060209110128.2:expandPane
def expandPane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.expandBodyPane()
    elif wname.startswith('log'):
        f.expandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.expandOutlinePane()
#@nonl
#@-node:ekr.20060209110128.2:expandPane
#@+node:ekr.20060210123852:fullyExpandPane
def fullyExpandPane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.fullyExpandBodyPane()
    elif wname.startswith('log'):
        f.fullyExpandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.fullyExpandOutlinePane()
#@nonl
#@-node:ekr.20060210123852:fullyExpandPane
#@+node:ekr.20060209143933:hidePane
def hidePane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.hideBodyPane()
        c.treeWantsFocusNow()
    elif wname.startswith('log'):
        f.hideLogPane()
        c.bodyWantsFocusNow()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.hideOutlinePane()
        c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20060209143933:hidePane
#@+node:ekr.20060209110936:expand/contract/hide...Pane
@ The first arg to divideLeoSplitter means the following:

    f.splitVerticalFlag: use the primary   (tree/body) ratio.
not f.splitVerticalFlag: use the secondary (tree/log) ratio.
@c

def contractBodyPane (self,event=None):
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def contractLogPane (self,event=None):
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def contractOutlinePane (self,event=None):
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)
    
def expandBodyPane (self,event=None):
    self.contractOutlinePane()

def expandLogPane(self,event=None):
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)
    
def expandOutlinePane (self,event=None):
    self.contractBodyPane()
#@nonl
#@-node:ekr.20060209110936:expand/contract/hide...Pane
#@+node:ekr.20060210123852.1:fullyExpand/hide...Pane
def fullyExpandBodyPane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)

def fullyExpandLogPane (self,event=None):
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

def fullyExpandOutlinePane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)
    
def hideBodyPane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideLogPane (self,event=None):
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

def hideOutlinePane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)
#@nonl
#@-node:ekr.20060210123852.1:fullyExpand/hide...Pane
#@-node:ekr.20060209110128:Minibuffer commands... (tkFrame)
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):
    
    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(wname,func and func.__name__)

    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        try:
            i = w.index('@%s,%s' % (event.x,event.y))
            g.app.gui.setTextSelection (w,i,i,insert=i)
            c.editCommands.setMoveCol(w,i)
            c.frame.updateStatusLine()
        except Exception:
            pass

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None
        
masterClick3Handler         = masterClickHandler
masterDoubleClick3Handler   = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@-node:ekr.20060116083359.1:Added expand/contract/hide-pane/fully-expand commands
#@+node:ekr.20060209113357:clicks now clear selection
#@-node:ekr.20060209113357:clicks now clear selection
#@+node:ekr.20060210132142.1:Special-cased select-all-text in headlines
#@+node:ekr.20031218072017.4023:selectAllText
def selectAllText (self,event=None):
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass
#@nonl
#@-node:ekr.20031218072017.4023:selectAllText
#@-node:ekr.20060210132142.1:Special-cased select-all-text in headlines
#@+node:ekr.20060210141604:Special-cased commands for minibuffer
@nocolor

(done) select-all-text.
(done) move back/forward char.
(done) move back/forward char.
(done) start-of-line, end-of-line.
    
It turned out that the only special case is in moveToHelper, which means the solution is general.

@color
#@nonl
#@+node:ekr.20060210141604.1:getEditableTextRange
def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # g.trace(i,j)
    return i,j
#@-node:ekr.20060210141604.1:getEditableTextRange
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.4023:selectAllText
def selectAllText (self,event=None):
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass
#@nonl
#@-node:ekr.20031218072017.4023:selectAllText
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@-node:ekr.20060210141604:Special-cased commands for minibuffer
#@+node:ekr.20060210145627:Copy find text into minibuffer for search commands
# To do: getArg must handle completion = False differently.
#@nonl
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20060210172035:From keyHandler
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20050924064254:Label...
@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.
#@nonl
#@+node:ekr.20060125175103:k.minibufferWantsFocus/Now
def minibufferWantsFocus(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20060125175103:k.minibufferWantsFocus/Now
#@+node:ekr.20051023132350:getLabel
def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        while s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        # g.trace(repr(s))
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

#@-node:ekr.20051023132350:getLabel
#@+node:ekr.20051023132350.2:protectLabel
def protectLabel (self):
    
    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        w.update_idletasks()
        k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()
#@nonl
#@-node:ekr.20051023132350.2:protectLabel
#@+node:ekr.20050920085536.37:resetLabel
def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''
#@nonl
#@-node:ekr.20050920085536.37:resetLabel
#@+node:ekr.20051023132350.1:setLabel
def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return

    # g.trace(repr(s))

    if self.useTextWidget:
        w.delete('1.0','end')
        w.insert('1.0',s)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s
#@nonl
#@-node:ekr.20051023132350.1:setLabel
#@+node:ekr.20060206064635:extendLabel
def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
#@-node:ekr.20060206064635:extendLabel
#@+node:ekr.20050920085536.36:setLabelBlue
def setLabelBlue (self,label=None,protect=False):
    
    k = self ; w = k.widget
    if not w: return
    
    w.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@nonl
#@-node:ekr.20050920085536.36:setLabelBlue
#@+node:ekr.20050920085536.35:setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return
    
    w.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@nonl
#@-node:ekr.20050920085536.35:setLabelGrey
#@+node:ekr.20050920085536.38:updateLabel
def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) <= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@-node:ekr.20050920085536.38:updateLabel
#@+node:ekr.20060210141604.1:getEditableTextRange
def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # g.trace(i,j)
    return i,j
#@-node:ekr.20060210141604.1:getEditableTextRange
#@-node:ekr.20050924064254:Label...
#@+node:ekr.20060210141604.1:getEditableTextRange
def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # g.trace(i,j)
    return i,j
#@-node:ekr.20060210141604.1:getEditableTextRange
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=None,completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,'keysym',keysym,'completion',completion)
    if state == 0:
        k.arg = '' ; k.arg_completion = completion
        if tabList: k.argTabList = tabList[:]
        else:       k.argTabList = []
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()

    return 'break'
#@+node:ekr.20050928092516:<< init altX vars >>
# Clear the list, any other character besides tab indicates that a new prefix is in effect.
k.mb_tabList = []

if prefix:
    k.mb_tabListPrefix = prefix
    k.mb_prefix = prefix
    k.mb_prompt = prefix
else:
    k.mb_tabListPrefix = k.mb_prefix = k.getLabel()
    k.mb_prompt = ''
#@nonl
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@+node:ekr.20060206064635:extendLabel
def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
#@-node:ekr.20060206064635:extendLabel
#@+node:ekr.20050920085536.38:updateLabel
def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) <= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@-node:ekr.20050920085536.38:updateLabel
#@+node:ekr.20050920085536.46:doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c
    
    # g.trace('completion',completion)
    
    if completion:
        if len(k.mb_tabListPrefix) > len(k.mb_prefix):
            k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
            k.setLabel(k.mb_tabListPrefix)
            k.computeCompletionList(defaultCompletionList,backspace=True)
    else:
        s = k.getLabel(ignorePrompt=False)
        # g.trace(repr(s),repr(k.mb_prefix))
        if s and len(s) > len(k.mb_prefix):
            k.setLabel(s[:-1])
#@nonl
#@-node:ekr.20050920085536.46:doBackSpace
#@+node:ekr.20050920085536.44:doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.bodyWantsFocus()
#@-node:ekr.20050920085536.44:doTabCompletion
#@-node:ekr.20060210172035:From keyHandler
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(event,tag,'Search: ',self.searchWithPresentOptions)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)
#@nonl
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind (the findHandler)
class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@nonl
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    self.c = c
    self.k = c.k
    self.finder = finder
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@nonl
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:setOption
def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124122844:setOption
#@+node:ekr.20060125082510:getOption
def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        if verbose:
             g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@nonl
#@-node:ekr.20060125082510:getOption
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@nonl
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060124135401:toggleOption
def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124135401:toggleOption
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)
#@nonl
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)
#@nonl
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060124134356: setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@nonl
#@-node:ekr.20060124134356: setupArgs
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@nonl
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@nonl
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        
#@nonl
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel()
    k.getArg(event,tag,1,handler,completion=False,prefix=prefix)
#@nonl
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@nonl
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    self.setupSearchPattern(pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@nonl
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search Backward:',self.reSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search:',self.reSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search Backward: ',self.searchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search: ',self.searchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(event,tag,'Search: ',self.searchWithPresentOptions)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind (the findHandler)
#@+node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
#@nonl
#@+node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.11:__init__
def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    << create the tkinter intVars >>
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20051020120306.12:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20051020120306.12:<< create the tkinter intVars >>
#@-node:ekr.20051020120306.11:__init__
#@+node:ekr.20051023181449:createBindings (findTab)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        k.masterKeyHandler(event)

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    self.findButtonCallback),
        ("<Escape>",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
#@nonl
#@-node:ekr.20051023181449:createBindings (findTab)
#@+node:ekr.20051020120306.13:createFrame (findTab)
def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    
    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole &Word", self.dict["whole_word"]),
    ("&Ignore Case",self.dict["ignore_case"]),
    ("Wrap &Around",self.dict["wrap"]),
    ("&Reverse",    self.dict["reverse"]),
    ('Rege&xp',     self.dict['pattern_match']),
    ("Mark &Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.dict["search_headline"]),
    ("Search &Body",     self.dict["search_body"]),
    ("Mark &Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (findTab)
#@+node:ekr.20051020120306.19:find.init
def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20051020120306.20:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20051020120306.20:<< set find/change widgets >>
#@+node:ekr.20051020120306.21:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
#@nonl
#@-node:ekr.20051020120306.21:<< set radio buttons from ivars >>
#@-node:ekr.20051020120306.19:find.init
#@-node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.22:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20051020120306.22:find.update_ivars
#@+node:ekr.20051023183028:findButtonCallback
def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'
#@nonl
#@-node:ekr.20051023183028:findButtonCallback
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@nonl
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s.endswith('\n'): s = s[:-1]
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@nonl
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
#@nonl
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051020120306.25:hideTab
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@+node:ekr.20051020120306.27:selectAllFindText
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"
#@nonl
#@-node:ekr.20051020120306.27:selectAllFindText
#@+node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@nonl
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@nonl
#@+node:ekr.20050920084036.258: ctor
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
#@nonl
#@-node:ekr.20050920084036.258: ctor
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@nonl
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@nonl
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@nonl
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere     (self, event): return self.setFindScope('entire-outline')
def setFindScopeNodeOnly       (self, event): return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event): return self.setFindScope('suboutline-only')

def setFindScope (self, where): self.getHandler().setFindScope(where)

def showFindOptions      (self,event): self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event): return self.toggleOption('ignore_case')
def toggleMarkChangesOption    (self, event): return self.toggleOption('mark_changes')
def toggleMarkFindsOption      (self, event): return self.toggleOption('mark_finds')
def toggleRegexOption          (self, event): return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event): return self.toggleOption('reverse')
def toggleSearchBodyOption     (self, event): return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event): return self.toggleOption('search_headline')
def toggleWholeWordOption      (self, event): return self.toggleOption('whole_word')
def toggleWrapSearchOption     (self, event): return self.toggleOption('wrap')

def toggleOption (self, ivar): self.getHandler().toggleOption(ivar)
#@nonl
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def cloneFindAll       (self,event): self.getHandler().cloneFindAll(event)
def findAll            (self,event): self.getHandler().findAll(event)

def replaceString      (self,event): self.getHandler().replaceString(event)
def reSearchBackward   (self,event): self.getHandler().reSearchBackward(event)
def reSearchForward    (self,event): self.getHandler().reSearchForward(event)
def searchBackward     (self,event): self.getHandler().searchBackward(event)
def searchForward      (self,event): self.getHandler().searchForward(event)
def wordSearchBackward (self,event): self.getHandler().wordSearchBackward(event)
def wordSearchForward  (self,event): self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    self.getHandler().searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)
#@nonl
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()
#@nonl
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler & helper
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '<Control-s>':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '<Control-r>':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        i = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if i:
            self.searchString = s
        else:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)
#@nonl
#@-node:ekr.20050920084036.264:iSearchStateHandler & helper
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@nonl
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    
    self.searchString = pattern
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
   
    try:
        i = None
        if forward:
            i = w.search(pattern,"insert + 1c",stopindex='end',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the top of the buffer.
                    i = w.search(pattern,'1.0',stopindex='insert',regexp=regexp)
        else:
            i = w.search(pattern,'insert',backwards=True,stopindex='1.0',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the bottom of the buffer.
                    i = w.search(pattern,'end',backwards=True,stopindex='insert',regexp=regexp)
    except: pass
        
    # Don't call endSearch here.  We'll do that when the user hits return.
    if i and not i.isspace():
        w.mark_set('insert',i)
        w.see('insert')
#@nonl
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@-node:ekr.20060210145627:Copy find text into minibuffer for search commands
#@+node:ekr.20031218072017.792:Added commands to simulate clicks
#@+node:ekr.20060211065245:What I did
@nocolor

# http://sourceforge.net/forum/message.php?msg_id=3487424

Commands that simulate clicks in the outline are useful because such events call
hooks. In particular, double-click-icon-box will invoke the vim or xemacs
plugins if they are enabled.

Added these commands: click-click-box, click-headline, click-icon-box, double-click-headline, double-click-icon-box, simulate-begin-drag, simulate-end-drag

Notes:
    
- There is no need to simulate clicks in the canvas.  Left and right clicks are handled elsewhere.

- Most clicks are equivent to other commands. There is no need to simulate those clicks here.

- The simulateDrg methods are here for completeness.  They have not been tested.
#@nonl
#@-node:ekr.20060211065245:What I did
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20060211061217:Tree event handlers that trigger hooks
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):
    
    c = self.c ; tree = self
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return 'break'
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):
    
    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event,p=None):
    
    c = self.c ; p1 = c.currentPosition()
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@nonl
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    
    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@nonl
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.
    return 'continue'
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20060211061217:Tree event handlers that trigger hooks
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
@nocolor
@color
@

Commands that simulate clicks in the outline are useful because such events call
hooks. In particular, double-click-icon-box will invoke the vim or xemacs
plugins if they are enabled.

Notes:
- There is no need to simulate clicks in the canvas.  Left and right clicks are handled elsewhere.

- Most clicks are equivent to other commands. There is no need to simulate those clicks here.

- The simulateDrg methods are here for completeness.  They have not been tested.
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    c.set_focus(pane)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    
    self.c.bodyWantsFocus()

def focusToLog (self,event):

    self.c.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.treeWantsFocus()
#@nonl
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)
    
def doubleClickHeadline (self,event=None):
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected headline.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@nonl
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    
    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@nonl
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@-node:ekr.20031218072017.792:Added commands to simulate clicks
#@-node:ekr.20060208080524:4.4b2 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
