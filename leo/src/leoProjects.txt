#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ã
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20050524073547.1:4.3.1 projects
#@+node:ekr.20050524102538:Bug fixes...
#@+node:ekr.20050524092311:(Fixed ratio bugs)
#@+node:ekr.20050524092311.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3166883
By: rogererens

I swear I didn't wait for the release to be the first to report a bug! I just
didn't try this in the alfa/beta versions:

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.4.1, Tk 8.4.7, win32

Changing
Global settings: C:\Leo\config\leoSettings.leo-->Window options-->@page Options
for new windows-->@ratio initial_horizontal_ratio = 0.3
or any of the other ratios, does not save them to leoSettings.leo. So after
restarting I still have the old settings in use.
#@nonl
#@-node:ekr.20050524092311.1:Report
#@+node:ekr.20041225063637.43:createRatio
def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 <= val2 <= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.43:createRatio
#@-node:ekr.20050524092311:(Fixed ratio bugs)
#@+node:ekr.20050524095049:(Fixed crasher footprint plugin)
@ The fix was to add the following line to the init function:

    global click_registry, coloured_nodes
#@nonl
#@+node:ekr.20050524095049.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3167166
By: porter235

with footprints enabled, attempting to open a document causes the following
error

exceptions opening: D:\Program Files\leo-4.3-final\Leo\doc\LeoDocs.leo
Traceback (most recent call last):
  File "D:\Program Files\leo-4.3-final\Leo\src\leoGlobals.py", line 771, in
openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "D:\Program Files\leo-4.3-final\Leo\src\leoFileCommands.py", line 1325,
in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoFileCommands.py", line 649,
in getLeoFile
    c.frame.tree.redraw_now(scroll=False)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1277,
in redraw_now
    self.idle_redraw(scroll=scroll)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1317,
in idle_redraw
    self.drawTopTree()
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1174,
in drawTopTree
    self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1201,
in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 916,
in drawNode
    return self.force_draw_node(p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 945,
in force_draw_node
    h2 = self.drawText(p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1021,
in drawText
    self.configureTextState(p)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1738,
in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "D:\Program Files\leo-4.3-final\Leo\plugins\footprints.py", line 138,
in doFootprint
    if click_registry.get(p.v, 0) >= HITS_TO_HOT:
NameError: global name 'click_registry' is not defined
#@-node:ekr.20050524095049.1:Report
#@-node:ekr.20050524095049:(Fixed crasher footprint plugin)
#@+node:ekr.20050523071432:(Worked around invalid position bug)
#@+node:ekr.20050523085407:Report
@killcolor

While doing final testing I discovered a long-standing bug that is potentially serious but that has lain dormant for a year or more.  I'm not going to delay 4.3 while I (try) to fix this bug because any potential fix would create the potential for even more serious bugs.  So I'll start work on the bug right after releasing 4.3 final, and I'll release 4.3.1 b1 about a week later.

The bug is this:  modifying outlines can invalidate existing positions!  This rarely happens.  At present it affects the atFile.read logic when reading an outline whose initial current position is a clone outside an @thin tree with another clone inside the @thin tree.  So the read logic computes the expected current position before reading all derived files, and this expected current position becomes invalid.  This bug itself is minor: Leo doesn't highlight the initial node correctly in this case and nothing else bad happens.

However, this bug is probably also behind a recent hang in the unit tests.  What happens is that inserting and deleting nodes also can invalidate existing positions, and in general this can have bad results.  N.B. Typical scripts will never encounter the bug because the vast majority of scripts a) do not attempt to modify the outline and b) don't have state that must be saved as the outline changes.  However, unit tests do both.

The reason I'm not going even to attempt to fix the bug is that doing so will require a change deep in the heart of the position class.  I don't remember all the details of the implementation, so at the minimum I'll have to document the code much better than at present.  Iirc the code and data structures are something of a hack.  Rather than hacking the hack I'll see if maybe I can simplify matters, but this is potentially very dangerous.  Thus, I would rather live with a mostly dormant bug in 4.3 final than attempting a change that could ruin a release or two.
#@nonl
#@-node:ekr.20050523085407:Report
#@+node:ekr.20050525065038:What I did
@killcolor

1.  Moved << set current and top positions >> from getVnodes to end of getLeoFile.
This ensures that the outline won't change after computing the position.

2. Unit tests will have to be revised to make sure that only valid positions get used.
#@nonl
#@-node:ekr.20050525065038:What I did
#@+node:ekr.20031218072017.890:<< about the position class >>
@killcolor

@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible and p.hasThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.
#@nonl
#@-node:ekr.20031218072017.890:<< about the position class >>
#@+node:ekr.20050524082843:<< positions may become invalid when outlines change >>
@killcolor

@ If a vnode has only one parent, v._parent is that parent. Otherwise,
v.t.vnodeList is the list of vnodes v2 such that v2._firstChild == v. Alas, this
means that positions can become invalid when vnodeList's change!

There is no use trying to solve the problem in p.moveToParent or
p.vParentWithStack: the invalidated positions simply don't have the stack
entries needed to compute parent fields properly. In short, changing t.vnodeList
may invalidate existing positions!
#@nonl
#@-node:ekr.20050524082843:<< positions may become invalid when outlines change >>
#@+node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
#@+node:ekr.20040803140033:currentPosition
def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self
    
    if c._currentPosition:
        if copy:
            return c._currentPosition.copy() # Must make a second copy now.
        else:
            # The caller MUST copy the position if it is passed to any other method.
            # At present no core method uses copy = False.
            g.trace("copy=False")
            return c._currentPosition
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition
#@nonl
#@-node:ekr.20040803140033:currentPosition
#@+node:ekr.20040803140033.1:setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position."""
    
    c = self
    
    if p:
        if p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
        # g.trace('exists',p.exists(c),'returns',p)
        # if not p.exists(c):
            # g.printStack()
    else:
        c._currentPosition = None
    
# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:setCurrentPosition
#@-node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
#@+node:ekr.20050524095253:undo...
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@-node:ekr.20050524095253:undo...
#@+node:ekr.20050524074930.5:drawing...
#@+node:ekr.20040803072955.59:idle_redraw
def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    << return if disabled, or quitting or dragging >>

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            self.canvas.after_idle(self.idle_scrollTo)
        if 0:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@+node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
# g.trace('disableRedraw',self.disableRedraw)

if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
#@nonl
#@-node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
#@-node:ekr.20040803072955.59:idle_redraw
#@+node:ekr.20040803072955.69:scrollTo
def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        __pychecker__ = '--no-argsused' # event not used.

        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040803072955.69:scrollTo
#@+node:ekr.20040803072955.65:idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:idle_scrollTo
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@-node:ekr.20050524074930.5:drawing...
#@+node:ekr.20050524074930.7:position methods...
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):
    
    return len([p for p in self.parents_iter()])

def level(self,verbose=False):
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==self.simpleLevel())
            break
    return level
#@nonl
#@-node:ekr.20040227214711:p.level & simpleLevel
#@+node:ekr.20040307104131.3:p.exists
def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p,'parent',p.parent(),'back',p.back())
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False
#@nonl
#@-node:ekr.20040307104131.3:p.exists
#@-node:ekr.20050524074930.7:position methods...
#@+node:ekr.20050524074930.6:read logic...
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)

    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
        
    # g.trace(c.currentPosition())
    
    # New in 4.3.1: do this after reading derived files.
    if not self.usingClipboard:
        << set current and top positions >>

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    # g.trace('using convertStackToPosition',current)
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
if 0:
    top = self.convertStackToPosition(self.topVnodeStack)
    if top:
        c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@nonl
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20040326052245:convertStackToPosition
def convertStackToPosition (self,stack):

    c = self.c ; p2 = None
    if not stack: return None

    for p in c.allNodes_iter():
        if p.v == stack[0]:
            p2 = p.copy()
            for n in xrange(len(stack)):
                if not p2: break
                # g.trace("compare",n,p2.v,stack[n])
                if p2.v != stack[n]:
                    p2 = None
                elif n + 1 == len(stack):
                    break
                else:
                    p2.moveToParent()
            if p2:
                # g.trace('exists',p.exists(c),p)
                return p

    return None
#@nonl
#@-node:ekr.20040326052245:convertStackToPosition
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@-node:ekr.20050524074930.6:read logic...
#@-node:ekr.20050523071432:(Worked around invalid position bug)
#@+node:ekr.20050525074210:(Fixed undo problems in unit tests)
#@+node:ekr.20050525162830:What I did, and why
@killcolor

- Fixed bugs in convertAllBlanks and convertAllTabs.

These must always call afterChangeGroup to match beforeChangeGroup, even if
nothing has changed.

- Added u.getMark and u.rollbackToMark.

These allow unit tests to cut the undo stack back to an initial position in the
tearDown method. This should be done for all tests that use u.undo and u.redo
methods. The bug was probably the result of changing the outline in the tearDown
method.

Both the Reformat Paragraph and Edit Body unit tests now roll back the undo stack.

- Added traces for unexpected conditions in u.undo, u.redo and tree.select.

- Call u.setUndoTypes() in u.setUndoTypingParams when returning early.

- Corrected Edit Body unit tests.

These tests should not call undo/redo when nothing is expected to change. Doing
so may trigger the new 'cant undo' traces in u.undo.

- doTest in leoTest.py now makes copies of both p and p1.

It's not clear that this is needed, it can't hurt, and it may have been important.
#@nonl
#@-node:ekr.20050525162830:What I did, and why
#@+node:ekr.20050525163715:undo...
#@+node:ekr.20050525151217:getMark & rollbackToMark
def getMark (self):
    
    __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.
    
    return self.bead
    
def rollbackToMark (self,n):
    
    u = self

    u.bead = n
    u.beads = u.beads[:n+1]
    u.setUndoTypes()
    
rollBackToMark = rollbackToMark
#@nonl
#@-node:ekr.20050525151217:getMark & rollbackToMark
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):
    
    u = self

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
#@nonl
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    << return if there is nothing to do >>
    # g.trace(undo_type)
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return bunch
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
else:
    bunch = old_d

bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview

u.beads[u.bead:] = [bunch]
    
# g.trace(u.bead,len(u.beads))
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c
    # assert p == c.currentPosition(),'not current position'+repr(p)

    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    # g.trace(undoType)
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20050525163715:undo...
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self):

    c = self ; undoType = 'Indent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(p,undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo by calling setUndoTypingParams (in idle_body_key).
    body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    
    # g.trace(p.headString())

    if not p: return
    if not p.exists(c):
        g.trace(g.callerList(5),'does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@-node:ekr.20050525074210:(Fixed undo problems in unit tests)
#@+node:ekr.20050523134613:(Made sure same case is used in all recent files entries)
@ The problem was that leo.__file__ returns a randomly upper or lower cased drive letter.
#@nonl
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = leo.__file__
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@-node:ekr.20050523134613:(Made sure same case is used in all recent files entries)
#@+node:ekr.20050524061338:(Made sure all dialogs gets focus when they are run)
# The About Leo dialog was not getting focus.
#@nonl
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):
    
    """Run a leoTkinterDialog."""
    
    if g.app.unitTesting: return None

    c = self.c ; self.modal = modal

    self.center() # Do this after all packing complete.
    self.top.lift()

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        
    if self.focus_widget == None:
        self.focus_widget = self.top
        
    self.focus_widget.focus_set() # Get all keystrokes.
    if c:
        # g.trace(self.focus_widget,c)
        g.app.gui.widget_wants_focus(c,self.focus_widget)
       
    self.root.wait_window(self.top)
    
    if self.modal:
        return self.answer
    else:
        return None
#@nonl
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@-node:ekr.20050524061338:(Made sure all dialogs gets focus when they are run)
#@+node:ekr.20050514171429.1:(Improved Resize To Screen command)
#@+node:ekr.20050526091058:Request
@killcolor 
http://sourceforge.net/forum/message.php?msg_id=3151996
By: ngirard, Nicolas

The "resize to screen" command doesn't actually resize to the entire screen.
#@nonl
#@-node:ekr.20050526091058:Request
#@+node:EKR.20040422130619:resizeToScreen
def resizeToScreen (self):
    
    top = self.top
    
    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()

    if 1: # Fill the entire screen (almost)
        # This works well on Windows.  YMMV for other platforms.
        geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
    else: # The old way.
        geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)

    top.geometry(geom)
#@nonl
#@-node:EKR.20040422130619:resizeToScreen
#@-node:ekr.20050514171429.1:(Improved Resize To Screen command)
#@+node:ekr.20050531105422:(Made sure comments are always visible in setting dialog even for non-@ nodes)
# Tricky to get right.
# Note that createOnlyComments doesn't have to do anything.
#@nonl
#@+node:ekr.20050531105422.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3176499
By: mackal

5) am I missing text in the Settings panels?  the outline shows that certain
nodes have text (e.g., "About keyboard shortcuts" has the blue rectangle), yet
the body pane is empty; heck, even the title suggests that something should
be there...
#@-node:ekr.20050531105422.1:Report
#@+node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind)) or self.doComment
    if f is not None:
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
            return None
#@nonl
#@-node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
#@+node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
# Most of the work is done by base class methods.
#@nonl
#@+node:ekr.20050603065400:doComment
def doComment (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    self.set(p,'comment',None,None)
#@nonl
#@-node:ekr.20050603065400:doComment
#@+node:ekr.20041225063637.101:doFont
def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    d = self.parseFont(p)
    # g.trace("\n\nfont dict...\n%s" % g.dictToString(d))
    self.set(p,kind,name,d)
#@-node:ekr.20041225063637.101:doFont
#@+node:ekr.20041225063637.102:doPage
def doPage(self,p,kind,name,val):
    
    """Create a widget for each setting in the subtree."""
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    for p in p.subtree_iter():
        self.visitNode(p)
#@nonl
#@-node:ekr.20041225063637.102:doPage
#@+node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
def doBodyPaneList (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    lines = g.splitLines(s)

    vals = []
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            vals.append(line)
                
    self.set(p,kind,name,vals)
#@-node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
#@+node:ekr.20041225063637.104:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    self.set(p,kind,name,s)
    self.controller.suppressComments=p.copy()
#@nonl
#@-node:ekr.20041225063637.104:doShortcuts
#@-node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
#@+node:ekr.20041225063637.25:createWidgets & helpers
def createWidgets (self,widgets,parent,p):

    munge = g.app.config.munge

    << define creatorDispatchDict >>
    
    # g.trace(p.headString())
    
    # self.printWidgets(widgets)
    
    self.h = 0 # Offset from top of pane for first widget.
    self.createSpacerFrame(parent,size=15)
    
    if p != self.suppressComments:
        self.createComments(parent,p.copy())

    for data in widgets:
        p,kind,name,vals = data
        if kind.startswith('ints'):
            self.createInts(parent,p,kind,name,vals)
        if kind.startswith('strings'):
            self.createStrings(parent,p,kind,name,vals)
        else:
            f = creatorDispatchDict.get(munge(kind))
            if f is not None:
                try:
                    f(parent,p,kind,name,vals)
                except TypeError:
                    g.es_exception()
                    g.trace("***No handler***",kind)
#@nonl
#@+node:ekr.20041225063637.26:<< define creatorDispatchDict >>
creatorDispatchDict = {
    'bool':         self.createBool,
    'color':        self.createColor,
    'comment':      self.createOnlyComments, # New in 4.3.1
    'directory':    self.createDirectory,
    'font':         self.createFont,
    'int':          self.createInt,
    'ints':         self.createInts,
    'float':        self.createFloat,
    'path':         self.createPath,
    'ratio':        self.createRatio,
    'shortcut':     self.createShortcut,
    'shortcuts':    self.createShortcuts,
    'string':       self.createString,
    'strings':      self.createStrings,
}
#@nonl
#@-node:ekr.20041225063637.26:<< define creatorDispatchDict >>
#@+node:ekr.20041225063637.27:createBool
def createBool (self,parent,p,kind,name,val):
    
    val = g.choose(val.lower()=='true',1,0)

    # Inits the checkbutton widget. 
    var = Tk.IntVar()
    var.set(val)

    def boolCallback():
        val2 = g.choose(var.get(),True,False)
        # g.trace(name,val2)
        return val2
    
    val = g.choose(val,True,False)
    self.initValue(p,name,kind,val,boolCallback)

    box = Tk.Checkbutton(parent,text=name,variable=var,background=self.commonBackground)

    self.sc.create_window(10,self.h,anchor='w',window=box)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.27:createBool
#@+node:ekr.20041225063637.28:createColor
def createColor (self,parent,p,kind,name,val):
    
    munge = g.app.config.munge
    noColor = "<no color>"
    colorNamesList = list(self.colorNamesList)
    
    f = Tk.Frame(parent,background=self.commonBackground) # No need to pack.
    << munge val and add val to colorNamesList >>
    << create optionMenu and callback >>
    << create picker button and callback >>
    Tk.Label(f,text=name,background=self.commonBackground).pack(side='left')
    
    self.colorSettingDict [munge(name)] = val

    def getColorCallback ():
        return self.colorSettingDict.get(munge(name))

    self.initValue(p,name,kind,val,getColorCallback)

    self.sc.create_window(15,self.h+8,anchor='w',window=f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
if val in ("None",None): val = noColor
val = str(val) # Get rid of unicode.

if noColor in colorNamesList:
    colorNamesList.remove(val)
if val is not noColor and val not in colorNamesList:
     colorNamesList.append(val)
colorNamesList.sort()
colorNamesList.insert(0,noColor)

initVal = val
if val is noColor: val = None
#@nonl
#@-node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
#@+node:ekr.20041225063637.30:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f,scrolledlist_items=colorNamesList)
colorBox.selectitem(initVal)
colorBox.pack(side="left",padx=2)

color = g.choose(val is None,f.cget('background'),val)
colorSample = Tk.Button(f,width=8,background=color)
colorSample.pack(side='left',padx=2)

def colorCallback (newName):
    # g.trace(repr(newName))
    if not newName or newName.lower() in ('none','<none>','<no color>'):
        self.colorSettingDict[munge(name)] = None
        color = f.cget('background')
        colorSample.configure(background=color)
    else:
        try:
            colorSample.configure(background=newName)
            self.colorSettingDict[munge(name)] = g.choose(newName is noColor,None,newName)
        except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20041225063637.30:<< create optionMenu and callback >>
#@+node:ekr.20041225063637.31:<< create picker button and callback >>
def pickerCallback (color=val):

    rgb,val = tkColorChooser.askcolor(parent=parent,color=color)
    if rgb or val:
        # g.trace(rgb,val)
        self.colorSettingDict[munge(name)] = val
        colorSample.configure(background=val,activebackground=val,text=val)

b = Tk.Button(f,text="Color Picker...",command=pickerCallback,background=self.commonBackground)
b.pack(side="left")
#@nonl
#@-node:ekr.20041225063637.31:<< create picker button and callback >>
#@-node:ekr.20041225063637.28:createColor
#@+node:ekr.20050121131613:createComments
def createComments (self,parent,p):
    
    # g.trace(p.headString())
    
    bg = self.commonBackground

    s = p.bodyString().strip()
    if not s: return
    
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='comments',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background=bg,
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=5,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',s)
    t.configure(state='disabled')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 70
#@nonl
#@-node:ekr.20050121131613:createComments
#@+node:ekr.20050603065744:createOnlyComments
def createOnlyComments (self,parent,p,kind,name,val):
    
    pass # The existence of the 'comments' widget is enough.
#@nonl
#@-node:ekr.20050603065744:createOnlyComments
#@+node:ekr.20041225063637.32:createDirectory
def createDirectory (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.32:createDirectory
#@+node:ekr.20041225063637.33:createFloat
def createFloat (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent,background=bg)
    Tk.Entry(f,textvariable=var,background=bg).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def floatCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,floatCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.33:createFloat
#@+node:ekr.20041225063637.34:createFont
def createFont (self,parent,p,kind,fontName,val):
    
    """Create a font picker.  val is a dict containing the specified values."""
    bg = self.commonBackground
    d = val
    munge = g.app.config.munge
    f = Tk.Frame(parent,background=bg) # No need to pack.
    self.alterComments = p.copy()
    self.alteredCommentsString = d.get('comments')
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    Tk.Label(f,text=fontName,background=bg).pack(side='left')
    << define fontCallback >>

    familyBox.configure(selectioncommand=fontCallback)
    slantBox.configure(selectioncommand=fontCallback)
    weightBox.configure(selectioncommand=fontCallback)

    self.initValue(p,munge(fontName),'font',d,fontCallback)

    self.sc.create_window(15,self.h,anchor='w',window = f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.35:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

data = d.get('family')
initialitem = 0
if data:
    name2,val = data
    if val and val in names:
        initialitem = names.index(val)

familyBox = Pmw.ComboBox(f,
    labelpos="we",label_text='Family:',
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(initialitem)
familyBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.35:<< create the family combo box >>
#@+node:ekr.20041225063637.36:<< create the size entry >>
Tk.Label(f,text="Size:",background=bg).pack(side="left")

sizeEntry = Tk.Entry(f,width=4)
sizeEntry.pack(side="left")

data = d.get('size')
if data:
    kind,val = data
    if val not in (None,'None','none'):
        try:
            int(val)
            sizeEntry.insert('end',val)
        except ValueError:
            s = "invalid size: %s" % val
            print s ; self.es(s,color="blue")
#@nonl
#@-node:ekr.20041225063637.36:<< create the size entry >>
#@+node:ekr.20041225063637.37:<< create the weight combo box >>
initialitem = 0
values = ['<None>','normal','bold']
data = d.get('weight')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

weightBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Weight:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

weightBox.selectitem(initialitem)
weightBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.37:<< create the weight combo box >>
#@+node:ekr.20041225063637.38:<< create the slant combo box>>
initialitem = 0
values=['<None>','roman','italic']
data = d.get('slant')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

slantBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Slant:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

slantBox.selectitem(initialitem)
slantBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.38:<< create the slant combo box>>
#@+node:ekr.20041225063637.39:<< define fontCallback >>
def fontCallback(*args,**keys):
    
    __pychecker__ = '--no-argsused' # not used, but needed.
    
    d2 = d.copy() # The update logic must compare distinct dicts.
    
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:   val = sizeEntry.get().strip()
        if not val or  val.lower() in ('none','<none>',): val = None

        data = d.get(key)
        name,oldval = data
        d2[key] = name,val
    
    return d2
#@nonl
#@-node:ekr.20041225063637.39:<< define fontCallback >>
#@-node:ekr.20041225063637.34:createFont
#@+node:ekr.20041225063637.40:createInt
def createInt (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')

    def intCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
    
    self.initValue(p,name,kind,val,intCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.40:createInt
#@+node:ekr.20041225063637.41:createInts
def createInts (self,parent,p,kind,name,val):
    
    # g.trace(repr(kind),repr(name),val)
    
    bg = self.commonBackground
    
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent)

    intsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background=bg,
        scrolledlist_items=items)

    intsBox.selectitem(initialitem)
    intsBox.pack(side="left",padx=2)
    
    def intsCallback():
        val2 = intsBox.get()
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val

    self.initValue(p,name,kind,val,intsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.41:createInts
#@+node:ekr.20041225063637.42:createPath
def createPath (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.42:createPath
#@+node:ekr.20041225063637.43:createRatio
def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 <= val2 <= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.43:createRatio
#@+node:ekr.20041225063637.45:createShortcut
def createShortcut (self,parent,p,kind,name,val):
    
    g.trace(name,val)
    
    if name:
        self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.45:createShortcut
#@+node:ekr.20041225063637.46:createShortcuts
def createShortcuts (self,parent,p,kind,name,vals):
    
    __pychecker__ = '--no-argsused' # vals not used.
    
    t = self.createText(parent,p)
    
    def shortcutsCallback():
        val = t.get('1.0','end').rstrip()
        return val

    self.initValue(p,name,kind,vals,shortcutsCallback)
#@nonl
#@-node:ekr.20041225063637.46:createShortcuts
#@+node:ekr.20041225063637.47:createSpacerFrame
def createSpacerFrame (self,parent,size=10):
    
    f = Tk.Frame(parent)
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += size
#@nonl
#@-node:ekr.20041225063637.47:createSpacerFrame
#@+node:ekr.20041225063637.48:createString
def createString (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    if val in (None,'None'): val = ""
    
    # Inits the Entry widget.
    var = Tk.StringVar()
    var.set(val)
    
    f = Tk.Frame(parent) # No need to pack.
    Tk.Entry(f,textvariable=var,width=40).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def stringCallback():
        val = var.get()
        # g.trace(name,val)
        return val

    self.initValue(p,name,kind,val,stringCallback)
    
    self.sc.create_window(15,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.48:createString
#@+node:ekr.20041225063637.49:createStrings
def createStrings (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # g.trace(repr(kind),repr(name),val)
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent,background=bg)

    stringsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background = bg,
        scrolledlist_items=items)

    stringsBox.selectitem(initialitem)
    stringsBox.pack(side="left",padx=2)
    
    def stringsCallback():
        return stringsBox.get()

    self.initValue(p,name,kind,val,stringsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.49:createStrings
#@+node:ekr.20050512134219:createText
def createText (self,parent,p):
    
    bg = self.commonBackground
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='shortcuts',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background='white',
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=10,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',p.bodyString().strip())
    t.configure(state='normal')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 140
    
    return t
#@nonl
#@-node:ekr.20050512134219:createText
#@-node:ekr.20041225063637.25:createWidgets & helpers
#@-node:ekr.20050531105422:(Made sure comments are always visible in setting dialog even for non-@ nodes)
#@+node:ekr.20050608084340:(Fixed problem with leading @ in body text)
#@+node:ekr.20050608084340.1:Report
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3190593

As luck would have it, I need to put an @ character at the beginning of a line
in source code (windows registry file format) and can't figure out how to do
it.  Any suggestions?
#@-node:ekr.20050608084340.1:Report
#@+node:ekr.20050608084340.2:Notes
@nocolor
This looks like a bug.  I suspect the fix will be relatively straightforward.  I plan to fix it today.  BTW, I have no idea why Leo thinks it must special-case an @-sign in this context.

The rest of the posting are essentially notes to myself.  You can skip it if you like :-)

Here is an example of the bug.  I put the following text in an @file node and an @thin node.  (All examples were with @language plain: I doubt if language has any major effect.)

Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&Notepad"

The contents of the file derived from the @file tree was:

#@verbatim
#@+leo-ver=4
#@verbatim
#@+node:@file leadingAtTest.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
#@verbatim
#@@="&Notepad"
#@verbatim
#@-node:@file leadingAtTest.py
#@verbatim
#@-leo

The contents of the file derived from the @thin tree was:

#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20050608081942:@thin leadingAtTest2.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
#@verbatim
#@@="&Notepad"
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20050608081942:@thin leadingAtTest2.py
#@verbatim
#@-leo

The bug does not appear if the @ sign is followed by what looks to be a keyword.  For example, I put the following text in an @file node and an @thin node:

Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad

The contents of the file derived from the @file tree was:

#@verbatim
#@+leo-ver=4
#@verbatim
#@+node:@file leadingAtTest3.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
#@verbatim
#@nonl
#@verbatim
#@-node:@file leadingAtTest3.py
#@verbatim
#@-leo

The contents of the file derived from the @thin tree was:

#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20050608082702.1:@thin leadingAtTest4.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
#@verbatim
#@-node:ekr.20050608082702.1:@thin leadingAtTest4.py
#@verbatim
#@-leo
#@-node:ekr.20050608084340.2:Notes
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.198:directiveKind4 & test
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@nonl
#@+node:ekr.20050608103755:test_directiveKind4
def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@nonl
#@-node:ekr.20050608103755:test_directiveKind4
#@-node:ekr.20041005105605.198:directiveKind4 & test
#@-node:ekr.20050608084340:(Fixed problem with leading @ in body text)
#@+node:ekr.20050615100824:(Fixed several  crashers while undoing a move involving clones)
#@+node:ekr.20050615101010:(fixed) Crash: move c up, then undo.
exception executing command
Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 177, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1563, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1711, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2760, in moveToNthChildOf
    p.unlink()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3283, in unlink
    assert(parent.v in p.v.directParents())
AssertionError
#@nonl
#@-node:ekr.20050615101010:(fixed) Crash: move c up, then undo.
#@+node:ekr.20050615111747:(fixed) Crash2: clone c, move up twice, undo three times (no clone), redo: clone moves to wrong position
#@-node:ekr.20050615111747:(fixed) Crash2: clone c, move up twice, undo three times (no clone), redo: clone moves to wrong position
#@+node:ekr.20050615111747.1:(fixed) Crash 3: clone c, undo, redo
@killcolor

exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 177, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1309, in redo
    u.redoHelper()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1334, in redoCloneNode
    if u.newBack:

AttributeError: undoer instance has no attribute 'newBack'
#@nonl
#@-node:ekr.20050615111747.1:(fixed) Crash 3: clone c, undo, redo
#@+node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@nonl
#@-node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.5:p.unlink
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@nonl
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()

    # Selecting can scroll the tree which causes flash.
    if u.groupCount == 0:
        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411112033:undoMove
#@clone 2
#@+node:ekr.20050615101010.1:a
#@clone 2
#@+node:ekr.20050615101010.2:b
#@+node:ekr.20050615101010.3:c
#@-node:ekr.20050615101010.3:c
#@-node:ekr.20050615101010.2:b
#@-node:ekr.20050615101010.1:a
#@-node:ekr.20050615100824:(Fixed several  crashers while undoing a move involving clones)
#@+node:ekr.20050614061546.2:(Experimented with patch for canvas scrolling problems) Crashes on XP
#@+node:ekr.20050614061546.3:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3178878
By: mackal

Found this in Tk's   "text.tcl":

@color
@language tcltk

if {[string equal "x11" [tk windowingsystem]]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #   http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Text <4> {
        if {!$tk_strictMotif} {
            %W yview scroll -5 units
        }
    }
    bind Text <5> {
        if {!$tk_strictMotif} {
            %W yview scroll 5 units
        }
    }
}

@nocolor


So basically the text widget grabs the mouse-wheel scroll events.  I'm kind
of rusty in TclTk bind and bindtags particulars, so perhaps someone can suggest
the "proper" way to fix this... is it just a matter of deleting the binging
from the default bindtags for Tk.Text?

BTW, I'm using Tk 8.4... (i.e.,that's where that code snippet was ripped from)
#@-node:ekr.20050614061546.3:Report
#@+node:ekr.20050614064918:Patch
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3184865
By: mackal

The prior patch is even faultier than I realized, causing even the node body
mouse wheel events to scroll outline views (basically any mousewheel event in
any Tk.Text would scroll the outline which had the most recently called
newText()).

Here is a properly functioning patch:[snip]

EKR: I don't see how this can work.  The tree pane almost never gets focus.  And it seems to crash on XP.
#@nonl
#@-node:ekr.20050614064918:Patch
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget('all',t)
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("<Control-t>",self.onControlT)

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
    t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
    t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("<Button-4>", PropagateButton4)
    t.bind("<Button-5>", PropagateButton5)
    t.bind("<MouseWheel>", PropagateMouseWheel)

#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20050614061546.2:(Experimented with patch for canvas scrolling problems) Crashes on XP
#@+node:ekr.20050614065022:(Fixed Unicode encoding problem)
#@+node:ekr.20050614065022.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3186385
By: ejoy

I just tried 4.3-final, and it seems it does not work with Chinese LC_CTYPE:

echo $LC_CTYPE
zh_CN

leo
reading settings in /home/zl/opt/lib/leo/config/leoSettings.leo
Traceback (most recent call last):
  File "/home/zl/opt/lib/leo/src/leo.py", line 310, in ?
    run(fileName)
  File "/home/zl/opt/lib/leo/src/leo.py", line 96, in run
    g.app.setEncoding()
  File "/home/zl/opt/lib/leo/src/leoApp.py", line 361, in setEncoding
    for (encoding,src) in (
  File "/home/zl/opt/lib/python2.4/locale.py", line 415,
in getpreferredencoding
    setlocale(LC_CTYPE, "")
  File "/home/zl/opt/lib/python2.4/locale.py", line 379, in setlocale
    return _setlocale(category, locale)
locale.Error: unsupported locale setting

This can be solve by wrap setlocale with a try/except statement to fallback
to English on local.Error, I think.

#@-node:ekr.20050614065022.1:Report
#@+node:ekr.20031218072017.2618:app.setEncoding
@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    try: locale_encoding = g.getpreferredencoding()
    except Exception: locale_encoding = None
    
    try: sys_encoding = sys.getdefaultencoding()
    except Exception: sys_encoding = None

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        (locale_encoding,"locale"),
        (sys_encoding,"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding):
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding:
            color = g.choose(self.tkEncoding=="ascii","red","blue")
            g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
#@nonl
#@-node:ekr.20031218072017.2618:app.setEncoding
#@-node:ekr.20050614065022:(Fixed Unicode encoding problem)
#@+node:ekr.20050614061546:(Fixed problem with coloring @language plain)
#@+node:ekr.20050614061546.1:Report & fix
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3175553
By: nobody

When I set default_target_language to plain in 4.2., no words in any body text
is colored. This behavior seems to have changed in 4.3. Is it right, that I
now have to write @nocolor on top of *every* body text to get rid of randomly
colored words?
 
Kind regards 
Franz GEIGER, who's still using Leo as the world's best outliner and not for
programming tasks (I'm in love for more than 2 years now :-) )

What I did:

- Added entries for target_language to ivarsDic and defaultsDict in leoConfig.py.
- Added @language target_language = Python to leoSettings.leo.
- Convert c.target_language to lowercase in several places.
 
#@-node:ekr.20050614061546.1:Report & fix
#@+node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
# Add any newly-added user keywords.
for d in g.globalDirectiveList:
    name = '@' + d
    if name not in leoKeywords:
        leoKeywords.append(name)

# Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
s = self.body.getAllText() # 10/27/03
self.sel = sel = self.body.getInsertionPoint() # 10/27/03
start,end = self.body.convertIndexToRowColumn(sel) # 10/27/03

if self.language: self.language = self.language.lower() # 6/20/05
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    self.removeAllImages()

self.redoColoring = False
self.redoingColoring = False

<< configure tags >>
<< configure language-specific settings >>

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')
#@nonl
#@+node:ekr.20031218072017.1603:<< configure tags >>
for name in default_colors_dict.keys(): # Python 2.1 support.
    option_name,default_color = default_colors_dict[name]
    option_color = c.config.getColor(option_name)
    color = g.choose(option_color,option_color,default_color)
    # Must use foreground, not fg.
    try:
        self.body.tag_configure(name, foreground=color)
    except: # Recover after a user error.
        self.body.tag_configure(name, foreground=default_color)

underline_undefined = c.config.getBool("underline_undefined_section_names")
use_hyperlinks      = c.config.getBool("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    self.body.tag_configure("link",underline=1) # defined
    self.body.tag_configure("name",underline=0) # undefined
else:
    self.body.tag_configure("link",underline=0)
    if underline_undefined:
        self.body.tag_configure("name",underline=1)
    else:
        self.body.tag_configure("name",underline=0)
        
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = c.config.getColor(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            self.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            self.body.tag_configure(name,background=default_color)
    
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    self.body.tag_configure("latexModeBackground",foreground="black")
    self.body.tag_configure("latexModeKeyword",foreground="blue")
    self.body.tag_configure("latexBackground",foreground="black")
    self.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    self.body.tag_configure("latexBackground",foreground="black",background="white")
    self.body.tag_configure("latexKeyword",foreground="blue",background="white")
    
# Tags for wiki coloring.
if self.showInvisibles:
    self.body.tag_configure("elide",background="yellow")
else:
    self.body.tag_configure("elide",elide="1")
self.body.tag_configure("bold",font=self.bold_font)
self.body.tag_configure("italic",font=self.italic_font)
self.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    self.body.tag_configure(name,foreground=name)
#@nonl
#@-node:ekr.20031218072017.1603:<< configure tags >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@-node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20050614061546:(Fixed problem with coloring @language plain)
#@-node:ekr.20050524102538:Bug fixes...
#@+node:ekr.20050526081733:New features...
#@+node:ekr.20050523075215:(Created separate helpers for idle_body_key)
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@-node:ekr.20050523075215:(Created separate helpers for idle_body_key)
#@+node:ekr.20050518055557:(Created v0.2 of UniversalScrolling plugin)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3155710

I simplified the code so I could understand it.

Known problems:

- Binding <Button-1> events is not a good idea.  The plugin has no good way to be sure whether the user intended to select a headline or scroll.

- Sometimes 'junk' appears above the scrolled outline when the root node gets scrolled down.  It appears impossible to fix.  A workaround would be to prevent scrolling downward if that would move the root node down.  However, I don't know how to do this: the canvas.yview method always returns the same value.
#@nonl
#@-node:ekr.20050518055557:(Created v0.2 of UniversalScrolling plugin)
#@+node:ekr.20050512085922:(Made all Mark commands undoable)
# I also fixed a bug: the Mark Clones command did not work!
#@nonl
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command
    
    return bunch
#@nonl
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self): 

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()
    
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self):

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    p.setMarked()
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
def markAllAtFileNodesDirty (self):

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode()and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
def markAtFileNodesDirty (self):

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2927:markClones
def markClones (self):

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline
def markHeadline (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            p.clearMarked()
        else:
            p.setMarked()
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2928:markHeadline
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads(self):

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll(self):

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.clearMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@-node:ekr.20031218072017.2922:Mark...
#@-node:ekr.20050512085922:(Made all Mark commands undoable)
#@+node:ekr.20050527100614:(Removed dependence on profile and pstats modules from leoTest.py)
#@+node:ekr.20050527100614.1:Report
@killcolor

https://sourceforge.net/forum/message.php?msg_id=3172485
By: ktenney


/usr/lib/python2.4/site-packages# python leo/src/leo.py
reading settings in /usr/lib/python2.4/site-packages/leo/config/leoSettings.leo
Traceback (most recent call last):
  File "leo/src/leo.py", line 312, in ?
    run()
  File "leo/src/leo.py", line 95, in run
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting
g.app.config.
  File "/usr/lib/python2.4/site-packages/leo/src/leoConfig.py", line 1169, in
readSettingsFiles
    c = self.openSettingsFile(path)
  File "/usr/lib/python2.4/site-packages/leo/src/leoConfig.py", line 1141, in
openSettingsFile
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
  File "/usr/lib/python2.4/site-packages/leo/src/leoGui.py", line 105,
in newLeoCommanderAndFrame
    import leoCommands
  File "/usr/lib/python2.4/site-packages/leo/src/leoCommands.py", line 24, in ?
    import leoImport
  File "/usr/lib/python2.4/site-packages/leo/src/leoImport.py", line 8, in ?
    import leoTest # Support for unit tests.
  File "/usr/lib/python2.4/site-packages/leo/src/leoTest.py", line 29, in ?
    import profile
ImportError: No module named profile


#@-node:ekr.20050527100614.1:Report
#@-node:ekr.20050527100614:(Removed dependence on profile and pstats modules from leoTest.py)
#@+node:ekr.20050601112005:(Body key handlers now call colorizer.interrupt)
# This supports the new colorizer.  It has no effect in the present code base.
#@nonl
#@-node:ekr.20050601112005:(Body key handlers now call colorizer.interrupt)
#@+node:ekr.20050602081251:(Added patch for tk options)
@

Leo will now look for a file called .leo_xresources' in the users home
directory. If found, Leo will pass that file to Tk's option_readfile method for
the top widget. This allows users to set Tk options.
#@nonl
#@+node:ekr.20050602081251.1:Initial posting
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3181786
By: mackal

The following is a patch for allowing the user to have a configuration file
specifying what fonts to use in menubars, etc.  This is mostly intended for
Linux/UNIX, where the default Tk look is very Motif-like (read "ugly"!).  As
suggested, I might turn this into a plugin once I figure out how to do that,
but for the time being it might be a fix for other Linux users currently suffering.
:)

Although AFAIK TclTk supports the notion of X11 resources with  its option_readfile()
and other option-related commands, I'm not sure whether this has any effect
under Windows, where I believe the native toolkit is used.

Here is the patch:[snip]

Here is a sample resource file I look to give Leo a much "lighter" feel
(to be placed in ~/.leo_xresources):

! X resources to use in Leo
*font:                  -*-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*
*padY:                  0
*borderWidth:           1
*activeBorderWidth:     1

! have to reset the borderWidth back to 0 for dialogs
*Dialog*borderWidth:    0
*Dialog.msg.font:       -*-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*
#@-node:ekr.20050602081251.1:Initial posting
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
#@nonl
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.wantedCommander = None # Used by leoTkinterFrame logic to manage calls to g.app.gui.set_focus.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@-node:ekr.20050602081251:(Added patch for tk options)
#@+node:ekr.20050618045013.1:(Installed support for PL/SQL language)
#@+node:ekr.20050618045013.17:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618045013.17:plsql keywords
#@-node:ekr.20050618045013.1:(Installed support for PL/SQL language)
#@-node:ekr.20050526081733:New features...
#@-node:ekr.20050524073547.1:4.3.1 projects
#@+node:ekr.20050621084408:4.3.2 projects
#@+node:ekr.20050705192437:Bug fixes...
#@+node:ekr.20050705140158:Fixed bug with non-unicode characters in file name
#@+node:ekr.20050705140158.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3224635
By: madmike

Leo doesn't seem to like to read leo-Files which has non-ascii charaters in
the Filename (like "Präsentation.leo"). Trying to do so results in the following
Exception raised:

C:\>D:\Userdata\CH00JAP\Programme\Python\python.exe
D:\Userdata\CH00JAP\Programme\leo\src\leo.py
D:\Userdata\CH00JAP\programming\leo\Präsentation.leo
reading settings in D:\Userdata\CH00JAP\Programme\leo\config\leoSettings.leo
Traceback (most recent call last):
  File "D:\Userdata\CH00JAP\Programme\leo\src\leo.py", line 310, in ?
    run(fileName)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leo.py", line 95, in run
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting
g.app.config.
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 1173,
in readSettingsFiles
    print s ; g.es(s)
  File "D:\Userdata\CH00JAP\Programme\Python\lib\encodings\cp850.py", line 18,
in encode
    return codecs.charmap_encode(input,errors,encoding_map)
UnicodeEncodeError: 'charmap' codec can't encode character u'\ufffd' in position
58: character maps to <undefined>

Renaming the File does work as a workaround.

#@-node:ekr.20050705140158.1:Report
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@-node:ekr.20050705140158:Fixed bug with non-unicode characters in file name
#@+node:ekr.20050705142321:Fixed bug with non-unicode characters in settings value
#@+node:ekr.20050705142321.1:Report
@nocolor 
http://sourceforge.net/forum/message.php?msg_id=3222750
By: madmike

Trying to set non-ascii characters in settingsraises exception on clicking
"OK":

Exception in Tkinter callback
Traceback (most recent call last):
  File "D:\Userdata\CH00JAP\Programme\Python\lib\lib-tk\Tkinter.py", line 1345,
in __call__
    return self.func(*args)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 1893,
in buttonCallback
    self.onAnyButton(name)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 2758,
in onAnyButton
    if f: f()
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 2977,
in writeChangedVars
    s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
UnicodeEncodeError: 'ascii' codec can't encode character u'\xf6' in position
29: ordinal not in range(128)

I've tested this in my own outline local preferences and with the global prefernces
and get the same result.

I've recieve reproduced the error on @string, @path und @directory.


MadMike

#@-node:ekr.20050705142321.1:Report
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
            elif ikind == 'shortcuts':
                s = 'updating shortcuts in %s' % ip.headString()
            else:
                # Convert unicode strings to strings safe for printing.
                # The calls to str are needed because g.toEncodedString only changes unicode strings.
                strOldVal = str(g.toEncodedString(oldVal,'ascii'))
                strNewVal = str(g.toEncodedString(newVal,'ascii'))
                strIname  = str(g.toEncodedString(iname,'ascii'))
                s = "write  %10s -> %10s %s" % (strOldVal,strNewVal,strIname)
            g.es_print(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList)
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Just put the new the values in the body.
                p.setBodyStringOrPane(val)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList):
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (g.callerList(2),kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050705142321:Fixed bug with non-unicode characters in settings value
#@+node:ekr.20050706081854:Fixed two recent files bugs
#@+node:ekr.20050706081854.1:Report
@nocolor 
http://sourceforge.net/forum/message.php?msg_id=3218558
By: billp9619

Leo Log Window...
Leo 4.3.1, build  1.266 , June 20, 2005
Python 2.3.4, Tk 8.4.3, win32

On a new install with no prior Recent Files, I opened a file without saving
and exited Leo. On return there were still no Recent Files listed.

I opened another file and saved under a different name. After exiting leo and
restarting, the different name saved did not appear listed but the original
opened file was.I guess both should have been listed.

My preference for Recent Files list is that there would be a very long history
maintained and any file name I view is in the the list. :)

I guess you need to update the list anytime a name is dropped from the open
widow status including if the current open file is Closed or superceded using
Save As.

regards,

bill p
#@-node:ekr.20050706081854.1:Report
#@+node:ekr.20031218072017.2835:saveAs
def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@nonl
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@nonl
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        # g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)
#@nonl
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@nonl
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
        
    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.
#@nonl
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20050706081854:Fixed two recent files bugs
#@+node:ekr.20050825081645:Fixed bug in g.reportBadChars
#@+node:ekr.20050825084513:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3307318
By: zhms

Error in tangling when section name contain unicode.

reading: D:\doc\digest\buddha\amtb\amtb.leo
Tangling...
exception executing command
Traceback (most recent call last):
  File "C:\tool\Leo\src\leoCommands.py", line 177, in doCommand
    command()
  File "C:\tool\Leo\src\leoCommands.py", line 889, in tangle
    c.tangleCommands.tangle()
  File "C:\tool\Leo\src\leoTangle.py", line 604, in tangle
    if not self.tangleTree(p,report_errors):
  File "C:\tool\Leo\src\leoTangle.py", line 744, in tangleTree
    self.tanglePass2() # self.p invalid in pass 2.
  File "C:\tool\Leo\src\leoTangle.py", line 712, in tanglePass2
    self.put_all_roots() # pass 2 top level function.
  File "C:\tool\Leo\src\leoTangle.py", line 1466, in put_all_roots
    self.put_part_node(part,False) # output first lws
  File "C:\tool\Leo\src\leoTangle.py", line 1782, in put_part_node
    self.put_code(part.code,no_first_lws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1525, in put_code
    self.put_section(s,i,name,name_end)
  File "C:\tool\Leo\src\leoTangle.py", line 1907, in put_section
    self.put_part_node(part,no_first_leading_ws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1782, in put_part_node
    self.put_code(part.code,no_first_lws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1525, in put_code
    self.put_section(s,i,name,name_end)
  File "C:\tool\Leo\src\leoTangle.py", line 1879, in put_section
    self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
  File "C:\tool\Leo\src\leoTangle.py", line 1382, in os
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
  File "C:\tool\Leo\src\leoGlobals.py", line 3603, in toEncodedString
    g.reportBadChars(s,encoding)
  File "C:\tool\Leo\src\leoGlobals.py", line 3582, in reportBadChars
    g.es("%d errors converting %s to %s" %
UnicodeDecodeError: 'ascii' codec can't decode byte 0xcc in position 23: ordinal
not in range(128)
#@-node:ekr.20050825084513:Report
#@+node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.1499:isUnicode
def isUnicode(s):
    
    return s is None or type(s) == type(u' ')
#@nonl
#@-node:ekr.20031218072017.1499:isUnicode
#@+node:ekr.20031218072017.1500:isValidEncoding
def isValidEncoding (encoding):
    
    try:
        if len(encoding) == 0:
            return False
        unicode("a",encoding)
        return True
    except:
        return False
#@-node:ekr.20031218072017.1500:isValidEncoding
#@+node:ekr.20031218072017.1501:reportBadChars
def reportBadChars (s,encoding):
    
    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except UnicodeEncodeError:
                errors += 1
        if errors:
            g.es("%d errors converting %s to %s" % (
                errors, s.encode(encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % (
                errors,
                unicode(s,encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
#@nonl
#@+node:ekr.20050825092149:test_g_reportBadChars
def test_g_reportBadChars ():
    
    for s,encoding in (
        ('aĂbĂ',  'ascii'),
        (u'aĂbĂ', 'ascii'),
        ('炰',    'ascii'),
        (u'炰',   'ascii'),
        
        ('aĂbĂ',  'utf-8'),
        (u'aĂbĂ', 'utf-8'),
        ('炰',    'utf-8'),
        (u'炰',   'utf-8'),
    ):
    
        g.reportBadChars(s,encoding)
#@nonl
#@-node:ekr.20050825092149:test_g_reportBadChars
#@-node:ekr.20031218072017.1501:reportBadChars
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20050208093903:toEncodedStringWithErrorCode
def toEncodedStringWithErrorCode (s,encoding):
    
    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208093903:toEncodedStringWithErrorCode
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
    
#@-node:ekr.20050208093800.1:toUnicode
#@+node:ekr.20050208095723:toUnicodeWithErrorCode
def toUnicodeWithErrorCode (s,encoding):
    
    ok = True
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208095723:toUnicodeWithErrorCode
#@+node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
def test_round_trip_toUnicode_toEncodedString ():
   
    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('äöü',  'utf-8'),
        ('äöü',  'mbcs'),
        ('炰',   'utf-8'),
        ('炰',   'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s
#@nonl
#@-node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
#@+node:ekr.20050208112123:test_failure_with_ascii_encodings
def test_failure_with_ascii_encodings():

    encoding = 'ascii'
    
    s = '炰'
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = u'炰'
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@nonl
#@-node:ekr.20050208112123:test_failure_with_ascii_encodings
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
# Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        << define getpreferredencoding using _locale >>
    else:
        << define getpreferredencoding for *nix >>
        
__pychecker__ = '--reuseattr'
#@+node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
# On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
#@+node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
# On Unix, if CODESET is available, use that.

__pychecker__ = '--no-noeffect' # Note: this is at the top level!

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
#@-node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
#@-node:ekr.20031218072017.1498:Unicode utils...
#@-node:ekr.20050825081645:Fixed bug in g.reportBadChars
#@+node:ekr.20050723093228:Fixed minor crash in colorizer
#@+node:ekr.20050825095048:What I did
@nocolor

The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.
#@nonl
#@-node:ekr.20050825095048:What I did
#@+node:ekr.20050723093228.1:Traceback
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoColor.py", line 1688, in colorizeAnyLanguage
    state = self.colorizeLine(new_lines[i],state)
  File "C:\prog\leoCVS\leo\src\leoColor.py", line 1803, in colorizeLine
    func = self.state_dict[state]
KeyError: 'unknown'
#@-node:ekr.20050723093228.1:Traceback
#@+node:ekr.20031218072017.1607:<< define dispatch dicts >>
self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['<'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["<<"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
#@nonl
#@-node:ekr.20031218072017.1607:<< define dispatch dicts >>
#@-node:ekr.20050723093228:Fixed minor crash in colorizer
#@+node:ekr.20050825101028:Protected several methods used by plugin manager
@nocolor

The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.

This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py
#@nonl
#@-node:ekr.20050825101028:Protected several methods used by plugin manager
#@+node:ekr.20050704090830:Added test files to distribution list and cvs
@

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.
- Other test files should be distributed in @ignore nodes.
- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.
#@nonl
#@+node:ekr.20050830051128:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3231597
By: edcdave

After uninstalling my earlier version of Leo and deleting all files, I installed
Leo 4.3.1 Build 1.266. (Python 2.3.3)

Making no other changes or installing any other files, I opened leo/test/test.leo.
The document opens with the following errors:

fixed:
    can not open: '@file C:\Program Files\Leo\extensions\testExtension.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest2.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest3.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest4.py'

Add to distribution list (and cvs)
    can not open: '@file C:\Program Files\Leo\test\unittest\errorTest.py'
    can not open: '@file C:\Program Files\Leo\test\unittest\batchTest.py'

And sure enough none of these files are in leo/test and the directory
leo/test/unittest was not created by the installation.

Dave
#@-node:ekr.20050830051128:Report
#@-node:ekr.20050704090830:Added test files to distribution list and cvs
#@+node:ekr.20050801102407:Investigated bug report: dead link for leoPy.leo in help menu: not a problem
@ This does not seem to be a problem.

Leo is distributed with the expected file names for LeoDocs.leo, LeoPy.leo, LeoPluings.leo.
#@nonl
#@+node:ekr.20050801102407.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3274505
By: ktenney

I like that, a nice way to access the source 
without risking unwanted changes.

Does the same principle apply to 
LeoPy.leo/LeoPyRef.leo ?

Didn't there used to be an entry for leoPy.leo 
on the 'Help' menu?

That means that Leo ships with a dead link on the 
'Help' menu, I wonder how we could make sure the
 reason for that is explained.

We don't want to cause discouragement among folks
wanting to dive into the source.

Maybe the menu text could be;
leoPlugins.leo (leoPluginsRef.leo save as)
leoPy.leo (leoPyRef.leo save as)
... must be a better way ...

Thanks,
Kent
#@-node:ekr.20050801102407.1:Report
#@+node:ekr.20050802082948:Post 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3274666
By: ktenney

Maybe the menu item could be 'Leo plugins source'

When selected, create leoPlugins.leo if required, explaining that this is a safe
copy of the source file.

An entry which behaved like this called 'Leo source' which did the same routine
with LeoPy.leo might be nice for folks in the 'Use the source, Luke' category.
#@nonl
#@-node:ekr.20050802082948:Post 2
#@-node:ekr.20050801102407:Investigated bug report: dead link for leoPy.leo in help menu: not a problem
#@+node:ekr.20050906192101:Fixed bug in mod_spelling
# Sometimes the word wasn't selected properly.
#@nonl
#@-node:ekr.20050906192101:Fixed bug in mod_spelling
#@+node:ekr.20050721095052:Investigated problems with outline colors: works for me
#@+node:ekr.20050721095052.1:Post 1
http://sourceforge.net/forum/message.php?msg_id=3247013
By: rich_ries

First, I D/L'd all the 'stuff' I could find in CVS, making sure none of the
files were older than the LeoPy.leo file.

CLEO - Nice! But I can't clear the priority marks.

Group Operations - I _used_ to be able to use keypresses Alt+Shift+M/V/C/T/~
to Mark/Move/Copy/Tag/Clone, which was a LOT easier than playing with the mouse.
(Try Tagging three sequential nodes. Previously, it was Alt+Shift+T, Alt+Shift+T,
Alt+Shift+T. Now it's Move-Mouse-to-location+ click+ Move-Mouse-to-another-location+
Move-Mouse-to-another-location+ click JUST TO TAG ONE NODE! Now try doing that
for  THREE nodes -- let alone the dozen I usually work with!

I have (amongst other plugins) Nav_Buttons, NodeBar, and Hoist turned on, and
it's a gamble regarding which button(s) will be full-sized, and which ones
half-sized. NodeBar's 'about' claims to add buttons "to the bottom of the tree
canvas", yet they are up with the other buttons.

When I open an empty .LEO file, the focus is on the body pane. I press a key
to start entering text, but after the first character, I'm in the Outline Pane,
_adding_ text to "NewHeadline".

--Rich
#@nonl
#@-node:ekr.20050721095052.1:Post 1
#@+node:ekr.20050721095052.2:Post 2
http://sourceforge.net/forum/message.php?msg_id=3248719
By: nobody

From: Rich

Nit:
Outline Pane Colors goes background/foreground until headline_text_editing_selection,
which is then reversed: foreground/background. Similar thing with the Log Pane
Colors. Changing leoSettings.leo corrected this.

Hitting [ESC] no longer exits the editing mode.

Also, running Preferences & clicking [OK] seems to have no effect, at least
on the colors. If this is a case of "exit to enable" a message should be shown
in BIG NEON LETTERS indicating this: It's an important functional detail, but
I shouldn't need to remember it -- the computer can do that very nicely.

Try as I can, I can not change the headline_text_unselected_background_color.
It is stuck on white, and white it SHALL remain!

--Rich
#@nonl
#@-node:ekr.20050721095052.2:Post 2
#@+node:ekr.20050831130936:Post 3
http://sourceforge.net/forum/message.php?msg_id=3260433
By: nobody

From: Rich
I get the names from the color-selector, and I am careful with the case.
Here are my outline pane colors:
+ @page Outline pane colors
- @color outline_pane_background_color = AntiqueWhite1
- @color headline_text_unselected_foreground_color = black
- @color headline_text_unselected_background_color = AntiqueWhite1
- @color headline_text_selected_foreground_color = black
- @color headline_text_selected_background_color = AntiqueWhite3
- @color headline_text_editing_foreground_color = blue
- @color headline_text_editing_background_color = white
- @color headline_text_editing_selection_foreground_color = black
- @color headline_text_editing_selection_background_color = blue

And what I see:
New file comes up w/ Blue on White for "New Headline"
Pressing the first key changes the headline to Black on Blue, and brings the
cursor/focus up to the headline.
Pressing [Enter] to go back to the body pane sets the headkine to Black
on AntiqueWhite3.
Adding another node sets the first headline to Black on White, and the second
headline to Black on Blue, with the cursor/focus on the headline.

I also tried restoring the order of the names to their original locations just
in case this would have an effect. No difference.

--Rich
#@-node:ekr.20050831130936:Post 3
#@-node:ekr.20050721095052:Investigated problems with outline colors: works for me
#@+node:ekr.20050909113245.4:Investigated problems with *some* settings (still works for me)
#@+node:ekr.20050909113245.5:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3331806
By: nobody

From: Rich
Further tests

I changed leoSettings to:

+ @page Outline pane colors
   - @color headline_text_unselected_background_color = black
   - @color headline_text_unselected_foreground_color = brown

   - @color headline_text_selected_background_color = red
   - @color headline_text_selected_foreground_color = orange
   - @color headline_text_editing_background_color = yellow
   - @color headline_text_editing_foreground_color = green
   - @color headline_text_editing_selection_foreground_color = blue
   - @color headline_text_editing_selection_background_color = purple
   - @color outline_pane_background_color = AntiqueWhite1

saved the file, and opened a new (empty) .leo file. I would expect the colors
to follow the scheme in config\leoSettings.leo. However, what I got was:

+ @page Outline pane colors
   - @color headline_text_unselected_background_color = white
   - @color headline_text_unselected_foreground_color = black

   - @color headline_text_selected_background_color = red
   - @color headline_text_selected_foreground_color = orange
   - @color headline_text_editing_background_color = yellow
   - @color headline_text_editing_foreground_color = green
   - @color headline_text_editing_selection_foreground_color = blue
   - @color headline_text_editing_selection_background_color = purple
   - @color outline_pane_background_color = AntiqueWhite1

That is, everything changed _except_ the unselected background and foreground
colors!? When I hit Ctrl-Y, the UBG/UFG colors changed to black/brown, thereby
matching the @settings selection. Hitting [Apply] and closing the preferences
window brought UBG/UFG back to white/black.

--Rich


______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

#@-node:ekr.20050909113245.5:Report
#@-node:ekr.20050909113245.4:Investigated problems with *some* settings (still works for me)
#@-node:ekr.20050705192437:Bug fixes...
#@+node:ekr.20050705192437.1:New & improved features...
#@+node:ekr.20050706090801:(Added g.es_print, es_trace & eliminate corresponding print statements)
@ Calling print directly is dangerous: it will fail for unicode characters.
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):
    
    print g.toEncodedString(s,'ascii')
    g.es(s,*args,**keys)
    
def test_g_es_print():
    
    g.es_print('\ntest of es_print: Ă',color='red')
#@nonl
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20050707065530:es_trace & test
def es_trace(s,*args,**keys):
    
    g.trace(g.toEncodedString(s,'ascii'))
    g.es(s,*args,**keys)
    
def test_g_es_trace():
    
    g.es_trace('\ntest of es_trace: Ă',color='red')
#@nonl
#@-node:ekr.20050707065530:es_trace & test
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20041225063637.76:printChangedVars
def printChangedVars (self):

    d = self.initValueDict
    
    for key in d.keys():
        
        data = d.get(key)
        p,name,kind,val,getValueCallback = data
        newVal = getValueCallback()
        
        if val != newVal:
            name   = str(g.toEncodedString(name))
            val    = str(g.toEncodedString(val))
            newVal = str(g.toEncodedString(newVal))
            print "%10s -> %10s %s" % (val,newVal,name)
#@nonl
#@-node:ekr.20041225063637.76:printChangedVars
#@-node:ekr.20050706090801:(Added g.es_print, es_trace & eliminate corresponding print statements)
#@+node:ekr.20050726101110.1:(Improved PrettyPrinting)
#@+node:ekr.20050726130115:What I did
@nocolor

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.
#@nonl
#@-node:ekr.20050726130115:What I did
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20050729211526:prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self
    
    if not p:
        p = c.currentPosition()
    
    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20050729211526:prettyPrintPythonNode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next text by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@nonl
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@nonl
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@-node:ekr.20050726101110.1:(Improved PrettyPrinting)
#@+node:ekr.20050906081155:Added leoPostings.leo to distribution
#@-node:ekr.20050906081155:Added leoPostings.leo to distribution
#@+node:ekr.20050711185846.1:Installed patch for xemacs plugin from mackal
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3219471
By: mackal

Here's a simple patch to have this plugin work in Linux:

*** xemacs.py.orig Sat Jun 25 19:12:52 2005
--- xemacs.py Sat Jun 25 19:15:15 2005
***************
*** 51,54 ****
--- 51,64 ----
      # This path must not contain blanks in XP.  Sheesh.
      _emacs_cmd = r"c:\XEmacs\XEmacs-21.4.13\i586-pc-win32\xemacs.exe"
+ elif sys.platform.startswith("linux"):
+     clients = ["gnuclient", "emacsclient", "xemacs"]
+     _emacs_cmd = ""
+     for cl in clients:
+         path = "/usr/bin/"+cl
+         if os.path.exists(path):
+             _emacs_cmd = path
+             break
+     if not _emacs_cmd:
+         print>> sys.stderr, "Unable to locate a usable version of *Emacs"
  else:
      _emacs_cmd = "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"
#@nonl
#@-node:ekr.20050711185846.1:Installed patch for xemacs plugin from mackal
#@+node:JSBiz.20050817134120:Installed patches for vim, openWith: Jim Sizelove
#@+node:JSBiz.20050817145837:Problems spawning gVim, and the solutions I came up with.
@nocolor

I was trying to get Leo to work more effectively with Vim, my editor of choice.
To do so, I made several changes to Leo which (I believe) make it work better.

After much exploring and trying various things, I made a change to the os.spawnv
section of the openWith function in leoCommands.py. This added line seems to
prevent the "weird error message on first open of Vim." (vim.py, line 32) when
opening Vim with os.spawnv.

os.spawnv needs the command it is calling as the first argument in the args list
in addition, so the command actually shows twice in the total args to os.spawnv,
e.g.::
    
    os.spawnv(os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["gvim.exe", "--servername", "LEO", "--remote", "foo.txt"])
    
If the call is made without the command-name as the first item in the list of
args, like so::
    
    os.spawnv(os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["--servername", "LEO", "--remote", "foo.txt"])

an error message pops up::
    
    E247: no registered server named "GVIM": Send failed.  Trying to execute locally
    
This message means that gVim is not looking for a server named "LEO", which
presumably the user has already opened with the command "gvim --servername LEO".
Instead it is looking for a server named "GVIM", and not finding it, opens the
files "foo.txt" and "LEO" (notice that it didn't catch the "--servername"
argument and thinks that "LEO" is the name of a new file to create) in two
buffers in a local copy of gVim. Now, if the command is::

    os.spawnv(
        os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["gvim.exe", "--servername", "LEO", "--remote", "foo.txt"])

everything works great, as long as the user doesn't close the gVim window. If
the user has closed the gVim window, then tries to open a node in Vim, they will
see this error message::

    E247: no registered server named "LEO": Send failed.

Trying to execute locally If you use the "--remote-silent" argument, gVim will
start the LEO server without the error message.

One other comment:  you can see which servers gVim has running by typing::

    vim --serverlist

at the command prompt.
#@nonl
#@-node:JSBiz.20050817145837:Problems spawning gVim, and the solutions I came up with.
#@+node:JSBiz.20050817145837.1:Using the subprocess module from Python 2.4
@nocolor

The rest of my changes have to do with using the subprocess module instead of
the os.system, and various os.spawn* calls. I find subprocess easier to
understand, and it is fairly simple to use for the most common kinds of process
calls, but is capable of all the variations you may need. It is designed to
replace all the os.system, os.spawn*, and popen* calls. It is available in
Python 2.4.

So I added some lines to use subprocess in the OpenWith plugin and the Vim
plugin. I also have added a table in the "create_open_with_menu" function that
makes use of the various editors I have used at times. Most of those editors are
called with subprocess.Popen.
#@nonl
#@-node:JSBiz.20050817145837.1:Using the subprocess module from Python 2.4
#@+node:ekr.20040712045933:<< imports  >> (leoCommands)
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import leoAtFile
import leoConfig
import leoEditCommands
import leoFileCommands
import leoKeys
import leoImport
import leoNodes
import leoTangle
import leoUndo

import compiler # for Check Python command
import keyword
import os
import parser # needed only for weird Python 2.2 parser errors.
import string

# Bug fix: 9-16-05
subprocess = g.importExtension('subprocess',None,verbose=False)

import sys
import tempfile

import tabnanny # for Check Python command
import tokenize # for Check Python command

# The following import _is_ used.
__pychecker__ = '--no-import'
import token    # for Check Python command
#@nonl
#@-node:ekr.20040712045933:<< imports  >> (leoCommands)
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@-node:JSBiz.20050817134120:Installed patches for vim, openWith: Jim Sizelove
#@+node:ekr.20050910103843:added aspell23.pyd and aspell24.pyd to Leo's extension folder
@nocolor

See the installation nodes in the docstring for the spellpyx plugin for how to use these files.
#@nonl
#@-node:ekr.20050910103843:added aspell23.pyd and aspell24.pyd to Leo's extension folder
#@-node:ekr.20050705192437.1:New & improved features...
#@-node:ekr.20050621084408:4.3.2 projects
#@+node:ekr.20050914132013:4.3.2 final projects
#@+node:ekr.20050912070506:Fixed crasher in rst3 plugin when docutils not present
#@+node:ekr.20050912070506.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3333638
By: tfer

As downloaded; log pane notes problems with rst3 and aspell plug-ins.  Will,
aspell still appears in the plugin menu and supplies directions for downloading
and setting up needed components for that plugin in its "about".

Following those directions (and searching help for aspell tips that lead me
to making the using raw strings for the pathnames, (i.e. <pathvar> = r'<pahtname>')),
I get the following in the log pane:

global config dir: C:\Program Files\Leo\config
home dir: None
reading settings in C:\Program Files\Leo\config\leoSettings.leo
unexpected exception in g.importFromPath
Traceback (most recent call last):

  File "C:\Program Files\Leo\src\leoGlobals.py", line 4964, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\Program Files\Leo\plugins\rst3.py", line 553, in ?
    code_block.options = {

AttributeError: 'NoneType' object has no attribute 'parsers'

can not load enabled rst3 plugin
Can not import aspell from plugin spellpyx
can not load enabled spellpyx plugin
5 plugins loaded
#@-node:ekr.20050912070506.1:Report
#@-node:ekr.20050912070506:Fixed crasher in rst3 plugin when docutils not present
#@+node:ekr.20050911085148:Investigated problems with es_print (works for me)
#@+node:ekr.20050914132954:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3333424
Viktor Ransmayr

  with your release of the beta I tried to generate the Leo
User Guide locally at my laptop and encountered the
following problems:

2005-09-11 09:04:20

o Try creation of leo-documentation with rst3-plugin. 
 - Help->Open LeoDocs.leo
 - Edit->Write Restructured Text
 - See <<Log2>>

### Begin of Log2 content

Leo Log Window...
Leo 4.3.2 beta 1, build  1.278 , September 10, 2005
Python 2.4.1, Tk 8.4.7, win32

reading: C:\Programme\Leo\doc\LeoDocs.leo
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\rstplugin3.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\leo_TOC.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css

...

SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\directives.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
exception executing command
Traceback (most recent call last):
  File "C:\Programme\Leo\src\leoCommands.py", line 186, in doCommand
    command()
  File "C:\Programme\Leo\plugins\rst3.py", line 656, in callback
    self.processTree(c.currentPosition())
  File "C:\Programme\Leo\plugins\rst3.py", line 1105, in processTree
    self.report(self.outputFileName)
  File "C:\Programme\Leo\plugins\rst3.py", line 1537, in report
    g.es_print('wrote: %s' % (name),color="blue")
  File "C:\Programme\Leo\src\leoGlobals.py", line 2458, in es_print
    print g.toEncodedString(s,'ascii')
IOError: [Errno 9] Bad file descriptor

### End of Log2 content

When I tried to generate the various chapters manually
by hand using the rst3 button in the outline I succeeded.
#@-node:ekr.20050914132954:Report
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):
    
    print g.toEncodedString(s,'ascii')
    g.es(s,*args,**keys)
    
def test_g_es_print():
    
    g.es_print('\ntest of es_print: Ă',color='red')
#@nonl
#@-node:ekr.20050707064040:es_print & test
#@-node:ekr.20050911085148:Investigated problems with es_print (works for me)
#@+node:ekr.20050911084855:Added doc/html/*.html to distribution list
#@-node:ekr.20050911084855:Added doc/html/*.html to distribution list
#@-node:ekr.20050914132013:4.3.2 final projects
#@+node:ekr.20050916095957:4.3.3 projects
#@+node:ekr.20050916101421:Cleanup
#@+node:ekr.20050902074723:Protected c.beginEndUpdate against exceptions.
@nocolor

Use the following pattern throughout:

@color

    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate(flag)
        
@nocolor

c.endUpdate re-raises any pending exception.
#@nonl
#@+node:ekr.20031218072017.2952:c.endUpdate & test
def endUpdate(self, flag=True):
    
    '''End a beginUpdate/endUpdate region.
    
    Redraw the tree if this is the outermost endUpdate.
    
    Note that calls to g.es() will disable redraws, so calls to endUpdate
    should follow all such writes to the log pane.
    
    New in Python 4.4:  All of Leo's core code uses this pattern::
        
        c.beginUpdate()
        try:
            ...
        finally:
            c.endUpdate()
        
    Python automatically re-raises an exception after executing a finally block,
    so there is no need to do so here.'''

    try:
        self.frame.tree.endUpdate(flag)
    except Exception:
        pass
    
EndUpdate = endUpdate # Compatibility with old scripts
#@nonl
#@+node:ekr.20050916100046:test_c_endUpdate
def test_c_endUpdate (self):

    try:
        c.beginUpdate()
        try:
            assert(0)
        finally:
            c.endUpdate()
    except AssertionError:
        return
    
    # This will never happen: finally always re-raises a pending exception.
    assert(0,'no re-raise after finally')
#@nonl
#@-node:ekr.20050916100046:test_c_endUpdate
#@-node:ekr.20031218072017.2952:c.endUpdate & test
#@-node:ekr.20050902074723:Protected c.beginEndUpdate against exceptions.
#@+node:ekr.20050902115502:Any way to fix this bug? (works for me)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3322277
By: dcbbcd

If I use Toggle Active Pane to switch to the outline, the
outline does not get the keyboard focus. I.e. I can't select
another node by using the arrow keys. The black focus
rectangle is around the outline, so partly it worked.

Is this a bug or am I misunderstanding what the 
command does?
#@-node:ekr.20050902115502:Any way to fix this bug? (works for me)
#@-node:ekr.20050916101421:Cleanup
#@+node:ekr.20050916190932:Docs
#@+node:ekr.20050621130815:Rewrote tech report with rst3
@nocolor

This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.
#@nonl
#@-node:ekr.20050621130815:Rewrote tech report with rst3
#@-node:ekr.20050916190932:Docs
#@+node:ekr.20050917092155:Plugins
@nocolor

- Fixed bugs in niceNosent and fastGotoNode plugins.
- Added niceNosent and fastGotoNode plugins to pluginsManager.txt (disabled)
- Realized that the rst3 plugin should **ignore** @ignore directives.
  Indeed, we typically want to use @ignore to suppress creation of derived files.
- Called Pmw.initialise in the plugins manager plugin.
#@nonl
#@+node:ekr.20050917114044:Fix problem in plugin manager
#@+node:ekr.20050917114044.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3342256

Started Plugin Mgr. Got:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 186, in doCommand
    command()
  File "C:\Software Engineering\Leo\plugins\plugins_menu.py", line 502,
in callback
    p.hastoplevel()
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 193, in
topLevelMenu
    dlg = ManagerDialog()
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 680, in
__init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 311, in
__init__
    label_text = 'Name:',
  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py",
line 73, in __init__
    sequences = root.bind_class(tag)
  File "C:\Language\Python\lib\lib-tk\Tkinter.py", line 958, in bind_class
    return self._bind(('bind', className), sequence, func, add, 0)
  File "C:\Language\Python\lib\lib-tk\Tkinter.py", line 893, in _bind
    return self.tk.splitlist(self.tk.call(what))
TclError: bad window path name
".12775632.15466288.15466328.15466408.15466448.15800760.15801320"
#@nonl
#@-node:ekr.20050917114044.1:Report
#@+node:ekr.20050917114044.2:What I did
@nocolor

- Added a call to Pmw.initialise(g.app.root) in the top-level init method.
#@nonl
#@-node:ekr.20050917114044.2:What I did
#@-node:ekr.20050917114044:Fix problem in plugin manager
#@-node:ekr.20050917092155:Plugins
#@-node:ekr.20050916095957:4.3.3 projects
#@+node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row > len(lines) or col > len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050710102922:get/setPythonInsertionPoint
def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
#@nonl
#@-node:ekr.20050710102922:get/setPythonInsertionPoint
#@+node:ekr.20050710104804:getPythonTextSelection
def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
#@nonl
#@-node:ekr.20050710104804:getPythonTextSelection
#@+node:ekr.20050710104804.1:setPythonTextSelection
def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
#@nonl
#@-node:ekr.20050710104804.1:setPythonTextSelection
#@+node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3174:escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 >= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
#@nonl
#@-node:ekr.20031218072017.3174:escaped
#@+node:ekr.20031218072017.3175:find_line_start
def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
#@nonl
#@-node:ekr.20031218072017.3175:find_line_start
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k > -1: return k
    else: return None
#@nonl
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3178:is_nl
def is_nl(s,i):

    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@nonl
#@-node:ekr.20031218072017.3178:is_nl
#@+node:ekr.20031218072017.3179:is_special
# We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i < len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
#@nonl
#@-node:ekr.20031218072017.3179:is_special
#@+node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i < len(s) and g.is_ws(s[i]))
#@nonl
#@-node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
#@+node:ekr.20031218072017.3181:match
# Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
#@nonl
#@-node:ekr.20031218072017.3181:match
#@+node:ekr.20031218072017.3182:match_c_word
def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
#@nonl
#@-node:ekr.20031218072017.3182:match_c_word
#@+node:ekr.20031218072017.3183:match_ignoring_case
def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
#@nonl
#@-node:ekr.20031218072017.3183:match_ignoring_case
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')
#@nonl
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3185:skip_blank_lines
def skip_blank_lines(s,i):

    while i < len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3185:skip_blank_lines
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    n = len(s)
    while i < n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
#@nonl
#@-node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i < n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3189:skip_matching_delims
def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)
#@nonl
#@-node:ekr.20031218072017.3189:skip_matching_delims
#@+node:ekr.20031218072017.3190:skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
#@nonl
#@-node:ekr.20031218072017.3190:skip_nl
#@+node:ekr.20031218072017.3191:skip_non_ws
def skip_non_ws (s,i):

    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3191:skip_non_ws
#@+node:ekr.20031218072017.3192:skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
#@nonl
#@-node:ekr.20031218072017.3192:skip_pascal_braces
#@+node:ekr.20031218072017.3193:skip_to_char
def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
#@-node:ekr.20031218072017.3193:skip_to_char
#@+node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
def skip_ws(s,i):

    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
#@-node:ekr.20031218072017.3173:Scanners: no error messages
#@-node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20051025065958:(Recent)
#@+node:ekr.20051010062551.1:(key dicts)
@

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.
    
inverseBindingsDict (computed by computeInverseBindingDict)
    keys are emacs command names, values are shortcuts.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are g.bunch(func,name,warningGiven)
#@+node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
def finishCreateEditCommanders (c):
    
    '''Finish creating edit classes in the commander.
    
    Return the commands dictionary for all the classes.'''
    
    global classesList
    
    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                keys = d2.keys()
                keys.sort()
                print '----- %s' % name
                for key in keys: print
                
    return d
#@nonl
#@-node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'close-find-dialog':    c.dismissFindPanel, # Deprecated.
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'find-dialog-change':       c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':   c.replaceAll,           # Deprecated.
    'find-dialog-find-next':    c.findNext,             # Deprecated.
    'find-dialog-find-previous':c.findPrevious,         # Deprecated.
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-find-dialog':          c.showFindPanel, # Deprecated.
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@-node:ekr.20051010062551.1:(key dicts)
#@+node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = True
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands')
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)
    
# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands')
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("<Activate>",f.OnActivateLeoEvent)
    f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()

    c.beginUpdate()
    try:
        c.selectVnode(p)
        c.redraw()
        c.frame.getFocus()
        c.editPosition(p)
    finally:
        c.endUpdate(False)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label
#@nonl
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 1: # I wish there were an easier way...
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'close-find-dialog':    c.dismissFindPanel, # Deprecated.
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'find-dialog-change':       c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':   c.replaceAll,           # Deprecated.
    'find-dialog-find-next':    c.findNext,             # Deprecated.
    'find-dialog-find-previous':c.findPrevious,         # Deprecated.
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-find-dialog':          c.showFindPanel, # Deprecated.
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@-node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c
    
    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return

    try:
        << bind callback to shortcut in pane >>

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            # g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20051022094136:<< bind callback to shortcut in pane >>
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

# Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the <Key>+ binding.

allPanes = [body,log,tree,menu,minibuffer]

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or 'all').lower(),[])

if shortcut == '<Key>':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:<< bind callback to shortcut in pane >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWantFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callerList(5))

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callerList(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callerList(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others
#@nonl
#@+node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.11:__init__
def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    
    << create the tkinter intVars >>
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20051020120306.12:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20051020120306.12:<< create the tkinter intVars >>
#@-node:ekr.20051020120306.11:__init__
#@+node:ekr.20051023181449:find.createBindings
def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunch = c.config.getShortcut(commandName)
            accel = bunch and bunch.val
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            if shortcut:
                # g.trace(shortcut,commandName)
                w.bind(shortcut,func)
        w.bind ("<1>",  self.resetWrap,'+')
        w.bind("<Key>", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("<Key-Return>", self.findButtonCallback)
        w.bind("<Key-Escape>", self.hideTab)
#@nonl
#@-node:ekr.20051023181449:find.createBindings
#@+node:ekr.20051020120306.13:find.createFrame
def createFrame (self,parentFrame):
    
    c = self.c
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    << Create two columns of buttons >>
    
    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.frame = Tk.Frame(self.top,background=bg)
self.outerFrame = outer = Tk.Frame(self.frame,background=bg)

self.top.pack   (side='top',expand=0,fill='x',pady=5)
    # Don't expand, so the frame goes to the top.

self.frame.pack (side="top",expand=1,fill='x')
outer.pack      (side='top',expand=1,fill='x',padx=2,pady=2,)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ("&Mark Finds",           self.dict["mark_finds"]),
    ("Mark &Changes",         self.dict["mark_changes"]),
    ('Show Context',          self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:find.createFrame
#@+node:ekr.20051020120306.19:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20051020120306.20:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20051020120306.20:<< set find/change widgets >>
#@+node:ekr.20051020120306.21:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20051020120306.21:<< set radio buttons from ivars >>
#@-node:ekr.20051020120306.19:find.init
#@-node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.22:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20051020120306.22:find.update_ivars
#@+node:ekr.20051023183028:findButtonCallback
def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'
#@nonl
#@-node:ekr.20051023183028:findButtonCallback
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@nonl
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()
#@nonl
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20051020120306.25:hideTab
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t,later=False)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t,later=True)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@+node:ekr.20051020120306.27:selectAllFindText
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.
#@nonl
#@-node:ekr.20051020120306.27:selectAllFindText
#@+node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl	
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20051020120306.28:Tkinter wrappers (leoTkinterFind)
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@nonl
#@+node:ekr.20050920084036.258: ctor
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    self.forward = True
    self.regexp = False

    # For replace-string and replace-regexp
    self._sString = ''
    self._rpString = ''
#@nonl
#@-node:ekr.20050920084036.258: ctor
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }
#@nonl
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20051022211617:find tab...
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:commands...
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@nonl
#@-node:ekr.20051022212004:commands...
#@-node:ekr.20051022211617:find tab...
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)
#@nonl
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,regexp):

    k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
#@nonl
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler & helper
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    k = self.k ; w = event.widget ; keysym = event.keysym
    if keysym == 'Control_L': return
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '<Control-s>':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '<Control-r>':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            << do a non-incremental search >>
        k.resetLabel()
        k.clearState()
        return

    if event.char == '\b':
        g.trace('backspace not handled yet')
        return
    
    if event.char:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)
#@nonl
#@+node:ekr.20051002120125:<< do a non-incremental search >>
s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)
#@nonl
#@-node:ekr.20051002120125:<< do a non-incremental search >>
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = event.widget
    s = k.getLabel(ignorePrompt=True)
    g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')
#@nonl
#@-node:ekr.20050920084036.263:iSearchHelper
#@-node:ekr.20050920084036.264:iSearchStateHandler & helper
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event):

    k = self.k ; w = event.widget

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@nonl
#@-node:ekr.20050920084036.265:scolorizer
#@-node:ekr.20050920084036.261:incremental search...
#@+node:ekr.20050920084036.267:non-incremental search...
#@+node:ekr.20050920084036.269:seachForward/Backward & helper
def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=True)
#@nonl
#@+node:ekr.20050920084036.268:plainSearchHelper
def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)
#@nonl
#@-node:ekr.20050920084036.268:plainSearchHelper
#@-node:ekr.20050920084036.269:seachForward/Backward & helper
#@+node:ekr.20051002111614:wordSearchBackward/Forward & helper
def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=True)
#@nonl
#@+node:ekr.20050920084036.272:wordSearchHelper
def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) > 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
#@-node:ekr.20050920084036.272:wordSearchHelper
#@-node:ekr.20051002111614:wordSearchBackward/Forward & helper
#@+node:ekr.20050920084036.274:reSearchBackward/Forward & helper
def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)
#@nonl
#@+node:ekr.20050920084036.275:reSearchHelper
def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget
    cpattern = re.compile(pattern)

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) > 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')
#@nonl
#@-node:ekr.20050920084036.275:reSearchHelper
#@-node:ekr.20050920084036.274:reSearchBackward/Forward & helper
#@-node:ekr.20050920084036.267:non-incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@+node:ekr.20051025071455:Spell classes
@ To do:
- open the minibuffer to get suggestions.
- Per-pane key bindings. (arrows, etc.)
- Accumulate status messages.
@c

<< specify aspell directories >>

@others
#@nonl
#@+node:ekr.20051025071455.3:<< specify aspell directories >>
if sys.platform == 'darwin':
    aspell_dir = '/sw/lib'
        # The top-level directory.
    aspell_bin_dir = '/sw/lib/bin'
        # NOT TESTED YET.
else:
    aspell_dir = r'c:\Aspell'
        # The top-level directory.
    aspell_bin_dir = r'c:\Aspell\bin'
        # The directory continaing apell.pyd and aspell-15.dll
#@nonl
#@-node:ekr.20051025071455.3:<< specify aspell directories >>
#@+node:ekr.20051025071455.6:class Aspell
class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

#@+node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.8:__init__
def __init__(self,c,local_dictionary_file,local_language_code):
    
    """Ctor for the Aspell class."""
    
    self.c = c
    
    # Specify the path to the top-level Aspell directory.
    if sys.platform == 'darwin':
        aspell = g.importFromPath ("aspell",aspell_dir,pluginName=__name__,verbose=True)
    else:
        aspell = g.importFromPath(
            "aspell",aspell_bin_dir,pluginName=__name__,verbose=True)
            
    self.aspell = aspell

    self.sc = aspell.spell_checker(prefix=aspell_dir,lang=local_language_code)
    # g.trace(self.sc)
    
    self.aspell_exe_loc = (c.config.getString('aspell_bin_dir') or aspell_bin_dir)
    # g.trace(self.aspell_exe_loc)

    self.local_language_code = local_language_code
    self.local_dictionary_file = local_dictionary_file
    self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
    # g.trace(self.local_dictionary)
#@nonl
#@-node:ekr.20051025071455.8:__init__
#@+node:ekr.20051025071455.9:getAspellDirectory (not used)
def getAspellDirectory(self):

    """Get the directory containing aspell.exe from the .ini file"""

    try:
        fileName = os.path.join(g.app.loadDir,"..","plugins",ini_file_name)
        config = ConfigParser.ConfigParser()
        config.read(fileName)
        return config.get("main", "aspell_dir")
    except:
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20051025071455.9:getAspellDirectory (not used)
#@-node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.10:processWord
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)
#@nonl
#@-node:ekr.20051025071455.10:processWord
#@+node:ekr.20051025071455.11:updateDictionary
def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl < %s.txt" %
            (self.aspell_exe_loc, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es("Unable to update local aspell dictionary: %s" % err)
        print err
        add_dicts = ""
        return False
#@nonl
#@-node:ekr.20051025071455.11:updateDictionary
#@-node:ekr.20051025071455.6:class Aspell
#@+node:ekr.20051025071455.1:class spellCommandsClass
class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others
#@nonl
#@+node:ekr.20051025080056:ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.
#@nonl
#@-node:ekr.20051025080056:ctor
#@+node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
#@nonl
#@-node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()
#@nonl
#@-node:ekr.20051025080633:openSpellTab
#@+node:ekr.20051025080420.1:commands...
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@nonl
#@-node:ekr.20051025080420.1:commands...
#@-node:ekr.20051025071455.1:class spellCommandsClass
#@+node:ekr.20051025071455.18:class spellTab (leoFind.leoFind)
class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
#@nonl
#@+node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.20:spellTab.__init__
def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    self.c = c ; log = c.frame.log ; tabName = 'Spell'
    
    leoFind.leoFind.__init__(self,c) # Call the base ctor.
    
    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()
#@nonl
#@-node:ekr.20051025071455.20:spellTab.__init__
#@+node:ekr.20051025094004:init_aspell
def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
#@nonl
#@-node:ekr.20051025094004:init_aspell
#@+node:ekr.20051025071455.22:createSpellTab
def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    # Create the outer frame.
    self.outerFrame = outer = Tk.Frame(parentFrame,bd=2,bg=bg)
    outer.pack(expand=1,fill='both',padx=2,pady=2)
    
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>
    
    self.fillbox([])
    self.listBox.bind("<Double-Button-1>",self.onChangeThenFindButton)
    self.listBox.bind("<Button-1>",self.onSelectListBox)
    self.listBox.bind("<Map>",self.onMap)
#@nonl
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=10,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@nonl
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@nonl
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20051025071455.22:createSpellTab
#@+node:ekr.20051025120920:createBindings
def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunch = c.config.getShortcut(commandName)
            accel = bunch and bunch.val
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            if shortcut:
                # g.trace(shortcut,commandName)
                w.bind(shortcut,func)
#@nonl
#@-node:ekr.20051025120920:createBindings
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % local_dictionary)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@nonl
#@-node:ekr.20051025071455.16:readDictionary
#@-node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.29:Buttons
#@+node:ekr.20051025071455.30:onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
#@nonl
#@-node:ekr.20051025071455.30:onAddButton
#@+node:ekr.20051025071455.31:onIgnoreButton
def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
#@nonl
#@-node:ekr.20051025071455.31:onIgnoreButton
#@+node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
#@-node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
#@+node:ekr.20051025071455.33:onFindButton
def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20051025071455.33:onFindButton
#@+node:ekr.20051025071455.34:onHideButton
def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()
#@nonl
#@-node:ekr.20051025071455.34:onHideButton
#@-node:ekr.20051025071455.29:Buttons
#@+node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.37:add
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
#@nonl
#@-node:ekr.20051025071455.37:add
#@+node:ekr.20051025071455.38:change
def change(self,event=None):
    """Make the selected change to the text"""

    c = self.c ; current = c.currentPosition()
    body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, ">", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            newSel = g.app.gui.getTextSelection(t)

            # update node, undo status, dirty flag, changed mark & recolor
            c.beginUpdate()
            c.frame.body.onBodyChanged(current,"Change",oldSel=oldSel,newSel=newSel)
            c.endUpdate(True)
            t.focus_set()
            return True

    # The focus must never leave the body pane.
    t.focus_set()
    return False
#@nonl
#@-node:ekr.20051025071455.38:change
#@+node:ekr.20051025071455.40:find
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.frame.bodyWantsFocus(later=False)
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])
#@nonl
#@-node:ekr.20051025071455.40:find
#@+node:ekr.20051025121408:hide
def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
#@nonl
#@-node:ekr.20051025121408:hide
#@+node:ekr.20051025071455.41:ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
#@nonl
#@-node:ekr.20051025071455.41:ignore
#@-node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.42:Helpers
#@+node:ekr.20051025071455.43:bringToFront
def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
#@nonl
#@-node:ekr.20051025071455.43:bringToFront
#@+node:ekr.20051025071455.44:fillbox
def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

#@-node:ekr.20051025071455.44:fillbox
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition() ; t = self.workCtrl
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word
#@nonl
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    
    # print "Ignored", word
    continue
    
# print "Didn't ignore '%s'" % word
#@nonl
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
# Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as é.  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i < len(line) and line[i] not in word_start:
            i += 1
        if i < len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j < len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert",">=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@+node:ekr.20051025071455.48:getSuggestion
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
#@nonl
#@-node:ekr.20051025071455.48:getSuggestion
#@+node:ekr.20051025071455.49:onMap
def onMap (self, event=None):
    """Respond to a Tk <Map> event."""
    
    self.update(show= False, fill= False)
#@nonl
#@-node:ekr.20051025071455.49:onMap
#@+node:ekr.20051025071455.50:onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    self.updateButtons()
    self.body.bodyCtrl.focus_set()
#@-node:ekr.20051025071455.50:onSelectListBox
#@+node:ekr.20051025071455.51:update
def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.frame.body.bodyCtrl.focus_set()
#@nonl
#@-node:ekr.20051025071455.51:update
#@+node:ekr.20051025071455.52:updateButtons
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@nonl
#@-node:ekr.20051025071455.52:updateButtons
#@-node:ekr.20051025071455.42:Helpers
#@-node:ekr.20051025071455.18:class spellTab (leoFind.leoFind)
#@-node:ekr.20051025071455:Spell classes
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    if 1: # Bind to the Find tab.
        sc = c.searchCommands
        self.editMenuFindMenuTable = [
            ("&Show Find Tab",sc.openFindTab),
            ("&Hide Find Tab",sc.hideFindTab),
            ("-",None),
            ("Find &Next",          sc.findTabFindNext),
            ("Find &Previous",      sc.findTabFindPrev),
            ("&Replace",            sc.findTabChange),
            ("Replace, &Then Find", sc.findTabChangeThenFind),
        ]
    else: # Bind to deprecated Find dialog.
        self.editMenuFindMenuTable = [
            ("&Find Panel",c.showFindPanel),
            ("-",None),
            ("Find &Next",c.findNext),
            ("Find &Previous",c.findPrevious),
            ("&Replace",c.replace),
            ("Replace, &Then Find",c.replaceThenFind),
        ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@-node:ekr.20051025065958:(Recent)
#@+node:ekr.20051016115757:4.4a1 projects
#@+node:ekr.20050929075341:Added option for selected body text
#@+node:ekr.20050929075920:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3355954
By: nobody

Well, I came to the conclusion that there is no setting for body selection colors.
Please consider adding such settings in the future.

I changed it the source (Code-->Gui Tkinter classes-->@thin
leoTkinterFrame.py-->class leoTkinterBody--> Birth & death-->tkBody.createControl).
CadetBlue3 is more cheerful than Gray80, and syntax coloring still looks good.
#@-node:ekr.20050929075920:Request
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,frame,parentFrame):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    return body
#@nonl
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: body.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: body.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@-node:ekr.20050929075341:Added option for selected body text
#@+node:ekr.20050928112629:Fixed bug in Leo's read logic
#@+node:ekr.20050929082939:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3351985
By: leouserz

I have ran into my first case of actual brittleness in regular leos read code.

If I output via dom a tnode that has no text it does it like so:
<t/>

leo yacks on the fact that it was expecting:
<t></t>
#@nonl
#@-node:ekr.20050929082939:Report
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
#@+node:ekr.20031218072017.1561:getTnode (changed for 4.4)
def getTnode (self):

    # we have already matched <t.
    index = -1 ; attrDict = {}

    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed tnode.
        return

    # Attributes may appear in any order.
    while 1:
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag(">"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    << handle unknown attributes >>
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("</t>")
#@nonl
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        g.es_print(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@nonl
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode (changed for 4.4)
#@-node:ekr.20050928112629:Fixed bug in Leo's read logic
#@+node:ekr.20050929084510:Fixed problem with auto-indent
@

idle_body_key was being called twice for every keystroke.
Why this worked at all is still a bit of a mystery.
The fix was to eliminate the binding to <Key> in tkBody.createBindings.

To do: remove the cut/copy/paste bindings in tkBody.createBindings.
#@nonl
#@-node:ekr.20050929084510:Fixed problem with auto-indent
#@+node:ekr.20051006195420:Added background/foreground selection confic options
#@+node:ekr.20051006195420.1:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3361442
By: nobody

Thanks, now I know where those settings live. For completeness, and in case
somebody doesn't like low contrast of white on gray, I suggest to also add foreground
color setting. Imitating what you did I added the following:

two new settings under @settings-->Colors-->@page Body pane colors
in leoSettings.leo:

 @color body_text_selection_background_color = Gray80   (or CadetBlue2 etc.)
 @color body_text_selection_foreground_color = white    (or black)

added to tkBody.setColorFromConfig:

....sel_bg = c.config.getColor('body_text_selection_background_color')
or 'Gray80'
....try: body.configure(selectbackground=sel_bg)
....except Exception:
........g.es("exception setting body pane text selection background color")
........g.es_exception()
....
....sel_fg = c.config.getColor('body_text_selection_foreground_color')
or 'white'
....try: body.configure(selectforeground=sel_fg)
....except Exception:
........g.es("exception setting body pane text selection foreground color")
........g.es_exception()

Works with Leo 4.3.3, build  1.282 , Python 2.3.5, Tk 8.4.3, win32
#@-node:ekr.20051006195420.1:Report
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: body.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: body.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@-node:ekr.20051006195420:Added background/foreground selection confic options
#@+node:ekr.20050920084720.1:Moved emacs commands and new keyHandler to Leo's core
#@+node:ekr.20051003064825:Big picture
- The primary goal is to allow Emacs and Vim users to retain their 'finger habits' while using Leo.

    - It is *not* necessary to implement all Emacs commands: just those that are used frequently.
    - It *is* necessary to extend commands like isearch so they can deal with multiple body texts.

- The secondary goal is 'mouseless leo': being able to drive all parts of Leo without using the mouse.

    - The user must be able to drive all dialogs from the keyboard,
      **or to get the same effect without using a dialog at all**.
#@nonl
#@-node:ekr.20051003064825:Big picture
#@+node:ekr.20051008204635:Docs
#@+node:ekr.20050930083044:@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)
@killcolor

Invoking:
    emacs file1 file2 file3 .... 

Help
    CTRL-h enters the Help facility.
    Help Tutorial  (CTRL-h t)
    Help Apropos   (CTRL-h a) find a command given its functionality,
    Help Character (CTRL-h c) describes a given character's effect,
    Help Function ( CTRL-h f) describes a given Lisp function specified by name.

Reading, writing files
    C-x C-f Find file (to read into buffer) 
    C-x C-s Save current buffer (ie. file in the buffer) 

Moving the cursor
    C-f forward character 
    C-b backward character 
    C-n next line 
    C-p previous line 
    C-e move cursor to end of line 
    C-a move cursor to beginning of line 
    Esc-< move cursor to top of document 
    Esc-> move cursor to bottom of document 
    Esc-f forward word 
    Esc-b backward word 
    Esc-a backward sentence 
    Esc-e forward sentence 
    Esc-] forward paragraph 
    Esc-[ backward paragraph 
    C-v forward page 
    Esc-v backward page 
    Esc-x goto-linen 
    Esc-x goto-char 
    C-l recenter and redraw page 

Repeating Commands
    ESC-5 C-f       move forward 5 chars 
    C-u (the universal argument command)
        Just like Esc-n, but does not need an argument -> in which case the default of 4 is used. eg: 
    C-u C-u -> repeat 16 times 

Deleting Stuff (Killing)
    C-d delete char 
    E-d kill word 
    C-k kill line (but not newline after it) 
    C-u C-k delete 4 lines (not 2 lines! - newlines go too!) 
    E-4 C-k same 

Yanking back things from the Kill ring
    C-y yank 
    C-w kill region 
    E-w copy region into kill ring 
    C-@ or C-SPC set-mark 
    
Paragraph Reformatting
    E-q fill-paragraph 
    E-g fill-region

Searching and replacing
    C-s isearch-forward 
    C-r isearch-backward 
    Esc exit a successful search 
    C-g quit 
    C-s Esc non incremental search forward 
    C-r Esc backward " 
    E-x  replace-string RET bad RET good RET 
    E-% query replace 

By default, searches are case insensitive. You can change this by setting the
variable: case-fold-search --> set it to: nil (Use Esc-x set-variable) 
    E-x re-search-forward simple 
    E-x re-search-backward 
    E-x isearch-forward-regexp incremental 
    E-x isearch-backward-regexp 
    E-x query-replace-regexp 
    E-x replace-regexp 
    replace unconditionally 

Undo
    E-x revert-buffer restore file from disk 
    C-s u undo

Transpose
    C-t transpose characters 
    E-t transpose words 
    C-x C-t transpose lines 

Buffer Manipulation
    C-x b move to other buffer 
    C-x s save some buffers 
    E-x kill-buffer kill buffer 
    E-x kill-some-buffers kill some buffers 
    E-x rename-buffer rename buffer 
    C-x C-q toggle read only status of buffer 
    C-x C-b list buffers 

Window Manipulation
    C-x 2 split current window into 2 horizontals 
    C-x 5 vertically 
    C-x o move to other window 
    E-C v scroll next window 
    Attach '4' to C-x to have the operation go to the other window, eg: C-x 4 f find-file-other window 
    C-x 4 b change buffer other window 
    E-x compare-windows (must have 2 buffers in split windows) 

Spelling Checker
    E-$ (spell check the word the cursor is on)
    E-x spell-string
    E-x spell-buffer
    E-x spell-region

Shell commands in Emacs
    E-! run UNIX command 
    E-| run command on marked region (shell-command-on-region) 
    C-u E-! run UNIX command, but in the current window! 
    E-x shell invoke shell buffer 

Fix echo'ing and ^M ing at the end of lines: 
    stty -echo nl 

Dired: Directory Editor commands
    E-x dired or emacs  
    SPC move 
    n next 
    p prev 
    v view (via recursive edit) 
    C-c (or q) to return to directory list 
    d mark for deletion 
    e edit file 
    f edit file 
    x DELETE those marked 
    c copy file 
    r rename file 
    M change file permissions 

Text Formatting
    E-x fill-paragraph
    E-x fill-individual-paragraphs
    E-x edit-tab-stops
    E-x untabify (converts tabs to spaces)
    E-x tabify
    E-x mark-whole-buffer
    C-x h variable: indent-tabs-mode
    (if set to nil, Emacs always uses spaces to make tabs)
    C-x fill-prefix: this string automatically gets inserted at begin of each line
    C-x . set-fill-prefix
    E-x indented-text-mode

Centering Text
    E-s center-line
    E-x center-paragraph
    C-l form feed - used for pagination

Macros
    C-x ( start macro definition
    C-x ) end macro definition
    C-x e call-last-kbd-macro

Customizing Emacs
    (define-key keymap "keystroke" 'command-name)
    (global-set-key "keystroke" 'command-name)
    (local-set-key "keystroke" 'command-name)
    (global-unset-key "\C-s") 
    Example:
        (define-key global-map "\C-xl" 'goto-line)
            (global-set-key "\C-xl" 'goto-line) 
    Maps: global-map, ctl-x-map, esc-map 

Indentation
    E-C-\ indent-region 
    E-m back-to-indentation 
    E-^ delete-indentation join this line to previous 
    E-; indent-for-comment 

C-Mode
    E-C-a beginning-of-defun 
    E-C-e end-of-defun 
    E-C-h mark-c-function 

Variables Default 
    c-indent-level 2 
    c-auto-new-line nil 
    c-continued-statement-offset 2 
    c-argdecl-indent 5 
    c-brace-offset 0 
    c-continued-brace-offset 0 
    c-brace-imaginary-offset 0 
    c-label-offset -2 

ETAGS
    etags *.[ch] creates a TAGS file E-.
    find-tag C-x 4 find-tag-other-window E-,
    tags-loop-continue (find next tag)
    E-x tags-search prompts for an RE and finds it.
    find next by E-,
    E-x tags-query-replace
    C-u E-x tags-query-replace (only replace for full words) E-x list-tags 

Lisp Mode
    3: emacs-lisp-mode, lisp-mode, lisp-interaction-mode 
    S-expression: any syntactically correct LISP expression: atom or parenthesized list. 
    E C-a beginning-of-defun 
    E C-e end-of-defun 
    E C-h mark-defun 

Lisp Interaction Mode
    E-x lisp-interaction-mode
    LINEFEED C-j is bound to eval-print-last-sexp

Compiling Programs withing Emacs
    E-x compile
    default: make -k (controlled by compile-command variable)
    C-c ` next-error
    C-u C-x ` start at first error again
    E-x grep
#@nonl
#@-node:ekr.20050930083044:@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)
#@+node:ekr.20051004093536:@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)
#@-node:ekr.20051004093536:@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)
#@+node:ekr.20051005094144:@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)
#@-node:ekr.20051005094144:@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)
#@-node:ekr.20051008204635:Docs
#@+node:ekr.20050921100955:Not used
#@+node:ekr.20050723064110:class generalizedEditCommands (Do not delete)
class editCommands:

    @others
#@nonl
#@+node:ekr.20050723064110.1:ctor
def __init__ (self,c):
    
    self.c = c

    self.mode = 'default'
    self.modeStack = []
    
    self.defaultWordChars1, self.defaultWordChars2 = self.setDefaultWordChars()
    self.wordChars1 = self.defaultWordChars1
    self.wordChars2 = self.defaultWordChars2

    self.setDefaultOptions()
#@nonl
#@-node:ekr.20050723064110.1:ctor
#@+node:ekr.20050723064110.3:Options...
#@+node:ekr.20050723064110.4:setDefaultOptions
def setDefaultOptions(self):
    
    self.options = {
        'extendMovesForward':   True,  # True: moving forward may cross node boundaries.
        'extendMovesBack':      True,  # True: moving back may cross node boundaries.
        'extendFindsForward':   True,   # True: find forward may cross node boundaries.
        'extendFindsBack':      True,   # True: find back may cross node boundaries.
    }
#@nonl
#@-node:ekr.20050723064110.4:setDefaultOptions
#@+node:ekr.20050723064110.5:getOption
def getOption (self,optionName):
    
    # This may change when modes get put in.
    return self.options.get(optionName)
#@nonl
#@-node:ekr.20050723064110.5:getOption
#@-node:ekr.20050723064110.3:Options...
#@+node:ekr.20050723064110.6:Word stuff...
#@+node:ekr.20050723064110.7:findWordStart
def findWordStart(self,s,i):
    
    while i < len(s):
        if s[i] in self.wordChars1:
            return i
        else:
            i += 1
    return i
#@nonl
#@-node:ekr.20050723064110.7:findWordStart
#@+node:ekr.20050723064110.8:insideWord
def insideWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        0 < i < len(s) and
        s[i] in self.wordChars2 and
        s[i-1] in self.wordChars2
    )
#@nonl
#@-node:ekr.20050723064110.8:insideWord
#@+node:ekr.20050723064110.9:skipWord
def skipWord(self,s,i):
    
    while i < len(s) and s[i] in self.wordChars2:
        i += 1
    return i
#@nonl
#@-node:ekr.20050723064110.9:skipWord
#@+node:ekr.20050723064110.10:startsWord
def startsWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        i < len(s) and 
        s[i] in self.wordChars1 and
        (i == 0 or s[i-1] not in self.wordChars1)
    )
#@nonl
#@-node:ekr.20050723064110.10:startsWord
#@+node:ekr.20050723064110.11:setDefaultWordChars
def setDefaultWordChars (self):
    
    chars1 = '_' + string.letters
    chars2 = '_' + string.letters + string.digits
    return chars1, chars2
#@nonl
#@-node:ekr.20050723064110.11:setDefaultWordChars
#@-node:ekr.20050723064110.6:Word stuff...
#@+node:ekr.20050723064110.12:Cursor movement
#@+node:ekr.20050723064110.13:moveBackwardChar
def moveBackwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i -= 1
    if i >= 0:
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            s = p.bodyString()
            if len(s) > 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(len(s)-1)
                return True
            else:
                p.moveToThreadBack()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.13:moveBackwardChar
#@+node:ekr.20050723064110.14:moveBackwardWord (Finish)
def moveBackwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.findWordStart(s,i)
    i = self.findWordStart(s,i) ###
    if self.startsWord(s,i): ###
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            c.selectPosition(p)
            if self.moveBackwardWord(0):
                return True
            p.moveToThreadBack()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.14:moveBackwardWord (Finish)
#@+node:ekr.20050723064110.15:moveForwardChar
def moveForwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i += 1
    if i < len(s):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            if len(p.bodyString()) > 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(0)
                return True
            else:
                p.moveToThreadNext()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.15:moveForwardChar
#@+node:ekr.20050723064110.16:moveForwardWord
def moveForwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.skipWord(s,i)
    i = self.findWordStart(s,i)
    if self.startsWord(s,i):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            c.selectPosition(p)
            if self.moveForwardWord(0):
                return True
            p.moveToThreadNext()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.16:moveForwardWord
#@+node:ekr.20050723064110.17:selectWord
#@-node:ekr.20050723064110.17:selectWord
#@+node:ekr.20050723064110.18:selectForwordWord
def selectForwardWord (self):
    
    c = self ; b = c.frame.body ; s = b.getAllText()

    i = i1 = b.getPythonInsertionPoint()
    
    if i < len(s) and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i+1)
    
    while i < len(s) and not g.is_c_id(s[i]):
        i += 1
        
    if i < len(s) and g.is_c_id(s[i]):
        # b.setPythonTextSelection(i1,i)
        pass ### TODO
#@nonl
#@-node:ekr.20050723064110.18:selectForwordWord
#@-node:ekr.20050723064110.12:Cursor movement
#@-node:ekr.20050723064110:class generalizedEditCommands (Do not delete)
#@+node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20050920084036.129:zapTo
def zapTo (self,event):

    k = self.k ; c = k.c ; w = event.widget
    s = string.ascii_letters+string.digits+string.punctuation

    if len(event.char) != 0 and event.char in s:
        k.setState('zap',0)
        i = w.search(event.char,'insert',stopindex='end')
        k.resetLabel()
        if i:
            t = w.get('insert','%s+1c' % i)
            c.killBufferCommands.addToKillBuffer(t)
            w.delete('insert','%s+1c' % i)

    return 'break'
#@-node:ekr.20050920084036.129:zapTo
#@+node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920084036.46:setBufferListGetter
def setBufferListGetter (self,buffer,method):

    #Sets a method that returns a buffer name and its text, and its insert position.
    self.bufferListGetters [buffer] = method
#@nonl
#@-node:ekr.20050920084036.46:setBufferListGetter
#@+node:ekr.20050920084036.47:setBufferSetter
def setBufferSetter( self, buffer, method ):

    #Sets a method that takes a buffer name and the new contents.
    self.bufferSetters[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.47:setBufferSetter
#@+node:ekr.20050920084036.48:getBufferDict
def getBufferDict (self,event):

    w = event.widget
    meth = self.bufferListGetters [w]
    return meth()
#@nonl
#@-node:ekr.20050920084036.48:getBufferDict
#@+node:ekr.20050920084036.49:setBufferData
def setBufferData( self, event, name, data ):
    
    w = event.widget
    meth = self.bufferSetters[ w ]
    meth( name, data )
#@nonl
#@-node:ekr.20050920084036.49:setBufferData
#@+node:ekr.20050920084036.50:setBufferGoto
def setBufferGoto( self, w, method ):

    self.bufferGotos[ w ] = method
#@nonl
#@-node:ekr.20050920084036.50:setBufferGoto
#@+node:ekr.20050920084036.51:setBufferDelete
def setBufferDelete( self, w, method ):
    
    self.bufferDeletes[ w ] = method
#@nonl
#@-node:ekr.20050920084036.51:setBufferDelete
#@+node:ekr.20050920084036.52:setBufferRename
def setBufferRename( self, buffer, method ):
    
    self.renameBuffers[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.52:setBufferRename
#@-node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
def findItemsWithPrefix (self,s,aList=None):

    '''This method returns a sorted list of matches.
    
    It returns the list of matches and the longest common prefix of all the matches.'''

    k = self ; c = k.c

    common_prefix = ''

    if s: pmatches = [a for a in aList if a.startswith(s)]
    else: pmatches = []
        
    if pmatches:
        s = pmatches[0] ; done = False
        for i in xrange(len(s)):
            prefix = s[:i]
            for z in pmatches:
                if not z.startswith(prefix):
                    done = True ; break
            if done:
                break
            else:
                common_prefix = prefix
        pmatches.sort()

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix
#@nonl
#@-node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
#@+node:ekr.20050920084036.73:startGoto (No longer used)
def startGoto (self,event,ch=False):

    k = self.k ; state = k.getState('goto')
    k.setState('goto',state+1,handler=self.Goto)
    k.setLabelBlue('')
    return 'break'
#@nonl
#@-node:ekr.20050920084036.73:startGoto (No longer used)
#@+node:ekr.20050920084036.143:Goto (no longer used)
def Goto (self,event):

    k = self.k ; w = event.widget
    if event.keysym == 'Return':
        i = k.getLabel()
        k.resetLabel()
        state = k.getState('goto')
        k.setState('goto',0)
        if i.isdigit():
            if state == 1:
                w.mark_set('insert','%s.0' % i)
            elif state == 2:
                w.mark_set('insert','1.0 +%sc' % i)
            w.event_generate('<Key>')
            w.update_idletasks()
            w.see('insert')
    else:
        k.updateLabel(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.143:Goto (no longer used)
#@+node:ekr.20050930091642:walkKB
def walkKB( self, event, frm, which ):# kb = self.iterateKillBuffer() ):

    k = self.k ; w = event.widget
    i = w.index( 'insert' )
    t , t1 = i.split( '.' )
    clip_text = self.getClipboard( w )    
    if self.killbuffer or clip_text:
        if which == 'c':
            self.reset = True
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
        else:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            t1 = str( int( t1 ) + len( txt ) )
            r = w.tag_ranges( 'kb' )
            if r and r[ 0 ] == i:
                w.delete( r[ 0 ], r[ -1 ] )
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
    return k._tailEnd( w )
#@nonl
#@-node:ekr.20050930091642:walkKB
#@+node:ekr.20050930095323:killSentenceHelper
def killSentenceHelper (self,event,back):
    w = event.widget
    i = w.search('.','insert',stopindex='end')
    if back:
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if not i: return 'break'
        i2 = w.search('.',i,backwards=True,stopindex='1.0') or '1.0'
        return self.kill(event,i2,'%s + 1c' % i)
    else:
        i  = w.search('.','insert',stopindex='end')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i)

    return 'break'
#@nonl
#@-node:ekr.20050930095323:killSentenceHelper
#@+node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920114619.1:utTailEnd
def utTailEnd (self,event=None):

    '''A method that Emacs will call with its _tailEnd method'''
    
    k = self ; c = k.c ; w = c.frame.bodyCtrl

    # w.event_generate('<Key>')
    w.focus_force()
    w.update_idletasks()
    # c.frame.bodyWantsFocus(w,later=True,tag='utTailEnd')

    return 'break'
#@nonl
#@-node:ekr.20050920114619.1:utTailEnd
#@+node:ekr.20050920085536.70:_tailEnd
def _tailEnd (self,w):
    
    '''This returns the tailEnd function that has been configure for the w parameter.'''
    
    k = self
    func = k.tailEnds.get(w)
    if func:
        # g.trace(func)
        return func(w)
    else:
        return 'break'
#@-node:ekr.20050920085536.70:_tailEnd
#@+node:ekr.20050920085536.71:setTailEnd
def setTailEnd (self,w,tailCall):

    '''This method sets a ending call that is specific for a particular Text widget.
       Some environments require that specific end calls be made after a keystroke
       or command is executed.'''

    k = self

    k.tailEnds [w] = tailCall
#@-node:ekr.20050920085536.71:setTailEnd
#@-node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920084036.44:setInBufferMode
def setInBufferMode (self,event,which):
    
    k = self.k ; w = event.widget

    k.keyboardQuit(event)
    k.setState('bufferList','start%s' % which)
    k.setLabelBlue('Choose Buffer Name: ',protect=True)
    self.bufferDict = self.getBufferDict(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.44:setInBufferMode
#@+node:ekr.20050920084036.256:executeRegister (not used)
def executeRegister (self,event):
    
    k = self.k

    if self.method:
        self.method(event)

        if self.registerMode != 0:
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.256:executeRegister (not used)
#@-node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050927101829.2:buildBufferList (not used)
def buildBufferList (self):

    '''Build a buffer list from an outline.'''
    
    self.positions =  {}
    self.tnodes = {}

    for p in c.allNodes_iter():
    
        t = p.v.t ; h = t.headString()
        
        theList = self.positions.get(h,[])
        theList.append(p.copy())
        self.positions [h] = theList
        
        self.tnodes [h] = t.bodyString()
#@nonl
#@-node:ekr.20050927101829.2:buildBufferList (not used)
#@+node:ekr.20050920084036.41:bufferList (to be deleted)
def bufferList (self,event):
    
    k = self.k
    state = k.getState('bufferList')
    if state.startswith('start'):
        state = state[5:]
        k.setState('bufferList',state)
        k.setLabel('')
    if event.keysym=='Tab':
        stext = k.getLabel().strip()
        if self.bufferTracker.prefix and stext.startswith(self.bufferTracker.prefix):
            k.setLabel(self.bufferTracker.next())#get next in iteration
        else:
            prefix = k.getLabel()
            pmatches =[]
            for z in self.bufferDict.keys():
                if z.startswith(prefix):
                    pmatches.append(z)
            self.bufferTracker.setTabList(prefix,pmatches)
            k.setLabel(self.bufferTracker.next())#begin iteration on new lsit
    elif event.keysym=='Return':
       bMode = k.getState('bufferList')
       c.commandsDict[bMode](event,k.getLabel())
    else:
        self.update(event)
#@nonl
#@-node:ekr.20050920084036.41:bufferList (to be deleted)
#@+node:ekr.20051012133615:switchToBuffer (not used)
def switchToBuffer (self,event,name):

    method = self.bufferGotos [event.widget]
    self.keyboardQuit(event)
    method(name)
    return 'break'
#@-node:ekr.20051012133615:switchToBuffer (not used)
#@-node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050920084036.251:_ToReg (not used)
def _ToReg (self,event,which):

    if not self._chckSel(event):
        return
    if self._checkIfRectangle(event):
        return

    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        w = event.widget
        if not self.registers.has_key(event.keysym):
            self.registers [event.keysym] = ''
        txt = w.get('sel.first','sel.last')
        rtxt = self.registers [event.keysym]
        if self.which == 'p':
            txt = txt + rtxt
        else:
            txt = rtxt + txt
        self.registers [event.keysym] = txt
#@nonl
#@-node:ekr.20050920084036.251:_ToReg (not used)
#@+node:ekr.20050920085536.64:k.manufactureKeyPress
def manufactureKeyPress (self,event,keysym):
    
    '''Implement a command by passing a keypress to Tkinter.'''

    w = event.widget
    w.event_generate('<Key>',keysym=keysym)
    
    ### Synthesize commandName instead of keysym?
    self.endCommand(event,keysym,tag='manufactureKeyPress')
    
    return 'break'
#@nonl
#@-node:ekr.20050920085536.64:k.manufactureKeyPress
#@+node:ekr.20050929170812:leoEditCommands.manufactureKeyPress
def manufactureKeyPress (self,event,keysym):
    
    return self.k.manufactureKeyPress(event,keysym)
#@nonl
#@-node:ekr.20050929170812:leoEditCommands.manufactureKeyPress
#@-node:ekr.20050921100955:Not used
#@+node:ekr.20050921094025.254:All xemacs commands
@killcolor
#@+node:ekr.20050921094025.255:B: Buffer-menu
Buffer-menu-1-window
Buffer-menu-2-window
Buffer-menu-backup-unmark
Buffer-menu-delete
Buffer-menu-delete-backwards
Buffer-menu-execute
Buffer-menu-igrep
Buffer-menu-mark
Buffer-menu-maybe-mouse-select
Buffer-menu-mouse-select
Buffer-menu-not-modified
Buffer-menu-other-window
Buffer-menu-popup-menu
Buffer-menu-quit
Buffer-menu-save
Buffer-menu-select
Buffer-menu-switch-other-window
Buffer-menu-this-window
Buffer-menu-toggle-read-only
Buffer-menu-unmark
Buffer-menu-visit-tags-table
#@nonl
#@-node:ekr.20050921094025.255:B: Buffer-menu
#@+node:ekr.20050921094025.256:C, E, F, H
Custom-buffer-done
Custom-goto-parent
Custom-make-dependencies
Custom-mode-menu
Custom-reset-current
Custom-reset-saved
Custom-reset-standard
Custom-save
Custom-set

Electric-command-history-redo-expression

Footnote-add-footnote

Helper-describe-bindings
Helper-help

#@-node:ekr.20050921094025.256:C, E, F, H
#@+node:ekr.20050921094025.257:I: info
Info-elisp-ref
Info-emacs-command
Info-emacs-key
Info-goto-emacs-command-node
Info-goto-emacs-key-command-node
Info-goto-node
Info-query
Info-search
Info-speedbar-browser
Info-split
Info-tagify
Info-validate
Info-visit-file
#@nonl
#@-node:ekr.20050921094025.257:I: info
#@+node:ekr.20050921094025.258:L, M, R, T, V: LaTeX,TeX
LaTeX-install-toolbar
LaTeX-mode

Manual-nuke-nroff-bs

Rd-mode

TeX-auto-generate
TeX-auto-generate-global
TeX-insert-quote
TeX-mode
TeX-submit-bug-report

View-process-status
#@nonl
#@-node:ekr.20050921094025.258:L, M, R, T, V: LaTeX,TeX
#@+node:ekr.20050921094025.259:a add- align- append- apropos- auto-
abbrev-mode
abbrev-prefix-mark

abort-recursive-edit
about-xemacs
activate-region
ada-make-filename-from-adaname
ada-mode

add-change-log-entry
add-change-log-entry-other-window
add-global-abbrev
add-log-convert
add-mode-abbrev
add-name-to-file

advertised-switch-to-completions
advertised-undo

align
align-current
align-entire
align-highlight-rule
align-newline-and-indent
align-regexp
align-unhighlight-rule

all-hail-emacs
all-hail-xemacs
ams-tex-mode
ansi-color-for-comint-mode-on
apache-mode

append-next-kill
append-to-buffer
append-to-file
append-to-register

apply-macro-to-region-lines
appt-add
appt-delete
apropos
apropos-command
apropos-documentation
apropos-value
apropos-zippy
arp
asm-mode
assign-last-kbd-macro-to-key

auto-compression-mode
auto-fill-mode
auto-insert
auto-revert-mode
auto-save-mode
auto-show-make-point-visible
auto-show-mode

autoconf-mode
awk-mode
#@nonl
#@-node:ekr.20050921094025.259:a add- align- append- apropos- auto-
#@+node:ekr.20050921094025.260:b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-
back-to-indentation
background
backtrace

backward-block-of-lines
backward-char
backward-char-command
backward-delete-char
backward-delete-char-untabify
backward-kill-line
backward-kill-paragraph
backward-kill-sentence
backward-kill-sexp
backward-kill-word
backward-list
backward-or-forward-delete-char
backward-or-forward-kill-sentence
backward-or-forward-kill-sexp
backward-or-forward-kill-word
backward-other-window
backward-page
backward-paragraph
backward-sentence
backward-sexp
backward-to-indentation
backward-up-list
backward-word

balance-windows
balloon-help-minor-mode
balloon-help-mode
base64-decode-region
base64-encode-region
basic-save-buffer

bbdb
bbdb-add-or-remove-mail-alias
bbdb-apply-next-command-to-all-records
bbdb-changed
bbdb-company
bbdb-complete-name
bbdb-create
bbdb-create-ftp-site
bbdb-creation-newer
bbdb-creation-no-change
bbdb-creation-older
bbdb-delete-current-field-or-record
bbdb-delete-current-record
bbdb-dial
bbdb-display-all-records-completely
bbdb-display-record-completely
bbdb-edit-current-field
bbdb-finger
bbdb-fontify-buffer
bbdb-force-record-create
bbdb-ftp
bbdb-help
bbdb-info
bbdb-insert-new-field
bbdb-load-touchtones
bbdb-menu
bbdb-merge-file
bbdb-name
bbdb-net
bbdb-notes
bbdb-omit-record
bbdb-print
bbdb-record-edit-notes
bbdb-record-edit-property
bbdb-refile-record
bbdb-send-mail
bbdb-show-all-recipients
bbdb-snarf
bbdb-snarf-region
bbdb-submit-bug-report
bbdb-timestamp-newer
bbdb-timestamp-older
bbdb-toggle-all-records-display-layout
bbdb-toggle-records-display-layout
bbdb-transpose-fields
bbdb-whois
bbdb-www
bbdb-www-grab-homepage
bbdb-yank
bbdb/gnus-annotate-sender
bbdb/gnus-show-all-recipients
bbdb/gnus-show-records
bbdb/gnus-snarf-signature
bbdb/mh-annotate-sender
bbdb/mh-show-sender
bbdb/rmail-annotate-sender
bbdb/rmail-show-sender
bbdb/vm-annotate-sender
bbdb/vm-set-auto-folder-alist
bbdb/vm-show-all-recipients
bbdb/vm-show-records
bbdb/vm-show-sender

beginning-of-buffer
beginning-of-buffer-other-window
beginning-of-defun
beginning-of-defun-raw
beginning-of-line
beginning-of-line-text

bib-cite-minor-mode
bib-mode
bibtex-mode
binary-overwrite-mode
blackbox
blink-cursor-mode
blink-matching-open
blink-paren
bnf-mode

bookmark-bmenu-list
bookmark-delete
bookmark-insert
bookmark-insert-location
bookmark-jump
bookmark-load
bookmark-locate
bookmark-menu-delete
bookmark-menu-insert
bookmark-menu-jump
bookmark-menu-locate
bookmark-menu-rename
bookmark-relocate
bookmark-rename
bookmark-save
bookmark-set
bookmark-write

br-complete-symbol
br-env-browse
br-env-load
br-three-button-mouse
br-to-from-viewer
br-two-button-mouse

browse-url
browse-url-at-mouse
browse-url-at-point
browse-url-cci
browse-url-firefox
browse-url-galeon
browse-url-generic
browse-url-gnome-moz
browse-url-grail
browse-url-iximosaic
browse-url-kde
browse-url-lynx-emacs
browse-url-lynx-xterm
browse-url-mail
browse-url-mmm
browse-url-mosaic
browse-url-mozilla
browse-url-netscape
browse-url-of-buffer
browse-url-of-dired-file
browse-url-of-file
browse-url-of-region
browse-url-opera
browse-url-w3
browse-url-w3-gnudoit
browse-url-w3m
browse-url-w3m-gnudoit

bsh-script-help

buffer-disable-undo
buffer-enable-undo
buffer-flush-undo
buffer-menu
buffer-menu-other-window

build
build-report
build-version

bury-buffer

byte-compile-and-load-file
byte-compile-buffer
byte-compile-file
byte-force-recompile
byte-recompile-directory
byte-recompile-file
#@nonl
#@-node:ekr.20050921094025.260:b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-
#@+node:ekr.20050921094025.261:c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-
c++-browse
c++-mode

c-add-style
c-comment-edit
c-macro-expand
c-mode
c-set-offset
c-set-style

calc
calc-dispatch
calc-embedded
calc-embedded-activate
calc-grab-rectangle
calc-grab-region
calc-keypad
calc-tutorial

calendar
call-last-kbd-macro
call-tree
caml-mode
camldebug
cancel-debug-on-entry
canonically-space-region

capitalize-region
capitalize-region-as-title
capitalize-region-or-word
capitalize-word

cd
cde-start-drag
cde-start-drag-region

center-line
center-paragraph
center-region
center-to-window-line

change-log-merge
change-log-mode
change-log-redate

check-ispell-version

checkdoc
checkdoc-continue
checkdoc-current-buffer
checkdoc-defun
checkdoc-eval-current-buffer
checkdoc-eval-defun
checkdoc-interactive
checkdoc-ispell
checkdoc-ispell-comments
checkdoc-ispell-continue
checkdoc-ispell-current-buffer
checkdoc-ispell-defun
checkdoc-ispell-interactive
checkdoc-ispell-message-interactive
checkdoc-ispell-message-text
checkdoc-ispell-start
checkdoc-message-interactive
checkdoc-message-text
checkdoc-minor-mode
checkdoc-rogue-spaces
checkdoc-start

choose-completion

clear-profiling-info
clear-rectangle
clearcase-install
clearcase-integrate
clearcase-unintegrate

clos-browse
column-number-mode
comint-dynamic-complete
comint-mode
comint-run
command-apropos
command-history-mode
comment-region
compare-windows
compilation-minor-mode
compilation-mode
compilation-shell-minor-mode
compile
compile-defun
complete

completion-do-in-minibuffer
completion-list-mode
completion-list-mode-quit
completion-switch-to-minibuffer

compose-mail
compose-mail-other-frame
compose-mail-other-window

consing-since-gc
context-en-mode
context-nl-mode

conx
conx-buffer
conx-load
conx-region

copy-file
copy-from-above-command
copy-primary-selection
copy-rectangle-to-register
copy-region-as-kill
copy-to-buffer
copy-to-register

count-lines-buffer
count-lines-page
count-lines-region
count-matches
count-words-buffer
count-words-region

cperl-mode
cperl-perldoc
cperl-perldoc-at-point

css-mode

ctypes-all-buffers
ctypes-auto-parse-mode
ctypes-buffer
ctypes-define-type
ctypes-define-type-in-mode
ctypes-dir
ctypes-file
ctypes-read-file
ctypes-tags

customize
customize-apropos
customize-apropos-faces
customize-apropos-groups
customize-apropos-options
customize-browse
customize-changed-options
customize-customized
customize-face
customize-face-other-window
customize-group
customize-group-other-window
customize-option
customize-option-other-window
customize-other-window
customize-save-customized
customize-save-variable
customize-saved
customize-set-value
customize-set-variable
customize-variable
customize-variable-other-window

cvs-checkout
cvs-examine
cvs-log-mode
cvs-quickdir
cvs-status
cvs-status-mode
cvs-update
#@nonl
#@-node:ekr.20050921094025.261:c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-
#@+node:ekr.20050921094025.262:d dabbrev- define- delete- describe- dictionary dired- display- downcase-
dabbrev-completion
dabbrev-expand

dbx

debug
debug-on-entry

decipher
decipher-mode
decrease-left-margin
decrease-right-margin

define-abbrevs
define-global-abbrev
define-mail-alias
define-mode-abbrev
defining-kbd-macro

delete-backward-char
delete-blank-lines
delete-char
delete-completion-window
delete-directory
delete-file
delete-frame
delete-horizontal-space
delete-indentation
delete-matching-lines
delete-non-matching-lines
delete-other-frames
delete-other-windows
delete-primary-selection
delete-rectangle
delete-region
delete-selection-mode
delete-window
delete-windows-on

deprecated-help-command

describe-beta
describe-bindings
describe-buffer-case-table
describe-class
describe-copying
describe-current-display-table
describe-distribution
describe-function
describe-function-arglist
describe-function-at-point
describe-generic
describe-installation
describe-key
describe-key-briefly
describe-last-error
describe-method
describe-mode
describe-no-warranty
describe-pointer
describe-prefix-bindings
describe-project
describe-stroke
describe-syntax
describe-variable
describe-variable-at-point

desktop-entry-mode
desktop-read

diary
diary-mail-entries

dictionary
dictionary-lookup-definition
dictionary-match-words
dictionary-mouse-popup-matching-words
dictionary-popup-matching-words
dictionary-search

diff
diff-backup
diff-minor-mode
diff-mode

digit-argument
directory-tree-thing

dired
dired-apropos
dired-backup-diff
dired-cleanup
dired-compress-subdir-files
dired-describe-mode
dired-diff
dired-do-background-shell-command
dired-do-compress
dired-do-copy-regexp
dired-do-grep
dired-do-hardlink-regexp
dired-do-igrep
dired-do-igrep-find
dired-do-print
dired-do-relsymlink-regexp
dired-do-rename-regexp
dired-do-shell-command
dired-do-symlink-regexp
dired-do-uucode
dired-downcase
dired-ediff
dired-emerge
dired-emerge-with-ancestor
dired-epatch
dired-flag-extension
dired-flag-files-regexp
dired-jump-back
dired-jump-back-other-frame
dired-jump-back-other-window
dired-mark-extension
dired-mark-files-compilation-buffer
dired-mark-files-from-other-dired-buffer
dired-mark-files-regexp
dired-mark-sexp
dired-other-frame
dired-other-window
dired-read-mail
dired-report-bug
dired-rmail
dired-summary
dired-upcase
dired-virtual
dired-vm

disable-command
disassemble

display-buffer
display-call-tree
display-column-mode
display-time

dissociated-press
dns-mode
dns-mode-soa-increment-serial
do-auto-save
docbook-grep
docbook-mode
docref-setup
doctor
down-list

downcase-region
downcase-region-or-word
downcase-word

drag-window-divider
dsssl-mode
dunnet
#@nonl
#@-node:ekr.20050921094025.262:d dabbrev- define- delete- describe- dictionary dired- display- downcase-
#@+node:ekr.20050921094025.263:e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-
ebuffers
ebuffers3

ecb-activate
ecb-byte-compile
ecb-minor-mode
ecb-show-help
edebug-defun
edebug-eval-top-level-form

ediff
ediff-backup
ediff-buffers
ediff-buffers3
ediff-customize
ediff-directories
ediff-directories3
ediff-directory-revisions
ediff-documentation
ediff-files
ediff-files3
ediff-merge
ediff-merge-buffers
ediff-merge-buffers-with-ancestor
ediff-merge-directories
ediff-merge-directories-with-ancestor
ediff-merge-directory-revisions
ediff-merge-directory-revisions-with-ancestor
ediff-merge-files
ediff-merge-files-with-ancestor
ediff-merge-revisions
ediff-merge-revisions-with-ancestor
ediff-merge-with-ancestor
ediff-patch-buffer
ediff-patch-file
ediff-regions-linewise
ediff-regions-wordwise
ediff-revision
ediff-show-registry
ediff-toggle-multiframe
ediff-toggle-use-toolbar
ediff-version
ediff-windows-linewise
ediff-windows-wordwise
ediff3

edir-merge-revisions
edir-merge-revisions-with-ancestor
edir-revisions
edirs
edirs-merge
edirs-merge-with-ancestor
edirs3

edit-abbrevs
edit-abbrevs-mode
edit-abbrevs-redefine
edit-bookmarks
edit-faces
edit-itimers
edit-kbd-macro
edit-last-kbd-macro
edit-mime
edit-named-kbd-macro
edit-picture
edit-pr
edit-tab-stops
edit-tab-stops-note-changes
edit-toolbar

edt-emulation-on
edt-set-scroll-margins

efs-display-ftp-activity
efs-nslookup-host
efs-report-bug
efs-set-passwd
efs-set-user

eieio-class-tree
eieio-describe-class
eieio-describe-generic
eieio-describe-method

eif-browse
eiffel-mode
eldoc-mode

electric-buffer-list
electric-command-history
electric-nroff-mode

elp-instrument-function
elp-instrument-list
elp-instrument-package
elp-results

emacs-lisp-byte-compile
emacs-lisp-byte-compile-and-load
emacs-lisp-mode
emacs-version

emerge
emerge-buffers
emerge-buffers-with-ancestor
emerge-files
emerge-files-with-ancestor
emerge-merge-directories
emerge-revisions
emerge-revisions-with-ancestor

enable-command
enable-flow-control

encrypt-insert-file-contents

end-kbd-macro
end-of-buffer
end-of-buffer-other-window
end-of-defun
end-of-line

enlarge-window
enlarge-window-horizontally
enlarge-window-pixels

enriched-mode
epatch

epatch-buffer
erase-buffer

erc-add-dangerous-host
erc-add-fool
erc-add-keyword
erc-add-pal
erc-autojoin-mode
erc-button-mode
erc-chanlist
erc-cmd-LIST
erc-complete
erc-completion-mode
erc-delete-dangerous-host
erc-delete-fool
erc-delete-keyword
erc-delete-pal
erc-fill-mode
erc-log-mode
erc-nickserv-identify
erc-nickserv-identify-mode
erc-notify-mode
erc-ring-mode
erc-save-buffer-in-logs
erc-select
erc-server-select
erc-services-mode
erc-spelling-mode
erc-timestamp-mode
erc-track-mode
erc-track-when-inactive-mode
erc-truncate-buffer
erc-truncate-mode
erc-xdcc-add-file

eregistry
erevision
escreen-install

eshell
eshell-command
eshell-report-bug
eshell-test
eshell-toggle
eshell-toggle-cd

eudc-edit-hotlist
eudc-expand-inline
eudc-get-email
eudc-get-phone
eudc-insert-record-at-point-into-bbdb
eudc-load-eudc
eudc-query-form
eudc-set-server
eudc-try-bbdb-insert

eval-buffer
eval-current-buffer
eval-defun
eval-expr
eval-expr-install
eval-expression
eval-last-sexp
eval-print-last-sexp
eval-region

exchange-dot-and-mark
exchange-point-and-mark

executable-self-display
executable-set-magic

execute-extended-command

exit-minibuffer
exit-recursive-edit

expand-abbrev
expand-region-abbrevs
#@nonl
#@-node:ekr.20050921094025.263:e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-
#@+node:ekr.20050921094025.264:f fill- find- format- forward-
f90-mode

facemenu-make-larger
facemenu-make-much-larger
facemenu-make-much-smaller
facemenu-make-smaller
facemenu-remove-props
facemenu-remove-special
facemenu-set-background
facemenu-set-face
facemenu-set-face-from-menu
facemenu-set-foreground
facemenu-set-intangible
facemenu-set-invisible
facemenu-set-read-only
facemenu-set-size-default

fast-lock-mode

feedmail-queue-reminder
feedmail-run-the-queue
feedmail-run-the-queue-global-prompt
feedmail-run-the-queue-no-prompts

ffap
ffap-at-mouse
ffap-menu
ffap-next

fill-individual-paragraphs
fill-nonuniform-paragraphs
fill-paragraph
fill-paragraph-or-region
fill-region
fill-region-as-paragraph

find-alternate-file
find-alternate-file-other-window
find-file
find-file-at-point
find-file-other-frame
find-file-other-window
find-file-read-only
find-file-read-only-other-frame
find-file-read-only-other-window
find-function
find-function-at-point
find-function-on-key
find-function-other-frame
find-function-other-window
find-library
find-library-other-frame
find-library-other-window
find-tag
find-tag-at-point
find-tag-other-window
find-variable
find-variable-at-point
find-variable-other-frame
find-variable-other-window

finder-by-keyword
finder-commentary
finger
first-error
fixup-whitespace
flame

floating-toolbar
floating-toolbar-from-extent-or-popup-mode-menu
floating-toolbar-or-popup-mode-menu

flush-lines

flyspell-buffer
flyspell-mode
flyspell-prog-mode
flyspell-region
flyspell-version

folding-mode
folding-mode-add-find-file-hook

font-lock-fontify-buffer
font-lock-mode

footnote-mode

format-decode-buffer
format-decode-region
format-encode-buffer
format-encode-region
format-find-file
format-insert-file
format-write-file

forms-find-file
forms-find-file-other-window
forms-mode

fortran-mode

forward-block-of-lines
forward-char
forward-char-command
forward-line
forward-list
forward-page
forward-paragraph
forward-sentence
forward-sexp
forward-to-indentation
forward-word

frame-configuration-to-register
ftelnet
ftp
full-calc
full-calc-keypad
fume-mode
fume-setup-buffer
function-menu
fundamental-mode
fusion-mode
#@nonl
#@-node:ekr.20050921094025.264:f fill- find- format- forward-
#@+node:ekr.20050921094025.265:g global- goto- grep-
garbage-collect
gdb
gdb-with-core
gdbsrc
generate-file-autoloads
generic-page-setup
generic-print-buffer
getenv

global-auto-revert-mode
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-semanticdb-minor-mode
global-senator-minor-mode
global-set-key
global-set-stroke
global-unset-key

gnats:edit-pr
gnats:query-pr
gnats:summ-pr
gnats:view-pr

gnuserv-start
gomoku

google-query
google-query-region

goto-address
goto-address-at-mouse
goto-address-at-point
goto-char
goto-line

grep
grep-all-files-in-current-directory
grep-all-files-in-current-directory-and-below
grep-find

gtk-start-drag
gtk-start-drag-region
#@nonl
#@-node:ekr.20050921094025.265:g global- goto- grep-
#@+node:ekr.20050921094025.266:h help- hide- html- hyper-
hanoi
haskell-doc-mode
haskell-doc-show-type
haskell-mode

help
help-for-help
help-mode
help-mode-bury
help-mode-quit
help-next-section
help-next-symbol
help-prev-section
help-prev-symbol
help-quit
help-with-tutorial

hexl-find-file
hexl-mode
hexlify-buffer

hide-copyleft-region
hide-ifdef-mode

highlight-headers-follow-url
highlight-headers-follow-url-kfm
highlight-headers-follow-url-mosaic
highlight-headers-follow-url-netscape

highline-customize
highline-local-mode
highline-mode
highline-mode-off
highline-mode-on
highline-off
highline-on
highline-view-mode
highline-view-off
highline-view-on

hippie-expand
hm--html-minor-mode
hm--html-mode
hmail:compose
holidays
how-many
hs-minor-mode

html-mode
html-quote-region
html-view-get-display
html-view-goto-url
html-view-start-mosaic
html-view-view-buffer
html-view-view-file
htmlize-buffer
htmlize-file
htmlize-many-files
htmlize-many-files-dired
htmlize-region

hyper-apropos
hyper-apropos-popup-menu
hyper-apropos-set-variable
hyper-describe-face
hyper-describe-function
hyper-describe-key
hyper-describe-key-briefly
hyper-describe-variable
hyper-set-variable
hyper-where-is

hyperb:customize
hyperb:find-file-urls-mode
hyperb:init-menubar
hyperbole

hypropos-popup-menu
hypropos-set-variable
#@nonl
#@-node:ekr.20050921094025.266:h help- hide- html- hyper-
#@+node:ekr.20050921094025.267:i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-
ibuffer
ibuffer-add-saved-filters
ibuffer-add-to-tmp-hide
ibuffer-add-to-tmp-show
ibuffer-auto-mode
ibuffer-backward-filter-group
ibuffer-backwards-next-marked
ibuffer-bs-show
ibuffer-clear-filter-groups
ibuffer-copy-filename-as-kill
ibuffer-customize
ibuffer-decompose-filter
ibuffer-delete-saved-filter-groups
ibuffer-delete-saved-filters
ibuffer-diff-with-file
ibuffer-do-kill-lines
ibuffer-do-occur
ibuffer-exchange-filters
ibuffer-filter-disable
ibuffer-filters-to-filter-group
ibuffer-forward-next-marked
ibuffer-invert-sorting
ibuffer-jump-to-buffer
ibuffer-jump-to-filter-group
ibuffer-kill-filter-group
ibuffer-kill-line
ibuffer-list-buffers
ibuffer-mark-by-file-name-regexp
ibuffer-mark-by-mode
ibuffer-mark-by-mode-regexp
ibuffer-mark-by-name-regexp
ibuffer-mark-dired-buffers
ibuffer-mark-dissociated-buffers
ibuffer-mark-help-buffers
ibuffer-mark-modified-buffers
ibuffer-mark-old-buffers
ibuffer-mark-read-only-buffers
ibuffer-mark-special-buffers
ibuffer-mark-unsaved-buffers
ibuffer-negate-filter
ibuffer-or-filter
ibuffer-other-window
ibuffer-pop-filter
ibuffer-pop-filter-group
ibuffer-save-filter-groups
ibuffer-save-filters
ibuffer-set-filter-groups-by-mode
ibuffer-switch-to-saved-filter-groups
ibuffer-switch-to-saved-filters
ibuffer-toggle-sorting-mode
ibuffer-yank

icomplete-mode
icon-mode
iconify-emacs
iconify-frame

id-select-and-copy-thing
id-select-and-kill-thing
id-select-goto-matching-tag
id-select-install
id-select-thing
id-select-thing-with-mouse

idl-mode
idlwave-mode
idlwave-shell
ielm
ifconfig

ignore

igrep
igrep-find
igrep-insinuate
igrep-visited-files

ilisp-imenu-add-menubar-index
image-mode

imenu
imenu-add-menubar-index
imenu-add-to-menubar

increase-left-margin
increase-right-margin

increment-register

indent-according-to-mode
indent-code-rigidly
indent-for-comment
indent-for-tab-command
indent-new-comment-line
indent-region
indent-relative
indent-relative-maybe
indent-rigidly
indent-sexp
indent-to
indent-to-column

indented-text-mode
inferior-prolog-mode
inferior-tcl

info
info-browse
info-complete-file
info-complete-symbol
info-lookup-file
info-lookup-reset
info-lookup-symbol

insert-abbrevs
insert-buffer
insert-file
insert-kbd-macro
insert-key-binding
insert-parentheses
insert-register
insert-selection
insert-zippyism

install-where-was-i
inverse-add-global-abbrev
inverse-add-mode-abbrev
invert-face
ipconfig

isearch-*-char
isearch-abort
isearch-backward
isearch-backward-regexp
isearch-cancel
isearch-complete
isearch-complete-edit
isearch-delete-char
isearch-edit-string
isearch-exit
isearch-forward
isearch-forward-exit-minibuffer
isearch-forward-regexp
isearch-help-or-delete-char
isearch-mode-help
isearch-nonincremental-exit-minibuffer
isearch-printing-char
isearch-quote-char
isearch-repeat-backward
isearch-repeat-forward
isearch-return-char
isearch-reverse-exit-minibuffer
isearch-ring-advance
isearch-ring-advance-edit
isearch-ring-retreat
isearch-ring-retreat-edit
isearch-toggle-case-fold
isearch-toggle-regexp
isearch-whitespace-chars
isearch-yank-clipboard
isearch-yank-kill
isearch-yank-line
isearch-yank-selection
isearch-yank-sexp
isearch-yank-word
isearch-yank-x-clipboard
isearch-yank-x-selection
isearch-|-char

iso-accents-mode

ispell
ispell-buffer
ispell-change-dictionary
ispell-comments-and-strings
ispell-complete-word
ispell-complete-word-interior-frag
ispell-continue
ispell-kill-ispell
ispell-message
ispell-minor-mode
ispell-pdict-save
ispell-region
ispell-word

iswitchb-buffer
iswitchb-buffer-other-frame
iswitchb-buffer-other-window
iswitchb-default-keybindings
iswitchb-display-buffer

itimer-edit-delete-itimer
itimer-edit-help
itimer-edit-next-field
itimer-edit-previous-field
itimer-edit-quit
itimer-edit-set-field
#@nonl
#@-node:ekr.20050921094025.267:i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-
#@+node:ekr.20050921094025.268:j jde-
japanese-latex-mode
japanese-plain-tex-mode

java-browse
java-mode

javascript-mode
javascript-shell

jde-ant-build
jde-ant-projecthelp
jde-ant-show-options
jde-bug-debug-app
jde-build
jde-checkstyle
jde-checkstyle-customize
jde-compile
jde-compile-jde
jde-create-new-project
jde-db-set-app-args
jde-db-set-args
jde-db-set-debugger
jde-ejb-entity-bean-buffer
jde-ejb-session-bean-buffer
jde-gen-buffer
jde-gen-class-buffer
jde-gen-console-buffer
jde-gen-interface-buffer
jde-gen-jfc-app-buffer
jde-gen-junit-test-class-buffer
jde-help-browse-jdk-doc
jde-import-organize
jde-java-font-lock-setup-keywords
jde-javadoc-autodoc-at-line
jde-javadoc-checkdoc
jde-javadoc-checkdoc-at-line
jde-javadoc-checker-fix
jde-javadoc-checker-next
jde-javadoc-checker-previous
jde-javadoc-checker-quit
jde-javadoc-customize
jde-javadoc-make
jde-jdb
jde-jdb-applet
jde-make
jde-make-show-options
jde-mode
jde-open-project-file
jde-package-update
jde-run
jde-run-applet
jde-run-set-app
jde-run-set-app-args
jde-run-set-applet-doc
jde-run-set-applet-viewer
jde-run-set-args
jde-save-project
jde-set-compile-options
jde-set-global-classpath
jde-show-help
jde-stat-loc-report
jde-stat-loc-report-directory
jde-stat-loc-report-project
jde-xref-customize
jde-xref-display-call-tree
jde-xref-first-caller
jde-xref-list-uncalled-functions
jde-xref-make-xref-db
jde-xref-next-caller
jde-xref-update

join-line
jump-to-register
just-one-space
justify-current-line
#@nonl
#@-node:ekr.20050921094025.268:j jde-
#@+node:ekr.20050921094025.269:k kill- kimport-
kbd-macro-query
keep-lines

keyboard-escape-quit
keyboard-quit

kfile:find
kfile:view

kill-all-abbrevs
kill-buffer
kill-buffer-and-window
kill-comment
kill-console-local-variable
kill-emacs
kill-entire-line
kill-line
kill-local-variable
kill-paragraph
kill-primary-selection
kill-rectangle
kill-region
kill-ring-save
kill-sentence
kill-sexp
kill-some-buffers
kill-this-buffer
kill-word

kimport:aug-post-outline
kimport:file
kimport:star-outline
kimport:text

klink:create
kotl-mode
kotl-mode:example
ksh-mode
#@nonl
#@-node:ekr.20050921094025.269:k kill- kimport-
#@+node:ekr.20050921094025.270:l lisp- list- load-
latex-mode
lazy-lock-mode
lazy-shot-mode
ledit-mode
liece
life
line-number-mode
linuxdoc-sgml-mode

lisp-complete-symbol
lisp-fill-paragraph
lisp-indent-for-comment
lisp-indent-line
lisp-interaction-mode
lisp-mode
lisp-send-defun

list-abbrevs
list-bookmarks
list-buffers
list-colors-display
list-command-history
list-directory
list-faces-display
list-holidays
list-itimers
list-load-path-shadows
list-matches-in-buffers
list-matching-lines
list-mode
list-mode-item-keyboard-selected
list-mode-item-mouse-selected
list-packages
list-processes
list-strokes
list-tags
list-text-properties-at
list-yahrzeit-dates

literate-haskell-mode

load-default-sounds
load-file
load-library
load-sound-file
load-user-strokes

local-set-key
local-unset-key

locate-library
lock-buffer
lower-frame
lpr-buffer
lpr-region
lua-mode
#@nonl
#@-node:ekr.20050921094025.270:l lisp- list- load-
#@+node:ekr.20050921094025.271:m macroexpand- mail- make- mark- minibuffer- mouse- move-
m4-mode

macroexpand-all-sexp
macroexpand-sexp

mail
mail-mode
mail-other-frame
mail-other-window

make-command-summary
make-compatible
make-compatible-variable
make-directory
make-directory-path
make-face-bold
make-face-bold-italic
make-face-italic
make-face-larger
make-face-smaller
make-face-unbold
make-face-unitalic
make-file-part
make-frame
make-indirect-buffer
make-local-variable
make-obsolete
make-obsolete-variable
make-search-dialog
make-symbolic-link
make-variable-buffer-local
makefile-mode

manual-entry
map-query-replace-regexp
mark-beginning-of-buffer

mark-bob
mark-defun
mark-end-of-buffer
mark-end-of-line
mark-end-of-sentence
mark-eob
mark-page
mark-paragraph
mark-sexp
mark-whole-buffer
mark-word

maybe-unmigrate-user-init-file
mchat
mchat-other-frame

metamail-buffer
metamail-interpret-body
metamail-interpret-header
metamail-region

mew
mew-send
mh-letter-mode
mh-nmail
mh-rmail
mh-smail
mh-smail-other-window
mh-version
migrate-user-init-file
mime-decode-region
mime-encode-region
mime-insert-encoded-file
mime/editor-mode

minibuffer-complete
minibuffer-complete-and-exit
minibuffer-complete-word
minibuffer-completion-help
minibuffer-electric-separator
minibuffer-electric-tilde
minibuffer-keyboard-quit
minibuffer-smart-maybe-select-highlighted-completion
minibuffer-smart-select-highlighted-completion

mode-compile
mode-compile-kill
mode-compile-submit-bug-report

modeline-buffers-menu
modeline-menu
modeline-minor-mode-menu
modeline-toggle-read-only

modify-syntax-entry
modula-2-mode
morse-region

mouse-avoidance-mode
mouse-bury-buffer
mouse-choose-completion
mouse-consolidated-yank
mouse-del-char
mouse-delete-window
mouse-drag-modeline
mouse-eval-last-sexpr
mouse-eval-sexp
mouse-ignore
mouse-keep-one-window
mouse-kill-line
mouse-line-length
mouse-me
mouse-scroll
mouse-select
mouse-select-and-split
mouse-set-mark
mouse-set-point
mouse-track
mouse-track-adjust
mouse-track-adjust-default
mouse-track-default
mouse-track-delete-and-insert
mouse-track-do-rectangle
mouse-track-insert
mouse-unbury-buffer
mouse-window-to-region
mouse-yank

move-past-close-and-reindent
move-to-left-margin
move-to-tab-stop
move-to-window-line

mpuz
mswindows-paste-clipboard
mwheel-install
#@nonl
#@-node:ekr.20050921094025.271:m macroexpand- mail- make- mark- minibuffer- mouse- move-
#@+node:ekr.20050921094025.272:n narrow- newline- next-
name-last-kbd-macro

narrow-stack-mode
narrow-to-defun
narrow-to-page
narrow-to-region
narrow-window-to-region

negative-argument
netstat
network-connection
network-connection-to-service
new-frame

newline
newline-and-indent

next-complete-history-element
next-error
next-file
next-history-element
next-line
next-list-mode-item
next-matching-history-element
next-multiframe-window

normal-mode
not-modified
nroff-mode
nslookup
nslookup-host
nuke-nroff-bs
nuke-selective-display
number-to-register
#@nonl
#@-node:ekr.20050921094025.272:n narrow- newline- next-
#@+node:ekr.20050921094025.273:o open- other- outl- outline- overwrite
objc-browse
objc-mode

occur
occur-mode-goto-occurrence
occur-mode-mouse-goto

offix-start-drag
offix-start-drag-region

old-whitespace-incremental-mode
old-whitespace-mode

oo-browser

open-dribble-file
open-line
open-rectangle
open-termscript

other-frame
other-window

outl-mouse-minor-mode
outl-mouse-mode

outline-minor-mode
outline-mode

overstrike-region
overwrite-mode
own-selection
#@nonl
#@-node:ekr.20050921094025.273:o open- other- outl- outline- overwrite
#@+node:ekr.20050921094025.274:p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-
package-admin-add-binary-package
package-admin-add-single-file-package
package-get
package-get-all
package-get-custom
package-get-delete-package
package-get-package-provider
package-get-save-base
package-get-update-all
package-get-update-base
package-get-update-base-from-buffer

paragraph-indent-text-mode
paren-activate
paren-backward-sexp
paren-deactivate
paren-forward-sexp
paren-set-mode
paren-toggle-matching-paired-delimiter
paren-toggle-matching-quoted-paren
paren-toggle-open-paren-context

pascal-mode
patch-to-change-log

patcher-mail
patcher-mail-subproject
patcher-version

pcomplete
pcomplete-continue
pcomplete-expand
pcomplete-expand-and-complete
pcomplete-help
pcomplete-list
pcomplete-reverse

pdb

pending-delete
pending-delete-mode
pending-delete-off
pending-delete-on

perl-mode
perldb
permanent-buffers-mode

pgg-decrypt
pgg-decrypt-region
pgg-encrypt
pgg-encrypt-region
pgg-insert-key
pgg-sign
pgg-sign-region
pgg-snarf-keys
pgg-snarf-keys-region
pgg-verify
pgg-verify-region

phases-of-moon
php-mode
picture-mode
pike-mode
ping

plain-TeX-mode
plain-tex-mode

play-sound-file
point-to-register

pop-global-mark
pop-tag-mark
pop-window-configuration

popper-install

popup-buffer-menu
popup-menubar-menu
popup-mode-menu

posix-search-backward
posix-search-forward

postscript-mode

pp-eval-expression
pp-eval-last-sexp
pp-function
pp-plist
pp-variable

praise-be-unto-emacs
praise-be-unto-xemacs

prefer-coding-system
prefix-region

prepend-to-buffer
prepend-to-register

press-toolbar-button

prettyexpand-all-sexp
prettyexpand-sexp

previous-complete-history-element
previous-error
previous-history-element
previous-line
previous-list-mode-item
previous-matching-history-element
previous-multiframe-window

print-buffer
print-region

profile-command
profile-expression
profile-key-sequence
profile-results

prolog-mode

ps
ps-despool
ps-line-lengths
ps-nb-pages-buffer
ps-nb-pages-region
ps-print-buffer
ps-print-buffer-with-faces
ps-print-customize
ps-print-region
ps-print-region-with-faces
ps-spool-buffer
ps-spool-buffer-with-faces
ps-spool-region
ps-spool-region-with-faces

psychoanalyze-pinhead
pui-add-install-directory
pui-list-packages
push-window-configuration
pwd

py-shell
pydoc-apropos
pydoc-commands
pydoc-help
pydoc-keywords
pydoc-modules
pydoc-packages
pydoc-topics
pydoc-xrefs

pymacs-eval
pymacs-load

python-browse
python-mode
#@nonl
#@-node:ekr.20050921094025.274:p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-
#@+node:ekr.20050921094025.275:q query-
query-pr
query-replace
query-replace-regexp
quick-calc
quoted-insert
#@nonl
#@-node:ekr.20050921094025.275:q query-
#@+node:ekr.20050921094025.276:r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-
raise-frame

re-builder
re-search-backward
re-search-forward

read-abbrev-file
read-kbd-macro
read-library-name

recent-files-initialize
recent-files-visit-file

recenter

recentf-cancel-dialog
recentf-cleanup
recentf-dialog-mode
recentf-edit-list
recentf-mode
recentf-open-files
recentf-open-more-files
recentf-rebuild-virtual-pathes
recentf-save-list

recover-all-files
recover-file
recover-session
recover-session-finish

recursive-edit

reftex-citation
reftex-index-phrases-mode
reftex-mode

regexp-builder
register-to-point
reindent-then-newline-and-indent
release-and-activate-toolbar-button
release-toolbar-button
remote-compile
remove-directory

rename-buffer
rename-file
rename-uniquely

repeat-complex-command
repeat-matching-complex-command

replace-buffer-in-windows
replace-rectangle
replace-regexp
replace-string

report-emacs-bug
report-xemacs-bug

reposition-window
resize-minibuffer-mode
restore-initial-toolbar
resume-console
reverse-region
revert-buffer
rexx-mode
riece
rlogin

rmail
rmail-input
rmail-mode

rolo-add
rolo-display-matches
rolo-edit
rolo-fgrep
rolo-fgrep-logical
rolo-grep
rolo-kill
rolo-sort
rolo-toggle-datestamps
rolo-yank

rot13-other-window
rotate-yank-pointer
route

rpm
rpm-spec-mode

rsh

rtf-clip-buffer
rtf-clip-region
rtf-export
rtf-export-region
rtf-spool-buffer
rtf-spool-region

ruby-mode
rubydb

run-at-time
run-caml
run-ediff-from-cvs-buffer
run-prolog
run-ruby
run-scheme
run-scsh
run-sml
run-with-idle-timer
run-with-timer
#@nonl
#@-node:ekr.20050921094025.276:r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-
#@+node:ekr.20050921094025.277:s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-
s-region-bind
s-region-bind-cua

save-buffer
save-buffers-kill-emacs
save-some-buffers

savehist-load
savehist-save

scheme-mode
scribe-mode

scroll-down
scroll-down-command
scroll-down-one
scroll-left
scroll-other-window
scroll-other-window-down
scroll-right
scroll-up
scroll-up-command
scroll-up-one

sdb

search-backward
search-backward-regexp
search-forward
search-forward-regexp

self-insert-and-exit
self-insert-command

semantic-analyze-current-context
semantic-auto-parse-mode
semantic-bnf-mode
semantic-cb-speedbar-mode
semantic-chart-database-size
semantic-chart-nonterminal-complexity-token
semantic-chart-nonterminals-by-token
semantic-show-dirty-mode
semantic-show-unmatched-syntax-mode
semantic-summary-mode

senator-complete-symbol
senator-completion-menu-popup
senator-jump
senator-jump-regexp
senator-minor-mode
senator-next-token
senator-previous-token
senator-re-search-backward
senator-re-search-forward
senator-search-backward
senator-search-forward
senator-word-search-backward
senator-word-search-forward

send-pr
send-pr-mode
send-pr:send-pr
send-pr:send-pr-mode

set-buffer-file-coding-system
set-buffer-file-coding-system-for-read
set-buffer-process-coding-system
set-comment-column
set-default-buffer-file-coding-system
set-default-file-coding-system
set-face-background
set-face-background-pixmap
set-face-blinking-p
set-face-dim-p
set-face-display-table
set-face-doc-string
set-face-font
set-face-foreground
set-face-highlight-p
set-face-reverse-p
set-face-strikethru-p
set-face-underline-p
set-file-coding-system
set-file-coding-system-for-read
set-fill-column
set-fill-prefix
set-goal-column
set-justification
set-justification-center
set-justification-full
set-justification-left
set-justification-none
set-justification-right
set-keyboard-coding-system
set-left-margin
set-mark-command
set-pathname-coding-system
set-right-margin
set-selective-display
set-terminal-coding-system
set-variable
set-visited-file-name

setenv
setnu-mode
sgml-mode
sh-mode

shell
shell-command
shell-command-on-region
shell-script-mode

show-message-log

shrink-window
shrink-window-horizontally
shrink-window-if-larger-than-buffer
shrink-window-pixels

sieve-manage
sieve-mode
sieve-upload
sieve-upload-and-bury

signal-process
simula-mode

skeleton-pair-insert-maybe
skeleton-proxy
skeleton-proxy-new

smart-c++
smart-info
smart-info-assist
smart-java
smart-objc

smerge
sml-mode
smt-browse
snake
sokoban

sort-columns
sort-fields
sort-float-fields
sort-lines
sort-numeric-fields
sort-pages
sort-paragraphs
sort-regexp-fields
sort-regexp-fields-numerically

speedbar
speedbar-frame-mode
speedbar-get-focus

spell-buffer
spell-region
spell-string
spell-word

split-line
split-window
split-window-horizontally
split-window-vertically

spook

sql-db2
sql-help
sql-informix
sql-ingres
sql-interbase
sql-linter
sql-mode
sql-ms
sql-mysql
sql-oracle
sql-postgres
sql-product-interactive
sql-solid
sql-sqlite
sql-sybase

ssh
standard-display-european
start-itimer
start-kbd-macro
startup-presentation-hack
string-rectangle

strokes-compose-complex-stroke
strokes-decode-buffer
strokes-describe-stroke
strokes-do-complex-stroke
strokes-do-stroke
strokes-global-set-stroke
strokes-help
strokes-list-strokes
strokes-load-user-strokes
strokes-mode

style-format
summ-pr
sunrise-sunset

suspend-console
suspend-emacs
suspend-emacs-or-iconify-frame
suspend-or-iconify-emacs

switch-to-buffer
switch-to-buffer-other-frame
switch-to-buffer-other-window
switch-to-completions
switch-to-other-buffer

symbol-file
symbol-near-point
#@nonl
#@-node:ekr.20050921094025.277:s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-
#@+node:ekr.20050921094025.278:t tab tags- toggle- toolbar- turn-off turn-on
tab-to-tab-stop
tabify

tag-complete-symbol
tags-apropos
tags-loop-continue
tags-query-replace
tags-search

tcl-help-on-word
tcl-mode

tdbx
teco-command
telnet
term
terminal-emulator
tetris

tex-mode
texi2info
texinfo-format-buffer
texinfo-format-region
texinfo-mode
texmathp

text-mode
tgdb
time-stamp
time-stamp-toggle-active

tmpl-expand-templates-in-buffer
tmpl-expand-templates-in-region
tmpl-insert-template-file
tmpl-insert-template-file-from-fixed-dirs
tmpl-minor-mode

toggle-auto-compression
toggle-buffer-file-coding-system
toggle-debug-on-error
toggle-debug-on-quit
toggle-debug-on-signal
toggle-profiling
toggle-read-only
toggle-rot13-mode
toggle-text-mode-auto-fill
toggle-truncate-lines
toggle-viper-mode
toggle-where-was-i

toolbar-add-button-on-the-fly
toolbar-add-execute-macro-button
toolbar-add-kbd-macro
toolbar-compile
toolbar-copy
toolbar-cut
toolbar-debug
toolbar-dired
toolbar-external
toolbar-gnus
toolbar-info
toolbar-ispell
toolbar-ispell-internal
toolbar-mail
toolbar-news
toolbar-not-configured
toolbar-open
toolbar-paste
toolbar-print
toolbar-redo
toolbar-replace
toolbar-save
toolbar-search
toolbar-undo

top-level
tperldb
tpu-edt
tpu-edt-mode
tpu-edt-on
tpu-set-cursor-bound
tpu-set-cursor-free
tpu-set-scroll-margins

tpum-global-mode
tpum-minor-mode

trace-function
trace-function-background
traceroute

transpose-chars
transpose-line-down
transpose-line-up
transpose-lines
transpose-paragraphs
transpose-preceding-chars
transpose-sentences
transpose-sexps
transpose-words

tree-test-it-all
tsdb
tshell

turn-off-font-lock
turn-off-haskell-doc-mode
turn-off-pending-delete
turn-on-auto-fill
turn-on-eldoc-mode
turn-on-font-lock
turn-on-fume-mode
turn-on-haskell-doc-mode
turn-on-pending-delete
turn-on-permanent-buffers

txdb
#@nonl
#@-node:ekr.20050921094025.278:t tab tags- toggle- toolbar- turn-off turn-on
#@+node:ekr.20050921094025.279:u universal- upcase- url-
uil-mode
undefined
underline-region
undo
unexpand-abbrev
unhide-copyleft-region

universal-argument
universal-argument-minus
universal-argument-more
universal-argument-other-key
universal-coding-system-argument

unix-sync
unload-feature
unlock-buffer
unmigrate-user-init-file
unmorse-region
unoverstrike-region
unpop-window-configuration
unrmail
untabify
ununderline-and-unoverstrike-region
ununderline-region
up-list

upcase-initials-region
upcase-region
upcase-region-or-word
upcase-word

update-autoloads-from-directory
update-autoloads-here
update-file-autoloads

url-gateway-nslookup-host
url-mail
url-setup-save-timer

use-hard-newlines
user-mail-address
#@nonl
#@-node:ekr.20050921094025.279:u universal- upcase- url-
#@+node:ekr.20050921094025.280:v view- vm-
vc-annotate
vc-cancel-version
vc-create-snapshot
vc-diff
vc-directory
vc-insert-headers
vc-load-vc-hooks
vc-merge
vc-next-action
vc-print-log
vc-register
vc-rename-file
vc-resolve-conflicts
vc-retrieve-snapshot
vc-revert-buffer
vc-update-change-log
vc-version-diff
vc-version-other-window

verilog-customize
verilog-mode
verilog-version

version
vertical-mode
vhdl-mode

view-buffer
view-buffer-other-window
view-emacs-news
view-file
view-file-other-window
view-lossage
view-major-mode
view-minor-mode
view-mode
view-pr
view-register
view-sample-init-el

viper-mode
visit-tags-table

vm
vm-compose-mail
vm-folders-summarize
vm-mail
vm-mail-other-frame
vm-mail-other-window
vm-mode
vm-other-frame
vm-other-window
vm-submit-bug-report
vm-visit-folder
vm-visit-folder-other-frame
vm-visit-folder-other-window
vm-visit-imap-folder
vm-visit-imap-folder-other-frame
vm-visit-imap-folder-other-window
vm-visit-pop-folder
vm-visit-pop-folder-other-frame
vm-visit-pop-folder-other-window
vm-visit-virtual-folder
vm-visit-virtual-folder-other-frame
vm-visit-virtual-folder-other-window

vrml-mode
#@nonl
#@-node:ekr.20050921094025.280:v view- vm-
#@+node:ekr.20050921094025.281:w win32- winring- word- write-
w3
w3-display-stylesheet
w3-fetch
w3-fetch-other-frame
w3-find-file
w3-follow-link
w3-follow-url-at-point
w3-follow-url-at-point-other-frame
w3-hotindex-add-key
w3-hotindex-query
w3-hotindex-rm-key
w3-hotlist-add-document
w3-hotlist-add-document-at-point
w3-hotlist-append
w3-hotlist-apropos
w3-hotlist-delete
w3-hotlist-refresh
w3-hotlist-rename-entry
w3-maybe-follow-link
w3-maybe-follow-link-mouse
w3-next-document
w3-open-local
w3-prev-document
w3-preview-this-buffer
w3-print-this-url
w3-print-url-under-point
w3-read-html-bookmarks
w3-region
w3-show-dvi
w3-table-speak-current-table-column
w3-use-hotlist
w3-version

wconfig-add-by-name
wconfig-delete-by-name
wconfig-delete-pop
wconfig-restore-by-name
wconfig-ring-save
wconfig-yank-pop

webjump

what-coding-system
what-cursor-position
what-domain
what-line
what-page

where-is

whitespace-buffer
whitespace-cleanup
whitespace-cleanup-region
whitespace-global-mode
whitespace-region
whitespace-toggle-ateol-check
whitespace-toggle-indent-check
whitespace-toggle-leading-check
whitespace-toggle-spacetab-check
whitespace-toggle-trailing-check
whitespace-visual-incremental-mode
whitespace-visual-mode
whitespace-write-file-hook

whois
whois-reverse-lookup
widen

widget-backward
widget-beginning-of-line
widget-browse
widget-browse-at
widget-browse-other-window
widget-button-click
widget-button-press
widget-button1-click
widget-complete
widget-end-of-line
widget-field-activate
widget-file-complete
widget-forward
widget-kill-line
widget-minor-mode
widget-transpose-chars

win32-get-current-locale-id
win32-get-default-locale-id
win32-get-locale-info
win32-get-valid-locale-ids
win32-long-file-name
win32-set-current-locale
win32-set-process-priority
win32-short-file-name

window-configuration-to-register
winmgr-mode

winring-delete-configuration
winring-duplicate-configuration
winring-jump-to-configuration
winring-new-configuration
winring-next-configuration
winring-prev-configuration
winring-rename-configuration

word-search-backward
word-search-forward

wordstar-mode

write-abbrev-file
write-file
write-region
write-region-internal

wrolo-popup-menu
#@nonl
#@-node:ekr.20050921094025.281:w win32- winring- word- write-
#@+node:ekr.20050921094025.282:x xwem-
x-symbol-decode
x-symbol-decode-recode
x-symbol-encode
x-symbol-encode-recode
x-symbol-fontify
x-symbol-grid
x-symbol-image-editor
x-symbol-image-parse-buffer
x-symbol-init-language-interactive
x-symbol-initialize
x-symbol-key-autoload
x-symbol-map-autoload
x-symbol-mode
x-symbol-modify-key
x-symbol-package-bug
x-symbol-package-info
x-symbol-package-reply-to-report
x-symbol-package-web
x-symbol-rotate-key
x-symbol-unalias

xdb

xemacs-local-faq
xemacs-splash-buffer
xemacs-www-faq
xemacs-www-page

xetla
xetla-add-log-entry
xetla-apply-changeset
xetla-archives
xetla-bookmarks
xetla-browse
xetla-changelog
xetla-changes
xetla-changes-against
xetla-changes-last-revision
xetla-commit
xetla-conflicts-finish
xetla-delta
xetla-ediff-add-log-entry
xetla-edit-log
xetla-file-diff
xetla-file-ediff
xetla-file-ediff-revisions
xetla-file-view-original
xetla-get-changeset
xetla-help
xetla-id-tagging-method
xetla-inventory
xetla-inventory-file-mode
xetla-log-edit-mode
xetla-logs
xetla-make-archive
xetla-missing
xetla-my-id
xetla-my-revision-library
xetla-prepare-patch-submission
xetla-revisions
xetla-rm
xetla-start-project
xetla-submit-bug-report
xetla-tag-insert
xetla-tag-regenerate
xetla-tree-lint
xetla-tree-version
xetla-version
xetla-view-conflicts

xmine
xmine-mode
xml-mode
xpm-mode
xrdb-mode
xsl-grep
xsl-mode
xslt-process-mode
xt-check-xlib

xwem-attach-client
xwem-backward-application
xwem-balance-windows
xwem-battery
xwem-battery-popup-menu
xwem-battery-status
xwem-cl-pop-to-client
xwem-cl-set-title
xwem-cl-switch-other-frame
xwem-cl-switch-other-win
xwem-cl-switch-to-other
xwem-cl-switch-to-other-in-other-win
xwem-cl-transpose
xwem-clgen-toggle-other-on-split
xwem-clgen-turn-off-other-on-split
xwem-clgen-turn-on-other-on-split
xwem-client-demanage-others
xwem-client-exchange-selected-and-mark
xwem-client-iconify
xwem-client-idestroy
xwem-client-imove
xwem-client-info
xwem-client-iresize
xwem-client-kill
xwem-client-query-kill
xwem-client-run-copy
xwem-client-run-copy-other-frame
xwem-client-run-copy-other-win
xwem-client-set-mark
xwem-client-unset-mark
xwem-clswi-next
xwem-clswi-next-other-window
xwem-clswi-prev
xwem-clswi-prev-other-window
xwem-copy-cutbuffer
xwem-copy-region-as-cutbuffer
xwem-describe-prefix-bindings
xwem-desktop-load
xwem-desktop-load-onetime
xwem-desktop-save
xwem-desktop-save-onetime
xwem-edit-client-properties
xwem-edmacro-edit-kbd-macro
xwem-eval-expression
xwem-execute-extended-command
xwem-fini
xwem-focus-click-on
xwem-forward-application
xwem-frame-destroy
xwem-frame-fit-screen
xwem-frame-goto-next
xwem-frame-goto-next-hor
xwem-frame-goto-next-vert
xwem-frame-goto-prev
xwem-frame-goto-prev-hor
xwem-frame-goto-prev-vert
xwem-frame-hide
xwem-frame-imove
xwem-frame-iresize
xwem-frame-lower
xwem-frame-next
xwem-frame-on-delim-menu
xwem-frame-on-delim-resize
xwem-frame-previous
xwem-frame-raise
xwem-frame-sbs-hor-split
xwem-frame-sbs-vert-split
xwem-frame-set-name
xwem-frame-showroot
xwem-frame-split-sbs
xwem-frame-switch
xwem-frame-switch-nth
xwem-frame-switch-nth-linkage
xwem-frame-transparency
xwem-frame-transpose
xwem-framei-dockapp-popup-alt-menu
xwem-framei-dockapp-popup-menu
xwem-fullscreen-mode
xwem-help
xwem-help-clients
xwem-help-cutbuffers
xwem-help-describe-bindings
xwem-help-describe-key
xwem-help-describe-key1
xwem-help-for-help
xwem-help-frames
xwem-help-mode
xwem-help-where-is
xwem-help-wins
xwem-ignore-command
xwem-kbd-quit
xwem-kbd-quote-command
xwem-keyboard-quit
xwem-keymacro-begin
xwem-keymacro-end
xwem-keymacro-exit-recursive-edit
xwem-keymacro-recursive-edit
xwem-keymacro-undefined
xwem-keytt-minor-mode
xwem-kill-cl-and-window
xwem-launch-dock-down
xwem-launch-dock-launch
xwem-launch-dock-menu
xwem-launch-lupe
xwem-launch-lupe-other-frame
xwem-launch-lupe-other-win
xwem-launch-program
xwem-launch-program-other-frame
xwem-launch-program-other-win
xwem-launch-xlock
xwem-launch-xterm
xwem-launch-xterm-other-frame
xwem-launch-xterm-other-win
xwem-launcher-toggle-frame-type
xwem-launcher-toggle-split-type
xwem-launcher-turn-on-embedded-frame-type
xwem-launcher-turn-on-horizontal-split-type
xwem-launcher-turn-on-normal-frame-type
xwem-launcher-turn-on-vertical-split-type
xwem-make-frame
xwem-mini-calc
xwem-minib-resize-mode
xwem-minibuffer-activate
xwem-misc-make-screenshot
xwem-misc-pause
xwem-misc-profiling-results
xwem-misc-start-profiling
xwem-modeline-disable
xwem-modeline-enable
xwem-open-file
xwem-other-window
xwem-pager
xwem-pager-move-down
xwem-pager-move-left
xwem-pager-move-right
xwem-pager-move-up
xwem-paste-cutbuffer
xwem-popup-auto-menu
xwem-popup-clients-menu
xwem-recover-do-recover
xwem-recover-toggle
xwem-recover-turn-off
xwem-recover-turn-on
xwem-register-client
xwem-register-frame-config
xwem-register-jump
xwem-register-win-config
xwem-report-bug
xwem-rooter-lower
xwem-rooter-raise
xwem-run-program
xwem-self-insert-or-undefined
xwem-shell-command
xwem-show-message-log
xwem-sm-global-mode
xwem-sm-mode
xwem-strokes-begin
xwem-strokes-cmplx-begin
xwem-strokes-define
xwem-strokes-ibutton1
xwem-strokes-ibutton1up
xwem-strokes-ibutton3
xwem-strokes-idescribe
xwem-strokes-list
xwem-strokes-nocmd
xwem-strokes-unset-last-stroke
xwem-switch-client
xwem-switch-other-client
xwem-switch-to-fullscreen-cl
xwem-tabber-popup-cl-menu
xwem-tabber-switch-cl
xwem-theme-set
xwem-time
xwem-toggle-fullscreen
xwem-transpose-frames
xwem-turn-off-keytt
xwem-turn-off-vline
xwem-turn-on-keytt
xwem-turn-on-vline
xwem-undefined-command
xwem-universal-argument
xwem-universal-command
xwem-universal-digit
xwem-universal-minus
xwem-universal-more
xwem-vline-minor-mode
xwem-weather-popup-menu
xwem-weather-popup-remove
xwem-weather-show-details
xwem-weather-update
xwem-window-delete
xwem-window-delete-others
xwem-window-enlarge-horizontally
xwem-window-enlarge-vertically
xwem-window-split-horizontally
xwem-window-split-vertically
xwem-winmove-down
xwem-winmove-left
xwem-winmove-right
xwem-winmove-up
xwem-worklog-login
xwem-worklog-logout
#@nonl
#@-node:ekr.20050921094025.282:x xwem-
#@+node:ekr.20050921094025.283:y yank-
yank
yank-clipboard-selection
yank-pop
yank-rectangle
yow
#@-node:ekr.20050921094025.283:y yank-
#@+node:ekr.20050921094025.284:z zap-
zap-to-char
zap-up-to-char
zenirc
#@nonl
#@-node:ekr.20050921094025.284:z zap-
#@-node:ekr.20050921094025.254:All xemacs commands
#@+node:ekr.20050921094025.6:What I did
@nocolor
#@nonl
#@+node:ekr.20051004132320:Early days
#@+node:ekr.20050921094025.7:Rewrote buildBufferList
There may be bugs here.  The old code had definite strange aspects to it.
#@nonl
#@-node:ekr.20050921094025.7:Rewrote buildBufferList
#@+node:ekr.20050921094025.8:Removed Emacs_instances class var
createBindings now sets c.emacs, so modifyOnBodyKey just uses c.emacs.
#@nonl
#@-node:ekr.20050921094025.8:Removed Emacs_instances class var
#@+node:ekr.20050921094025.9:Added c ivar to Emacs class
This is an important addition:  it guarantees that the proper commander is always used.
#@nonl
#@-node:ekr.20050921094025.9:Added c ivar to Emacs class
#@+node:ekr.20050921094025.10:Removed labels class var
This is not needed.  createBindings is called at most once per commander.
#@nonl
#@-node:ekr.20050921094025.10:Removed labels class var
#@+node:ekr.20050921094025.11:Added baseCommands class
Subclasses of baseCommands class should implement getPublicCommands.

This returns a dict whose keys are emacs command names and whose values are bound methods.
#@nonl
#@-node:ekr.20050921094025.11:Added baseCommands class
#@+node:ekr.20050921094025.12:The big collapse (of complexity)
The miniBufferClass is the one half of the great divide.  The commands classes are the other.

- The commnds classes do not understand the details of the miniBufferClass: it can be rearranged as needed.

(done) Replace:
    svar, label = self.getSvarLabel( event )
by:
    b = self.miniBuffer ; tbuffer = event.widget

(done) self.setSvar(event,svar) -> b.update(event)
(done) svar ->  b
(done) label.configure(background='lightblue') --> b.setLabelBlue()
(done) self.miniBuffer -> b
(done) Replaced all delegators by b.methods.
(done) Removed unused args from most methods.
#@nonl
#@-node:ekr.20050921094025.12:The big collapse (of complexity)
#@+node:ekr.20050921094025.13:Improvements to commands
- Improved feedback for interactive search.
    - The minibuffer now says isearch:
    - Added args to miniBuffer.set/get methods to protect/ignore initial prompt characters.

- Backspacing when tab completion cuts back to last 'really' typed character.
    - Further backspaces work as you would expect.
#@nonl
#@-node:ekr.20050921094025.13:Improvements to commands
#@+node:ekr.20050921094025.14:Removed all globals
- positions and tnodes globals are now ivars of bufferCommands class.
#@nonl
#@-node:ekr.20050921094025.14:Removed all globals
#@+node:ekr.20050921094025.15:Fixed bug: newline was not setting body pane dirty
The fix was to return return orig_OnBodyKey(self.c.frame.body,event) at end of masterCommand.
#@nonl
#@-node:ekr.20050921094025.15:Fixed bug: newline was not setting body pane dirty
#@+node:ekr.20050921101706:Replaced 'M-x' prompt by 'full-command'
#@-node:ekr.20050921101706:Replaced 'M-x' prompt by 'full-command'
#@+node:ekr.20050921105623:Added useMiniBuffer and useEditorMenu @settings
#@-node:ekr.20050921105623:Added useMiniBuffer and useEditorMenu @settings
#@+node:ekr.20050921105623.1:Deleted coreEmacs plugin
No longer needed.
#@nonl
#@-node:ekr.20050921105623.1:Deleted coreEmacs plugin
#@+node:ekr.20050922080526:Fixed outline selection bug
Thie problem was in the code at the end of keyHandler.finishCreate.

The watchDelete hack was interfering with some kind of event.

It was an ugly hack anyway ;-)
#@nonl
#@-node:ekr.20050922080526:Fixed outline selection bug
#@+node:ekr.20050923143034:c.commandsDict now describes all commands
- Keys are full Emacs command names, values are methods.
#@nonl
#@-node:ekr.20050923143034:c.commandsDict now describes all commands
#@+node:ekr.20050923141539:Rewrote altX code
- Eliminated iterator class.  (I now understand the code :-)
- Automatically call b.clearState() and b.keyboardQuit() before dispatching commands.
- Tab completion returns a non-trivial common prefix if it exists.  Further tabs cycle through possibilities.
#@nonl
#@-node:ekr.20050923141539:Rewrote altX code
#@+node:ekr.20050923233827:Eliminated all helper classes and simplified the code.
- Eliminated self.tbuffer

- Removed all subclssses from keyHandlerClass.
    - Replaced all references to keyHandler, miniBuffer, kstrokeManager, etc.
    - All methods are now methods of the keyHandler class.

- k denotes the keyHandler class everywhere.
    - All commands classes define k ivar that refers to keyHandler.

- Replaced tbuffer by w everywhere.

The effect of these changes:
    - There is never any confusion about how to access a keyHandler method: just use k.whatever.
    - The init logic is simple and clean.
    - The client code is visually much shorter and easier to understand.
    - The keyHandler class is now simpler, though larger.
    - There is no need for redirector methods.
#@nonl
#@-node:ekr.20050923233827:Eliminated all helper classes and simplified the code.
#@-node:ekr.20051004132320:Early days
#@+node:ekr.20051014170101:Before changeover
#@+node:ekr.20050924073836.1:Simplifications 1
- setEvent is only used in one commands class, so it was moved there.

- setLabelBlue and setLabelGrey now can set the label text as well as color.
  This is a nice simplification of the client code.

- Changed k.get, k.set and k.update to k.getLabel, k.setLable and k.updateLabel.
  This is an important clarification.

- Used simplified state-handling scheme, under control of k.newState ivar.
    - I now see that state-handling is actually fully encapsulated in the commands classes.
    - In particular, masterCommand knows essentially nothing of states.
    - Removed getStateCommands dicts.

- Simplified keyboardQuit by defining leoEditCommands.initAllEditCommanders at the module level.
    - This call theInstance.init() for all commands classes.
      The default in the base class does nothing.
#@nonl
#@-node:ekr.20050924073836.1:Simplifications 1
#@+node:ekr.20051001180444:Simplifications 2
10/1/05

Important simplifications:

- Dispatchers call endCommand (via handleEndCommand)
  when a command returns and there is no state.
- "User" commands need only clear the state and set (or clear) the label:
  everything else is automatic.
- endCommand calls bodyWillChange.  This is the correct way to ensure that changes 'stick'.
- Dispatchers will return 'break' or None as appropriate:
  User code will not have to worry about this.
- keyboardQuit still exists, but it merely clears the state and the label.
  As before, commands may set the label to inform the user of what has happened.
#@nonl
#@-node:ekr.20051001180444:Simplifications 2
#@+node:ekr.20051002161714:Simplfications 3
- Removed tailEnd and return 'break's.  They are no longer needed.

- Replaced stopControlX by keyboardQuit.

- Rewrote state handling for search commands.

- Call endCommand after every keystroke.

- Set k.commandName to include args in keep-lines, shell-command, etc.

- Removed k.doUndo.
#@nonl
#@-node:ekr.20051002161714:Simplfications 3
#@+node:ekr.20051003140625:Improvements
- Extended k.commandName for undoable commands that use extension arguments.
  There aren't that many such commands, surprisingly.
#@nonl
#@-node:ekr.20051003140625:Improvements
#@+node:ekr.20051004085713:Improvement 2
- Split abbrevDispatch into addAbbreviation and inversAddAbbriviation.
- Removed coresponding lambda's.
- Change the hard binding for <Control-g> to k.abbortAllModesKey.
- Renamed the top-level dispatches to fullCommand and quickCommand.
** Massive improvements to rectangle and register commands.
    - new rCommands dispatcher.
    - Use new states in rCommands and most rectangle and register commands.
    - This simplifies and localizes the code.
    - The new code gives much better feedback.
    - Allow arbitrary location-types in registers:  e.g. 'end'
#@nonl
#@-node:ekr.20051004085713:Improvement 2
#@+node:ekr.20051007093659:Final integration
@nocolor

- menu.createMenuEntries calls c.keyHandler.bindShortcutFromMenu.
    menu.createMenuEntries makes **no** bindings itself in this case.

- Created k.makeAllBindings to localize bindings.

- bindShortcutFromMenu and setBufferStrokes use two levels of callbacks.
    The keyCallback is bound to the key: it calls k.masterCommand.
    It refers to a refers to a second callback that dispatches the actual command.

- bindKey now tests for duplicates and recovers from bad key bindings (user error).

- Removed test to keystrokeFunctionDict in masterCommand.
    The regular key binding mechanism should be enough!
#@nonl
#@-node:ekr.20051007093659:Final integration
#@+node:ekr.20051008065518:Final integration 2
- k.finishCreate calls k.createInverseCommandsDict first.

- The values in k.inverseCommandsDict are f.__name__, rather than f.

- leoCommands.getPublicCommands now adds underlying f.__name__ to k.inverseCommandsDict rather than leoCallback.

- createInverseCommandsDict ignores 'leoCallback' when adding entries.

- Used k.inverseCommandsDict in << set accel to the shortcut for name >> to get shortcuts using emacs-style names.

    This allows either old-style menu shortcuts or emacs command names.

- Allow '-' in shortcut names in parseShortcutLine.

- Allow trailing comments in shortcut names in parseShortcutLine.

* cb_dict is now vestigial and will soon be removed.
    However, <Alt-X> is not bound properly at present.

Binding is mostly complete:  the traces from createMenuEntries show missing command names in leoSettings.leo.

- Removed last traces of cbDict ivar.  Use. by k.bindingsDict as need.
#@nonl
#@-node:ekr.20051008065518:Final integration 2
#@+node:ekr.20051009042953:Changeover
@nocolor

- replaced x.useMiniBuffer by c.useMiniBuffer.
- Replace useEditorMenu by useCmdMenu, etc.
- Call createMenuBar in c.finishCreate.
- Removed all dummy methods from nullMenu class.
    - The methods of the base class will do fine, provided that an overrided oops method does nothing!
** Always define c.keyHandler, even if c.useMiniBuffer is False.
    - Changes to c.finishCreate and keyHandler.ctor.
- Removed all warnings:
    - Added dynamicMenu arg to createMenuEntries to suppress a warning when a menu is created from a plugin.
    - Revise << set accel to the shortcut for name >> in createMenuEntries tests c.useMiniBuffer.
    - Use c.frame.selectAllText instead of c.editCommands.selectAll.
- Fixed bug in makeSpecialBindings so that Control-g works.
#@nonl
#@-node:ekr.20051009042953:Changeover
#@+node:ekr.20051009130341:Bugs fixed
- Make all bindings to c.frame.top (not w) in bindKey.
  This make bindings available everywhere.
#@nonl
#@-node:ekr.20051009130341:Bugs fixed
#@+node:ekr.20051011091759:Added big kludge to solve infamous control-v problems
Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.
#@nonl
#@-node:ekr.20051011091759:Added big kludge to solve infamous control-v problems
#@-node:ekr.20051014170101:Before changeover
#@+node:ekr.20051011124540:After changeover
- Fixed duplicate Pastes in headlines.
    - Works when paste-text command is not defined.
    - Removed weird virtual bindings in tkBody.createBindings.

- Control-H now works properly.
    - Added forceFocuse arg to k.endCommand.
      This is always False for Leo commands.
      
- At present the processing for @shortcuts does not allow multiple shortcuts for a single command.
  The **last** setting prevails.  The value should be a list, and each item on the list should create a binding.
  
- Fixed crash in unit test for rst2 plugin.
    The call to createMenuEntries had callOnFileOpen() instead of callOnFileOpen.

- k.checkBindings checks that commands have an @shortcuts entry.
    - The entry may be None, of course.
    - Created g.app.config.exists as a helper function.
    ** The major @shortcuts nodes now pass this test.

- created `@button align to col` in leoSettings.leo.
- open-with shortcuts now work.
- Made sure old-style settings still work.

- Changed name Editor menu to Cmds menu.
- Used previously unused init param to createMenuEntries to suppress warnings.
- Disabled many plugin tests. These tests are flakey: they don't work the same if repeated.
- Fixed all pychecker errors.
- Fixed bugs in nextLine, prevLine.  Can't call manufactureKeyPress: the keys may have been rebound!
#@nonl
#@-node:ekr.20051011124540:After changeover
#@+node:ekr.20051014170101.1:Before a1
- Changed k.updateLabel so unknown control keysare not put into minibuffer.
- Added hide/show/toggle-mini-buffer commands.
- Added contract-and-go-right command
- Fixed long-standing bug in goto-last-node.
- Added goto-first-sibling and goto-last-sibling commands.
- Created help command.
- Changed c.useMiniBuffer to c.showMinibuffer
- Fixed existing bug in config logic: (munged) shortcuts could conflict with other settings!
#@nonl
#@-node:ekr.20051014170101.1:Before a1
#@-node:ekr.20050921094025.6:What I did
#@-node:ekr.20050920084720.1:Moved emacs commands and new keyHandler to Leo's core
#@+node:ekr.20051012084345:Bugs fixed
#@clone 2
#@+node:ekr.20051012075322:openWithFileName now reads @settings by default
#@+node:ekr.20051010152921:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3376527
By: vpe

My first complaint is the same as in this earlier post:
http://sourceforge.net/forum/message.php?msg_id=3331283
If leo file has @settings in it, these settings are not applied when I open
the file from another outline, that is from File->Recent Files or File->Open
or Help->Leo Docs etc. They are applied when I open the file directly by double
clicking.

Also, when leo files are opened from another outline, the log window has no
messages about leoID, global config dir, home dir, reading settings, # plugins
loaded.

Possible reason:

I have leo files associated with "path\pythonw.exe" "path\leo.py" "%1". Each
time I open a leo file directly, a new pythonw.exe process is started. But,
when I open files from an outline, no new pythonw.exe is started. This does
not make much sense to me. It's not an MDI editor. It's also safer to have separate
processes--if one outline crashes, others will survive.

Leo 4.3.3, build  1.282 , Python 2.4.2, Tk 8.4.7, win2k
#@nonl
#@-node:ekr.20051010152921:Report
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(repr(fileName))

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            # We have already read settings from this file.
            ok, frame = g.openWithFileName(fileName,None,readSettings=False)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # 5/13/05
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(repr(fileName))

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            # We have already read settings from this file.
            ok, frame = g.openWithFileName(fileName,None,readSettings=False)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # 5/13/05
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@nonl
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)
    
    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.printDict(d)
#@nonl
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True,readSettings=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.trace('Already open',fileName)
            return True, frame
    try:
        # g.trace('Not open',fileName)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_dirname(fileName)
        if readSettings:
            g.app.config.updateSettings(c,localFlag=True)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20051012075322:openWithFileName now reads @settings by default
#@+node:ekr.20051012205437:(Replaced all calls to manufactureKeyPress)
# Such calls will fail if keys have been rebound.
#@nonl
#@+node:ekr.20050929115226.1:forward/backCharacter
def backCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
    
def forwardCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
#@-node:ekr.20050929115226.1:forward/backCharacter
#@+node:ekr.20050929163210:next/prevLine
def nextLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.

def prevLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20050929163210:next/prevLine
#@+node:ekr.20050929163010:backwardDeleteCharacter
def backwardDeleteCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.delete('%s-1c' % (i), '%s' % (i))
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20050929163010:backwardDeleteCharacter
#@-node:ekr.20051012205437:(Replaced all calls to manufactureKeyPress)
#@+node:ekr.20051013103838:(Escape does not end label editing)
@
Control-c while editing headline caused problems.
end/abort-edit-headline did not work.
#@nonl
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWantFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callerList(5))

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callerList(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callerList(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@+node:ekr.20040803072955.135:setNormalLabelState
def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        
        # self.frame.headlineWantsFocus(p,later=False)
#@nonl
#@-node:ekr.20040803072955.135:setNormalLabelState
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()
    
    # g.trace(p and p.headString())

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.126:endEditLabel
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

    frame = self ; c = frame.c ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
        return
        
    if 1: # New code in 4.4a1.
        tree.endEditLabel()
        tree.select(tree.editPosition())
    else:
        v = frame.tree.editPosition()
        # g.trace(v)
        if v and v.edit_text():
            tree.select(v)
        if v: # Bug fix 10/9/02: also redraw ancestor headlines.
            tree.force_redraw() # force a redraw of joined headlines.

    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode() ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    if self.revertHeadline and v.edit_text() and v == tree.editPosition():
    
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        if 1: # New code in 4.4a1.
            tree.endEditLabel()
            tree.select(tree.editPosition())
        else: # Old code:
            tree.select(v)
            if v and len(v.t.vnodeList) > 0:
                tree.force_redraw() # force a redraw of joined headlines.
#@nonl
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@-node:ekr.20051013103838:(Escape does not end label editing)
#@+node:ekr.20051012101104:Don't override menu defaults if there is no setting for the command in the @shortcuts node
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20051012101104:Don't override menu defaults if there is no setting for the command in the @shortcuts node
#@+node:ekr.20051013155435:Minor crashes during development
#@+node:ekr.20051012082219:Crash in backwardParagraph
TclError Exception in Tk callback
  Function: <function keyCallback at 0x017923B0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x026A9E18>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

TclError Exception in Tk callback
  Function: <function keyCallback at 0x017923B0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x026B2648>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

#@+node:ekr.20050920084036.102:backwardParagraph
def backwardParagraph (self,event):

    k = self.k ; w = event.widget ; i = w.index('insert')

    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        w.mark_set('insert',i)
        w.see('insert')
#@-node:ekr.20050920084036.102:backwardParagraph
#@-node:ekr.20051012082219:Crash in backwardParagraph
#@+node:ekr.20051012101954:Crash in Open Compare Window
exception executing command
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 236, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 4856, in openCompareWindow
    frame.comparePanel = g.app.gui.createComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterGui.py", line 254, in createComparePanel
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterComparePanel.py", line 41, in __init__
    self.useOutputFileVar = Tk.IntVar()

  File "c:\python24\lib\lib-tk\Tkinter.py", line 244, in __init__
    Variable.__init__(self, master)

  File "c:\python24\lib\lib-tk\Tkinter.py", line 179, in __init__
    self._tk = master.tk

AttributeError: 'NoneType' object has no attribute 'tk'

Exception exceptions.AttributeError: "IntVar instance has no attribute '_tk'" in <bound method IntVar.__del__ of <Tkinte
r.IntVar instance at 0x0171B800>> ignored
#@-node:ekr.20051012101954:Crash in Open Compare Window
#@+node:ekr.20051010130212:Crash in unit test
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoGlobals.py", line 2349, in doHook
    return f(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 88, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 47, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 248, in onFileOpen
    transform_rst2_text_in_subtree(c)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 239, in transform_rst2_text_in_subtree
    c.frame.menu.createMenuEntries(editMenu, newEntries)

  File "C:\prog\leoCVS\leo\src\leoMenu.py", line 1022, in createMenuEntries
    emacs_name = k.inverseCommandsDict.get(command.__name__)

AttributeError: 'callOnFileOpen' object has no attribute '__name__'
#@nonl
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20051010130212:Crash in unit test
#@-node:ekr.20051013155435:Minor crashes during development
#@+node:ekr.20051014034200:(Fixed problems when special keys are not defined
#@+node:ekr.20051014104337:Notes
@ The hard-to-find bug was in makeSpecialBindings.

- Changed tag to tag=tag.  The bug was causing tag to be bound to the openWith arg!
#@nonl
#@-node:ekr.20051014104337:Notes
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunch = c.config.getShortcut(commandName)
        accel = (bunch and bunch.val) or stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        # g.trace(stroke,accel,shortcut,func.__name__)
        if pane == 'mini' and func != k.keyboardQuit:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
        else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)

            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)

            k.bindKey(pane,shortcut,keyCallback,commandName)

        if ivar:
            setattr(k,ivar,shortcut)
        
    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@-node:ekr.20051014034200:(Fixed problems when special keys are not defined
#@+node:ekr.20051015063053:(Problems enabling minibuffer)
# These arose because @bool useMinibuffer conflicted with @shortcut use-mini-buffer(!!)
# Added new checks in g.app.config.getValFromDict.
#@nonl
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = True
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20051011105014:exists (g.app.config)
def exists (self,c,setting,kind):
    
    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True
                
    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
#@nonl
#@-node:ekr.20051011105014:exists (g.app.config)
#@+node:ekr.20041118084146:Setters (g.app.config)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041118084241:setString
def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)
#@nonl
#@-node:ekr.20041118084241:setString
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20041118084146:Setters (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):
    
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):
    
    '''
    Return True if type1, the actual type, matches type2, the requeseted type.
    
    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts')
    
    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20041118195812:Setters... (c.configSettings)
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters... (c.configSettings)
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@-node:ekr.20051015063053:(Problems enabling minibuffer)
#@+node:ekr.20051015163627:(last-minute problem with ctrl-g)
@ What I did:
    
- Bind shortcuts in makeSpecialBindings *before* defining callbacks.

- Removed duplicate entry for universal-argument in @shortcuts node.
  (very confusing).
  
- Chose default for universal-argument in makeSpecialBindings that does
  not conflict with move-outline-up or untangle.
#@-node:ekr.20051015163627:(last-minute problem with ctrl-g)
#@-node:ekr.20051012084345:Bugs fixed
#@-node:ekr.20051016115757:4.4a1 projects
#@+node:ekr.20051016115757.1:4.4a2 projects
#@+node:ekr.20051014155115:(Added f.show/hideMinibuffer)
#@-node:ekr.20051014155115:(Added f.show/hideMinibuffer)
#@+node:ekr.20051014180059:(Help command)
#@+node:ekr.20051014170754:k.help
def help (self,event):
    
    k = self ; c = k.c
    commands = (
        k.fullCommand,
        k.quickCommand,
        k.universalArgument,
        k.keyboardQuit,
        # negative-argument
        # repeat-complex-command
    )
    shortcuts = [
        k.getShortcutForCommand(command)
        for command in commands]

    # A bug in Leo: triple quotes puts indentation before each line.
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

%s: Just like Emacs Alt-x: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit <Return> to execute the command. Tab completion
works, but not for file names.

%s: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

%s: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

%s: Just like Emacs Ctrl-g: Closes the mini-buffer.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])
    g.es_print(s)
#@nonl
#@-node:ekr.20051014170754:k.help
#@+node:ekr.20031218072017.3197:Whitespace...
#@+node:ekr.20051014175117:g.adjustTripleString (same as removeExtraLws)
def adjustTripleString (s,tab_width):
    
    '''Remove leading indentation from a triple-quoted string.
    
    This works around the fact that Leo nodes can't represent underindented strings.
    '''
    
    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    w = -1
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w2 = g.computeWidth(lws,tab_width)
            if w < 0: w = w2
            else:     w = min(w,w2)
            # g.trace('w',w)
    if w <= 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    return result
#@nonl
#@-node:ekr.20051014175117:g.adjustTripleString (same as removeExtraLws)
#@+node:ekr.20031218072017.3198:computeLeadingWhitespace
# Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width <= 0:
        return ""
    if tab_width > 1:
        tabs   = width / tab_width
        blanks = width % tab_width
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)
#@nonl
#@-node:ekr.20031218072017.3198:computeLeadingWhitespace
#@+node:ekr.20031218072017.3199:computeWidth
# Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):
        
    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            w += 1
    return w
#@nonl
#@-node:ekr.20031218072017.3199:computeWidth
#@+node:ekr.20031218072017.3200:get_leading_ws
def get_leading_ws(s):
    
    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i < n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
#@-node:ekr.20031218072017.3200:get_leading_ws
#@+node:ekr.20031218072017.3201:optimizeLeadingWhitespace
# Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

    i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
    s = g.computeLeadingWhitespace(width,tab_width) + line[i:]
    return s
#@nonl
#@-node:ekr.20031218072017.3201:optimizeLeadingWhitespace
#@+node:ekr.20040723093558:regularizeTrailingNewlines
@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):
    
    """Kind is 'asis', 'zero' or 'one'."""
    
    pass
#@nonl
#@-node:ekr.20040723093558:regularizeTrailingNewlines
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@nonl
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@+node:ekr.20050211120242.2:g.removeExtraLws & tests
def removeExtraLws (s,tab_width):
    
    '''Remove extra indentation from one or more lines.
    
    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    
    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result
#@nonl
#@+node:ekr.20050211120837:test_g_removeExtraLws
def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@nonl
#@-node:ekr.20050211120837:test_g_removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & tests
#@+node:ekr.20031218072017.3203:removeTrailingWs
# Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

    j = len(s)-1
    while j >= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[:j+1]
#@-node:ekr.20031218072017.3203:removeTrailingWs
#@+node:ekr.20031218072017.3204:skip_leading_ws
# Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

    count = 0
    while count < ws and i < len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i
#@nonl
#@-node:ekr.20031218072017.3204:skip_leading_ws
#@+node:ekr.20031218072017.3205:skip_leading_ws_with_indent
def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent), 
    
    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i < n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count
#@nonl
#@-node:ekr.20031218072017.3205:skip_leading_ws_with_indent
#@+node:ekr.20040723093558.1:stripBlankLines
def stripBlankLines(s):
    
    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j >= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))
            
    return ''.join(lines)
#@-node:ekr.20040723093558.1:stripBlankLines
#@-node:ekr.20031218072017.3197:Whitespace...
#@-node:ekr.20051014180059:(Help command)
#@+node:ekr.20051021070335:(Created open-find-tab command)
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@-node:ekr.20051021070335:(Created open-find-tab command)
#@+node:ekr.20051015112436:(Fixed bugs in k.registerCommand, k.printBindings
#@+node:ekr.20051016171402:Notes
@nocolor

print-bindings was printing the function name, not the command name. Fixing this
was hairy: it involved adding the commandName argument to k.bindShortcut and
k.bindKey. The work is worthwhile: it is now much clearer what is being bound.
The most complicated change was to menu.createMenuEntries, as usual...
#@nonl
#@-node:ekr.20051016171402:Notes
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20051015110547:registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
            
    if verbose:
        if shortcut and ok:
            g.es_print('Registered %s bound to %s' % (
                commandName,shortcut),color='blue')
        else:
            g.es_print('Registered %s' % (commandName), color='blue')
#@nonl
#@-node:ekr.20051015110547:registerCommand
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c
    
    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return

    try:
        << bind callback to shortcut in pane >>

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            # g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20051022094136:<< bind callback to shortcut in pane >>
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

# Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the <Key>+ binding.

allPanes = [body,log,tree,menu,minibuffer]

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or 'all').lower(),[])

if shortcut == '<Key>':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:<< bind callback to shortcut in pane >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        b = k.bindingsDict.get(key)
        g.es('[%s]' % b.pane,key,b.commandName or b.name,tabName='Command')
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunch = c.config.getShortcut(commandName)
        accel = (bunch and bunch.val) or stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        # g.trace(stroke,accel,shortcut,func.__name__)
        if pane == 'mini' and func != k.keyboardQuit:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
        else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)

            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)

            k.bindKey(pane,shortcut,keyCallback,commandName)

        if ivar:
            setattr(k,ivar,shortcut)
        
    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@-node:ekr.20051015112436:(Fixed bugs in k.registerCommand, k.printBindings
#@+node:ekr.20051021074728.1:(Improved shortcuts parser)
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.

    bunch = self.get(c,key,"shortcut")
    if bunch and bunch.val:
        # g.trace(bunch.pane,key,repr(bunch.val))
        if bunch.val.lower() == 'none':
            return key,None
        else:
            return key,bunch
    else:
        return key,None
#@nonl
#@-node:ekr.20041117062717.14:getShortcut (config)
#@+node:ekr.20051021212323:What I did
@nocolor

- Allow per-pane bindings in parseShortcutLine.

    goto-next-visible ! outline =  DnArrow
    next-line         ! body = DnArrow

- Warn and ignore duplicate shortcuts in doShortcuts.
#@nonl
#@-node:ekr.20051021212323:What I did
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace. 
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)
#@nonl
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    d = {} # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                if d.get(name):
                    g.es('ignoring duplicate @shortcuts entry: %s' % (
                        name), color='blue')
                else:
                    d [name] = bunch
                    self.set(p,"shortcut",name,bunch)
                    self.setShortcut(name,bunch)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)
#@nonl
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@-node:ekr.20051021074728.1:(Improved shortcuts parser)
#@+node:ekr.20051016113907:(Moved TabbedLog code into Leo's core)
@

I removed the TabbedLog plugin from cvs, and changed the UASearch and URLloader
plugins so they create create tabbed logs using c.frame.log.selectTab rather
than TabbedLog.getPane. No other official plugins use TabbedLog. 
#@+node:ekr.20051016113907.1:How to use the new code
@nocolor

c.frame.log.selectTab(tabName) selects the tab in the log pane, creating it if
necessary.

The g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log', so existing code works as
before.

Minor notes:

1. The following are official status ivars.  They can be read by client code,
but they should never be changed outside of the leoTkinterLog class:

c.frame.log.tabName: the name of the active tab.
c.frame.log.logCtrl: the Tk.Text widget for the active tab.
c.frame.log.tabFrame: the Tk.Frame containing the active tab.

These ivars may not exist in nullLog's.

2. The put and putnl methods of the tkinterLog class also take an optional
tabName argument which defaults to 'Log'.
#@nonl
#@-node:ekr.20051016113907.1:How to use the new code
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others
#@nonl
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@nonl
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@nonl
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@nonl
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@nonl
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@nonl
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@nonl
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@nonl
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)
        
# g.trace(repr(self.logCtrl))

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    << bind a tab-specific pop-up menu to the tab >>
    << Create the tab's text widget >>
    self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('<Button-1>',tabMenuClickCallback)
tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("<Button-1>",self.onActivateLog)
textWidget.tag_config('black',foreground='black')
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        return

    if tabName in ('Find','Spell'):
        self.selectTab('Log')
        return
    
    if tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20051018061932.1:ower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    
def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        logCtrl = self.textDict.get(tabName)
        self.c.frame.widgetWantsFocus(logCtrl)
#@nonl
#@-node:ekr.20051018061932.1:ower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    textWidget = self.textDict.get(tabName)

    if k and textWidget:

        k.copyBindingsToWidget(['all','log','text'],textWidget)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):

    menu.post(event.x_root,event.y_root)
    
def onClick (self,event,tabName):
    
    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    parentFrame = self.frameDict.get(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (oldName,newName):
        self.selectTab(newName)

    self.getTabName(parentFrame,'',selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        parentFrame = self.frameDict.get(tabName)
        self.getTabName(parentFrame,tabName,self.renameTab)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,parentFrame,tabName,exitCallback):

    f = Tk.Frame(parentFrame)
    f.pack(side='bottom',fill='x',expand=1)

    Tk.Label(f,text='Tab name').pack(side='left')

    e = Tk.Entry(f,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(tabName,s)
    
    if 0:
        b = Tk.Button(row,text="Close",command=getNameCallback)
        b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@-node:ekr.20051016113907:(Moved TabbedLog code into Leo's core)
#@+node:ekr.20051022061226:(Refactored createMenuEntries)
@nocolor

- Split openWith logic from createMenuEntries into createOpenWithMenuItemsFromTable.
- Removed openWith keyword arg from createMenuEntries and k.bindShortcut.
- Removed dontBind arg from openWith.
- Removed key bindings from popup menu table.

At last createMenuEntries does one thing.
createMenuEntries will never be a simple method, but it is reasonable now.

@color
#@nonl
#@+node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20051022053758: Top level
#@+node:ekr.20031218072017.3784:createMenuItemsFromTable
def createMenuItemsFromTable (self,menuName,table):
    
    try:
        menu = self.getMenu(menuName)
        if menu == None:
            print "menu does not exist: ",menuName
            g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table)
    except:
        s = "exception creating items for %s menu" % menuName
        g.es_print(s)
        g.es_exception()
        
    g.app.menuWarningsGiven = True
#@nonl
#@-node:ekr.20031218072017.3784:createMenuItemsFromTable
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):
    
    c = self.c
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createEditorMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
#@nonl
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createEditorMenuFromTable
def createEditorMenuFromTable (self):

    cmdsMenu = self.createNewMenu('C&mds')

    for name,table,sep in (
        #('View...',   self.emacsMenuViewMenuTable,    True),
        ('Commands...',self.emacsMenuCommandsMenuTable,True),
        ('Tools...',   self.emacsMenuToolsMenuTable,   True),
        ('Options...', self.emacsMenuOptionsMenuTable, True),
        ('Buffers...', self.emacsMenuBuffersMenuTable, False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)
#@nonl
#@-node:ekr.20050921103736:createEditorMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@nonl
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    helpMenu = self.createNewMenu("&Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20031218072017.3804:createNewMenu (contains Tk code)
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.3804:createNewMenu (contains Tk code)
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.keyHandler.bindOpenWith (shortcut,name,data)
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
#@nonl
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineEditorMenuTables()

    self.defineHelpMenuTables()
#@nonl
#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@nonl
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.delete),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]
#@nonl
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section",c.extractSection),
        ("Extract &Names",c.extractSectionNames),
        ("&Extract",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",c.convertAllBlanks),
        ("Convert All T&abs",c.convertAllTabs),
        ("Convert &Blanks",c.convertBlanks),
        ("Convert &Tabs",c.convertTabs),
        ("Insert Body Time/&Date",c.insertBodyTime),
        ("&Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&Indent",c.indentBody),
        ("&Unindent",c.dedentBody),
        ("&Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline",c.editHeadline),
        ("&End Edit Headline",f.endEditLabelCommand),
        ("&Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]
#@nonl
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    if 1: # Bind to the Find tab.
        sc = c.searchCommands
        self.editMenuFindMenuTable = [
            ("&Show Find Tab",sc.openFindTab),
            ("&Hide Find Tab",sc.hideFindTab),
            ("-",None),
            ("Find &Next",          sc.findTabFindNext),
            ("Find &Previous",      sc.findTabFindPrev),
            ("&Replace",            sc.findTabChange),
            ("Replace, &Then Find", sc.findTabChangeThenFind),
        ]
    else: # Bind to deprecated Find dialog.
        self.editMenuFindMenuTable = [
            ("&Find Panel",c.showFindPanel),
            ("-",None),
            ("Find &Next",c.findNext),
            ("Find &Previous",c.findPrevious),
            ("&Replace",c.replace),
            ("Replace, &Then Find",c.replaceThenFind),
        ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number",c.goToLineNumber),
        ("&Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@nonl
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New",c.new),
        ("&Open...",c.open),
    ]
#@nonl
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&Close",c.close),
        ("&Save",c.save),
        ("Save &As",c.saveAs),
        ("Save To",c.saveTo), # &Tangle
        ("Re&vert To Saved",c.revert), # &Read/Write
    ]
#@nonl
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only",c.readOutlineOnly),
        ("Read @file &Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &Outline Only",fc.writeOutlineOnly),
        ("&Write @file Nodes",fc.writeAtFileNodes),
    ]
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All",c.tangleAll),
        ("Tangle &Marked",c.tangleMarked),
        ("&Tangle",c.tangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",c.untangleAll),
        ("Untangle &Marked",c.untangleMarked),
        ("&Untangle",c.untangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&file",c.importAtFile),
        ("Import To @&root",c.importAtRoot),
        ("Import &CWEB Files",c.importCWEBFiles),
        ("Import &noweb Files",c.importNowebFiles),
        ("Import Flattened &Outline",c.importFlattenedOutline),
    ]
#@nonl
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",c.exportHeadlines),
        ("Outline To &CWEB",c.outlineToCWEB),
        ("Outline To &Noweb",c.outlineToNoweb),
        ("&Flatten Outline",c.flattenOutline),
        ("&Remove Sentinels",c.removeSentinels),
        ("&Weave",c.weave),
    ]
#@nonl
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit",g.app.onQuit),
    ]
#@nonl
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node",c.cutOutline),
        ("C&opy Node",c.copyOutline),
        ("&Paste Node",c.pasteOutline),
        ("Pas&te Node As Clone",c.pasteOutlineRetainingClones),
        ("&Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node",c.insertHeadline),
        ("&Clone Node",c.clone),
        ("Sort Childre&n",c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&Hoist",c.hoist),
        ("D&e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",c.checkOutline),
        ("&Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &All Python Code",c.checkAllPythonCode),
        ("&Check Python &Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&rint All Python Code",c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All",c.contractAllHeadlines),
        ("Contract &Node",c.contractNode),
        ("Contract &Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&rev Level",c.expandPrevLevel),
        ("Expand N&ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &1",c.expandLevel1),
        ("Expand To Level &2",c.expandLevel2),
        ("Expand To Level &3",c.expandLevel3),
        ("Expand To Level &4",c.expandLevel4),
        ("Expand To Level &5",c.expandLevel5),
        ("Expand To Level &6",c.expandLevel6),
        ("Expand To Level &7",c.expandLevel7),
        ("Expand To Level &8",c.expandLevel8),
        ("-",None),
        ("Expand &All",c.expandAllHeadlines),
        ("Expand N&ode",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down",c.moveOutlineDown),
        ("Move &Left",c.moveOutlineLeft),
        ("Move &Right",c.moveOutlineRight),
        ("Move &Up",c.moveOutlineUp),
        ("-",None),
        ("&Promote",c.promote),
        ("&Demote",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark",c.markHeadline),
        ("Mark &Subheads",c.markSubheads),
        ("Mark Changed &Items",c.markChangedHeadlines),
        ("Mark Changed &Roots",c.markChangedRoots),
        ("Mark &Clones",c.markClones),
        ("&Unmark All",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineEditorMenuTables
def defineEditorMenuTables (self):
    
    def dummyCommand():
        pass
    
    self.emacsMenuCommandsMenuTable = [
        ('Cmnd Command 1',dummyCommand),
    ]
    
    self.emacsMenuToolsMenuTable = [
        ('Tools Command 1',dummyCommand),
    ]

    self.emacsMenuOptionsMenuTable = [
        ('Options Command 1',dummyCommand),
    ]

    self.emacsMenuBuffersMenuTable = [
        ('Buffers Command 1',dummyCommand),
    ]
#@nonl
#@-node:ekr.20050921103230:defineEditorMenuTables
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &Active Pane",f.toggleActivePane),
        ("Toggle &Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&de",f.cascade),
        ("&Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &Compare Window",c.openCompareWindow),
        ("Open &Python Window",c.openPythonWindow),
    ]
#@nonl
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&About Leo...",c.about),
        ("Online &Home Page",c.leoHome),
        ("Open Online &Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&Docs.leo",c.leoDocumentation),
        ("Open Leo&Plugins.leo",c.openLeoPlugins),
        ("Open Leo&Settings.leo",c.openLeoSettings),
    ]
#@nonl
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@+node:ekr.20031218072017.3805:deleteMenu
def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3805:deleteMenu
#@+node:ekr.20031218072017.3806:deleteMenuItem
def deleteMenuItem (self,itemName,menuName="top"):
    
    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3806:deleteMenuItem
#@-node:ekr.20051022053758: Top level
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20051022053758.1:Helpers
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    chars = string.ascii_letters + string.digits
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in chars:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20031218072017.2098:canonicalizeShortcut
@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") >= 0     or s.find("command") >= 0 # 11/18/03
    has_ctrl  = s.find("control") >= 0 or s.find("ctrl") >= 0
    has_alt   = s.find("alt") >= 0
    has_shift = s.find("shift") >= 0   or s.find("shft") >= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    << set the last field, preserving case >>
    << canonicalize the last field >>
    << synthesize the shortcuts from the information >>
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut
#@nonl
#@+node:ekr.20031218072017.2102:<< set the last field, preserving case >>
s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) > 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None
#@nonl
#@-node:ekr.20031218072017.2102:<< set the last field, preserving case >>
#@+node:ekr.20031218072017.2099:<< canonicalize the last field >>
bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        << define dict of Tk bind names >>
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) > 0:
    << define dict of special names >>
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]
#@nonl
#@+node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
# These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "<" : "less",
    "=" : "equal",
    ">" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }
#@nonl
#@-node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
#@+node:ekr.20031218072017.2101:<< define dict of special names >>
# These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20031218072017.2101:<< define dict of special names >>
#@-node:ekr.20031218072017.2099:<< canonicalize the last field >>
#@+node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) > 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "<" + bind_head + bind_last + ">"
menu_shortcut = menu_head + menu_last
#@nonl
#@-node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
#@-node:ekr.20031218072017.2098:canonicalizeShortcut
#@+node:ekr.20051022044950:computeOldStyleShortcutKey
def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    chars = string.ascii_letters + string.digits
    
    result = [ch for ch in s.strip().lower() if ch in chars]
            
    return ''.join(result)
#@nonl
#@-node:ekr.20051022044950:computeOldStyleShortcutKey
#@+node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
def createOpenWithMenuItemsFromTable (self,menu,table):
    
    '''Create an entry in the Open with Menu from the table.
    
    Each entry should be a sequence with 2 or 3 elements.'''

    if g.app.unitTesting: return

    for data in table:
        << get label, accelerator & command or continue >>
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&")
        realLabel = realLabel.replace("&","")
        callback = self.defineOpenWithMenuCallback(openWithData)
    
        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
#@+node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        junk,accelerator = self.canonicalizeShortcut(accelerator)
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
#@nonl
#@-node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
#@-node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
#@+node:ekr.20031218072017.4117:defineMenuCallback
def defineMenuCallback(self,command,name):
    
    # The first parameter must be event, and it must default to None.
    def menuCallback(event=None,self=self,command=command,label=name):
        __pychecker__ = '--no-argsused' # event not used, and must be present.
        return self.c.doCommand(command,label)

    return menuCallback
#@nonl
#@-node:ekr.20031218072017.4117:defineMenuCallback
#@+node:ekr.20031218072017.4118:defineOpenWithMenuCallback
def defineOpenWithMenuCallback(self,data):
    
    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event param must be present.
        return self.c.openWith(data=data)

    return openWithMenuCallback
#@nonl
#@-node:ekr.20031218072017.4118:defineOpenWithMenuCallback
#@+node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)
    
def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@nonl
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@-node:ekr.20051022053758.1:Helpers
#@-node:ekr.20031218072017.3781:Gui-independent menu routines
#@-node:ekr.20051022061226:(Refactored createMenuEntries)
#@+node:ekr.20051021143159.1:(Removed all key bindings from createMenuEntries)
@ This is an important simplification.

One not-so-horrible kludge remains. The cut/copy/paste commands in the menu
tables are not the same as the methods actually bound to cut/copy/paste-text
minibuffer commands, so we must do a bit of extra translation to discover
whether the user has overridden their bindings.

Important: this affect only the **appearance** of the menu, **not** any bindings!
#@nonl
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20051021143159.1:(Removed all key bindings from createMenuEntries)
#@+node:ekr.20051022083459:(Simplified the inverseBindingsDict)
@ Keys are now minibuffer command names, not function.__name__.

The confusing 'name' entry is now longer needed in k.bindingsDict. This
simplifies the calls to k.bindKey.

As a result, the print-commands and print-bindings commands no longer need a
helper function.
#@nonl
#@+node:ekr.20051018070524:computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        b = k.bindingsDict.get(shortcut)
        d [b.commandName] = shortcut

    return d
#@nonl
#@-node:ekr.20051018070524:computeInverseBindingDict
#@+node:ekr.20051017212452:computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion')

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcut = inverseBindingDict.get(commandName,'')
            g.es('%s %s' % (commandName,shortcut),tabName='Completion')

    k.forceFocusToBody()
#@nonl
#@-node:ekr.20051017212452:computeCompletionList
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        b = k.bindingsDict.get(key)
        g.es('[%s]' % b.pane,key,b.commandName or b.name,tabName='Command')
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051014061332:printCommands
def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c
    
    c.frame.log.clearTab('Command')
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    for commandName in commandNames:
        shortcut = inverseBindingDict.get(commandName,'')
        g.es('%s %s' % (commandName,shortcut),tabName='Command')
#@nonl
#@-node:ekr.20051014061332:printCommands
#@-node:ekr.20051022083459:(Simplified the inverseBindingsDict)
#@+node:ekr.20051020074023:Created show-fonts & show-colors commands
#@-node:ekr.20051020074023:Created show-fonts & show-colors commands
#@+node:ekr.20051017111039:Fixed minor bug in k.doTabCompletion
@nocolor

Set the tab-list index to-1 if we first print a common prefix.  That way item returned next will be item 0.
#@nonl
#@-node:ekr.20051017111039:Fixed minor bug in k.doTabCompletion
#@+node:ekr.20051017053631:Improved the scripting plugin
@nocolor

The scripting plugin now has support for the following kinds of headlines:

@button name @key=shortcut

This binds the shortcut to the script in the script button.  The button's name is 'name', but you can see the full headline in the status line when you move the mouse over the button.  This is a clean and simple way of discovering the shortcut.

@command name

This creates a new minibuffer command whose name is 'name'.

@command name @key=shortcut

This creates a new minibuffer command and binds shortcut to it.

The scripting plugin no longer contains the 'bindLate' code-level option.  The scripts for all @button or @command nodes are computed 'dynamically', that is, when the button is pushed or the command is executed from the minibuffer.  This is the most useful way, and the most intuitive.

Previously, scripts for @button nodes were never dynamic, while scripts in @button nodes created by the 'Script button' button were dynamic only if bindLate was True.  You could call this a bug: it was unhelpful, annoying and confusing.
#@-node:ekr.20051017053631:Improved the scripting plugin
#@+node:ekr.20051016162459:k.registerShortcut now makes sure to set k.inverseCommandsDict
# k.finishCreate sets k.inverseCommandsDict, but k.registerShortcut can be called after that.
#@nonl
#@-node:ekr.20051016162459:k.registerShortcut now makes sure to set k.inverseCommandsDict
#@+node:ekr.20051013103457:(Per-pane bindings)
#@+node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20050920085536.11:add_ekr_altx_commands
def add_ekr_altx_commands (self):

    << define dict d of abbreviations >>

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            
#@nonl
#@+node:ekr.20050920085536.12:<< define dict d of abbreviations >>
d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}
#@nonl
#@-node:ekr.20050920085536.12:<< define dict d of abbreviations >>
#@-node:ekr.20050920085536.11:add_ekr_altx_commands
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c
    
    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return

    try:
        << bind callback to shortcut in pane >>

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            # g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20051022094136:<< bind callback to shortcut in pane >>
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

# Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the <Key>+ binding.

allPanes = [body,log,tree,menu,minibuffer]

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or 'all').lower(),[])

if shortcut == '<Key>':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:<< bind callback to shortcut in pane >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051008135051.1:bindOpenWith
def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')
#@nonl
#@-node:ekr.20051008135051.1:bindOpenWith
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20051023182326:copyBindingsToWidget
def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    
    panes = list(paneOrPanes)
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in panes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('find tab',shortcut,commandName)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                event.widget = widget
                # g.trace(commandName,widget)
                func(event)

            widget.bind(shortcut,textBindingsRedirectionCallback)
#@nonl
#@-node:ekr.20051023182326:copyBindingsToWidget
#@+node:ekr.20051007080058:makeAllBindings
def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.checkBindings()
#@nonl
#@-node:ekr.20051007080058:makeAllBindings
#@+node:ekr.20050923174229.1:makeHardBindings
def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '<Alt-c>': c.editCommands.changePreviousWord,
        '<Alt-u>': c.editCommands.changePreviousWord,
        '<Alt-l>': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '<Control-s>':      (2, c.searchCommands.startIncremental),
        '<Control-r>':      (2, c.searchCommands.startIncremental),
        '<Alt-g>':          (1, c.editCommands.gotoLine),
        '<Alt-z>':          (1, c.killBufferCommands.zapToCharacter),
        '<Alt-percent>':    (1, c.queryReplaceCommands.queryReplace),
        '<Control-Alt-w>':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '<Control-t>':  c.editCommands.transposeLines,
        '<Control-u>':  c.editCommands.upCaseRegion,
        '<Control-l>':  c.editCommands.downCaseRegion,
        '<Control-o>':  c.editCommands.removeBlankLines,
        '<Control-i>':  c.editFileCommands.insertFile,
        '<Control-s>':  c.editFileCommands.saveFile,
        '<Control-x>':  c.editCommands.exchangePointMark,
        '<Control-c>':  c.controlCommands.shutdown,
        '<Control-b>':  c.bufferCommands.listBuffers,
        '<Control-Shift-at>': lambda event: event.widget.selection_clear(),
        '<Delete>':     c.killBufferCommands.backwardKillSentence,
    }
#@nonl
#@-node:ekr.20050923174229.1:makeHardBindings
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunch = c.config.getShortcut(commandName)
        accel = (bunch and bunch.val) or stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        # g.trace(stroke,accel,shortcut,func.__name__)
        if pane == 'mini' and func != k.keyboardQuit:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
        else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)

            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)

            k.bindKey(pane,shortcut,keyCallback,commandName)

        if ivar:
            setattr(k,ivar,shortcut)
        
    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@+node:ekr.20051008134059:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunch = c.config.getShortcut(commandName)
        accel = bunch and bunch.val
        if accel:
            bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
            k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
        
        if 0:
            if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
            else:     g.trace(commandName)
#@nonl
#@-node:ekr.20051008134059:makeBindingsFromCommandsDict
#@-node:ekr.20051006125633:Binding (keyHandler)
#@-node:ekr.20051013103457:(Per-pane bindings)
#@clone 2
#@+node:ekr.20051017184201:(Tabbed log pane)
#@+node:ekr.20051017204206:Notes
@nocolor

We can't use nb.selectpage('Log') after writing the tab completion list,
but we want to restore the default page to 'Log'.

There are at least two approaches:

1. Create a method, say, setDefaultTab(), that causes *future* writes to go to the 'Log' tab but does *not* change the presently selected tab.

2. Add tabName='Log' as a keyword argument to g.es, g.enl, etc. and tkLog.put/putnl.

This is more explicit and easier to program, and does the same thing.  This is what I have done.  So by default, g.es does what it always has done, but it is easy to switch to other panes.
#@nonl
#@-node:ekr.20051017204206:Notes
#@+node:ekr.20051002152108.1:Shared helpers
#@+node:ekr.20051017212452:computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion')

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcut = inverseBindingDict.get(commandName,'')
            g.es('%s %s' % (commandName,shortcut),tabName='Completion')

    k.forceFocusToBody()
#@nonl
#@-node:ekr.20051017212452:computeCompletionList
#@+node:ekr.20051018070524:computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        b = k.bindingsDict.get(shortcut)
        d [b.commandName] = shortcut

    return d
#@nonl
#@-node:ekr.20051018070524:computeInverseBindingDict
#@+node:ekr.20050920085536.46:doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList):

    '''Cut back to previous prefix and update prefix.'''

    k = self

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):

        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)

    k.computeCompletionList(defaultCompletionList,backspace=True)
#@nonl
#@-node:ekr.20050920085536.46:doBackSpace
#@+node:ekr.20050920085536.44:doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        k.computeCompletionList(defaultTabList,backspace=False)
#@nonl
#@-node:ekr.20050920085536.44:doTabCompletion
#@+node:ekr.20051012092847:forceFocusToBody
def forceFocusToBody (self):
    
    k = self ; c = k.c
    
    # Later=False does not always work.
    c.frame.bodyWantsFocus(later=True)
#@nonl
#@-node:ekr.20051012092847:forceFocusToBody
#@+node:ekr.20051014170754.1:getShortcutForCommand/Name
def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.name == command.__name__:
                return key
    
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.name == command.__name__:
                return key
    
    return ''
#@nonl
#@-node:ekr.20051014170754.1:getShortcutForCommand/Name
#@+node:ekr.20051010063452:ultimateFuncName
def ultimateFuncName (self,func):
    
    '''Return func.__name__ unless it is 'leoCallback.
    In that case, return the name in k.leoCallbackDict.get(func).'''
    
    k = self
    
    if not func:
        return '<no function>'
        
    if func.__name__ != 'leoCallback':
        return func.__name__
        
    # Get the function wrapped by this particular leoCallback function.
    calledFunc = k.leoCallbackDict.get(func)
    if calledFunc:
        return 'leoCallback -> %s' % calledFunc.__name__ 
    else:
        return '<no leoCallback name>'
#@nonl
#@-node:ekr.20051010063452:ultimateFuncName
#@-node:ekr.20051002152108.1:Shared helpers
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others
#@nonl
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@nonl
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@nonl
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@nonl
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@nonl
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@nonl
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@nonl
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@nonl
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)
        
# g.trace(repr(self.logCtrl))

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    << bind a tab-specific pop-up menu to the tab >>
    << Create the tab's text widget >>
    self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('<Button-1>',tabMenuClickCallback)
tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("<Button-1>",self.onActivateLog)
textWidget.tag_config('black',foreground='black')
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        return

    if tabName in ('Find','Spell'):
        self.selectTab('Log')
        return
    
    if tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20051018061932.1:ower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    
def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        logCtrl = self.textDict.get(tabName)
        self.c.frame.widgetWantsFocus(logCtrl)
#@nonl
#@-node:ekr.20051018061932.1:ower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    textWidget = self.textDict.get(tabName)

    if k and textWidget:

        k.copyBindingsToWidget(['all','log','text'],textWidget)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):

    menu.post(event.x_root,event.y_root)
    
def onClick (self,event,tabName):
    
    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    parentFrame = self.frameDict.get(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (oldName,newName):
        self.selectTab(newName)

    self.getTabName(parentFrame,'',selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        parentFrame = self.frameDict.get(tabName)
        self.getTabName(parentFrame,tabName,self.renameTab)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,parentFrame,tabName,exitCallback):

    f = Tk.Frame(parentFrame)
    f.pack(side='bottom',fill='x',expand=1)

    Tk.Label(f,text='Tab name').pack(side='left')

    e = Tk.Entry(f,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(tabName,s)
    
    if 0:
        b = Tk.Button(row,text="Close",command=getNameCallback)
        b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@-node:ekr.20051017184201:(Tabbed log pane)
#@+node:ekr.20051022152427:(Focus commands, etc.)
#@+node:ekr.20051022142249:focus (editCommandsClass)
#@+node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.body.bodyCtrl,later=True)

def focusToLog (self,event):
    self.c.frame.logWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.log.logCtrl,later=True)
    
def focusToMinibuffer (self,event):
    self.c.frame.minibufferWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.log.logCtrl,later=True)

def focusToTree (self,event):
    self.c.frame.treeWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.tree.canvas,later=True)
#@nonl
#@-node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane,later=True)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@-node:ekr.20051022142249:focus (editCommandsClass)
#@+node:ekr.20051022132934:Click event handlers (tkTree)
#@+node:ekr.20040803072955.20:tkTree.createPermanentBindings
def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('<Button-1>',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','<Button-1>', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','<Button-1>',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','<Button-1>', self.onIconBoxClick)
    canvas.tag_bind('iconBox','<Double-1>', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','<Button-3>', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','<B1-Motion>',            self.onDrag)
    canvas.tag_bind('iconBox','<Any-ButtonRelease-1>',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("<Button-1>", self.onHeadlineClick, '+')
        t.bind("<Button-3>", self.onHeadlineRightClick, '+')
        t.bind("<Key>",      self.onHeadlineKey)
            # There must be only one general key handler.

        if 0: # This does not appear necessary in 4.4.
            t.bind("<Control-t>",self.onControlT)
#@nonl
#@-node:ekr.20040803072955.20:tkTree.createPermanentBindings
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4003:Focus (tkBody)
def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.bodyCtrl.focus_set()
#@nonl
#@-node:ekr.20031218072017.4003:Focus (tkBody)
#@+node:ekr.20040803072955.108:tree.OnDeactivate (caused double-click problem)
def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        except:
            g.es_event_exception("deactivate tree")
#@-node:ekr.20040803072955.108:tree.OnDeactivate (caused double-click problem)
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20051022141020:onTreeClick
def onTreeClick (self,event=None):
    
    self.frame.treeWantsFocus()
    
    return 'break'
#@-node:ekr.20051022141020:onTreeClick
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(later=False)
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@-node:ekr.20051022132934:Click event handlers (tkTree)
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()
    
    # g.trace(p and p.headString())

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.126:endEditLabel
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p.edit_text."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)
    
    # g.trace(p,p.edit_text())

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)
        self.frame.headlineWantsFocus(p)
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    
    # g.trace(p.headString())

    if not p: return
    if not p.exists(c):
        g.trace(g.callerList(5),'does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setNormalLabelState
def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        
        # self.frame.headlineWantsFocus(p,later=False)
#@nonl
#@-node:ekr.20040803072955.135:setNormalLabelState
#@+node:ekr.20040803072955.136:setDisabledLabelState
def setDisabledLabelState (self,p): # selected, disabled

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return

    if p and p.edit_text():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setDisabledLabelState
#@+node:ekr.20040803072955.137:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, not editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    # g.trace(p)
    self.setDisabledLabelState(p)

#@-node:ekr.20040803072955.137:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    if p and p.edit_text():
        # g.trace(p.headString())
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag
#@nonl
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@-node:ekr.20051022152427:(Focus commands, etc.)
#@+node:ekr.20051023130656:(Use a Tk.Text widget for the minibuffer)
#@+node:ekr.20051023135812:What I did
@nocolor

- Made the minibuffer a Tk.Text widget rather than a Tk.Label.
- Put the focus in the minibuffer when it is active.
- Created a 'text' pane specification for common editing bindings.
  To do:  copy these text bindings whenever a Text widget is created.
#@nonl
#@-node:ekr.20051023135812:What I did
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label
#@nonl
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)
    
# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050924064254:Label...
@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.
#@nonl
#@+node:ekr.20051023132350:getLabel
def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        if s.endswith('\n') or s.endswith('\r'): s = s[:-1]
        # g.trace(repr(s))
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

#@-node:ekr.20051023132350:getLabel
#@+node:ekr.20051023132350.2:protectLabel
def protectLabel (self):
    
    k = self ; w = self.widget

    if self.useTextWidget:
        if w:
            w.update_idletasks()
            k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()


#@-node:ekr.20051023132350.2:protectLabel
#@+node:ekr.20050920085536.37:resetLabel
def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''
#@nonl
#@-node:ekr.20050920085536.37:resetLabel
#@+node:ekr.20051023132350.1:setLabel
def setLabel (self,s,protect=False):

    k = self ; w = self.widget

    # g.trace(repr(s))

    if self.useTextWidget:
        if w:
            k.c.frame.minibufferWantsFocus(later=False)
            w.update_idletasks()
            w.delete('1.0','end') ; w.insert('1.0',s)
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s
#@nonl
#@-node:ekr.20051023132350.1:setLabel
#@+node:ekr.20050920085536.36:setLabelBlue
def setLabelBlue (self,label=None,protect=False):
    
    k = self

    k.widget.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@nonl
#@-node:ekr.20050920085536.36:setLabelBlue
#@+node:ekr.20050920085536.35:setLabelGrey
def setLabelGrey (self,label=None):

    k = self
    k.widget.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)
        
setLabelGray = setLabelGrey
#@nonl
#@-node:ekr.20050920085536.35:setLabelGrey
#@+node:ekr.20050920085536.38:updateLabel
def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; s = k.getLabel()
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    
    # g.trace(repr(s),ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) <= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        s = s + ch # Add the character.
    
    k.setLabel(s)
#@nonl
#@-node:ekr.20050920085536.38:updateLabel
#@-node:ekr.20050924064254:Label...
#@-node:ekr.20051023130656:(Use a Tk.Text widget for the minibuffer)
#@+node:ekr.20051024053428:(Special bindings for minibuffer)
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunch = c.config.getShortcut(commandName)
        accel = (bunch and bunch.val) or stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        # g.trace(stroke,accel,shortcut,func.__name__)
        if pane == 'mini' and func != k.keyboardQuit:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
        else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)

            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)

            k.bindKey(pane,shortcut,keyCallback,commandName)

        if ivar:
            setattr(k,ivar,shortcut)
        
    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc(fromMinibuffer=True)
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.frame.minibufferWantsFocus(later=True)
        # g.trace('new prefix',k.mb_tabListPrefix)
    if keysym != 'Return':
        c.frame.minibufferWantsFocus(later=True)
    return 'break'
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@-node:ekr.20051024053428:(Special bindings for minibuffer)
#@+node:ekr.20051023175530:Improved the minibuffer
@nocolor

- Support 'text' and 'mini' pane selectors.
    - 'mini' is used only in k.makeSpecialBindings to bind ctrl-g inside the minibuffer.

- Every very Tk.Text widget is given a 'name' when it is created.
    - w._name is the name created by the 'name' option.

- minibufferWantsFocus *does* work.
    - The 'raw' ctrl keys were confusing k.fullCommand.
      k.masterCommand now doesn't pass those keys along.

- Eliminated the weird call to bodyWantsFocus in k.masterCommand.
#@nonl
#@-node:ekr.20051023175530:Improved the minibuffer
#@+node:ekr.20051024101355:(Copy bindings to headlines)
@nocolor

- Removed the Ctrl-T hack.  It does not appear to be needed.

- Created Ctrl-Shift-V shortcut for show-invisibles.

- (done) Created c.frame.headlineWantsFocus

- (done) Fixed problems with multiple calls to newHeadline.

- (done) copyBindingsToWidget can take either a single pane name or a list of pane names.

- (done) Copy both 'all' bindings and 'tree' bindings to headline.

- (done) Create separate names for all log panes.

- (done) Create names for find/change Text widgets.

@color
#@nonl
#@+node:ekr.20040803072955.20:tkTree.createPermanentBindings
def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('<Button-1>',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','<Button-1>', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','<Button-1>',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','<Button-1>', self.onIconBoxClick)
    canvas.tag_bind('iconBox','<Double-1>', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','<Button-3>', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','<B1-Motion>',            self.onDrag)
    canvas.tag_bind('iconBox','<Any-ButtonRelease-1>',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("<Button-1>", self.onHeadlineClick, '+')
        t.bind("<Button-3>", self.onHeadlineRightClick, '+')
        t.bind("<Key>",      self.onHeadlineKey)
            # There must be only one general key handler.

        if 0: # This does not appear necessary in 4.4.
            t.bind("<Control-t>",self.onControlT)
#@nonl
#@-node:ekr.20040803072955.20:tkTree.createPermanentBindings
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget('all',t)
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("<Control-t>",self.onControlT)

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
    t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
    t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("<Button-4>", PropagateButton4)
    t.bind("<Button-5>", PropagateButton5)
    t.bind("<MouseWheel>", PropagateMouseWheel)

#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@+node:ekr.20051024102724:tkTtree.setBindings
# New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas)
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
        # g.trace('tkTree,t.bind())
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()
#@nonl
#@-node:ekr.20051024102724:tkTtree.setBindings
#@-node:ekr.20051024101355:(Copy bindings to headlines)
#@+node:ekr.20051024112703:(Problems with key bindings in headlines)
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p) # Do this after before the redraw first.
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.editPosition(p) # Do this again after the redraw so p.edit_text() will succeed.
    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20051024152318:Focus
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,later=True):
    if self.body and self.body.bodyCtrl:
        self.set_focus(self.body.bodyCtrl,later=later)
        
def headlineWantsFocus(self,p,later=True):
    w = p and p.edit_text()
    if w:
        self.set_focus(w,later=later)
    
def logWantsFocus(self,later=True):
    if self.log and self.log.logCtrl:
        self.set_focus(self.log.logCtrl,later=later)

def minibufferWantsFocus(self,later=True):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus(later=later)
    else:
        if self.c.miniBufferWidget:
            self.set_focus(self.c.miniBufferWidget,later=later)

def treeWantsFocus(self,later=True):
    if self.tree and self.tree.canvas:
        self.set_focus(self.tree.canvas,later=later)
    
def widgetWantsFocus(self,widget,later=True):
    if widget:
        self.set_focus(widget,later=later)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWantFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callerList(5))

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callerList(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callerList(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20051024152318:Focus
#@+node:ekr.20051024152318.1:Bindings
#@+node:ekr.20040803072955.20:tkTree.createPermanentBindings
def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('<Button-1>',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','<Button-1>', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','<Button-1>',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','<Button-1>', self.onIconBoxClick)
    canvas.tag_bind('iconBox','<Double-1>', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','<Button-3>', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','<B1-Motion>',            self.onDrag)
    canvas.tag_bind('iconBox','<Any-ButtonRelease-1>',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("<Button-1>", self.onHeadlineClick, '+')
        t.bind("<Button-3>", self.onHeadlineRightClick, '+')
        t.bind("<Key>",      self.onHeadlineKey)
            # There must be only one general key handler.

        if 0: # This does not appear necessary in 4.4.
            t.bind("<Control-t>",self.onControlT)
#@nonl
#@-node:ekr.20040803072955.20:tkTree.createPermanentBindings
#@+node:ekr.20051023182326:copyBindingsToWidget
def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    
    panes = list(paneOrPanes)
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in panes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('find tab',shortcut,commandName)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                event.widget = widget
                # g.trace(commandName,widget)
                func(event)

            widget.bind(shortcut,textBindingsRedirectionCallback)
#@nonl
#@-node:ekr.20051023182326:copyBindingsToWidget
#@+node:ekr.20051024102724:tkTtree.setBindings
# New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas)
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
        # g.trace('tkTree,t.bind())
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()
#@nonl
#@-node:ekr.20051024102724:tkTtree.setBindings
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget('all',t)
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("<Control-t>",self.onControlT)

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
    t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
    t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("<Button-4>", PropagateButton4)
    t.bind("<Button-5>", PropagateButton5)
    t.bind("<MouseWheel>", PropagateMouseWheel)

#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20051024152318.1:Bindings
#@+node:ekr.20051024152318.2:Event handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    """Handle a key event in a headline."""
    
    w = event.widget ; ch = event.char
    
    g.trace(repr(ch))

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('error *****')
        return "continue"

    return self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)
#@nonl
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    head = g.toUnicode(p.headString() or u'',"utf-8")
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        << update p >>
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head)
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

g.trace(repr(s),g.callerList(5))

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
try: # In update...
    # Update changed bit.
    if not c.changed: c.setChanged(True)
    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s)
    edit_text.mark_set("insert",index)
finally:
    c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20051024152318.2:Event handlers
#@+node:ekr.20051024145643:Label state
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
#@nonl
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20040803072955.76:findEditWidget
# Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None
#@nonl
#@-node:ekr.20040803072955.76:findEditWidget
#@+node:ekr.20031218072017.2991:c.editVnode (calls tree.editLabel)
# Selects v: sets the focus to p and edits p.

def editPosition(self,p):

    c = self

    if p:
        c.selectVnode(p)
        c.frame.tree.editLabel(p)
#@nonl
#@-node:ekr.20031218072017.2991:c.editVnode (calls tree.editLabel)
#@+node:ekr.20040803072955.75:edit_text
def edit_text (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
#@nonl
#@-node:ekr.20040803072955.75:edit_text
#@+node:ekr.20040803072955.135:setNormalLabelState
def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        
        # self.frame.headlineWantsFocus(p,later=False)
#@nonl
#@-node:ekr.20040803072955.135:setNormalLabelState
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p.edit_text."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)
    
    # g.trace(p,p.edit_text())

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)
        self.frame.headlineWantsFocus(p)
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()
    
    # g.trace(p and p.headString())

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.126:endEditLabel
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@-node:ekr.20051024145643:Label state
#@-node:ekr.20051024112703:(Problems with key bindings in headlines)
#@+node:ekr.20051011071542.1:(Cut/Copy/Paste bindings)
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.delete),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        << set amp_index using rawKey and realLabel >>
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    << compute emacs_name >>
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
if rawKey:
    amp_index = rawKey.find("&")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&")
#@nonl
#@-node:ekr.20031218072017.1728:<< set amp_index using rawKey and realLabel >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    # These two branches used to be different, an might be so again.
    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    elif fromMinibuffer:
        pass
    else:
        # Old: Do **not** call w.event_generate.
        # New: Do call w.event_generate.
        w.event_generate(g.virtual_event_name("Copy"))
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Old: Do **not** call w.event_generate.
        # New: Do call w.event_generate.
        w.event_generate(g.virtual_event_name("Cut"))
        if not fromMinibuffer:
            f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    elif fromMinibuffer:
        pass
    else:
        # Do **not** call w.event_generate for headlines.
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@+node:ekr.20051011072903.1:OnCopyFromMenu
def OnCopyFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    else:
        # Necessary when not using shortcut keys.
        w.event_generate(g.virtual_event_name("Copy"))
#@nonl
#@-node:ekr.20051011072903.1:OnCopyFromMenu
#@+node:ekr.20051011072049.1:OnCutFromMenu
def OnCutFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Necessary
        w.event_generate(g.virtual_event_name("Cut"))
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072049.1:OnCutFromMenu
#@+node:ekr.20051011072903.4:OnPasteFromMenu
def OnPasteFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    w = self.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    else:
        w.event_generate(g.virtual_event_name("Paste"))
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072903.4:OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20051011071542.1:(Cut/Copy/Paste bindings)
#@+node:ekr.20051025110549:(Keep the focus in the body)
# minibufferWantsFocus is now the same as bodyWantsFocus.
#@nonl
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = True
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,later=True):
    if self.body and self.body.bodyCtrl:
        self.set_focus(self.body.bodyCtrl,later=later)
        
def headlineWantsFocus(self,p,later=True):
    w = p and p.edit_text()
    if w:
        self.set_focus(w,later=later)
    
def logWantsFocus(self,later=True):
    if self.log and self.log.logCtrl:
        self.set_focus(self.log.logCtrl,later=later)

def minibufferWantsFocus(self,later=True):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus(later=later)
    else:
        if self.c.miniBufferWidget:
            self.set_focus(self.c.miniBufferWidget,later=later)

def treeWantsFocus(self,later=True):
    if self.tree and self.tree.canvas:
        self.set_focus(self.tree.canvas,later=later)
    
def widgetWantsFocus(self,widget,later=True):
    if widget:
        self.set_focus(widget,later=later)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWantFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callerList(5))

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callerList(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callerList(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@-node:ekr.20051025110549:(Keep the focus in the body)
#@+node:ekr.20051025161103:(Fixed settingsTree)
# Just had to call setBindings in the ctor.
#@nonl
#@+node:ekr.20041225063637.79:ctor (settingsTree)
def __init__(self,c,frame,canvas,controller):
    
    # Init the base class.
    leoTkinterTree.leoTkinterTree.__init__(self,c,frame,canvas)
    
    self.controller = controller
    self.old_p = None
    self.setBindings() # New in 4.4
#@nonl
#@-node:ekr.20041225063637.79:ctor (settingsTree)
#@-node:ekr.20051025161103:(Fixed settingsTree)
#@+node:ekr.20051025150540:(Test focus at idle time)
@

Force focus to body at idle time if it isn't a known pane, the outer pane or a dialog.

This works, but I don't like it: it is fragile. I also dislike doing anything at idle time.
#@nonl
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 1: # I wish there were an easier way...
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20051025150224:onIdleTime
def onIdleTime (self):
    
    '''Set the focus to the body pane if the focus is in limbo.
    
    We must allow dialogs and the outer window frame to retain focus.'''
    
    k = self ; c = k.c
    if g.app.quitting: return # Essential.
    
    w = g.app.gui.get_focus(c.frame)
    if w:
        # Allow clicks in enclosing window frame or in dialogs.
        name = w._name
        ok = (
            name[0] in string.letters # A known Leo frame.
            or w == c.frame.top # The top of the Leo window
            or g.app.dialogs > 0) # A dialog.
        if not ok:
            # Not a name created by Leo.
             g.trace(self.idleCount,name,g.top())
             c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20051025150224:onIdleTime
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    top = g.top() # Important: only fire k.onIdleTime for the top window.
    for w in g.app.windowList:
        c = w.c
        # New in 4.2 Beta 3. Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        # New in 4.4 a2: direct support for k.onIdleTime()
        c and c.keyHandler and c == top and c.keyHandler.onIdleTime()
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@-node:ekr.20051025150540:(Test focus at idle time)
#@+node:ekr.20051025162409:(Fix warnings in compare dialog)
#@+node:ekr.20051026070250:Notes
@nocolor

1. Warning: ignoring path:compare_file_1 not string
There may be conflicting settings!

Etc.

This warning is given by config.get.

I changed @path to @string in leoConfig.txt.

2. The dialog does not always come to the front.

Actually, the warnig message go to the Log, which forces the dialog to the back.
Yet another reason to get rid of dialogs!
#@nonl
#@-node:ekr.20051026070250:Notes
#@+node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
# Initialize ivars from config parameters.

def finishCreate (self):
    
    c = self.c
    
    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):
            
        name = c.config.getString(option)
        if name and len(name) > 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)
            
    name = c.config.getString("output_file")
    b = g.choose(name and len(name) > 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)
    
    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)
    
    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) > 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        e.delete(0,"end")
        e.insert(0,ext)
        
    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)
    
    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)
    
    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)
    
    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)
    
    n = c.config.getInt("limit_count")
    b = n and n > 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.delete(0,"end")
        e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)
    
    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)
        
        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)
        
        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)
#@nonl
#@-node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
#@-node:ekr.20051025162409:(Fix warnings in compare dialog)
#@-node:ekr.20051016115757.1:4.4a2 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
