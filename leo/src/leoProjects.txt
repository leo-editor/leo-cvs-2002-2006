#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            << Do auto indent >>
        elif ch == '\t' and tab_width < 0:
            << convert tab to blanks >>
        elif ch in (chr(8)) and tab_width < 0:
            << handle backspace with negative tab_width >>
    << set s to widget text, removing trailing newlines if necessary >>
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (called from core)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (called from core)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char 
    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    # g.trace(repr(ch))

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # g.trace(p)
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)

#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20031218072017.1332:headline key handlers (tree)
@ The <Key> event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1333:onHeadChanged
def onHeadChanged (self,p):
    
    """Handle a change to headline text."""
    
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)

#@-node:ekr.20031218072017.1333:onHeadChanged
#@+node:ekr.20031218072017.1334:OnHeadlineKey
def OnHeadlineKey (self,p,event):
    
    """Handle a key event in a headline."""

    ch = event.char
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)


#@-node:ekr.20031218072017.1334:OnHeadlineKey
#@+node:ekr.20031218072017.1335:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; v = p.v

    if not p or not p.edit_text() or p != c.currentPosition():
        return "break"
        
    edit_text = p.edit_text()
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        << update v and all nodes joined to v >>
    if done or changed:
        << reconfigure v and all nodes joined to v >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1337:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20031218072017.1337:<< set head to vnode text >>
#@+node:EKR.20040614075003:<< set the widget text to head >>
edit_text.delete("1.0","end")
edit_text.insert("end",head)
edit_text.mark_set("insert",index)
#@nonl
#@-node:EKR.20040614075003:<< set the widget text to head >>
#@+node:ekr.20031218072017.1336:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) > 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20031218072017.1336:<< set s to the widget text >>
#@+node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    if not p.isDirty():
        p.setDirty()
    # Update v.
    v.initHeadString(s)
    edit_text.delete("1.0","end")
    edit_text.insert("end",s)
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
#@+node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))
#@nonl
#@-node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20031218072017.1340:<< update the screen >>
if done:
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # Update v immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20031218072017.1340:<< update the screen >>
#@-node:ekr.20031218072017.1335:idle_head_key
#@-node:ekr.20031218072017.1332:headline key handlers (tree)
#@-node:ekr.20031218072017.1319:(Key handlers)
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20031218072017.1342:atFile.scanAllDirectives (calls writeError on errors)
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	<< Set ivars >>
	<< Set path from @file node >>
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		<< Test for @path >>
		<< Test for @encoding >>
		<< Test for @comment and @language >>
		<< Test for @header and @noheader >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @tabwidth >>
		old.update(dict)
		v = v.parent()
	<< Set current directory >>
	<< Set comment Strings from delims >>
#@nonl
#@+node:ekr.20031218072017.1343:<< Set ivars >>
self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app().config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1343:<< Set ivars >>
#@+node:ekr.20031218072017.1344:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) > 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
#@-node:ekr.20031218072017.1344:<< Set path from @file node >>
#@+node:ekr.20031218072017.1345:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1345:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1346:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@nonl
#@-node:ekr.20031218072017.1346:<< Test for @encoding >>
#@+node:ekr.20031218072017.1347:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.1347:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1348:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.1348:<< Test for @lineending >>
#@+node:ekr.20031218072017.1349:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			<< handle absolute path >>
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.1350:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1350:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.1351:<< handle absolute path >>
# path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.1351:<< handle absolute path >>
#@-node:ekr.20031218072017.1349:<< Test for @path >>
#@+node:ekr.20031218072017.1352:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=True)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1352:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1353:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=True)
	if w and w != 0:
		self.tab_width = w

#@-node:ekr.20031218072017.1353:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1354:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""
#@nonl
#@-node:ekr.20031218072017.1354:<< Set current directory >>
#@+node:ekr.20031218072017.1355:<< Set comment Strings from delims >>
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""
#@nonl
#@-node:ekr.20031218072017.1355:<< Set comment Strings from delims >>
#@-node:ekr.20031218072017.1342:atFile.scanAllDirectives (calls writeError on errors)
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline()
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = g.app.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        dict = g.get_directives_dict(s)
        # g.trace("dict:",dict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(dict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif dict.has_key("comment"):

    i = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif dict.has_key("language"):

    i = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,dict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if dict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(dir) > 0:
        base = g.getBaseDirectory() # May return "".
        if dir and len(dir) > 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + dir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

dir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    dir = g.os_path_join(g.app.loadDir,dir)

# g.trace("dir: " + dir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(dir):
    self.tangle_directory = dir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(dir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + dir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and dict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and dict.has_key("root"):

    i = dict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and dict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif dict.has_key("header") and dict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif dict.has_key("header"):
    self.use_header_flag = True

elif dict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory() # May return "".

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,dir:",base,dir
            dir = g.os_path_join(base,dir2)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(dir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = dir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(dir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + dir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if dict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    language = c.target_language
    self.language = language # 2/2/03
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
    k = dict["comment"]
    self.comment_string = s[k:]

if dict.has_key("language"):
    i = dict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language # 2/2/03

if dict.has_key("comment") or dict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if dict.has_key("root") and not self.rootMode:

    k = dict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = g.app.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set dict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set dict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return dict
#@nonl
#@+node:ekr.20031218072017.1261:<< set dict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set dict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (lineending = None):
    
    """Convert the name of a line ending to the line ending itself.
    Use the output_newline configuration option if no lineending is given.
    """
    
    if lineending:
        s = lineending
    else:
        s = app.config.output_newline

    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,dict):
    
    """Scan the @encoding directive at s[dict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = dict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,dict):
    
    """Scan the @lineending directive at s[dict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = dict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[dict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,dict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[dict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = dict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20031218072017.984:Unfinished projects
#@+node:ekr.20031218072017.985:(Button class)
@ignore
@color
#@nonl
#@+node:ekr.20031218072017.986:Notes to Edward
@nocolor

I have a base window class that I use for all my TK stuff which handles, especially, focus issues between windows.  I have not looked at ButtonQ to see to what extent it depends upon WindowQ, the base class.

Anyway, this might be usefull as-is.  If not, let me know.
#@nonl
#@-node:ekr.20031218072017.986:Notes to Edward
#@+node:ekr.20031218072017.987:@file ButtonQ.py
@ Setup a button so it is handled with a keyboard shortcut like MSWindows tools.  See if there is an ampersand in the string.  If so, we want to underline that character and make that character a hot key for this button.
@c

from Tkinter import *
from string import *

def ButtonQ (master, **kw):
	b = ButtonQ_ (master, kw)
	return b.button

class ButtonQ_ (Button):
@others

## test
"""
from tkMessageBox import *
def buttonqcommand ():
	showinfo ("Title", "Button was pushed")

root = Tk ()
frame = Frame (root)
b = ButtonQ (frame, text = "&Push Me", command = buttonqcommand)
b.grid ()
frame.grid (pady = 15)
"""
#@+node:ekr.20031218072017.988:__init__
def __init__(self, master, kw = {}):

	<< get inputs to this method >>
	<< see if there is an ampersand in the string. >>
	<< make the button with the correct text >>
	<< bind the button >>

	# make the button available to the caller
	self.button = b
#@nonl
#@+node:ekr.20031218072017.989:<< get inputs to this method >>
_master = master
_text = kw['text']
_command = kw['command']
#@-node:ekr.20031218072017.989:<< get inputs to this method >>
#@+node:ekr.20031218072017.990:<< see if there is an ampersand in the string. >>
length = len (_text)
index = 0
text3 = _text

# Show there is no hot key yet
IsHot = 0
HotKey = None

while index < length:
	if _text [index] == '&':
		<< handle an ampersand >>
	index = += 1
#@nonl
#@+node:ekr.20031218072017.991:<< handle an ampersand >>
# if the word ends in an ampersand, we ignore it, and there is no hot key
if index == length - 1:
	break

# we have found a good hot key.  Remove the ampersand.
text1 = _text [0 : index]
text2 = _text [(index + 1) : 10000]
text3 = text1 + text2
IsHot = 1
HotKey = _text [index + 1]
break
#@nonl
#@-node:ekr.20031218072017.991:<< handle an ampersand >>
#@-node:ekr.20031218072017.990:<< see if there is an ampersand in the string. >>
#@+node:ekr.20031218072017.992:<< make the button with the correct text >>
if IsHot:
	kw['text'] = text3
	kw['underline'] = index

b = Button (master, kw)
#@-node:ekr.20031218072017.992:<< make the button with the correct text >>
#@+node:ekr.20031218072017.993:<< bind the button >>
@ If there is a hot key, bind it to the window that owns the button.
Use the alt of both the lower case and upper case of the letter.
@c

if IsHot:
	HotKey = lower(HotKey)
	self.HotKey = HotKey
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)

	HotKey = upper(HotKey)
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)


#@-node:ekr.20031218072017.993:<< bind the button >>
#@-node:ekr.20031218072017.988:__init__
#@+node:ekr.20031218072017.994:callback
# The hot key has been hit.  Call the button's command.

def callback (self, event):

	self.button.invoke ()
#@-node:ekr.20031218072017.994:callback
#@-node:ekr.20031218072017.987:@file ButtonQ.py
#@-node:ekr.20031218072017.985:(Button class)
#@+node:ekr.20031218072017.995:(Incremental update of screen)
@ignore
@nocolor

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = True in tree.__init__.

To do:
	
- We might switch to a line-oriented scheme.
	- This might simplify the code and make the code more useful to users.
	- Conceivably this scheme might eliminate the need for the auto-scroll in the redraw code,
	and that might make a single-pass redraw scheme possible.

- The last line isn't always completely visible: this is clearly a bug.

@color
#@nonl
#@+node:ekr.20031218072017.996:From Frame class
#@+node:ekr.20031218072017.997:<< create the tree canvas >>
scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = canvas = Tk.Canvas(split2Pane1,name="canvas",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("<MouseWheel>", self.OnMouseWheel)
	
canvas['yscrollcommand'] = self.setCallback
treeBar['command']     = self.yviewCallback

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	canvas['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = canvas.xview 
	treeXBar.pack(side="bottom", fill="x")

canvas.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20031218072017.997:<< create the tree canvas >>
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20031218072017.996:From Frame class
#@+node:ekr.20031218072017.999:From Tree class
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        box_id = canvas.create_image(x,y+self.lineyoffset,image=image)
    
        id1 = canvas.tag_bind(box_id, "<1>", p.OnBoxClick)
        id2 = canvas.tag_bind(box_id, "<Double-1>", lambda x2: None)

        self.tagBindings.append((box_id,id1,"<1>"),)
        self.tagBindings.append((box_id,id2,"<Double-1>"),)
        
        return box_id
#@nonl
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    tree = self ; v = p.v # Make sure the bindings refer to the _present_ position.

    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=tree,p=p,v=v,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image,tag="iconBox")
        self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.
    
        id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
        id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
        id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
        
        # Remember the bindings so deleteBindings can delete them.
        self.tagBindings.append((id,id1,"<1>"),)
        self.tagBindings.append((id,id2,"<Double-1>"),)
        self.tagBindings.append((id,id3,"<3>"),)
    
    return 0,icon_width # dummy icon height,width
#@nonl
#@+node:EKR.20040602150338:<< compute x,y and iconVal >>

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:EKR.20040602150338:<< compute x,y and iconVal >>
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    """Draw horizontal line from vertical line to icon"""
    
    tree = self ; v = p.v
    
    data = g.doHook("draw-outline-node",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data
    
    # g.trace(p)
    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
        
    self.canvas.create_line(x,y+7+self.lineyoffset,
        x+box_width,y+7+self.lineyoffset,
        tag="lines",fill="gray50") # stipple="gray25")

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

    self.allocatedNodes += 1
    h,w = self.drawUserIcons(p,"beforeBox",x,y)
    xw = w # The extra indentation before the icon box.
    if p.hasChildren():
        box_id = self.drawBox(p,x+w,y)
    else:
        box_id = None

    w += box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
    h = max(h,h2) ; w += w2 ; xw += w2

    h2,w2 = self.drawIcon(p,x+w,y)
    h = max(h,h2) ; w += w2

    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
    h = max(h,h2) ; w += w2

    expand_x = x+w # save this for later.
    h2 = self.drawText(p,x+w,y,box_id)
    h = max(h,h2)
    w += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
    h = max(h,h2)
    
    self.drawClickFrame(p,y)

    return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

    self.allocatedNodes += 1

    if p.hasChildren():
        box_id = self.drawBox(p,x,y)
    w = box_width # Even if the box isn't drawn.

    h2,w2 = self.drawIcon(p,x+w,y)
    w += w2

    h = self.drawText(p,x+w,y)
    
    return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y,box_id=None):
    
    """draw text for v at nominal coordinates x,y."""

    tree = self ; c = self.c ; v = p.v
    h = self.line_height
    x += text_indent
    
    data = g.doHook("draw-outline-text-box",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data

    self.lastText = t = Tk.Text(self.canvas,
        font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

    # New in 4.2: entries are pairs (p,t) indexed by v.
    # Remember which text widget belongs to v.
    d = self.edit_text_dict
    val = d.get(v,[])
    val.append((p,t),)
    d[v] = val
    # g.trace("entry",d[p.v])

    # Remember the widget so deleteBindings can delete it.
    self.widgets.append(t) # Fixes a _huge_ memory leak.

    t.insert("end", v.headString())
    << configure the text depending on state >>

    if 1: # use bind here, else use bind_tag in drawTopTree.
        # Use vnode or postion callbacks.
        id1 = t.bind("<1>",p.OnHeadlineClick)
        id2 = t.bind("<3>",p.OnHeadlineRightClick)
        id3 = t.bind("<Key>", p.OnHeadlineKey)
        id4 = t.bind("<Control-t>",self.OnControlT)
            # 10/16/02: Stamp out the erroneous control-t binding.
        # Remember the bindings so deleteBindings can delete them.
        self.bindings.append((t,id1,"<1>"),)
        self.bindings.append((t,id2,"<3>"),)
        self.bindings.append((t,id3,"<Key>"),)
        self.bindings.append((t,id4,"<Control-t>"),)
    
    if 0: # I like underlining only when the cursor is outside the text widget.
        << highlight text widget on enter events >>
        
    id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t,tag="textBox")
    self.canvas.tag_lower(id)
    
    # This doesn't work: must call update_idletasks first, and that's hard here.
    # g.trace(t,t.winfo_height(),t.winfo_width())
    
    return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
    if p == self.editPosition():
        self.setNormalLabelState(p)
    else:
        self.setDisabledLabelState(p) # selected, disabled
else:
    self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@+node:ekr.20040709194954:<< highlight text widget on enter events >>
if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 1: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040709194954:<< highlight text widget on enter events >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; v = p.v
    yfirst = ylast = y
    if level==0: yfirst += 10
    w = 0
    
    # We must make copies for drawText and drawBox and drawIcon,
    # So making copies here actually reduces the total number of copies.
    ### This will change for incremental redraw.
    p = p.copy()
    
    data = g.doHook("draw-sub-outline",tree=tree,p=p,v=v,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        h,w = self.drawNode(p,x,y)
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
            x += w2 ; w += w2
        if hoistFlag: break
        else:         p = p.next()
    << draw vertical line >>
    return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
    x, yfirst-hline_y,
    x, ylast+hline_y-h,
    fill="gray50", # stipple="gray50"
    tag="lines")

# self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20031218072017.1011:Updating routines (tree)...
#@+node:ekr.20031218072017.1012:tree.redraw
# Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    # g.trace(self.updateCount,self.redrawScheduled)
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1012:tree.redraw
#@+node:ekr.20040106095546:tkTree.redrawAfterException
@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
    
    """Make sure drawing is enabled following an exception."""
        
    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
        self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.
#@nonl
#@-node:ekr.20040106095546:tkTree.redrawAfterException
#@+node:ekr.20031218072017.1013:force_redraw
# Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
    
    # g.trace(self.redrawScheduled)
    # import traceback ; traceback.print_stack()

    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1013:force_redraw
#@+node:ekr.20031218072017.1014:redraw_now
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # g.trace()
    
    # Bug fix: 4/24/04: cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.
    self.disableRedraw = True
    self.canvas.update_idletasks()
    self.disableRedraw = False
        
    # Now do the actual redraw.
    self.idle_redraw(scroll=scroll)
#@nonl
#@-node:ekr.20031218072017.1014:redraw_now
#@+node:ekr.20031218072017.1015:idle_redraw
def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    << return if disabled, or quitting or dragging >>

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=self.c):
        self.allocatedNodes = 0
        << Erase and redraw the entire tree >>
        if self.trace:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
    g.doHook("after-redraw-outline",c=self.c)

    self.canvas['cursor'] = oldcursor
    
    # g.collectGarbage()
    g.printGc()
    # import gc ; print len(gc.get_referents(frame))
    # g.printGcRefs(verbose=False)
    # g.trace("positions",g.app.positions)
#@+node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
#@-node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
#@+node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
# Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
    self.canvas.after_idle(self.idle_scrollTo)

#@-node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
#@-node:ekr.20031218072017.1015:idle_redraw
#@+node:ekr.20031218072017.1016:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
    
    g.trace()
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    self.deleteBindings()
    self.canvas.delete("all")
    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes
#@nonl
#@-node:ekr.20031218072017.1016:idle_second_redraw
#@-node:ekr.20031218072017.1011:Updating routines (tree)...
#@+node:ekr.20031218072017.1017:tree.__init__
def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas

    # Miscellaneous info.
    self.iconimages = {} # Image cache set by getIconImage().
    self.active = False # True if tree is active
    self._editPosition = None # returned by leoTree.editPosition()
    self.lineyoffset = 0 # y offset for this headline.
    self.disableRedraw = False # True: reschedule a redraw for later.
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    # Set self.font and self.fontName.
    self.setFontFromConfig()
    
    # Recycling bindings.
    self.bindings = [] # List of bindings to be unbound when redrawing.
    self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
    self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
    self.widgets = [] # Widgets that must be destroyed when redrawing.
    
    # Drag and drop
    self.drag_p = None
    self.controlDrag = False # True: control was down when drag started.
    self.drag_id = None # To reset bindings after drag
    
    # 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
    #                     behavior better on Linux
    # Context menu
    self.popupMenu = None
    
    # Incremental redraws:
    self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
    self.trace = False # True enabling of various traces.
    self.prevMoveToFrac = None
    self.visibleArea = None
    self.expandedVisibleArea = None
    
    self.allocatedNodes = 0 # A crucial statistic.
        # Incremental drawing allocates visible nodes at most twice.
        # Non-incremetal drawing allocates all visible nodes once.
        
    if self.allocateOnlyVisibleNodes:
        self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw)
    
    if not leoTkinterTree.callbacksInjected: # Class var.
        leoTkinterTree.callbacksInjected = True
        self.injectCallbacks()
#@nonl
#@-node:ekr.20031218072017.1017:tree.__init__
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that v is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition() # 4/8/04.
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=True):

    if not p: return
    
    << define vars and stop editing >>
    
    # g.trace(p)
    # g.printGc()

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    # g.trace("different node")
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
body.delete("1.0","end")
body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p)
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@-node:ekr.20031218072017.999:From Tree class
#@+node:ekr.20031218072017.1026:Used only for incremental redraws
#@+node:ekr.20031218072017.1027:allocateNodes
def allocateNodes(self,where,lines):
    
    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
    
    assert(where in ("above","below"))

    # print "allocateNodes: %d lines %s visible area" % (lines,where)
    
    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # print "expandedArea:   %5.1f %5.1f" % (y1,y2)
    
    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.c.rootPosition(),root_left,root_top,0,0)
    # if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
#@-node:ekr.20031218072017.1027:allocateNodes
#@+node:ekr.20031218072017.1028:allocateNodesBeforeScrolling
def allocateNodesBeforeScrolling (self, args):
    
    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # print "allocateNodesBeforeScrolling:",self.redrawCount,args

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = g.choose(n<frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = g.choose(n == 1,"below","above")
        lines = g.choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)
#@nonl
#@-node:ekr.20031218072017.1028:allocateNodesBeforeScrolling
#@+node:ekr.20031218072017.1029:setVisibleArea
def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # print "scroll ratios:",r1,r2

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return
        
    scroll_h = y2-y1
    # print "height of scrollregion:", scroll_h

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
#@-node:ekr.20031218072017.1029:setVisibleArea
#@+node:ekr.20031218072017.1030:setVisibleAreaToFullCanvas
def setVisibleAreaToFullCanvas(self):
    
    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2
#@nonl
#@-node:ekr.20031218072017.1030:setVisibleAreaToFullCanvas
#@+node:ekr.20031218072017.1031:tree.updateTree
def updateTree (self,v,x,y,h,level):

    yfirst = ylast = y
    if level==0: yfirst += 10
    while v:
        # g.trace(x,y,v)
        h = self.updateNode(v,x,y)
        y += h ; ylast = y
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
        v = v.next()
    return y
#@-node:ekr.20031218072017.1031:tree.updateTree
#@-node:ekr.20031218072017.1026:Used only for incremental redraws
#@-node:ekr.20031218072017.995:(Incremental update of screen)
#@+node:ekr.20031218072017.1032:(Syntax coloring a la jEdit) (do not delete)
@ To do:

- ** Use a general purpose XML parser to parse the jEdit mode files.
- ** Do incremental syntax coloring
	- Create lines table.
	- Initialize lines table when select new node.
- Use strings for states.
- Define colorizeLine method.
- Create self.state ivar
- Use a keyword lead-in table.
	- Use this for latex keywords and Leo keywords.
	- Add ignore-case ivar.
- Define @language xml.
- Defined syntax coloring for all jEdit token types:
	KEYWORD1,KEYWORD2,KEYWORD3,LABEL,LITERAL1,LITERAL2,MARKUP,OPERATOR
	Where do Leo keywords fit in?

#@+node:ekr.20031218072017.1033:Ideas for dynamic code
@ignore

@ The following gives the general idea.

The self.known_languages dict contains all the data structures for a particular language.  This dict is created dynamically.  Each entry is a tuple of other info:
	"c"      : (dict1,...,dictM,list1,...,listN,etc.),
	"python" : (dict1,...,dictM,list1,...,listN,etc.),
These tuples, i.e., all the data structures, are created by the initialization routine.

@c
data = self.known_languages.get(self.language)
if not data:
	# Create all the data structures for the language.
	data = parse_xml_file(self.language) 
	if data: self.known_languages[language] = data
if data:
	self.dict1,...,self.listN=data

# The subsidiary data structures will be created from the xml files.
# The exact data structures used depends on the format of the xml files.

self.reserved_words1 = {} # Main language keywords: reserved words.
self.reserved_words2 = {} # Functions etc. to be colored separately.
self.keyword_chars1 = {} # Characters that appear as the first character of a keyword.
self.keyword_chars2 = {} # Characters that appear as second or following characters of a keyword.
self.string_start1,self.string.start2 # Opening characters of strings.

# The code might scan for keywords as follows:
n = len(s)
if i < n and self.keywords1.get(s[i]):
	j = i ; i += 1
	while i < n and self.keywords2.get(s[i]):
		i += 1
	word = s[j:i]
	if self.reserved_words1.get(word):
		# colorize the reserved word
	elif self.reserved_words2.get(word):
		# colorize the reserved word
#@-node:ekr.20031218072017.1033:Ideas for dynamic code
#@+node:ekr.20031218072017.1034:New data structures
special_keywords_dict = {
	'\\' : (latex_keywords_dict,"keyword"),
	'@' :  (leo_keywords_dict,"leoKeword") }
	
if << ch is alphabetic >>:
	word = scan_c_word(s,i)
	kind = keywords_dict.get(word)
	if kind:
		<< colorize word using kind >>
else:
	data = special_keywords_dict.get(ch)
	if data:
		dict,kind = data
		word = scan_c_word(s,i+1)
		key = d.get(word)
		if key:
			<< colorize ch and word using kind >>
#@nonl
#@-node:ekr.20031218072017.1034:New data structures
#@+node:ekr.20031218072017.1049:jEdit docs
@nocolor

#@+node:ekr.20031218072017.1050:The Preamble and MODE tag
Each mode definition must begin with the following: 

<?xml version="1.0"?>
<!DOCTYPE MODE SYSTEM "xmode.dtd"> 

Each mode definition must also contain exactly one MODE tag. All other tags (PROPS, RULES) must be placed inside the MODE tag. The MODE tag does not have any defined attributes. Here is an example: 

<MODE>
    ... mode definition goes here ...
</MODE> 
#@-node:ekr.20031218072017.1050:The Preamble and MODE tag
#@+node:ekr.20031218072017.1051:The PROPS Tag (Leo could ignore these)
The PROPS tag and the PROPERTY tags inside it are used to define mode-specific properties. Each PROPERTY tag must have a NAME attribute set to the property's name, and a VALUE attribute with the property's value. 

All buffer-local properties listed in the section called "Buffer-Local Properties" may be given values in edit modes. In addition, the following mode properties have no buffer-local equivalent: 

commentEnd - the comment end string, used by the Range Comment command. 

commentStart - the comment start string, used by the Range Comment command. 

lineComment - the line comment string, used by the Line Comment command. 

doubleBracketIndent - If a line matches the indentPrevLine regular expression and the next line contains an opening bracket, a level of indent will not be added to the next line, unless this property is set to "True". For example, with this property set to "False", Java code will be indented like so: 

while(objects.hasMoreElements())
{
        ((Drawable)objects.nextElement()).draw();
} 

On the other hand, settings this property to "True" will give the following result: 

while(objects.hasMoreElements())
        {
                ((Drawable)objects.nextElement()).draw();
        } 

indentCloseBrackets - A list of characters (usually brackets) that subtract indent from the current line. For example, in Java mode this property is set to "}".

indentOpenBrackets - A list of characters (usually brackets) that add indent to the next line. For example, in Java mode this property is set to "{".

indentPrevLine - When indenting a line, jEdit checks if the previous line matches the regular expression stored in this property. If it does, a level of indent is added. For example, in Java mode this regular expression matches language constructs such as "if", "else", "while", etc.

Here is the complete <PROPS> tag for Java mode: 

<PROPS>
    <PROPERTY NAME="indentOpenBrackets" VALUE="{" />
    <PROPERTY NAME="indentCloseBrackets" VALUE="}" />
    <PROPERTY NAME="indentPrevLine" VALUE="\s*(((if|while)
        \s*\(|else|case|default)[^;]*|for\s*\(.*)" />
    <PROPERTY NAME="doubleBracketIndent" VALUE="false" />
    <PROPERTY NAME="commentStart" VALUE="/*" />
    <PROPERTY NAME="commentEnd" VALUE="*/" />
    <PROPERTY NAME="blockComment" VALUE="//" />
    <PROPERTY NAME="wordBreakChars" VALUE=",+-=<>/?^&*" />
</PROPS> 
#@-node:ekr.20031218072017.1051:The PROPS Tag (Leo could ignore these)
#@+node:ekr.20031218072017.1052:The RULES Tag
RULES tags must be placed inside the MODE tag. Each RULES tag defines a ruleset.

A ruleset consists of a number of parser rules, with each parser rule specifying how to highlight a specific syntax token. There must be at least one ruleset in each edit mode. There can also be more than one, with different rulesets being used to highlight different parts of a buffer (for example, in HTML mode, one rule set highlights HTML tags, and another highlights inline JavaScript). For information about using more than one ruleset, see the section called "The SPAN Rule". 

The RULES tag supports the following attributes, all of which are optional: 

SET - the name of this ruleset. All rulesets other than the first must have a name. 

HIGHLIGHT_DIGITS - if set to TRUE, digits (0-9, as well as hexadecimal literals prefixed with "0x") will be highlighted with the DIGIT token type. Default is FALSE. 

IGNORE_CASE - if set to FALSE, matches will be case sensitive. Otherwise, case will not matter. Default is TRUE. 

DEFAULT - the token type for text which doesn't match any specific rule. Default is NULL. See the section called "Token Types" for a list of token types. 

Here is an example RULES tag: 

<RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE">
    ... parser rules go here ...
</RULES> 

Rule Ordering Requirements

You might encounter this very common pitfall when writing your own modes. 

Since jEdit checks buffer text against parser rules in the order they appear in the ruleset, more specific rules must be placed before generalized ones, otherwise the generalized rules will catch everything. 

This is best demonstrated with an example. The following is incorrect rule ordering: 

<SPAN TYPE="MARKUP">
    <BEGIN>[</BEGIN>
    <END>]</END>
</SPAN>

<SPAN TYPE="KEYWORD1">
    <BEGIN>[!</BEGIN>
    <END>]</END>
</SPAN> 

If you write the above in a rule set, any occurrence of "[" (even things like "[!DEFINE", etc) will be highlighted using the first rule, because it will be the first to match. This is most likely not the intended behavior. 

The problem can be solved by placing the more specific rule before the general one: 

<SPAN TYPE="KEYWORD1">
    <BEGIN>[!</BEGIN>
    <END>]</END>
</SPAN>

<SPAN TYPE="MARKUP">
    <BEGIN>[</BEGIN>
    <END>]</END>
</SPAN> 

Now, if the buffer contains the text "[!SPECIAL]", the rules will be checked in order, and the first rule will be the first to match. However, if you write "[FOO]", it will be highlighted using the second rule, which is exactly what you would expect. 

Per-Ruleset Properties

The PROPS tag (described in the section called "The PROPS Tag") can also be placed inside the RULES tag to define ruleset-specific properties. Only the following properties can be set on a per-ruleset basis: 

commentEnd - the comment end string. 

commentStart - the comment start string. 

lineComment - the line comment string. 

These properties are used by the commenting commands to implement context-sensitive comments; see the section called "Commenting Out Code". 

The TERMINATE Rule

The TERMINATE rule specifies that parsing should stop after the specified number of characters have been read from a line. The number of characters to terminate after should be specified with the AT_CHAR attribute. Here is an example: 

<TERMINATE AT_CHAR="1" /> 

This rule is used in Patch mode, for example, because only the first character of each line affects highlighting. 

The SPAN Rule

The SPAN rule highlights text between a start and end string. The start and end strings are specified inside child elements of the SPAN tag. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be highlighted, only the text between them will

NO_LINE_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it spans more than one line

NO_WORD_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it includes whitespace

DELEGATE - text inside the span will be highlighted with the specified ruleset. To delegate to a ruleset defined in the current mode, just specify its name. To delegate to a ruleset defined in another mode, specify a name of the form mode::ruleset. Note that the first (unnamed) ruleset in a mode is called "MAIN".

Here is a SPAN that highlights Java string literals, which cannot include line breaks: 

<SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE">
   <BEGIN>"</BEGIN>
   <END>"</END>
</SPAN> 

Here is a SPAN that highlights Java documentation comments by delegating to the "JAVADOC" ruleset defined elsewhere in the current mode: 

<SPAN TYPE="COMMENT2" DELEGATE="JAVADOC">
   <BEGIN>/**</BEGIN>
   <END>*/</END>
</SPAN> 

Here is a SPAN that highlights HTML cascading stylesheets inside <STYLE> tags by delegating to the main ruleset in the CSS edit mode: 

<SPAN TYPE="MARKUP" DELEGATE="css::MAIN">
   <BEGIN>&lt;style&gt;</BEGIN>
   <END>&lt;/style&gt;</END>
</SPAN> 

Tip
The <END> tag is optional. If it is not specified, any occurrence of the start string will cause the remainder of the buffer to be highlighted with this rule. 

This can be very useful when combined with delegation. 

The EOL_SPAN Rule
An EOL_SPAN is similar to a SPAN except that highlighting stops at the end of the line, not after the end sequence is found. The text to match is specified between the opening and closing EOL_SPAN tags. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start sequence will not be highlighted, only the text after it will

Here is an EOL_SPAN that highlights C++ comments: 

<EOL_SPAN TYPE="COMMENT1">//</EOL_SPAN> 

The MARK_PREVIOUS Rule
The MARK_PREVIOUS rule highlights from the end of the previous syntax token to the matched text. The text to match is specified between opening and closing MARK_PREVIOUS tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if it occurs at the beginning of the line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text before it will

Here is a rule that highlights labels in Java mode (for example, "XXX:"): 

<MARK_PREVIOUS AT_LINE_START="TRUE"
    EXCLUDE_MATCH="TRUE">:</MARK_PREVIOUS> 

The MARK_FOLLOWING Rule
The MARK_FOLLOWING rule highlights from the start of the match to the next syntax token. The text to match is specified between opening and closing MARK_FOLLOWING tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text after it will

Here is a rule that highlights variables in Unix shell scripts ("$CLASSPATH", "$IFS", etc): 

<MARK_FOLLOWING TYPE="KEYWORD2">$</MARK_FOLLOWING> 

The SEQ Rule
The SEQ rule highlights fixed sequences of text. The text to highlight is specified between opening and closing SEQ tags. The following attributes are supported: 

TYPE - the token type to highlight the sequence with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a line

The following rules highlight a few Java operators: 

<SEQ TYPE="OPERATOR">+</SEQ>
<SEQ TYPE="OPERATOR">-</SEQ>
<SEQ TYPE="OPERATOR">*</SEQ>
<SEQ TYPE="OPERATOR">/</SEQ> 

The KEYWORDS Rule

There can only be one KEYWORDS tag per ruleset. The KEYWORDS rule defines keywords to highlight. Keywords are similar to SEQs, except that SEQs match anywhere in the text, whereas keywords only match whole words. 

The KEYWORDS tag does not define any attributes. 

Each child element of the KEYWORDS tag should be named after the desired token type, with the keyword text between the start and end tags. For example, the following rule highlights the most common Java keywords: 

<KEYWORDS IGNORE_CASE="FALSE">
   <KEYWORD1>if</KEYWORD1>
   <KEYWORD1>else</KEYWORD1>
   <KEYWORD3>int</KEYWORD3>
   <KEYWORD3>void</KEYWORD3>
</KEYWORDS> 

Token Types

Parser rules can highlight tokens using any of the following token types: 

NULL - no special highlighting is performed on tokens of type NULL 

COMMENT1 

COMMENT2 

FUNCTION 

INVALID - tokens of this type are automatically added if a NO_WORD_BREAK or NO_LINE_BREAK SPAN spans more than one word or line, respectively. 

KEYWORD1 

KEYWORD2 

KEYWORD3 

LABEL 

LITERAL1 

LITERAL2 

MARKUP 

OPERATOR 
#@-node:ekr.20031218072017.1052:The RULES Tag
#@-node:ekr.20031218072017.1049:jEdit docs
#@-node:ekr.20031218072017.1032:(Syntax coloring a la jEdit) (do not delete)
#@+node:ekr.20031218072017.1658:(Using xml parser)
import leoGlobals
import os,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = False
tnodes = vnodes = 0

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
@others
	
try:
	f = None
	try:
		print path
		if 1:
			source = f = open(path)
		else: # not needed, and it works.
			source = InputSource(path)
			source.setEncoding(app().tkEncoding) # Not needed.
		parser = make_parser()
		h = trace_parse()
		parser.setContentHandler(h)
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: g.es_exception()
finally:
	if f: f.close()
#@nonl
#@+node:ekr.20031218072017.1659:characters
def characters(self,content):

	content = content.replace('\r','')

	if verbose and content.strip():
		print clean(content)
#@-node:ekr.20031218072017.1659:characters
#@+node:ekr.20031218072017.1660:endDocument
def endDocument(self):
	trace()


#@-node:ekr.20031218072017.1660:endDocument
#@+node:ekr.20031218072017.1661:endElement
def endElement(self,name):
	if verbose: print '</' + clean(name).strip() + '>'
#@-node:ekr.20031218072017.1661:endElement
#@+node:ekr.20031218072017.1662:other methods
def ignorableWhitespace(self):
	trace()

def processingInstruction (self,target,data):
	trace()

def skippedEntity(self,name):
	trace(name)

def startElementNS(self,name,qname,attrs):
	trace(name)

def endElementNS(self,name,qname):
	trace(name)
#@-node:ekr.20031218072017.1662:other methods
#@+node:ekr.20031218072017.1663:startDocument
def startDocument(self):

	if verbose:
		print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
	trace()
#@-node:ekr.20031218072017.1663:startDocument
#@+node:ekr.20031218072017.1664:startElement
def startElement(self,name,atts):
	global vnodes,tnodes
	if verbose: print '<' + clean(name).strip() + '>',
	if name == "v":
		vnodes += 1
		v = leoNodes.vnode(top(),leoNodes.tnode())
	elif name == "t":
		tnodes += 1
		t = leoNodes.tnode()
#@nonl
#@-node:ekr.20031218072017.1664:startElement
#@-node:ekr.20031218072017.1658:(Using xml parser)
#@-node:ekr.20031218072017.984:Unfinished projects
#@+node:ekr.20040706080316:Projects: 4.2 b3
#@+node:ekr.20040705194708:(Cleaned up recognition of @file nodes)
#@+node:ekr.20031218072017.3152:g.scanAtFileOptions (used in 3.x read code)
def scanAtFileOptions (h,err_flag=False):
    
    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        << scan another @file option >>
        
    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)
            
    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList
#@nonl
#@+node:ekr.20031218072017.3153:<< scan another @file option >>
i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i < len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err > -1:
    g.es("unknown option:" + h[err:i] + " in " + h)
#@nonl
#@-node:ekr.20031218072017.3153:<< scan another @file option >>
#@-node:ekr.20031218072017.3152:g.scanAtFileOptions (used in 3.x read code)
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    n = len(s)
    while i < n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@nonl
#@-node:ekr.20040306211032:p.Comparisons
#@+node:ekr.20040706072845:No longer used (from v.comparisons)
#@+node:ekr.20040328055931:afterHeadlineFileTypeName NO LONGER USED
def afterHeadlineFileTypeName(self,s):
    
    h = self.headString()

    if s != "@file" and g.match_word(h,0,s):
        # No options are valid.
        return s,string.strip(h[len(s):])

    elif g.match(h,0,"@file"):
        i,atFileType,junk = g.scanAtFileOptions(h)
        return atFileType,h[i:].strip()

    else:
        return None,None
#@nonl
#@-node:ekr.20040328055931:afterHeadlineFileTypeName NO LONGER USED
#@+node:ekr.20031218072017.3347:afterHeadlineMatch NO LONGER USED
def afterHeadlineMatch(self,s):
    
    atFileType,fileName = self.afterHeadlineFileTypeName(s)
    if s == atFileType:
        return fileName
    else:
        return ""
#@nonl
#@-node:ekr.20031218072017.3347:afterHeadlineMatch NO LONGER USED
#@+node:ekr.20040706073044:anyAtFileNodeName OLD
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""
    
    if g.match(h,0,"@file"):
        type,name = self.afterHeadlineFileTypeName("@file")
        if type and name: return name
        else:             return ""
    else:
        # New, shorter names are now preferred.
        names = [
            "@thin", "@asis", "@noref", "@nosent",
            "@thinfile", "@silentfile", "@rawfile", "@nosentinelsfile" ]
        for name in names:
            if g.match(h,0,name):
                name = self.afterHeadlineMatch(name)
                if name: return name
        return ""
#@nonl
#@-node:ekr.20040706073044:anyAtFileNodeName OLD
#@+node:ekr.20040706073337:at...FileNodeName  OLD
@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
    if 1: # new code
        names = ("@file"),
        return self.findAtFileName(names)
    else:
        return self.afterHeadlineMatch("@file")

def atNoSentinelsFileNodeName (self):
    if 1: # new code
        names = ("@nosent", "@file-nosent", "@nosentinelsfile")
        return self.findAtFileName(names)
    else:
        return self.afterHeadlineMatch("@nosentinelsfile")

def atRawFileNodeName (self):
    if 1: # new code
        names = ("@noref", "@file-noref", "@rawfile")
        return self.findAtFileName(names)
    else:
        return self.afterHeadlineMatch("@rawfile")
    
def atSilentFileNodeName (self):
    if 1: # new code
        names = ("@asis", "@file-asis", "@silentfile")
        return self.findAtFileName(names)
    else:
        return self.afterHeadlineMatch("@silentfile")
    
def atThinFileNodeName (self):
    if 1: # new code
        names = ("@thin", "@file-thin", "@thinfile")
        return self.findAtFileName(names)
    else:
        return self.afterHeadlineMatch("@thinfile") or self.afterHeadlineMatch("@thin")
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20040706073337:at...FileNodeName  OLD
#@-node:ekr.20040706072845:No longer used (from v.comparisons)
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040705201018:findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@nonl
#@-node:ekr.20040705201018:findAtFileName (new in 4.2 b3)
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@nonl
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@nonl
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040326031436:isAnyAtFileNode good
#@+node:ekr.20040325073709:isAt...FileNode
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@nonl
#@-node:ekr.20040325073709:isAt...FileNode
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@nonl
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@nonl
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]
#@nonl
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@-node:ekr.20040705194708:(Cleaned up recognition of @file nodes)
#@+node:ekr.20040705071418:(Made sure the user is given a chance to save read-only files)
#@+node:ekr.20040706111156:Notes
@killcolor

- Leo now vetos the shutdown logic if saving a dirty file fails.

- Leo prints in red the warning about not being able save the read-only file.

- The user can use the Save To command to save the file. The Save To command
does not clear the file's dirty bit, so Leo will prompt again to save the file.
The user will have to ignore this prompt in order to exit. This is basically
correct: the _original_ file has not been saved.
#@nonl
#@-node:ekr.20040706111156:Notes
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.
#@nonl
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@+node:ekr.20031218072017.3692:promptForSave
def promptForSave (self):
    
    """Prompt the user to save changes.
    
    Return True if the user vetos the quit or save operation."""
    
    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))
        
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            << Put up a file save dialog to set mFileName >>
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@nonl
#@+node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
# Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
#@nonl
#@-node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
#@-node:ekr.20031218072017.3692:promptForSave
#@+node:ekr.20031218072017.1720:save
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,v=v,fileName=fileName)
    if ok is None:
        c.beginUpdate()
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            c.setChanged(False) # Clears all dirty bits.
            g.es("saved: " + g.shortFileName(fileName))
            if g.app.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()
        c.endUpdate()
    g.doHook("save2",c=c,v=v,fileName=fileName)
    return ok
#@nonl
#@-node:ekr.20031218072017.1720:save
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c ; config = g.app.config

    self.assignFileIndices()
    if not outlineOnlyFlag:
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        << create backup file >>
        self.mFileName = fileName
        << create the output file >>
        << update leoConfig.txt >>
        << put the .leo file >>
    except:
        << report the exception >>
        << erase filename and rename backupName to fileName >>
        return False
    if self.outputFile:
        << close the output file >>
        << delete backup file >>
        return True
    else: # This probably will never happen because errors should raise exceptions.
        << erase filename and rename backupName to fileName >>
        return False
        
write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    try:
        backupName = g.os_path_join(g.app.loadDir,fileName)
        backupName = fileName + ".bak"
        if g.os_path_exists(backupName):
            os.unlink(backupName)
        # os.rename(fileName,backupName)
        g.utils_rename(fileName,backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception creating backup file: " + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception creating backup file: " + backupName)
        g.es_exception()
        backupName = None
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080359.2:<< create the output file >>
self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
    g.es("can not open " + fileName)
    << delete backup file >>
    return False
#@nonl
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
    try:
        os.unlink(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20040324080359.2:<< create the output file >>
#@+node:ekr.20040324080819:<< update leoConfig.txt >>
c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()
#@nonl
#@-node:ekr.20040324080819:<< update leoConfig.txt >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20040324080819.2:<< report the exception >>
g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
    try:
        self.outputFile.close()
        self.outputFile = None
    except:
        g.es("exception closing: " + fileName)
        g.es_exception()
#@nonl
#@-node:ekr.20040324080819.2:<< report the exception >>
#@+node:ekr.20040324080819.3:<< close the output file >>
try:
    self.outputFile.close()
    self.outputFile = None
except:
    g.es("exception closing: " + fileName)
    g.es_exception()
#@nonl
#@-node:ekr.20040324080819.3:<< close the output file >>
#@+node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
    try:
        os.unlink(fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting: " + fileName)
            g.es_exception()
    except:
        g.es("exception deleting: " + fileName)
        g.es_exception()
        
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    try:
        g.utils_rename(backupName, fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception renaming " + backupName + " to " + fileName)
            g.es_exception()
    except:
        g.es("exception renaming " + backupName + " to " + fileName)
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
    try:
        os.unlink(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@-node:ekr.20040705071418:(Made sure the user is given a chance to save read-only files)
#@+node:ekr.20040709085421:(Added p.copyTreeAfter, copyTreeTo)
#@+node:ekr.20040303175026.9:p.copyTreeAfter, copyTreeTo
# This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
#@nonl
#@-node:ekr.20040303175026.9:p.copyTreeAfter, copyTreeTo
#@-node:ekr.20040709085421:(Added p.copyTreeAfter, copyTreeTo)
#@+node:ekr.20040707144444:(Improved unit testing)
#@+node:ekr.20040707150139:What I did
@killcolor

- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.
#@nonl
#@-node:ekr.20040707150139:What I did
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p)
    << redirect output >>
    if script:
        script = script.strip()
    if script:
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except:
            << unredirect output >>
            g.es("exception executing script")
            n = g.es_exception(full=False,c=c)
            if n is not None:
                << dump the lines of script near the error >>
                if p and not script1:
                    c.goToScriptLineNumber(p,script,n)
            c.frame.tree.redrawAfterException()
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if g.app.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040612215018:<< dump the lines of script near the error >>
lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    s = "line %d: %s" % (n,lines[n-1])
    print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines of script near the error >>
#@+node:EKR.20040627100424:<< unredirect output >>
if g.app.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    << assert equivalence of lastVisible methods >>
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@nonl
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@nonl
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@-node:ekr.20040707144444:(Improved unit testing)
#@+node:ekr.20040709065122:(Added 3 .css files to cvs and distribution)
@killcolor

- Added to manifest.in:
    
include doc/default.css
include doc/leo_rst.css
include doc/silver_city.css

- Added to leo.nsi:

File c:\prog\leoCVS\leo\doc\default.css
File c:\prog\leoCVS\leo\doc\leo_rst.css
File c:\prog\leoCVS\leo\doc\silver_city.css

- Uploaded leo-stylesheets.zip to plugins package at SourceForge.
#@nonl
#@-node:ekr.20040709065122:(Added 3 .css files to cvs and distribution)
#@+node:ekr.20040709075150:(Fixed double-click-drag) Now reverted
#@+node:ekr.20040709075150.1:Patch
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2655535
By: nobody

I think this solves your request:

@color

def selectWord( event ):
    event.widget.tag_add( 'sel', 'insert wordstart', 'insert' )
textwidget.bind( '<Double-Button-1>', selectWord )

@nocolor

add it to the code where the Text widget editor is created and you should have
the behavior and not feel grief anymore.  Oh yeah, 'textwidget' needs to be
the reference to the Text editor, whatever it's called.  This is actually shorter
than I thought it was going to be. :)

EKR: This doesn't seem to work, regardless of where it is placed.
#@-node:ekr.20040709075150.1:Patch
#@+node:ekr.20040709094545:In app.gui.Tkinter.utils
#@+node:ekr.20031218072017.4089:setTextSelection
def setTextSelection (self,t,start,end):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, ">", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    t.mark_set("insert",end)
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection
#@-node:ekr.20040709094545:In app.gui.Tkinter.utils
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodydclick1",c=c,v=v,event=event):
            if event: # 8/4/02: prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked
                # 7/9/04
                event.widget.tag_add('sel', 'insert wordstart', 'insert wordend')
            body = self.bodyCtrl
            start = body.index(index + " wordstart")
            end = body.index(index + " wordend")
            self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.
#@nonl
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    t.bind("<Key>", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyclick1",c=c,v=v,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyrclick1",c=c,v=v,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("iconrclick")
#@nonl
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3975:OnActivateBody
def OnActivateBody (self,event=None):

    try:
        frame = self ; c = frame.c ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
            # Reference to bodyCtrl is allowable in an event handler.
            gui.set_focus(c,frame.body.bodyCtrl) 
    except:
        g.es_event_exception("activate body")
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody
#@-node:ekr.20040709075150:(Fixed double-click-drag) Now reverted
#@+node:ekr.20040709080432:(Scroll the tree pane on Shift left/right click)
http://sourceforge.net/forum/message.php?msg_id=2649750
#@nonl
#@+node:ekr.20040709151825:Changed find_closest to find_overlapping
#@+node:ekr.20031218072017.2343:<< continue dragging >>
# g.trace(p)
assert(p == self.drag_p)

canvas = self.canvas
frame = self.c.frame

if event:
    x,y = event.x,event.y
else:
    x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
    if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

if 0: # no longer used.
    canvas_x = canvas.canvasx(x)
    canvas_y = canvas.canvasy(y)
    id = self.canvas.find_closest(canvas_x,canvas_y)
    # id = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
    << scroll the canvas as needed >>
#@nonl
#@+node:ekr.20031218072017.2344:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.OnContinueDrag,p,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20031218072017.2344:<< scroll the canvas as needed >>
#@-node:ekr.20031218072017.2343:<< continue dragging >>
#@+node:ekr.20031218072017.1778:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
# id = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20031218072017.1778:<< set vdrag, childFlag >>
#@+node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
def OnIconClick (self,p,event):
    
    # g.trace(p)
    
    p = p.copy() # Make sure callbacks use the _present_ position.

    tree = self ; canvas = tree.canvas
    if event:
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        id = canvas.find_closest(canvas_x,canvas_y)
        # id = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if id != None:
            try: id = id[0]
            except: pass
            self.drag_p = p
            self.drag_id = id
            
            # Create the bindings.
            id4 = canvas.tag_bind(id,"<B1-Motion>", p.OnDrag)
            id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", p.OnEndDrag)
            
            # Remember the bindings so deleteBindings can delete them.
            self.tagBindings.append((id,id4,"<B1-Motion>"),)
            self.tagBindings.append((id,id5,"<Any-ButtonRelease-1>"),)
    tree.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.
    
def OnIconRightClick (self,p,event):

    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
#@-node:ekr.20040709151825:Changed find_closest to find_overlapping
#@+node:ekr.20031218072017.3944:f.createCanvas
def createCanvas (self,parentFrame):
    
    frame = self ; config = g.app.config
    
    scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
import threading
import time
way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('<Shift Button-3>',exe)
    canvas.bind_all('<Shift Button-1>',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('<Shift ButtonRelease-1>', off)
    canvas.bind_all('<Shift ButtonRelease-3>', off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>', exe)
    canvas.bind_all( '<Button-1>', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '<ButtonRelease-1>', off)
    canvas.bind_all( '<ButtonRelease-3>', off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20031218072017.3944:f.createCanvas
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        box_id = canvas.create_image(x,y+self.lineyoffset,image=image)
    
        id1 = canvas.tag_bind(box_id, "<1>", p.OnBoxClick)
        id2 = canvas.tag_bind(box_id, "<Double-1>", lambda x2: None)

        self.tagBindings.append((box_id,id1,"<1>"),)
        self.tagBindings.append((box_id,id2,"<Double-1>"),)
        
        return box_id
#@nonl
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@-node:ekr.20040709080432:(Scroll the tree pane on Shift left/right click)
#@+node:ekr.20040709144318.1:(Underline tree nodes when entered)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    tree = self ; v = p.v # Make sure the bindings refer to the _present_ position.

    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=tree,p=p,v=v,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image,tag="iconBox")
        self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.
    
        id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
        id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
        id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
        
        # Remember the bindings so deleteBindings can delete them.
        self.tagBindings.append((id,id1,"<1>"),)
        self.tagBindings.append((id,id2,"<Double-1>"),)
        self.tagBindings.append((id,id3,"<3>"),)
    
    return 0,icon_width # dummy icon height,width
#@nonl
#@+node:EKR.20040602150338:<< compute x,y and iconVal >>

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:EKR.20040602150338:<< compute x,y and iconVal >>
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.4162:tree.set...LabelState
def setNormalLabelState (self,p): # selected, editing

    # g.trace(p)
    if p and p.edit_text():
        << set editing headline colors >>
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

    # g.trace(p,g.callerName(2),g.callerName(3))
    if p and p.edit_text():
        << set selected, disabled headline colors >>

def setSelectedLabelState (self,p): # selected, not editing

    # g.trace(p)
    self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

    # g.trace(p)
    if p and p.edit_text():
        << set unselected headline colors >>
#@+node:ekr.20031218072017.4163:<< set editing headline colors >>
config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    if selfg and selbg:
        p.edit_text().configure(
            selectforeground=selfg,selectbackground=selbg,
            state="normal",highlightthickness=1,fg=fg,bg=bg)
    else:
        p.edit_text().configure(
            state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4163:<< set editing headline colors >>
#@+node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
    fg,bg = "black","gray80"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
#@+node:ekr.20031218072017.4165:<< set unselected headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4165:<< set unselected headline colors >>
#@-node:ekr.20031218072017.4162:tree.set...LabelState
#@+node:ekr.20031218072017.2029:drawTopTree (tag_bind)
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount)
    # import traceback ; traceback.print_stack()
    
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    if c.hoistStack:
        p,junk = c.hoistStack[-1]
        self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),root_left,root_top,0,0)
        
    canvas.lower("lines")
    canvas.lower("colorBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox")
    
    if 0:
        << define callbacks >>
        # Use vnode or postion callbacks.
        canvas.tag_bind("textBox","<1>",onHeadlineClickCallback)
        canvas.tag_bind("textBox","<3>",onHeadlineRightClickCallback)
        canvas.tag_bind("textBox","<Key>", onHeadlineKeyCallback)
        canvas.tag_bind("textBox","<Control-t>",self.OnControlT)
            # Stamp out erroneous control-t binding.
#@nonl
#@+node:ekr.20040710060809:<< define callbacks >>
def onHeadlineClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.onHeadlineClick()
    
def onHeadlineRightClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineRightClick()
    
def onHeadlineKeyCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineKey()
    
    
#@nonl
#@-node:ekr.20040710060809:<< define callbacks >>
#@-node:ekr.20031218072017.2029:drawTopTree (tag_bind)
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; v = p.v
    yfirst = ylast = y
    if level==0: yfirst += 10
    w = 0
    
    # We must make copies for drawText and drawBox and drawIcon,
    # So making copies here actually reduces the total number of copies.
    ### This will change for incremental redraw.
    p = p.copy()
    
    data = g.doHook("draw-sub-outline",tree=tree,p=p,v=v,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        h,w = self.drawNode(p,x,y)
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
            x += w2 ; w += w2
        if hoistFlag: break
        else:         p = p.next()
    << draw vertical line >>
    return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
    x, yfirst-hline_y,
    x, ylast+hline_y-h,
    fill="gray50", # stipple="gray50"
    tag="lines")

# self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y,box_id=None):
    
    """draw text for v at nominal coordinates x,y."""

    tree = self ; c = self.c ; v = p.v
    h = self.line_height
    x += text_indent
    
    data = g.doHook("draw-outline-text-box",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data

    self.lastText = t = Tk.Text(self.canvas,
        font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

    # New in 4.2: entries are pairs (p,t) indexed by v.
    # Remember which text widget belongs to v.
    d = self.edit_text_dict
    val = d.get(v,[])
    val.append((p,t),)
    d[v] = val
    # g.trace("entry",d[p.v])

    # Remember the widget so deleteBindings can delete it.
    self.widgets.append(t) # Fixes a _huge_ memory leak.

    t.insert("end", v.headString())
    << configure the text depending on state >>

    if 1: # use bind here, else use bind_tag in drawTopTree.
        # Use vnode or postion callbacks.
        id1 = t.bind("<1>",p.OnHeadlineClick)
        id2 = t.bind("<3>",p.OnHeadlineRightClick)
        id3 = t.bind("<Key>", p.OnHeadlineKey)
        id4 = t.bind("<Control-t>",self.OnControlT)
            # 10/16/02: Stamp out the erroneous control-t binding.
        # Remember the bindings so deleteBindings can delete them.
        self.bindings.append((t,id1,"<1>"),)
        self.bindings.append((t,id2,"<3>"),)
        self.bindings.append((t,id3,"<Key>"),)
        self.bindings.append((t,id4,"<Control-t>"),)
    
    if 0: # I like underlining only when the cursor is outside the text widget.
        << highlight text widget on enter events >>
        
    id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t,tag="textBox")
    self.canvas.tag_lower(id)
    
    # This doesn't work: must call update_idletasks first, and that's hard here.
    # g.trace(t,t.winfo_height(),t.winfo_width())
    
    return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
    if p == self.editPosition():
        self.setNormalLabelState(p)
    else:
        self.setDisabledLabelState(p) # selected, disabled
else:
    self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@+node:ekr.20040709194954:<< highlight text widget on enter events >>
if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 1: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040709194954:<< highlight text widget on enter events >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        box_id = canvas.create_image(x,y+self.lineyoffset,image=image)
    
        id1 = canvas.tag_bind(box_id, "<1>", p.OnBoxClick)
        id2 = canvas.tag_bind(box_id, "<Double-1>", lambda x2: None)

        self.tagBindings.append((box_id,id1,"<1>"),)
        self.tagBindings.append((box_id,id2,"<Double-1>"),)
        
        return box_id
#@nonl
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

    self.allocatedNodes += 1
    h,w = self.drawUserIcons(p,"beforeBox",x,y)
    xw = w # The extra indentation before the icon box.
    if p.hasChildren():
        box_id = self.drawBox(p,x+w,y)
    else:
        box_id = None

    w += box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
    h = max(h,h2) ; w += w2 ; xw += w2

    h2,w2 = self.drawIcon(p,x+w,y)
    h = max(h,h2) ; w += w2

    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
    h = max(h,h2) ; w += w2

    expand_x = x+w # save this for later.
    h2 = self.drawText(p,x+w,y,box_id)
    h = max(h,h2)
    w += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
    h = max(h,h2)
    
    self.drawClickFrame(p,y)

    return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040710050236:tree.drawClickFrame
def drawClickFrame (self,p,y):
    
    h = self.line_height ;  defaultColor = ""
    
    # Define a slighly larger rect to catch clicks.

    click_rect = self.canvas.create_rectangle(0,y,1000,y+h-3,tag="clickBox")
    self.canvas.itemconfig(click_rect,fill=defaultColor,outline=defaultColor)
    
    id_click = self.canvas.tag_bind(click_rect, "<1>", p.OnBoxClick)
    self.tagBindings.append((click_rect,id_click,"<1>"),)
    
    if 0: # A major change to the user interface.
        
        # Define a slighly smaller rect to colorize.
        color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
        self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)
        
        # Color the click box or the headline
        def enterRect(event,id=color_rect,p=p,t=self.lastText):
            if 1: # Color or underline the headline
                t2 = self.lastColoredText
                if t2: # decolor the old headline.
                    if 1: # deunderline
                        t2.tag_delete('underline')
                    else: # decolor
                        t2.configure(background="white")
                if t and p != self.editPosition():
                    if 1: # underline
                        t.tag_add('underline','1.0','end')
                        t.tag_configure('underline',underline=True)
                    else: # color
                        t.configure(background="LightSteelBlue1")
                    self.lastColoredText = t
                else: self.lastColoredText = None
            else: # Color the click box.
                if self.lastClickFrameId:
                    self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
                self.lastClickFrameId = id
                color = "LightSteelBlue1"
                self.canvas.itemconfig(id,fill=color,outline=color)
    
        bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
        self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
    
#@nonl
#@-node:ekr.20040710050236:tree.drawClickFrame
#@-node:ekr.20040709144318.1:(Underline tree nodes when entered)
#@+node:ekr.20040709064521:(Allowed multiple files in import dialogs)
#@+node:ekr.20040709101338:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2653456
By: nobody

askopenfilenames allows you to select and return multiple file names. This does
work on Windows.  I haven't tested it on Linux.
#@nonl
#@-node:ekr.20040709101338:Report
#@+node:ekr.20031218072017.3097:CheckVersion (Dave Hein)
@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", ">=", "<=", ">", or "<"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def CheckVersion( version, againstVersion, condition=">=", stringCompare="0.0.0.0", delimiter='.' ):
    import sre  # Unicode-aware regular expressions
    #
    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )
    #
    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )
    #
    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount > len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount > len(testVersion):
        tokenCount = len(testVersion)
    #
    # Apply the stringCompare flags
    justInteger = sre.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg
    #
    # Compare the versions
    if condition == ">=":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == ">":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "<":
        for i in range(tokenCount):
            if testVersion[i] >= testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "<=":
        for i in range(tokenCount):
            if testVersion[i] > testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal
    #
    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
#@nonl
#@-node:ekr.20031218072017.3097:CheckVersion (Dave Hein)
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    # askopenfilenames only exists in Python 2.3 or later
    if multiple and g.CheckVersion(sys.version,"2.3"):
        files = tkFileDialog.askopenfilenames(
            title=title, filetypes=filetypes)
        return list(files)
    else:
        file = tkFileDialog.askopenfilename(
            title=title, filetypes=filetypes)
        if multiple: return [file]
        else:        return file
    
        # DTHEIN 2004.01.31: remove default extension on open,
        # so that we can open files without extensions

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
    # EKR: 2004.01.31: remove default extensions on save too.
    # defaultextension=defaultextension)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@+node:ekr.20040709104835:Changed import commands to accept lists of paths
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.exportHeadlines(fileName)

#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.flattenOutline(fileName)

#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@file")
#@nonl
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) > 0:
        c.importCommands.outlineToWeb(fileName,"cweb")

#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) > 0:
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py")

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20040709104835:Changed import commands to accept lists of paths
#@+node:ekr.20040709104835.1:Changed import helpers to accept lists of paths
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths):

    self.setEncoding()

    for fileName in paths:
        path, self.fileName = g.os_path_split(fileName) # path/fileName
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = g.app.config.remove_sentinels_extension
        if ext == None or len(ext) == 0:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        # g.trace(repr(s))
        << Write s into newFileName >>
#@nonl
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@nonl
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@nonl
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = g.app.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    file = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    file.write(s)
    file.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.webType = webType

    c.beginUpdate()
    for fileName in files:
        v = self.createOutlineFromWeb(fileName,current)
        v.contract()
        v.setDirty()
        c.setChanged(True)
    c.selectVnode(current)
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files,treeType,
    perfectImport=True,testing=False,verbose=False):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)
#@nonl
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@nonl
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent,paths):
    
    c = self.c ; at = c.atFileCommands
    current = c.currentVnode()
    
    c.beginUpdate()
    
    for fileName in paths:
        v = parent.insertAfter()
        v.initHeadString("Imported @file " + fileName)
        c.undoer.setUndoParams("Import",v,select=current)
        at.read(v,importFileName=fileName)
        c.selectVnode(v)
        v.expand()

    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v
#@nonl
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@nonl
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@-node:ekr.20040709104835.1:Changed import helpers to accept lists of paths
#@-node:ekr.20040709064521:(Allowed multiple files in import dialogs)
#@+node:ekr.20040711135244:(Improved g.importFromPath)
#@+node:ekr.20031218072017.2278:g,importFromPath
@ Warning:
g.importFromPath uses imp.load_module, and that is equivalent to reload!
Calling this function to reload Leo files will crash Leo!
@c

def importFromPath (name,path,verbose=False):
    
    import imp

    try:
        file = None ; data = None ; result = None
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                if verbose:
                    s = "Can not import %s from %s" % (mod_name,path)
                    print s ; g.es(s,color="blue")
            if data:
                file,pathname,description = data
                try:
                    result = imp.load_module(mod_name,file,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if file: file.close()

    return result
#@nonl
#@-node:ekr.20031218072017.2278:g,importFromPath
#@-node:ekr.20040711135244:(Improved g.importFromPath)
#@+node:ekr.20040712112449:(Removed scriptfile support)
# This is no longer used: we use toString logic instead.
#@nonl
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@-node:ekr.20040712112449:(Removed scriptfile support)
#@+node:ekr.20040712135130:(Fixed major bug in write logic)
#@+node:ekr.20040712135130.1:Notes
@language plain

For some reason, spurious entries in a tnodeList for @thin trees wipes out all the headlines in the @thin tree.  This needs more investigation.

This happened when running c.checkPythonCode from a script.  Apparently the script set tnodeList by mistake.

The quick fix was to set at.root.v.t.tnodeList = [] in the toString logic in new_df.write.
#@nonl
#@-node:ekr.20040712135130.1:Notes
#@+node:ekr.20031218072017.2114:new_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    << open the file; return on error >>
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.
#@nonl
#@+node:ekr.20031218072017.2116:<< open the file; return on error >>
if toString:
    at.targetFileName = "<new_df.write string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return
#@nonl
#@-node:ekr.20031218072017.2116:<< open the file; return on error >>
#@+node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
#@-node:ekr.20031218072017.2114:new_df.write
#@-node:ekr.20040712135130:(Fixed major bug in write logic)
#@+node:ekr.20040715094645:(Fix open bug)
#@+node:ekr.20040715100724:Report
@killcolor

https://sourceforge.net/forum/message.php?msg_id=2665410
By: bwmulder

I just updated from CVS. The attempt to open LeoPyRef.leo fails because
of runOpenFileDialog.

If "multiple" is false, it calls tkFileDialog.askopenfilename, and then makes
a list out of the result of this function, which is a list of characters.

Maybe this function should be really split into two versions: one for exactly
one file, and another one for a list of files? Probably the latter should *always*
return a list, even if the corresponding function really only returns one
filename.

[I am running on Windows XP].
#@-node:ekr.20040715100724:Report
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    # askopenfilenames only exists in Python 2.3 or later
    if multiple and g.CheckVersion(sys.version,"2.3"):
        files = tkFileDialog.askopenfilenames(
            title=title, filetypes=filetypes)
        return list(files)
    else:
        file = tkFileDialog.askopenfilename(
            title=title, filetypes=filetypes)
        if multiple: return [file]
        else:        return file
    
        # DTHEIN 2004.01.31: remove default extension on open,
        # so that we can open files without extensions

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
    # EKR: 2004.01.31: remove default extensions on save too.
    # defaultextension=defaultextension)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@+node:ekr.20031218072017.2821:open
def open(self):

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow==True and # The window was open on startup
    c.changed==False and c.frame.saved==False and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@-node:ekr.20040715094645:(Fix open bug)
#@+node:ekr.20040712082657:(Removed headline check logic in atFile read logic)
#@+node:ekr.20040715171241:Report
@nocolor

when opening a leo document that contains an @file, say like @file helloworld.bas, leo reports upon opening that:

Leo Log Window...
Leo 4.2 beta 2, build 1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32
File encoding: UTF-8
reading: D:\Programming\HelloWorld.leo
reading: @file helloworld.bas
----- error reading @file helloworld.bas
Mismatched headline.
Expecting: @file helloworld
got: @file helloworld.bas
leoConfig.txt encoding: utf-8
@run encoding: mbcs
13 plugins loaded
leoID = fil
#@-node:ekr.20040715171241:Report
#@+node:ekr.20031218072017.2007:findChild 4.x
def findChild (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
    
    if 0: # Old code:
        << Check the headlines >>
#@nonl
#@+node:ekr.20040716061450:<< Check the headlines >>
if headline.strip() == v.headString().strip():
    t.setVisited() # Supress warning about unvisited node.
    return t
else:
    at.readError(
        "Mismatched headline.\nExpecting: %s\ngot: %s" %
        (headline,v.headString()))
    g.trace("Mismatched headline",headline,v.headString())
    g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
    return None
#@nonl
#@-node:ekr.20040716061450:<< Check the headlines >>
#@-node:ekr.20031218072017.2007:findChild 4.x
#@-node:ekr.20040712082657:(Removed headline check logic in atFile read logic)
#@+node:ekr.20040718163531:(Fix pretty-printing bug)
#@+node:ekr.20040718163531.1:Report
By: Bernhard Mulder - bwmulder
Python check/pretty printing bug  
2004-07-18 13:09
It seems that the new python pretty printing / checking code has problems with triple quoted strings.

I tried this with an (updated) version of the basic_undo code posted on my site. 
#@nonl
#@-node:ekr.20040718163531.1:Report
#@-node:ekr.20040718163531:(Fix pretty-printing bug)
#@+node:ekr.20040711135244.2:(Finished all commands in the Outline Check submenu)
@ignore
@language python
@tabwidth -4
#@nonl
#@+node:ekr.20040713094547:To do
@killcolor

- More options, of course.  The following methods do the actual reformatting:
    
    - putOperator:      puts whitespace around operators.
    - putNormalToken:   puts whitespace around everything else.

Note that you can use putToken to dump lines for debugging.

- Once you have determined the 8323 formatting options that would be necessary to make _you_ happy, you can create those options in leoConfig.txt or a plugin :-)
#@-node:ekr.20040713094547:To do
#@+node:ekr.20040712045017:Notes
@killcolor

- Added onNodeOnly option to new_df.write.  This allows the Check Python command to get one node at a time for checking.

- Fixed bug in putNormalToken: @others was turned into others if there was leading whitespace.

- Fixed bug in setBodyStringOrPane (!).  The new code sets the selection properly.
#@nonl
#@-node:ekr.20040712045017:Notes
#@+node:ekr.20040713085052:undo...
# We borrow most of the Change/Change all logic.
#@nonl
#@+node:EKR.20040526090701.1:redoChangeAll
def redoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        # g.trace(u.undoType,u.p,u.newText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.v.setTnodeText(u.newText)
            u.p.setDirty()
            count += 1
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.newText)
            count += 1
        else: assert(False)

    g.es("redo %d instances" % count)
#@nonl
#@-node:EKR.20040526090701.1:redoChangeAll
#@+node:EKR.20040526090701.5:undoChangeAll
def undoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        # g.trace(u.undoType,u.p,u.oldText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.setTnodeText(u.oldText)
            count += 1
            u.p.setDirty()
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.oldText)
            count += 1
        else: assert False, "bad undo type:" % u.undoType

    g.es("undo %d instances" % count)
#@nonl
#@-node:EKR.20040526090701.5:undoChangeAll
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    << Incrementally update the Tk.Text widget >>
    << Compute the result using v's body text >>
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20040713085052:undo...
#@+node:ekr.20040713081916:selection stuff
#@+node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts
#@nonl
#@-node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
#@+node:ekr.20031218072017.4024:setTextSelection (tkinterBody)
def setTextSelection (self,i,j=None):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j)
#@nonl
#@-node:ekr.20031218072017.4024:setTextSelection (tkinterBody)
#@+node:ekr.20031218072017.4037:setSelectionAreas (tkinterBody)
def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)
#@nonl
#@-node:ekr.20031218072017.4037:setSelectionAreas (tkinterBody)
#@-node:ekr.20040713081916:selection stuff
#@+node:ekr.20040712144354:in leoGlobals...
#@+node:EKR.20040614071102.1:g.getScript
def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script
#@nonl
#@-node:EKR.20040614071102.1:g.getScript
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set dict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set dict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return dict
#@nonl
#@+node:ekr.20031218072017.1261:<< set dict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set dict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()

    if full:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        
    if 1:
        n = g.getLastTracebackLineNumber()
    else:
        # old, kludgy code...
        << look for lines containing a specific message >>

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    return n
#@nonl
#@+node:ekr.20040731211839:<< look for lines containing a specific message >>
errList = traceback.format_exception(typ,val,tb)

print ; print "es_exception (format_exception)"
for item in errList:
    print item
# Strip cruft lines.
s1 = "Traceback (most recent call last):"
s2 = "exec script in {}"
lines = []
for line in errList[-4:]:
    if n is None:
        tag = 'File "<string>", line'
        i = line.find(tag)
        if i > -1:
            << compute n from the line >>
    if not g.match(line,0,s1) and line.find(s2) == -1:
        lines.append(line)
#@nonl
#@+node:EKR.20040612223431:<< compute n from the line >>
i += len(tag)
j = line.find(',',i)
if j > i: n = line[i:j]
else:     n = line[i:].strip()
# g.trace(n)
try: n = int(n)
except (TypeError,ValueError): n = None
#@nonl
#@-node:EKR.20040612223431:<< compute n from the line >>
#@-node:ekr.20040731211839:<< look for lines containing a specific message >>
#@+node:ekr.20040731204831:getLastTracebackLineNumber
def getLastTracebackLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return lineno
        except:
            g.trace("bad line number")
            return 0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        item = data[-1]
        n = item[1]
        return n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackLineNumber
#@-node:ekr.20031218072017.3112:es_exception
#@-node:ekr.20040712144354:in leoGlobals...
#@+node:ekr.20040712100041:Write stuff...
#@+node:ekr.20031218072017.2128:putBody (4.x)
def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040429084140:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040429084140:<< Make sure all lines end in a newline >>
#@+node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
if kind == noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
    assert(not at.pending)
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (cDirective,codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
#@-node:ekr.20031218072017.2128:putBody (4.x)
#@+node:ekr.20031218072017.2111:Writing (4.x)
#@+node:ekr.20031218072017.2112:Top level
#@+node:ekr.20031218072017.2113:new_df.closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self
    if at.outputFile:
        at.outputFile.flush()
        if self.toStringFlag:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@nonl
#@-node:ekr.20031218072017.2113:new_df.closeWriteFile
#@+node:ekr.20031218072017.2114:new_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    << open the file; return on error >>
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.
#@nonl
#@+node:ekr.20031218072017.2116:<< open the file; return on error >>
if toString:
    at.targetFileName = "<new_df.write string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return
#@nonl
#@-node:ekr.20031218072017.2116:<< open the file; return on error >>
#@+node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
#@-node:ekr.20031218072017.2114:new_df.write
#@+node:EKR.20040506075328:new_df.writeOpenFile
def writeOpenFile(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    at = self ; c = at.c
    
    << init atFile ivars for writing >>
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    << put all @first lines in root >>

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    << put all @last lines in root >>
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@+node:EKR.20040506075328.1:<< init atFile ivars for writing >>
# Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.raw = False
assert(at.toStringFlag == toString) # Must have been set earlier.

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.
#@nonl
#@-node:EKR.20040506075328.1:<< init atFile ivars for writing >>
#@+node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    self.os(line) ; self.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
#@+node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        self.os(line[i:])
#@nonl
#@-node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
#@-node:EKR.20040506075328:new_df.writeOpenFile
#@+node:ekr.20031218072017.2122:new_df.norefWrite
def norefWrite(self,root,toString=False):

    at = self

    c = at.c ; at.root = root
    at.errors = 0
    at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
    at.sentinels = True # 10/1/03
    at.thinFile = False # 5/17/04
    c.endEditing() # Capture the current headline.
    try:
        at.targetFileName = root.atNorefFileNodeName()
        ok = at.openWriteFile(root,toString)
        if not ok: return
        << write root's tree >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.handleWriteException(root)
        
rawWrite = norefWrite
#@+node:ekr.20031218072017.2123:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
    << Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20031218072017.2124:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2124:<< put all @first lines in root >>
#@+node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
s2 = g.app.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)> 0:
            at.putSentinel("@comment " + line)
#@-node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
#@+node:ekr.20031218072017.2126:<< Write p's node >>
at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) > 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20031218072017.2126:<< Write p's node >>
#@+node:ekr.20031218072017.2127:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20031218072017.2127:<< put all @last lines in root >>
#@-node:ekr.20031218072017.2123:<< write root's tree >>
#@-node:ekr.20031218072017.2122:new_df.norefWrite
#@-node:ekr.20031218072017.2112:Top level
#@+node:ekr.20031218072017.2128:putBody (4.x)
def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040429084140:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040429084140:<< Make sure all lines end in a newline >>
#@+node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
if kind == noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
    assert(not at.pending)
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (cDirective,codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
#@-node:ekr.20031218072017.2128:putBody (4.x)
#@+node:ekr.20031218072017.2130:code lines... (4.x)
#@+node:EKR.20040430081109.1:@all
#@+node:EKR.20040430080943.1:putAtAllLine
def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
#@nonl
#@-node:EKR.20040430080943.1:putAtAllLine
#@+node:EKR.20040430104717:putatAllBody
def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040430104717.1:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040430104717.1:<< Make sure all lines end in a newline >>
#@-node:EKR.20040430104717:putatAllBody
#@+node:EKR.20040430080943.2:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)
#@nonl
#@-node:EKR.20040430080943.2:putAtAllChild
#@-node:EKR.20040430081109.1:@all
#@+node:EKR.20040430081109.2:@others
#@+node:ekr.20031218072017.2131:inAtOthers
def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@nonl
#@-node:ekr.20031218072017.2131:inAtOthers
#@+node:ekr.20031218072017.2132:putAtOthersChild
def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20031218072017.2132:putAtOthersChild
#@+node:ekr.20031218072017.2133:putAtOthersLine
def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2133:putAtOthersLine
#@-node:EKR.20040430081109.2:@others
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@+node:ekr.20031218072017.2106:putRefLine & allies
#@+node:EKR.20040430081109:putRefLine
def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
#@-node:EKR.20040430081109:putRefLine
#@+node:ekr.20031218072017.2107:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        if not at.perfectImportRoot: # A kludge: we shouldn't be importing derived files here!
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20031218072017.2107:putRefAt
#@+node:ekr.20031218072017.2108:putAfterLastRef
def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j < len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2108:putAfterLastRef
#@+node:ekr.20031218072017.2109:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start < end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2109:putAfterMiddleef
#@-node:ekr.20031218072017.2106:putRefLine & allies
#@-node:ekr.20031218072017.2130:code lines... (4.x)
#@+node:ekr.20031218072017.1745:doc lines... (write)
#@+node:ekr.20031218072017.1746:putBlankDocLine
def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
#@nonl
#@-node:ekr.20031218072017.1746:putBlankDocLine
#@+node:ekr.20031218072017.1747:putStartDocLine
def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == docDirective,"@+doc","@+at")
    directive = g.choose(kind == docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
#@nonl
#@-node:ekr.20031218072017.1747:putStartDocLine
#@+node:ekr.20031218072017.1748:putDocLine
def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        << append words to pending line, splitting the line if needed >>
#@+node:ekr.20031218072017.1749:<< append words to pending line, splitting the line if needed >>
@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i < len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i < len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) >= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)
#@nonl
#@-node:ekr.20031218072017.1749:<< append words to pending line, splitting the line if needed >>
#@-node:ekr.20031218072017.1748:putDocLine
#@+node:ekr.20031218072017.1750:putEndDocLine
def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
#@nonl
#@-node:ekr.20031218072017.1750:putEndDocLine
#@+node:ekr.20031218072017.1751:putPending
def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
#@nonl
#@-node:ekr.20031218072017.1751:putPending
#@-node:ekr.20031218072017.1745:doc lines... (write)
#@+node:ekr.20031218072017.2135:Writing Utils...
#@+node:ekr.20031218072017.2136:directiveKind (4.x)
# Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return othersDirective
        elif g.match_word(s,j,"@all"):
            return allDirective
        else:
            return noDirective

    table = (
        ("@all",allDirective),
        ("@c",cDirective),
        ("@code",codeDirective),
        ("@doc",docDirective),
        ("@end_raw",endRawDirective),
        ("@others",othersDirective),
        ("@raw",rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 >= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            noDirective,atDirective)

    # 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1>= n or s[i+1] not in string.ascii_letters):
        return noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # 10/14/02: return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return miscDirective

    return noDirective
#@nonl
#@-node:ekr.20031218072017.2136:directiveKind (4.x)
#@+node:ekr.20031218072017.2137:hasSectionName
def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)

    return -1 < n1 < n2, n1, n2
#@nonl
#@-node:ekr.20031218072017.2137:hasSectionName
#@+node:ekr.20031218072017.2138:os and allies
# Note:  self.outputFile may be either a fileLikeObject or a real file.

#@+node:EKR.20040620094529:oblank, oblanks & otabs
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))
#@nonl
#@-node:EKR.20040620094529:oblank, oblanks & otabs
#@+node:EKR.20040620094529.1:onl & onl_sent
def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
#@nonl
#@-node:EKR.20040620094529.1:onl & onl_sent
#@+node:EKR.20040620094529.2:os
def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    if s and self.outputFile:
        try:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            self.outputFile.write(s)
        except:
            g.es("exception writing:",s)
            g.es_exception(full=True)
#@nonl
#@-node:EKR.20040620094529.2:os
#@-node:ekr.20031218072017.2138:os and allies
#@+node:ekr.20031218072017.1921:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20031218072017.1922:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20031218072017.1922:<< handle @delims >>
#@+node:EKR.20040625103148:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:EKR.20040625103148:<< handle @language >>
#@+node:EKR.20040625103148.1:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:EKR.20040625103148.1:<< handle @comment >>
#@-node:ekr.20031218072017.1921:putDirective  (handles @delims,@comment,@language) 4.x
#@-node:ekr.20031218072017.2135:Writing Utils...
#@-node:ekr.20031218072017.2111:Writing (4.x)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode() and not v.isAtThinFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2132:putAtOthersChild
def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20031218072017.2132:putAtOthersChild
#@-node:ekr.20040712100041:Write stuff...
#@+node:ekr.20040711141625:Menu stuff...
#@+node:ekr.20031218072017.3797:<< create the outline menu >>
outlineMenu = self.createNewMenu("&Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

<< create check submenu >>
<< create expand/contract submenu >>
<< create move submenu >>
<< create mark submenu >>
<< create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("&Expand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:<< create the outline menu >>
#@+node:ekr.20031218072017.3752:defineMenuTables
def defineMenuTables (self):
    
    c = self.c ; f = self.frame
    
    << define edit menu tables >>
    << define file menu tables >>
    << define outline menu tables >>
    << define window menu tables >>
    << define help menu tables >>
#@nonl
#@+node:ekr.20031218072017.3753:<< define edit menu tables >>
<< define editMenuTopTable >>
<< define editMenuEditBodyTable >>
<< define editMenuEditHeadlineTable >>
<< define editMenuFindMenuTable >>
<< define editMenuTop2Table >>
#@nonl
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
    ("-",None,None),
    ("Cu&t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&y","Ctrl+C",f.OnCopyFromMenu),
    ("&Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&Delete",None,c.delete),
    ("Select &All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
self.editMenuEditBodyTable = (
    ("Extract &Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&lanks",None,c.convertAllBlanks),
    ("Convert All T&abs",None,c.convertAllTabs),
    ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&Indent","Ctrl+]",c.indentBody),
    ("&Unindent","Ctrl+[",c.dedentBody),
    ("&Match Brackets","Ctrl+K",c.findMatchingBracket))
#@nonl
#@-node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
#@+node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
self.editMenuEditHeadlineTable = (
    ("Edit &Headline","Ctrl+H",c.editHeadline),
    ("&End Edit Headline","Escape",f.endEditLabelCommand),
    ("&Abort Edit Headline","Shift-Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))
#@nonl
#@-node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
#@+node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
self.editMenuFindMenuTable = (
    ("&Find Panel","Ctrl+F",c.findPanel),
    ("-",None,None),
    ("Find &Next","F3",c.findNext),
    ("Find &Previous","F4",c.findPrevious),
    ("&Replace","Ctrl+=",c.replace),
    ("Replace, &Then Find","Ctrl+-",c.replaceThenFind))
#@nonl
#@-node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
#@+node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&visibles","Show In&visibles")
    
self.editMenuTop2Table = (
    ("&Go To Line Number","Alt+G",c.goToLineNumber),
    ("&Execute Script","Alt+Shift+E",c.executeScript),
    ("Set Fon&t...","Shift+Alt+T",c.fontPanel),
    ("Set &Colors...","Shift+Alt+C",c.colorPanel),
    (label,"Alt+V",c.viewAllCharacters),
    ("-",None,None),
    ("Prefere&nces","Ctrl+Y",c.preferences))
#@nonl
#@-node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
#@-node:ekr.20031218072017.3753:<< define edit menu tables >>
#@+node:ekr.20031218072017.3758:<< define file menu tables >>
<< define fileMenuTopTable >>
<< define fileMenuTop2Table >>
<< define fileMenuReadWriteMenuTable >>
<< define fileMenuTangleMenuTable >>
<< define fileMenuUntangleMenuTable >>
<< define fileMenuImportMenuTable >>
<< define fileMenuExportMenuTable >>
<< define fileMenuTop3MenuTable >>
#@nonl
#@+node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
self.fileMenuTopTable = (
    ("&New","Ctrl+N",c.new),
    ("&Open...","Ctrl+O",c.open))
#@nonl
#@-node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
#@+node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
self.fileMenuTop2Table = (
    ("-",None,None),
    ("&Close","Ctrl+W",c.close),
    ("&Save","Ctrl+S",c.save),
    ("Save &As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &Tangle
    ("Re&vert To Saved",None,c.revert)) # &Read/Write
#@nonl
#@-node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
#@+node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
self.fileMenuReadWriteMenuTable = (
    ("&Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes),
    ("-",None,None),
    ("Write 4.x Derived Files",None,c.writeNewDerivedFiles),
    ("Write 3.x Derived Files",None,c.writeOldDerivedFiles))
#@nonl
#@-node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
#@+node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
self.fileMenuTangleMenuTable = (
    ("Tangle &All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&Tangle","Shift+Ctrl+T",c.tangle))
#@nonl
#@-node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
#@+node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
self.fileMenuUntangleMenuTable = (
    ("Untangle &All",None,c.untangleAll),
    ("Untangle &Marked",None,c.untangleMarked),
    ("&Untangle","Shift+Ctrl+U",c.untangle))
#@nonl
#@-node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
#@+node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&root",None,c.importAtRoot),
    ("Import &CWEB Files",None,c.importCWEBFiles),
    
    ("Import &noweb Files",None,c.importNowebFiles),
    ("Import Flattened &Outline",None,c.importFlattenedOutline))
#@nonl
#@-node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
#@+node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
self.fileMenuExportMenuTable = [
    ("Export &Headlines",None,c.exportHeadlines),
    ("Outline To &CWEB",None,c.outlineToCWEB),
    ("Outline To &Noweb",None,c.outlineToNoweb),
    ("&Flatten Outline",None,c.flattenOutline),
    ("&Remove Sentinels",None,c.removeSentinels),
    ("&Weave",None,c.weave)]
#@nonl
#@-node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
#@+node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
self.fileMenuTop3MenuTable = (
    ("E&xit","Ctrl-Q",g.app.onQuit),)
#@nonl
#@-node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
#@-node:ekr.20031218072017.3758:<< define file menu tables >>
#@+node:ekr.20031218072017.3767:<< define outline menu tables >>
<< define outlineMenuTopMenuTable >>
<< define outlineMenuCheckOutlineMenuTable >>
<< define outlineMenuExpandContractMenuTable >>
<< define outlineMenuMoveMenuTable >>
<< define outlineMenuMarkMenuTable >>
<< define outlineMenuGoToMenuTable >>
#@nonl
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste &Retaining Clones",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  c,d,e,h,i,k,m,n,o,p,r,s,u
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
self.outlineMenuCheckOutlineMenuTable = (

    ("Check &Outline",None,c.checkOutline),
    ("&Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &All Python Code",None,c.checkAllPythonCode),
    ("&Check Python &Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
self.outlineMenuMoveMenuTable = (
    ("Move &Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &Right","Ctrl+R",c.moveOutlineRight),
    ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&Promote","Ctrl+{",c.promote),
    ("&Demote", "Ctrl+}",c.demote))
#@nonl
#@-node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
#@+node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
self.outlineMenuMarkMenuTable = (
    ("&Mark","Ctrl-M",c.markHeadline),
    ("Mark &Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
    ("Mark &Clones","Alt+K",c.markClones),
    ("&Unmark All","Alt+U",c.unmarkAll))
#@nonl
#@-node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
#@+node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&isible","Alt-UpArrow",c.selectVisBack),
    ("Go To Next &Visible","Alt-DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt-Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt-Shift-DnArrow",c.selectThreadNext))
#@nonl
#@-node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
#@-node:ekr.20031218072017.3767:<< define outline menu tables >>
#@+node:ekr.20031218072017.3773:<< define window menu tables >>
self.windowMenuTopTable = (
    ("&Equal Sized Panes","Ctrl-E",f.equalSizedPanes),
    ("Toggle &Active Pane","Ctrl-T",f.toggleActivePane),
    ("Toggle &Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&de",None,f.cascade),
    ("&Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &Compare Window",None,c.openCompareWindow),
    ("Open &Python Window","Alt+P",c.openPythonWindow))
#@nonl
#@-node:ekr.20031218072017.3773:<< define window menu tables >>
#@+node:ekr.20031218072017.3774:<< define help menu tables >>
self.helpMenuTopTable = (
    ("&About Leo...",None,c.about),
    ("Online &Home Page",None,c.leoHome),
    ("-",None,None),
    ("Open Online &Tutorial",None,c.leoTutorial))
    
self.helpMenuTop2Table = (
    ("Open &Offline Tutorial",None,f.leoHelp),)
    
self.helpMenuTop3Table = (
    ("Open Leo&Docs.leo",None,c.leoDocumentation),
    ("-",None,None),
    ("Open Leo&Config.leo",None,c.leoConfig),
    ("Apply &Settings",None,c.applyConfig))
#@nonl
#@-node:ekr.20031218072017.3774:<< define help menu tables >>
#@-node:ekr.20031218072017.3752:defineMenuTables
#@-node:ekr.20040711141625:Menu stuff...
#@+node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    << assert equivalence of lastVisible methods >>
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@nonl
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@nonl
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20040723094220.3:checkPythonCode
def checkPythonCode (self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking all Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@nonl
#@+node:ekr.20040723094220.4:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.4:<< print dots >>
#@-node:ekr.20040723094220.3:checkPythonCode
#@+node:ekr.20040723094220.5:checkPythonNode
def checkPythonNode (self,p,unittest=False):

    c = self
    
    h = p.headString()
    body = g.getScript(c,p.copy(),oneNodeOnly=True)
    if not body: return

    try:
        compiler.parse(body + '\n')
    except SyntaxError:
        if unittest:
            raise
        else:
            g.es("Syntax error in: %s" % h,color="blue")
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest)
#@nonl
#@-node:ekr.20040723094220.5:checkPythonNode
#@+node:ekr.20040723094220.6:tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:
        if unittest:
            raise
        else:
            g.es("Token error in %s" % headline,color="blue")
            g.es(str(msg))
            p.setMarked()

    except tabnanny.NannyNag, nag:
        if unittest:
            raise
        else:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
            p.setMarked()
        
    except:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
#@-node:ekr.20040723094220.6:tabNannyNode
#@-node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()
#@nonl
#@-node:ekr.20040412060927:c.dumpOutline
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.changed = False
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.c = c
    self.p = c.currentPosition()
    self.prevName = None
#@nonl
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 1:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    pp = self ; c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        pp.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            pp.putToken(token5tuple)
        lines = pp.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        pp.dumpLines(p,lines)
    else:
        pp.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20040711135244.10:putNormalToken
def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = t5
    name = token.tok_name[t1].lower()
    val = t2
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    # g.trace(name,repr(val))
    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        self.lines.append(''.join(a))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
        if self.prevName == "def": # A personal idiosyncracy.
            a.append(' ') # Retain the blank before '('.
        self.prevName = val
    elif name == "number":
        a.append(val)
    elif name in ("comment","string"):
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(val)
        for line in lines:
            a.append(line)
            if line and line[-1] == '\n':
                self.lines.append(''.join(a))
                self.array = []
    elif name == "errortoken":
        a.append(val)
        if val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(line,scol+1)
            ws = line[scol+1:i]
            if ws: a.append(ws)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)
#@nonl
#@-node:ekr.20040711135244.10:putNormalToken
#@+node:ekr.20040711135244.11:putOperator
def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:putOperator
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20040711135959.2:Check Outline submenu...
#@-node:ekr.20040711135244.2:(Finished all commands in the Outline Check submenu)
#@+node:ekr.20040719151353:(Fixed MAJOR bug in p.isAncestorOf)
#@+node:ekr.20040722043212:Notes
@killcolor

- p.isAncestorOf is used only in the move methods and in find.selectNextVnode.

- It is likely that the bug does not affect the move methods significantly.
#@nonl
#@-node:ekr.20040722043212:Notes
#@+node:ekr.20040722043212.1:Traceback
exception executing command

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 166, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 2458, in findNext
    g.app.findFrame.findNextCommand(c)
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 230, in findNextCommand
    self.findNext()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 554, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 594, in findNextMatch
    v = self.v = self.selectNextVnode()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 743, in selectNextVnode
    if (c.suboutline_only_flag and self.onlyVnode and v and
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1867, in isAncestorOf
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3133, in vParentWithStack
    return self.stack[n],n-1 # simulate popping the stack.

IndexError: list index out of range
#@nonl
#@-node:ekr.20040722043212.1:Traceback
#@+node:ekr.20040307104131.1:p.isAncestorOf
def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False
#@nonl
#@-node:ekr.20040307104131.1:p.isAncestorOf
#@-node:ekr.20040719151353:(Fixed MAJOR bug in p.isAncestorOf)
#@+node:ekr.20040722045721:Examined possible compatibility problems using old-style scripts: NO PROBLEM)
#@+node:ekr.20040722045721.1:Notes
@killcolor

1.  Assignments.

find.selectNextVnode has several assignments like:

self.wrapVnode = v

However, this is _completely_ safe because the find code never calls p.moveToX.  Therefore, the assigned postion never changes!

Indeed, the code uses v.threadNext and v.threadBack, and these never change positions, they create new ones.


2. Assigning None to a possition.

This will work properly in all situations.

3.  Tests for equality against None

This should work properly.  p.__cmp__ allows tests against None.
#@-node:ekr.20040722045721.1:Notes
#@-node:ekr.20040722045721:Examined possible compatibility problems using old-style scripts: NO PROBLEM)
#@+node:ekr.20040722052045:(Examined find.selectNextVnode)
#@+node:ekr.20040722052045.1:Notes
@killcolor

We do _not_ have to make copies when assigning to an ivar because the find code never calls p.moveToX.

Furthermore, v.copy will fail if v is None.
#@nonl
#@-node:ekr.20040722052045.1:Notes
#@+node:ekr.20031218072017.3081:selectNextVnode
# Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; v = self.v

    if c.selection_only_flag:
        return None

    # Start suboutline only searches.
    if c.suboutline_only_flag and not self.onlyVnode:
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.onlyVnode = v 

    # Start wrapped searches.
    if self.wrapping and not self.wrapVnode:
        assert(self.wrapPos != None)
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.wrapVnode = v 

    if self.in_headline and c.search_body_flag:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(v)
        return v

    if c.reverse_flag: v = v.threadBack()
    else:              v = v.threadNext()

    # Wrap if needed.
    if not v and self.wrapping and not c.suboutline_only_flag:
        v = c.rootVnode()
        if c.reverse_flag:
            # Set search_v to the last node of the tree.
            while v and v.next():
                v = v.next()
            if v: v = v.lastNode()

    # End wrapped searches.
    if self.wrapping and v and v == self.wrapVnode:
        # g.trace("ending wrapped search")
        v = None ; self.resetWrap()

    # End suboutline only searches.
    if (c.suboutline_only_flag and self.onlyVnode and v and
        (v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
        # g.trace("end outline-only")
        v = None ; self.onlyVnode = None

    # v.copy not needed because the find code never calls p.moveToX.
    # Furthermore, v might be None, so v.copy() would be wrong!
    self.v = v # used in initNextText().
    if v: # select v and set the search point within v.
        self.in_headline = c.search_headline_flag
        self.initNextText()
    return v
#@nonl
#@-node:ekr.20031218072017.3081:selectNextVnode
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not c.search_headline_flag and not c.search_body_flag:
        return None, None

    if len(c.find_text) == 0:
        return None, None

    v = self.v
    while v:
        pos, newpos = self.search()
        if pos:
            if c.mark_finds_flag:
                v.setMarked()
                c.frame.tree.drawIcon(v) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif c.node_only_flag:
            return None,None # We are only searching one node.
        else:
            v = self.v = self.selectNextVnode()
    return None, None
#@nonl
#@-node:ekr.20031218072017.3075:findNextMatch
#@-node:ekr.20040722052045:(Examined find.selectNextVnode)
#@+node:ekr.20040721151247:(Fixed bug in putTnodes)
# The new code only writes tnodes for the current tree when pasting to the clipboard.
#@nonl
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode() and not v.isAtThinFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):
    
    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>") ; self.put_nl()
    << write only those tnodes that were referenced >>
    self.put("</tnodes>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    iter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    iter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in iter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:ekr.20040721151247:(Fixed bug in putTnodes)
#@+node:EKR.20040506075328.3:(Perfect Import)
#@+node:ekr.20040717133553:What I did
@killcolor

- Added readline method to fileLikeObject class: new_df.readOpenFile calls readline.

- Added perfectImportRoot keyword arg to new_df.readOpenFile.

- Added perfectImportRoot ivar to new_df class.

- readEndNode counts the number of corrected nodes, and marks all corrected nodes.

- Forced at.perfectImportRoot = False in top-level read code.
    This corrects a problem with reading LeoDocs.leo during unit tests.
#@nonl
#@-node:ekr.20040717133553:What I did
#@+node:ekr.20040716105102.1:(Fixed bugs with handling @nonl)
#@+node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return removeSentinelsFromLines(lines,delims)
    
def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""
    
    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    << remove the newline from result[-1] if line[i] is followed by @nonl >>
    return result
#@nonl
#@+node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
i = last_nosent_i

if i + 1 < len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]
#@nonl
#@-node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
#@-node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
#@+node:EKR.20040504150046.6:create_mapping
def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """
    
    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)
    
    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping
#@nonl
#@-node:EKR.20040504150046.6:create_mapping
#@-node:ekr.20040716105102.1:(Fixed bugs with handling @nonl)
#@+node:ekr.20040718042049:From atFile...
#@+node:ekr.20031218072017.2756:Reading (4.x)
#@+node:ekr.20040321064134.5:createThinChild (4.2)
def createThinChild (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #g.trace("last",last,last.t.fileIndex)
    #g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace("creating node",child,gnx)

    return child
#@nonl
#@-node:ekr.20040321064134.5:createThinChild (4.2)
#@+node:ekr.20031218072017.2757:new_df.readOpenFile
def readOpenFile(self,root,file,firstLines,perfectImportRoot=None):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self
    
    # This is safe (just barely) because only this method calls scanText4>
    at.perfectImportRoot = perfectImportRoot

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20031218072017.2757:new_df.readOpenFile
#@+node:ekr.20031218072017.2007:findChild 4.x
def findChild (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
    
    if 0: # Old code:
        << Check the headlines >>
#@nonl
#@+node:ekr.20040716061450:<< Check the headlines >>
if headline.strip() == v.headString().strip():
    t.setVisited() # Supress warning about unvisited node.
    return t
else:
    at.readError(
        "Mismatched headline.\nExpecting: %s\ngot: %s" %
        (headline,v.headString()))
    g.trace("Mismatched headline",headline,v.headString())
    g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
    return None
#@nonl
#@-node:ekr.20040716061450:<< Check the headlines >>
#@-node:ekr.20031218072017.2007:findChild 4.x
#@+node:ekr.20031218072017.2758:scanText4 & allies
def scanText4 (self,file,p):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(file)
        if len(s) == 0: break
        kind = at.sentinelKind(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
#@+node:ekr.20031218072017.2760:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20031218072017.2760:<< report unexpected end of text >>
#@+node:ekr.20031218072017.2761:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20031218072017.2762:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20031218072017.2762:<< Skip the leading stuff >>
#@+node:ekr.20031218072017.2763:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20031218072017.2763:<< Append s to docOut >>
#@-node:ekr.20031218072017.2761:readNormalLine
#@+node:ekr.20031218072017.2764:start sentinels
#@+node:EKR.20040430081719:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(endAll)
#@nonl
#@-node:EKR.20040430081719:readStartAll (4.2)
#@+node:ekr.20031218072017.1752:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endDoc)
    
def skipToEndSentinel(self,s,i):
    end = self.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20031218072017.1752:readStartAt & readStartDoc
#@+node:ekr.20031218072017.2765:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20031218072017.2765:readStartLeo
#@+node:EKR.20040524070500:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:EKR.20040524070500:readStartMiddle
#@+node:ekr.20031218072017.2766:readStartNode
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild(headline)
    
    at.endSentinelStack.append(endNode)
#@nonl
#@+node:EKR.20040427105350:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:EKR.20040427105350:<< set gnx and bump i >>
#@+node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
#@-node:ekr.20031218072017.2766:readStartNode
#@+node:ekr.20031218072017.2769:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(endOthers)
#@nonl
#@-node:ekr.20031218072017.2769:readStartOthers
#@-node:ekr.20031218072017.2764:start sentinels
#@+node:ekr.20031218072017.2770:end sentinels
#@+node:EKR.20040430081719.1:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(endAll)
#@nonl
#@-node:EKR.20040430081719.1:readEndAll (4.2)
#@+node:ekr.20031218072017.1954:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20031218072017.1954:readEndAt & readEndDoc
#@+node:ekr.20031218072017.2771:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.file)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20031218072017.2771:readEndLeo
#@+node:EKR.20040524071414:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:EKR.20040524071414:readEndMiddle
#@+node:ekr.20031218072017.2772:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        if old:
            if at.perfectImportRoot:
                << bump at.correctedLines and tell about the correction >>
                p.setMarked()
                at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
                at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
                at.c.setChanged(True)
            else:
                g.es("Warning: updating changed text",color="blue")
                #g.es("old...\n%s\n" % old)
                #g.es("new...\n%s\n" % s)
                # Just set the dirty bit. Ancestors will be marked dirty later.
                at.t.setDirty()
                if 1: # We must avoid the full setChanged logic here!
                    c.changed = True
                else: # Far too slow for mass changes.
                    at.c.setChanged(True)
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)
#@nonl
#@+node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20031218072017.2772:readEndNode (4.x)
#@+node:ekr.20031218072017.2773:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(endOthers)
#@nonl
#@-node:ekr.20031218072017.2773:readEndOthers
#@+node:ekr.20031218072017.1753:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    if 0: # new code.
        << new code >>
    else:
        << old code >>
#@nonl
#@+node:ekr.20031218072017.1754:<< new code >>
if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(s) # The tag has already been removed.
at.docOut = []
#@nonl
#@-node:ekr.20031218072017.1754:<< new code >>
#@+node:ekr.20031218072017.1755:<< old code >>
# Remove the @doc or @space.  We'll add it back at the end.
if g.match(s,0,tag):
    s = s[len(tag):]
else:
    at.readError("Missing start of doc part")
    return

if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(tag + s)
at.docOut = []
#@nonl
#@-node:ekr.20031218072017.1755:<< old code >>
#@-node:ekr.20031218072017.1753:readLastDocLine
#@-node:ekr.20031218072017.2770:end sentinels
#@+node:ekr.20031218072017.2774:Unpaired sentinels
#@+node:ekr.20031218072017.2775:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20031218072017.2775:ignoreOldSentinel
#@+node:ekr.20031218072017.2776:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.file)
    at.out.append(s)
#@nonl
#@-node:ekr.20031218072017.2776:readAfterRef
#@+node:EKR.20040520093903:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:EKR.20040520093903:readClone
#@+node:ekr.20031218072017.2777:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20031218072017.2777:readComment
#@+node:ekr.20031218072017.2778:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20031218072017.2778:readDelims
#@+node:ekr.20031218072017.2779:readDirective
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
    
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if g.match_word(s,i,"@language"):
        << handle @language >>
    elif g.match_word(s,i,"@comment"):
        << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:EKR.20040625104908:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:EKR.20040625104908:<< handle @language >>
#@+node:EKR.20040625104908.1:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:EKR.20040625104908.1:<< handle @comment >>
#@-node:ekr.20031218072017.2779:readDirective
#@+node:ekr.20031218072017.2780:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20031218072017.2780:readNl
#@+node:ekr.20031218072017.2781:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20031218072017.2781:readNonl
#@+node:ekr.20031218072017.2782:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20031218072017.2782:readRef
#@+node:ekr.20031218072017.2783:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.file) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20031218072017.2783:readVerbatim
#@-node:ekr.20031218072017.2774:Unpaired sentinels
#@+node:ekr.20031218072017.2784:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    at.readError("Ignoring %s sentinel.  Expecting %s" %
        (at.sentinelName(at.endSentinelStack[-1]),
         at.sentinelName(expectedKind)))
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20031218072017.2784:badEndSentinel, push/popSentinelStack
#@-node:ekr.20031218072017.2758:scanText4 & allies
#@-node:ekr.20031218072017.2756:Reading (4.x)
#@+node:ekr.20031218072017.2114:new_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    << open the file; return on error >>
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.
#@nonl
#@+node:ekr.20031218072017.2116:<< open the file; return on error >>
if toString:
    at.targetFileName = "<new_df.write string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return
#@nonl
#@-node:ekr.20031218072017.2116:<< open the file; return on error >>
#@+node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
#@-node:ekr.20031218072017.2114:new_df.write
#@+node:ekr.20031218072017.2757:new_df.readOpenFile
def readOpenFile(self,root,file,firstLines,perfectImportRoot=None):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self
    
    # This is safe (just barely) because only this method calls scanText4>
    at.perfectImportRoot = perfectImportRoot

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20031218072017.2757:new_df.readOpenFile
#@+node:ekr.20031218072017.2772:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        if old:
            if at.perfectImportRoot:
                << bump at.correctedLines and tell about the correction >>
                p.setMarked()
                at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
                at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
                at.c.setChanged(True)
            else:
                g.es("Warning: updating changed text",color="blue")
                #g.es("old...\n%s\n" % old)
                #g.es("new...\n%s\n" % s)
                # Just set the dirty bit. Ancestors will be marked dirty later.
                at.t.setDirty()
                if 1: # We must avoid the full setChanged logic here!
                    c.changed = True
                else: # Far too slow for mass changes.
                    at.c.setChanged(True)
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)
#@nonl
#@+node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20031218072017.2772:readEndNode (4.x)
#@-node:ekr.20040718042049:From atFile...
#@+node:ekr.20040718042049.1:From leoGlobals...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self):
        self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr < len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)
#@nonl
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@+node:EKR.20040504154039:g.is_sentinel
def is_sentinel (line,delims):
    
    << is_sentinel doc tests >>
    
    delim1,delim2,delim3 = delims
    
    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i < j
    else:
        g.es("Can't happen: is_sentinel",color="red")
        return False
#@+node:ekr.20040719161756:<< is_sentinel doc tests >>
"""

Return True if line starts with a sentinel comment.

>>> py_delims = comment_delims_from_extension('.py')
>>> is_sentinel("#@+node",py_delims)
True
>>> is_sentinel("#comment",py_delims)
False

>>> c_delims = comment_delims_from_extension('.c')
>>> is_sentinel("//@+node",c_delims)
True
>>> is_sentinel("//comment",c_delims)
False

>>> html_delims = comment_delims_from_extension('.html')
>>> is_sentinel("<!--@+node-->",html_delims)
True
>>> is_sentinel("<!--comment-->",html_delims)
False

"""
#@nonl
#@-node:ekr.20040719161756:<< is_sentinel doc tests >>
#@-node:EKR.20040504154039:g.is_sentinel
#@-node:ekr.20040718042049.1:From leoGlobals...
#@+node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
import difflib,shutil

class mulderUpdateAlgorithm:
    
    """A class to update derived files using
    diffs in files without sentinels.
    """
    
    @others
    
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

    mu = mulderUpdateAlgorithm()

    mu.pull_source(sourcefilename,targetfilename)
    mu.copy_time(targetfilename,sourcefilename)
#@nonl
#@+node:EKR.20040504150046.3:__init__
def __init__ (self,testing=False,verbose=False):
    
    self.testing = testing
    self.verbose = False
    self.do_backups = False
#@nonl
#@-node:EKR.20040504150046.3:__init__
#@+node:EKR.20040504150046.9:copy_sentinels
@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """
    
    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i <= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos < j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos
#@nonl
#@-node:EKR.20040504150046.9:copy_sentinels
#@+node:EKR.20040504155109:copy_time
def copy_time(self,sourcefilename,targetfilename):
    
    """
    Set the target file's modification time to
    that of the source file.
    """

    st = os.stat(sourcefilename)

    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")
#@nonl
#@-node:EKR.20040504155109:copy_time
#@+node:EKR.20040504150046.6:create_mapping
def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """
    
    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)
    
    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping
#@nonl
#@-node:EKR.20040504150046.6:create_mapping
#@+node:EKR.20040505080156:Get or remove sentinel lines
# These routines originally were part of push_filter & push_filter_lines.
#@nonl
#@+node:EKR.20040505081121:separateSentinelsFromFile/Lines
def separateSentinelsFromFile (self,filename):
    
    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return self.separateSentinelsFromLines(lines,delims)
    
def separateSentinelsFromLines (self,lines,delims):
    
    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""
    
    strippedLines = self.removeSentinelsFromLines(lines,delims)
    sentinelLines = self.getSentinelsFromLines(lines,delims)
    
    return strippedLines,sentinelLines
#@nonl
#@-node:EKR.20040505081121:separateSentinelsFromFile/Lines
#@+node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return removeSentinelsFromLines(lines,delims)
    
def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""
    
    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    << remove the newline from result[-1] if line[i] is followed by @nonl >>
    return result
#@nonl
#@+node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
i = last_nosent_i

if i + 1 < len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]
#@nonl
#@-node:ekr.20040716105102:<< remove the newline from result[-1] if line[i] is followed by @nonl >>
#@-node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
#@+node:EKR.20040505080156.3:getSentinelsFromFile/Lines
def getSentinelsFromFile (self,filename,delims):
    
    """Returns all sentinels lines in a file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return getSentinelsFromLines(lines,delims)
    
def getSentinelsFromLines (self,lines,delims):
    
    """Returns all sentinels lines in lines."""
    
    return [line for line in lines if g.is_sentinel(line,delims)]
#@nonl
#@-node:EKR.20040505080156.3:getSentinelsFromFile/Lines
#@-node:EKR.20040505080156:Get or remove sentinel lines
#@+node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
    
    << init propagateDiffsToSentinelsFile vars >>
    
    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)
        
    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        << paranoia check>>
#@nonl
#@+node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
# Get the sentinel comment delims.
delims = self.comment_delims_from_extension(sourcefilename)
if not delims:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)
    
    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.
    
    i_lines,mapping = self.create_mapping(fat_lines,delims)
    
    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return
#@nonl
#@-node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
#@+node:EKR.20040504150046.12:<<paranoia check>>
# Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,delims)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")
#@nonl
#@-node:EKR.20040504150046.12:<<paranoia check>>
#@-node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
#@+node:EKR.20040504145804.1:propagateDiffsToSentinelsLines (called from perfect import)
def propagateDiffsToSentinelsLines (self,
    i_lines,j_lines,fat_lines,mapping):
    
    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    << init propagateDiffsToSentinelsLines vars >>
    << copy the sentinels at the beginning of the file >>
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        << update and check the loop invariant >>
        if tag == 'equal':
            << handle 'equal' tag >>
        elif tag == 'replace':
            << handle 'replace' tag >>
        elif tag == 'delete':
            << handle 'delete' tag >>
        elif tag == 'insert':
            << handle 'insert' tag >>
        else: assert 0,"bad tag"
    << copy the sentinels at the end of the file >>
    return write_lines
#@nonl
#@+node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
# Indices into i_lines, j_lines & fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose
#@nonl
#@-node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
#@+node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
while fat_pos < mapping[0]:

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "copy initial line",fat_pos,line,
    fat_pos += 1
#@-node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
#@+node:EKR.20040504145804.4:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, delims)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], delims)[1]
#@nonl
#@-node:EKR.20040504145804.4:<< update and check the loop invariant>>
#@+node:EKR.20040504145804.5:<< handle 'equal' tag >>
# Copy the lines, including sentinels.
while fat_pos <= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)
#@nonl
#@-node:EKR.20040504145804.5:<< handle 'equal' tag >>
#@+node:EKR.20040504145804.6:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_pos < j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.6:<< handle 'replace' tag >>
#@+node:EKR.20040504145804.7:<< handle 'delete' tag >>
if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.7:<< handle 'delete' tag >>
#@+node:EKR.20040504145804.8:<< handle 'insert' tag >>
while j_pos < j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.
#@nonl
#@-node:EKR.20040504145804.8:<< handle 'insert' tag >>
#@+node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
while fat_pos < len(fat_lines):

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "Append last line",line
    fat_pos += 1
#@-node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
#@-node:EKR.20040504145804.1:propagateDiffsToSentinelsLines (called from perfect import)
#@+node:EKR.20040504150046.5:report_mismatch
def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    print '='*20
    print message
    
    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,
         
        print '='*20
    
        print lines2_message
        print '-'*20
        for line in lines2:
            print line,
#@nonl
#@-node:EKR.20040504150046.5:report_mismatch
#@+node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    >>> import leoGlobals as g
    >>> s = "a\\n \\t\\n\\t\\t \\t\\nb"
    >>> theLines = g.splitLines(s)
    >>> theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    >>> g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        stripped_line = lines[i].lstrip(" \t")
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines
#@nonl
#@-node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
#@+node:EKR.20040504160820:write_if_changed
def write_if_changed(self,lines,sourcefilename,targetfilename):
    """
    
    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.
    
    Optionally backs up the overwritten file.

    """
    
    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
        
    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            << make backup file >>
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
#@+node:EKR.20040504160820.1:<< make backup file >>
if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if testing:
        print "backup file in ", backupname
#@nonl
#@-node:EKR.20040504160820.1:<< make backup file >>
#@-node:EKR.20040504160820:write_if_changed
#@-node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files,treeType,
    perfectImport=True,testing=False,verbose=False):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)
#@nonl
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@nonl
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    << about this algorithm >>
    c = p.c ; root = p.copy()
    df = c.atFileCommands.new_df
    if testing:
        << clear all dirty bits >>
    << Assign file indices >>
    << Write root's tree to to string s >>

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 0: # For testing.
            << put the corrected fat lines in a new node >>
        << correct root's tree using write_lines >>
    if verify:
        << verify that writing the tree would produce the original file >>
#@nonl
#@+node:ekr.20040717112739:<< about this algorithm >>
@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
#@nonl
#@-node:ekr.20040717112739:<< about this algorithm >>
#@+node:ekr.20040716065356:<< clear all dirty bits >>
for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
#@nonl
#@-node:ekr.20040716065356:<< clear all dirty bits >>
#@+node:ekr.20040716064333:<< Assign file indices  >>
nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        id,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
#@nonl
#@-node:ekr.20040716064333:<< Assign file indices  >>
#@+node:ekr.20040716064333.1:<< Write root's tree to to string s >>
df.write(root,thinFile=True,toString=True)
s = df.stringOutput
if not s: return
#@-node:ekr.20040716064333.1:<< Write root's tree to to string s >>
#@+node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
#@nonl
#@-node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
#@+node:ekr.20040717113036:<< correct root's tree using write_lines >>
@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    df.correctedLines = 0
    df.targetFileName = "<perfectImport string-file>"
    df.inputFile = fo = g.fileLikeObject()
    df.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk = c.atFileCommands.scanHeader(fo,df.targetFileName)
    # To do: pass params to readEndNode.
    df.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = df.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
#@nonl
#@-node:ekr.20040717113036:<< correct root's tree using write_lines >>
#@+node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    df.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(df.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            << dump the files >>
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
#@nonl
#@+node:ekr.20040718045423:<< dump the files >>
print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j < i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k < i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
#@nonl
#@-node:ekr.20040718045423:<< dump the files >>
#@-node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
#@-node:EKR.20040506075328.2:perfectImport
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "_\\_ _(_ _)_", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:EKR.20040506075328.3:(Perfect Import)
#@+node:ekr.20040722210735:(Investigated write logic to see how it handles whitespace)
#@+node:ekr.20040722211908:Notes
@killcolor

Apparently the code already intends to strip whitespace.  However, the old code has a bug that prevents this from happening.

Warning: changing from the old to the new code will change virtually every file.  I'm not sure I want to do this.  Maybe this is where the option should be implemented?

What about blank lines in doc parts?
#@nonl
#@-node:ekr.20040722211908:Notes
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@-node:ekr.20040722210735:(Investigated write logic to see how it handles whitespace)
#@+node:ekr.20040723054701:(Fixed new bug in p.setBodyStringOrPane)
#@+node:ekr.20040723054701.1:Notes
@nocolor

A recent change omitted the call to setSelectionAreas.  This was wrong: it fails to update the body pane, so the change doesn't take.

The new code calls setSelectionAreas to update the body pane and setTextSelection to force an empty selection.
#@nonl
#@-node:ekr.20040723054701.1:Notes
#@+node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts
#@nonl
#@-node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
#@+node:ekr.20031218072017.4037:setSelectionAreas (tkinterBody)
def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)
#@nonl
#@-node:ekr.20031218072017.4037:setSelectionAreas (tkinterBody)
#@-node:ekr.20040723054701:(Fixed new bug in p.setBodyStringOrPane)
#@+node:ekr.20040723093558.2:(Created g.stripBlankLines and regularizeTrailingNewlines)
# These are the heart of a two new commands.
#@nonl
#@+node:ekr.20040723093558.1:stripBlankLines
def stripBlankLines(s):
    
    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j >= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))
            
    return ''.join(lines)
#@-node:ekr.20040723093558.1:stripBlankLines
#@+node:ekr.20040723093558:regularizeTrailingNewlines
@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):
    
    """Kind is 'asis', 'zero' or 'one'."""
    
    pass
#@nonl
#@-node:ekr.20040723093558:regularizeTrailingNewlines
#@-node:ekr.20040723093558.2:(Created g.stripBlankLines and regularizeTrailingNewlines)
#@+node:ekr.20040723094220.7:(Improved and simplified Syntax Checking commands)
#@+node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    << assert equivalence of lastVisible methods >>
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@nonl
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@nonl
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20040723094220.3:checkPythonCode
def checkPythonCode (self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking all Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@nonl
#@+node:ekr.20040723094220.4:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.4:<< print dots >>
#@-node:ekr.20040723094220.3:checkPythonCode
#@+node:ekr.20040723094220.5:checkPythonNode
def checkPythonNode (self,p,unittest=False):

    c = self
    
    h = p.headString()
    body = g.getScript(c,p.copy(),oneNodeOnly=True)
    if not body: return

    try:
        compiler.parse(body + '\n')
    except SyntaxError:
        if unittest:
            raise
        else:
            g.es("Syntax error in: %s" % h,color="blue")
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest)
#@nonl
#@-node:ekr.20040723094220.5:checkPythonNode
#@+node:ekr.20040723094220.6:tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:
        if unittest:
            raise
        else:
            g.es("Token error in %s" % headline,color="blue")
            g.es(str(msg))
            p.setMarked()

    except tabnanny.NannyNag, nag:
        if unittest:
            raise
        else:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
            p.setMarked()
        
    except:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
#@-node:ekr.20040723094220.6:tabNannyNode
#@-node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()
#@nonl
#@-node:ekr.20040412060927:c.dumpOutline
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.changed = False
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.c = c
    self.p = c.currentPosition()
    self.prevName = None
#@nonl
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 1:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    pp = self ; c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        pp.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            pp.putToken(token5tuple)
        lines = pp.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        pp.dumpLines(p,lines)
    else:
        pp.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20040711135244.10:putNormalToken
def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = t5
    name = token.tok_name[t1].lower()
    val = t2
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    # g.trace(name,repr(val))
    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        self.lines.append(''.join(a))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
        if self.prevName == "def": # A personal idiosyncracy.
            a.append(' ') # Retain the blank before '('.
        self.prevName = val
    elif name == "number":
        a.append(val)
    elif name in ("comment","string"):
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(val)
        for line in lines:
            a.append(line)
            if line and line[-1] == '\n':
                self.lines.append(''.join(a))
                self.array = []
    elif name == "errortoken":
        a.append(val)
        if val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(line,scol+1)
            ws = line[scol+1:i]
            if ws: a.append(ws)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)
#@nonl
#@-node:ekr.20040711135244.10:putNormalToken
#@+node:ekr.20040711135244.11:putOperator
def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:putOperator
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20040711135959.2:Check Outline submenu...
#@-node:ekr.20040723094220.7:(Improved and simplified Syntax Checking commands)
#@+node:ekr.20040725043937:(Simplified edit_text)
def 
#@nonl
#@+node:ekr.20040725043937.1:Notes
@killcolor

Removed v.edit_text.

p.edit_text now just returns tree.edit_text.

I did this to avoid messing with edit_text in the outlines plugin.
#@nonl
#@-node:ekr.20040725043937.1:Notes
#@+node:ekr.20040306220230.1:p.edit_text
def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)
#@nonl
#@-node:ekr.20040306220230.1:p.edit_text
#@+node:ekr.20040725044521.1:tree.edit_text
def edit_text (self,p):
    
    c = self.c
    
    if c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.getEditTextDict(p.v)
        for p2,t2 in pairs:
            if p.equal(p2):
                # g.trace("found",t2)
                return t2
        return None
    else:
        return None
#@nonl
#@-node:ekr.20040725044521.1:tree.edit_text
#@-node:ekr.20040725043937:(Simplified edit_text)
#@+node:ekr.20040723050246:(Fixed big performance bug in the read code)
#@+node:ekr.20040730090103:Notes: 
@killcolor

The problem was in g.doHook("set-mark",c=self.c,v=self).

There was a _big_ performance bug in the nodenavigator plugin.
#@nonl
#@-node:ekr.20040730090103:Notes: 
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError:
        return None
    
    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
    
    if 0: # Don't use trace here!
        if tag != "idle":
            print "doHook",tag,c

    if not g.app.config.use_plugins:
        if tag == "start1":
            g.es("Plugins disabled: use_plugins is 0",color="blue")
        return None
    elif c and c.hookFunction:
        try:
            return c.hookFunction(tag,keywords)
        except:
            g.es("exception in c.hookFunction for " + c.frame.getTitle())
    elif g.app.hookFunction:
        try:
            return g.app.hookFunction(tag,keywords)
        except:
            g.es("exception in app.hookFunction")
    else:
        import leoPlugins
        try:
            g.app.hookFunction = leoPlugins.doPlugins
            return app.hookFunction(tag,keywords)
        except:
            g.app.hookFunction = None
            g.es("exception in plugin")

    # Handle all exceptions.
    g.es_exception()
    g.app.hookError = True # Supress this function.
    g.app.idleTimeHook = False # Supress idle-time hook
    return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=True):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    if ok and atFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
try:
    self.read_only = False
    self.read_only = not os.access(fileName,os.W_OK)
    if self.read_only:
        g.es("read only: " + fileName,color="red")
except:
    if 0: # testing only: access may not exist on all platforms.
        g.es("exception getting file access")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
    # g.trace("done")
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20040723050246:(Fixed big performance bug in the read code)
#@+node:ekr.20040730061923:(Fixed undo headline problem)
# We must make sure that state is "normal" in p.setHeadStringOrHeadline.
#@nonl
#@+node:EKR.20040526090701.2:redoChangeHeadline
def redoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.newText)
    
    u.p.setHeadStringOrHeadline(u.newText)
    
    c.selectVnode(u.p)
#@nonl
#@-node:EKR.20040526090701.2:redoChangeHeadline
#@+node:EKR.20040526090701.6:undoChangeHeadline
def undoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.oldText)
    
    u.p.setHeadStringOrHeadline(u.oldText)
    
    c.selectVnode(u.p)

    
#@nonl
#@-node:EKR.20040526090701.6:undoChangeHeadline
#@+node:ekr.20040305223225:p.setHeadStringOrHeadline
def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()
#@nonl
#@-node:ekr.20040305223225:p.setHeadStringOrHeadline
#@-node:ekr.20040730061923:(Fixed undo headline problem)
#@+node:ekr.20040709053152:(Fixed bug: @thin badDirectory/name caused too much traceback)
#@+node:ekr.20040730162633:Traceback & Notes
# Solution: openWriteFile must set self.root for the exception handling logic.

http://sourceforge.net/forum/message.php?msg_id=2654109

# @thin leo/4

errors writing: C:\prog\leoCVS\leo\test\leo\4
path does not exist: C:\prog\leoCVS\leo\test\leo
exception creating path:leo/4
Unexpected exception while writing @thin leo/4

Traceback (most recent call last):
    
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 731, in write
    try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile,toString=toString,oneNodeOnly=oneNodeOnly)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4766, in write
    ok = at.openWriteFile(root,toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2740, in openWriteFile
    self.writeError("exception creating path:" + fn)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2347, in writeError
    self.root.setOrphan()
AttributeError: 'NoneType' object has no attribute 'setOrphan'
#@-node:ekr.20040730162633:Traceback & Notes
#@+node:ekr.20031218072017.2720:atFile.openWriteFile (used by both old and new code)
# Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root,toString):
    
    self.toStringFlag = toString
    self.errors = 0 # Bug fix: 6/25/04.
    self.root = root # Bug fix: 7/30/04: needed by error logic.

    try:
        self.scanAllDirectives(root)
        valid = self.errors == 0
    except:
        self.writeError("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False
        
    if valid and toString:
        self.targetFileName = self.outputFileName = "<string-file>"
        self.outputFile = g.fileLikeObject()
        self.stringOutput = ""
        return valid

    if valid:
        try:
            fn = self.targetFileName
            self.shortFileName = fn # name to use in status messages.
            self.targetFileName = g.os_path_join(self.default_directory,fn)
            self.targetFileName = g.os_path_normpath(self.targetFileName)
            path = g.os_path_dirname(self.targetFileName)
            if not path or not g.os_path_exists(path):
                self.writeError("path does not exist: " + path)
                valid = False
        except:
            self.writeError("exception creating path:" + fn)
            g.es_exception()
            valid = False

    if valid and g.os_path_exists(self.targetFileName):
        try:
            if not os.access(self.targetFileName,os.W_OK):
                self.writeError("can not create: read only: " + self.targetFileName)
                valid = False
        except:
            pass # os.access() may not exist on all platforms.
        
    if valid:
        try:
            root.clearOrphan() # Bug fix: 5/25/04.
            self.outputFileName = self.targetFileName + ".tmp"
            self.outputFile = open(self.outputFileName,'wb')
            if self.outputFile is None:
                self.writeError("can not create " + self.outputFileName)
                valid = False
        except:
            g.es("exception creating:" + self.outputFileName)
            g.es_exception()
            valid = False
            self.outputFile = None # 3/22/04

    if not valid:
        root.setOrphan()
        root.setDirty()
        self.outputFile = None # 1/29/04
    
    return valid
#@nonl
#@-node:ekr.20031218072017.2720:atFile.openWriteFile (used by both old and new code)
#@+node:ekr.20031218072017.2707:writeError
def writeError(self,message):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20031218072017.2707:writeError
#@-node:ekr.20040709053152:(Fixed bug: @thin badDirectory/name caused too much traceback)
#@+node:ekr.20040702064435:(Allow collapsed xml tags in .leo files)
#@+node:ekr.20040730165221:Request
@nocolor
@language html
http://sourceforge.net/forum/message.php?msg_id=2645776
By: billp9619

Yes this works now. However, the opposite should also be true ...that instead
of <find_string></find_string> an outside process or editor is free to change
it to <find_string/>. This currently causes Leo to fail to load the file reprting
it was looking for </find_string>.

This is original Leo xml:

@color
<preferences> 
</preferences>
<find_panel_settings>
<find_string></find_string>
<change_string></change_string>
</find_panel_settings>
@nocolor

My xml editor automatically changed it to this:

@color
<preferences/> <!-- was ok -->
<find_panel_settings>
<find_string/> <!-- now ok -->
<change_string/> <!-- now ok -->
</find_panel_settings>
@nocolor

Leo will not load the edited "/>" type empty tags. 

Both forms of empty tags should always be accepted because it is officially
identical in meaning for xml.
#@nonl
#@-node:ekr.20040730165221:Request
#@+node:ekr.20040730174218:Notes
@nocolor

- getOpenTag returns True if the end of the tag was seen. (It throws an exception if the tag isn't seen at all).

- Add comments in several places to make what getOpenTag clearer.

- getFindPanelSettings has allowed <find_panel_settings/> for some time.

- For compatibility with older versions of Leo, Leo still writes:

<find_panel_settings>
    <find_string></find_string>
    <change_string></change_string>
</find_panel_settings>

- Leo now allows the <find_string> and <change_string> tags to be collapsed.  For example,

<find_panel_settings>
    <find_string/>
    <change_string/>
</find_panel_settings>

- Changed getPrefs to allow <preferences/>

- Changed getGlobals to set reasonable defaults for <globals/>

- The <leo_file> and <globals tags must not be terminated immediately.

- Leo writes <defaultDirectory> and <TSyntaxMemo_options> tags only if there is non-empty text between the opening and closing tags, so collapsing the tags is invalid.

- Therefore, the absolutely minimal .leo file is:

@color
@language html

<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes/>
<tnodes/>
</leo_file>

@nocolor

I updated the empty_leo_file plugin to use this code.  This is also the contents test/minimalLeoFile.leo.

- The minimal .leo file that Leo might actually write is more like this:

@color

<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header/>
<globals/>
<preferences/>
<find_panel_settings>
    <find_string/>
    <change_string/>
</find_panel_settings>
<vnodes/>
<tnodes/>
</leo_file>

This is the contents of test/minimalLeoFile2.leo.
#@nonl
#@-node:ekr.20040730174218:Notes
#@+node:EKR.20040526204706.7:getOpenTag
def getOpenTag (self,tag):
    
    """
    Look ahead for collapsed tag: tag may or may not end in ">"
    Skips tag and /> if found, otherwise does not alter index.
    Returns True if the closing part was found.
    Throws BadLeoFile if the tag does not exist.
    """

    if tag[-1] == ">":
        # Only the tag itself or a collapsed tag are valid.
        if self.matchTag(tag):
            return False # Not a collapsed tag.
        elif self.matchTag(tag[:-1]):
            # It must be a collapsed tag.
            self.skipWs()
            if self.matchTag("/>"):
                return True
        print "getOpenTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
    else:
        # The tag need not be followed by "/>"
        if self.matchTag(tag):
            old_index = self.fileIndex
            self.skipWs()
            if self.matchTag("/>"):
                return True
            else:
                self.fileIndex = old_index
                return False
        else:
            print "getOpenTag(", tag, ") failed:"
            raise BadLeoFile("expecting" + tag)
#@nonl
#@-node:EKR.20040526204706.7:getOpenTag
#@+node:ekr.20031218072017.3023:getCloneWindows
# For compatibility with old file formats.

def getCloneWindows (self):

    if not self.matchTag("<clone_windows>"):
        return # <clone_windows/> seen.

    while self.matchTag("<clone_window vtag=\"V"):
        self.getLong() ; self.getDquote() ; self.getTag(">")
        if not self.getOpenTag("<global_window_position"):
            self.getTag("<global_window_position")
            self.getPosition()
            self.getTag("/>")
        self.getTag("</clone_window>")
    self.getTag("</clone_windows>")
#@nonl
#@-node:ekr.20031218072017.3023:getCloneWindows
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):

    c = self.c ; config = g.app.config ; findFrame = g.app.findFrame
    << Set defaults of all flags >>
    if not self.getOpenTag("<find_panel_settings"):
        while 1:
            if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
            elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
            elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
            elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
            elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
            elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
            elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
            elif self.matchTag("script_change="): c.script_change_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("script_search="): c.script_search_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
            elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
            elif self.matchTag("selection_only="): c.selection_only_flag = self.getDqBool() # 11/9/03
            elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
            elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
            elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
            elif self.matchTag(">"): break
            else: self.getUnknownTag() # New in 4.1: ignore all other tags.

        # # 7/31/04: Allow only <find_string> or <find_string/>
        if self.getOpenTag("<find_string>"): 
            c.find_text = ""
        else:
            c.find_text = self.getEscapedString()
            self.getTag("</find_string>")
        # 7/31/04: Allow only <change_string> or <change_string/>
        if self.getOpenTag("<change_string>"): 
            c.change_text = ""
        else:
            c.change_text = self.getEscapedString()
            self.getTag("</change_string>")
        #
        self.getTag("</find_panel_settings>")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    config.setCommandsFindIvars(c)
    # Update the settings immediately.
    if g.app.gui.guiName() == "tkinter":
        g.app.findFrame.init(c)
#@nonl
#@+node:ekr.20031218072017.2065:<< Set defaults of all flags >>
if g.app.gui.guiName() == "tkinter":

    for var in findFrame.intKeys:
        attr = "%s_flag" % (var)
        setattr(c,attr,False)
        # g.trace(attr)
#@-node:ekr.20031218072017.2065:<< Set defaults of all flags >>
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@+node:ekr.20031218072017.2306:getGlobals
def getGlobals (self):

    if self.getOpenTag("<globals"):
        # <globals/> seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag(">")

        self.getTag("<global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/>")

        self.getTag("<global_log_window_position")
        self.getPosition()
        self.getTag("/>") # no longer used.

        self.getTag("</globals>")

    # 7/15/02: Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()
#@nonl
#@-node:ekr.20031218072017.2306:getGlobals
#@+node:ekr.20031218072017.2062:getPrefs
def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("<preferences"):
        return # <preferences/> seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    while 1:
        if self.matchTag("<defaultDirectory>"):
            # New in version 0.16.
            c.tangle_directory = self.getEscapedString()
            self.getTag("</defaultDirectory>")
            if not g.os_path_exists(c.tangle_directory):
                g.es("default tangle directory not found:" + c.tangle_directory)
        elif self.matchTag("<TSyntaxMemo_options>"):
            self.getEscapedString() # ignored
            self.getTag("</TSyntaxMemo_options>")
        else: break
    self.getTag("</preferences>")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)
#@nonl
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default
#@nonl
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@-node:ekr.20040702064435:(Allow collapsed xml tags in .leo files)
#@+node:ekr.20040730191553:Fixed bug: new outline code wasn't updating cloned and joined headlines.
#@-node:ekr.20040730191553:Fixed bug: new outline code wasn't updating cloned and joined headlines.
#@+node:ekr.20040731053740.1:Check outline now checks that p.edit_text.get matches p.headString()
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    << assert equivalence of lastVisible methods >>
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@nonl
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@nonl
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@-node:ekr.20040731053740.1:Check outline now checks that p.edit_text.get matches p.headString()
#@+node:ekr.20040731055419:(Fixed problems with confirm save box)
#@+node:ekr.20040731070513:What I did
@nocolor

- Added a call to self.top.lift() in base run() method.

- Disable additional prompting dialogs if one is already open.
#@nonl
#@-node:ekr.20040731070513:What I did
#@+node:ekr.20040731070513.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2683931
By: billp9619

Using Win XP:

On closing an unsaved file with changes , a Confirm" message box pops up. The
Leo main outline is locked but this Confirm box could be underneath the
Outline...acting like an independent window(if outline receives focus again
by clicking on it, etc.) Normally applications force these type of prompts to
stay on top of the related appl. window.

The above can can be confusing.  But it can be worse.

If I right click on the Leo icon on the task bar and select "Close" (say I am
confused now), what happens is it pops up another Confirm box.

After closing ...the extra Confirm boxes are left behind with no associated
Leo outline.

Leo Log Window...
Leo 4.2 beta 2, build  1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32
#@nonl
#@-node:ekr.20040731070513.1:Report
#@+node:ekr.20031218072017.3859: class leoTkinterDialog
class leoTkinterDialog:
    """The base class for all Leo Tkinter dialogs"""
    @others
#@nonl
#@+node:ekr.20031218072017.3860:__init__ (leoDialog)
def __init__(self,title="",resizeable=True,canClose=True):
    
    """Constructor for the leoTkinterDialog class."""
    
    self.answer = None # Value returned from run()
    self.resizeable = resizeable
    self.title = title
    self.modal = None
    
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # g.app.root
    self.top = None # The toplevel Tk widget.
    self.focus_widget = None # The widget to get the first focus.
    self.canClose = canClose
#@nonl
#@-node:ekr.20031218072017.3860:__init__ (leoDialog)
#@+node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
def cancelButton(self):
    
    """Do default click action in cancel button."""
    
    self.answer="cancel"
    self.top.destroy()
    
def noButton(self):
    
    """Do default click action in no button."""
    
    self.answer="no"
    self.top.destroy()
    
def okButton(self):
    
    """Do default click action in ok button."""
    
    self.answer="ok"
    self.top.destroy()

def yesButton(self):
    
    """Do default click action in yes button."""

    self.answer="yes"
    self.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
#@+node:ekr.20031218072017.3862:center
def center(self):
    
    """Center any leoTkinterDialog."""
    
    g.app.gui.center_dialog(self.top)
#@-node:ekr.20031218072017.3862:center
#@+node:ekr.20031218072017.3863:createButtons
def createButtons (self,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)
        
        if isDefault and command:
            self.defaultButtonCommand = command
        
    return buttonList
#@nonl
#@-node:ekr.20031218072017.3863:createButtons
#@+node:ekr.20031218072017.3864:createMessageFrame
def createMessageFrame (self,message):
    
    """Create a frame containing a Tk.Label widget."""

    label = Tk.Label(self.frame,text=message)
    label.pack(pady=10)
#@-node:ekr.20031218072017.3864:createMessageFrame
#@+node:ekr.20031218072017.3865:createTopFrame
def createTopFrame(self):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    
    self.root = g.app.root

    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)

    if not self.resizeable:
        self.top.resizable(0,0) # neither height or width is resizable.

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")
    
    if not self.canClose:
        self.top.protocol("WM_DELETE_WINDOW", self.onClose)
    
    # Do this at idle time.
    def callback(top=self.top):
        g.app.gui.attachLeoIcon(top)
    
    self.top.after_idle(callback)
#@nonl
#@-node:ekr.20031218072017.3865:createTopFrame
#@+node:ekr.20040731065422:onClose
def onClose (self):
    
    """Disable all attempts to close this frame with the close box."""
    
    pass
#@nonl
#@-node:ekr.20040731065422:onClose
#@+node:ekr.20031218072017.3866:run
def run (self,modal):
    
    """Run a leoTkinterDialog."""

    self.modal = modal
    
    self.center() # Do this after all packing complete.
    self.top.lift() # 7/31/04

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        if self.focus_widget == None:
            self.focus_widget = self.top
        self.focus_widget.focus_set() # Get all keystrokes.	
        self.root.wait_window(self.top)
        return self.answer
    else:
        self.root.wait_window(self.top)
        return None
#@nonl
#@-node:ekr.20031218072017.3866:run
#@-node:ekr.20031218072017.3859: class leoTkinterDialog
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.
#@nonl
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20040731055419:(Fixed problems with confirm save box)
#@+node:ekr.20040731084117:(Fixed a recent change bug: empty change text was converted to <)
#@+node:EKR.20040526204706.7:getOpenTag
def getOpenTag (self,tag):
    
    """
    Look ahead for collapsed tag: tag may or may not end in ">"
    Skips tag and /> if found, otherwise does not alter index.
    Returns True if the closing part was found.
    Throws BadLeoFile if the tag does not exist.
    """

    if tag[-1] == ">":
        # Only the tag itself or a collapsed tag are valid.
        if self.matchTag(tag):
            return False # Not a collapsed tag.
        elif self.matchTag(tag[:-1]):
            # It must be a collapsed tag.
            self.skipWs()
            if self.matchTag("/>"):
                return True
        print "getOpenTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
    else:
        # The tag need not be followed by "/>"
        if self.matchTag(tag):
            old_index = self.fileIndex
            self.skipWs()
            if self.matchTag("/>"):
                return True
            else:
                self.fileIndex = old_index
                return False
        else:
            print "getOpenTag(", tag, ") failed:"
            raise BadLeoFile("expecting" + tag)
#@nonl
#@-node:EKR.20040526204706.7:getOpenTag
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):

    c = self.c ; config = g.app.config ; findFrame = g.app.findFrame
    << Set defaults of all flags >>
    if not self.getOpenTag("<find_panel_settings"):
        while 1:
            if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
            elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
            elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
            elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
            elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
            elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
            elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
            elif self.matchTag("script_change="): c.script_change_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("script_search="): c.script_search_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
            elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
            elif self.matchTag("selection_only="): c.selection_only_flag = self.getDqBool() # 11/9/03
            elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
            elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
            elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
            elif self.matchTag(">"): break
            else: self.getUnknownTag() # New in 4.1: ignore all other tags.

        # # 7/31/04: Allow only <find_string> or <find_string/>
        if self.getOpenTag("<find_string>"): 
            c.find_text = ""
        else:
            c.find_text = self.getEscapedString()
            self.getTag("</find_string>")
        # 7/31/04: Allow only <change_string> or <change_string/>
        if self.getOpenTag("<change_string>"): 
            c.change_text = ""
        else:
            c.change_text = self.getEscapedString()
            self.getTag("</change_string>")
        #
        self.getTag("</find_panel_settings>")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    config.setCommandsFindIvars(c)
    # Update the settings immediately.
    if g.app.gui.guiName() == "tkinter":
        g.app.findFrame.init(c)
#@nonl
#@+node:ekr.20031218072017.2065:<< Set defaults of all flags >>
if g.app.gui.guiName() == "tkinter":

    for var in findFrame.intKeys:
        attr = "%s_flag" % (var)
        setattr(c,attr,False)
        # g.trace(attr)
#@-node:ekr.20031218072017.2065:<< Set defaults of all flags >>
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@-node:ekr.20040731084117:(Fixed a recent change bug: empty change text was converted to <)
#@+node:ekr.20040630214448.1:(Improved how es_exception gets line number of errors)
#@+node:ekr.20040731082738:Notes
@killcolor

This was tricky to get correct. The aha is that we must compute line numbers for
SyntaxErrors differently from other errors.

The traceback methods are very strange in this regard. For SyntaxError's,
format_exception_only computes the line number. For all other errors, extract_tb
gives the proper line number. It took a _long_ time to figure this out...

In the end, the calculations in getLastTracebackLineNumber are fairly
straightforward. In particular, it unpacks the line number for SyntaxErrors
using code lifted directly from format_exception_only.
#@nonl
#@-node:ekr.20040731082738:Notes
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()

    if full:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        
    if 1:
        n = g.getLastTracebackLineNumber()
    else:
        # old, kludgy code...
        << look for lines containing a specific message >>

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    return n
#@nonl
#@+node:ekr.20040731211839:<< look for lines containing a specific message >>
errList = traceback.format_exception(typ,val,tb)

print ; print "es_exception (format_exception)"
for item in errList:
    print item
# Strip cruft lines.
s1 = "Traceback (most recent call last):"
s2 = "exec script in {}"
lines = []
for line in errList[-4:]:
    if n is None:
        tag = 'File "<string>", line'
        i = line.find(tag)
        if i > -1:
            << compute n from the line >>
    if not g.match(line,0,s1) and line.find(s2) == -1:
        lines.append(line)
#@nonl
#@+node:EKR.20040612223431:<< compute n from the line >>
i += len(tag)
j = line.find(',',i)
if j > i: n = line[i:j]
else:     n = line[i:].strip()
# g.trace(n)
try: n = int(n)
except (TypeError,ValueError): n = None
#@nonl
#@-node:EKR.20040612223431:<< compute n from the line >>
#@-node:ekr.20040731211839:<< look for lines containing a specific message >>
#@+node:ekr.20040731204831:getLastTracebackLineNumber
def getLastTracebackLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return lineno
        except:
            g.trace("bad line number")
            return 0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        item = data[-1]
        n = item[1]
        return n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackLineNumber
#@-node:ekr.20031218072017.3112:es_exception
#@-node:ekr.20040630214448.1:(Improved how es_exception gets line number of errors)
#@-node:ekr.20040706080316:Projects: 4.2 b3
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
