#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            << Do auto indent >>
        elif ch == '\t' and tab_width < 0:
            << convert tab to blanks >>
        elif ch in (chr(8)) and tab_width < 0:
            << handle backspace with negative tab_width >>
    << set s to widget text, removing trailing newlines if necessary >>
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (called from core)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (called from core)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char
    
    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        << update p >>
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.92:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20040803072955.92:<< set head to vnode text >>
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20031218072017.1319:(Key handlers)
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    language = c.target_language
    self.language = language # 2/2/03
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language # 2/2/03

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ã
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20040929081120:4.3 a1 projects
#@+node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20050123151628:Code
#@+node:ekr.20050106032427:(g.import wrappers return module if it is in sys.modules)
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@-node:ekr.20050106032427:(g.import wrappers return module if it is in sys.modules)
#@+node:ekr.20040226094105:(Put the scrollWheel workaround in createTkTreeCanvas)
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20040226094105:(Put the scrollWheel workaround in createTkTreeCanvas)
#@-node:ekr.20050123151628:Code
#@+node:ekr.20050104122244:Commands
#@+node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041013061250.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2802138
By: rogererens

Using Leo4.2 on WinXP, control-clicking on a section reference:
instead of going to the section definition, I get the following log message:

exception handling , hypercclick,  event
AttributeError

and in the console:

unknown position attribute: redraw
Traceback (most recent call last):
  File "C:\Leo\src\leoTkinterTree.py", line 351, in OnHyperLinkControlClick
    self.redraw()
  File "C:\Leo\src\leoNodes.py", line 1534, in __getattr__
    raise AttributeError
AttributeError

Commenting out the line
self.redraw
in onHyperLinkControlClick
seems to work, but the comment above puts some doubts on the correctness of
this adaptation.

Also, the documentation w.r.t. hyperlinks seems outdated to me, since with the
'Recent' button one can quite easily navigate backward and forward like in web
browsers.
#@-node:ekr.20041013061250.1:Report
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            # New in recycled nodes code:
            # Call self.redraw to inhibit calls to setLabelState.
            c.frame.tree.redraw()
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
        
onHyperLinkControlClick = OnHyperLinkControlClick
#@nonl
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@-node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041018190736.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2805807
By: Ivan

In baseCommands.openWith(), the case for "openType == 'os.spawnv'" appears to
be broken. The two problems I see are that it actually invokes os.spawnl, and
that it does not allow the passing of a variable length list of parameters.

@color

# Replace the body of the os.spawnv case:

filename = g.os_path_basename(arg)
command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
apply(os.spawnl,(os.P_NOWAIT,arg,filename,path)))
 
# with:
    
filename = os.path.basename(arg[0])
vtuple = arg[1:]
vtuple.append(path)
command = "os.spawnv("+arg[0]+","+`vtuple`+")"
apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))

# This requires calls on openWith like
openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
#@nonl
#@-node:ekr.20041018190736.1:Report
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the "Open With..." menu.
    openWithMenu = Tk.Menu(parent,tearoff=0)
    self.setMenu("Open With...",openWithMenu)
    parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
    # Populate the "Open With..." menu.
    shortcut_table = []
    for triple in table:
        if len(triple) == 3: # 6/22/03
            shortcut_table.append(triple)
        else:
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
            
    # for i in shortcut_table: print i
    self.createMenuItemsFromTable("Open &With...",shortcut_table,openWith=True)
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; v = c.currentVnode()
    if not data or len(data) != 3: return # 6/22/03
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=v,v=v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=v,v=v,openType=openType,arg=arg,ext=ext)
    except:
        g.es("exception in openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(v,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to v.t >>
searchPath = c.openWithTempFilePath(v,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if v == theDict.get("v") and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both v and the temp file:

- If only v's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = v.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(v,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        command = "os.system(%s)" % (arg+shortPath)
        os.system(arg+path)
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {} # 12/11/02
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        if 1: # New code allows args to spawnv.
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:] 
            vtuple.append(path)
            command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
            apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple)) # Bug fix: 1/21/05
        else:
            filename = g.os_path_basename(arg)
            command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
            apply(os.spawnv,(os.P_NOWAIT,arg,(filename,path)))
    else:
        command="bad command:"+str(openType)
    # This seems a bit redundant.
    # g.es(command)
except:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self, v, ext):
    
    c = self
    path = c.openWithTempFilePath(v,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # 3/7/03: convert s to whatever encoding is in effect.
        s = v.bodyString()
        theDict = g.scanDirectives(c,p=v)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # 4/22/03: add body and encoding entries to dict for later comparisons.
        theDict = {"body":s, "c":c, "encoding":encoding, "f":theFile, "path":path, "time":time, "v":v}
        << remove previous entry from app.openWithFiles if it exists >> # 4/22/03
        g.app.openWithFiles.append(theDict)
        return path
    except:
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]: # 6/30/03
    v2 = d.get("v")
    if v.t == v2.t:
        print "removing previous entry in g.app.openWithFiles for",v
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:openWithTempFilePath
def openWithTempFilePath (self,v,ext):
    
    """Return the path to the temp file corresponding to v and ext."""

    name = "LeoTemp_" + str(id(v.t)) + '_' + g.sanitize_filename(v.headString()) + ext
    name = g.toUnicode(name,g.app.tkEncoding) # 10/20/03

    td = g.os_path_abspath(tempfile.gettempdir())
    path = g.os_path_join(td,name)
    
    # print "openWithTempFilePath",path
    return path
#@nonl
#@-node:ekr.20031218072017.2832:openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041020104517.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2807391
By: spboulet

Running the File->Export->Remove Sentinels command on a file derived from an
@file node, I get "Can not open D" in the log window (the file is on my D partition).
I do have permission to write the file; tangling works fine.

-------

The fix was to add multiple=True in the call to g.app.gui.runOpenFileDialog in removeSentinels.

Apparently there is a Python bug in askopenfilename, but this fix avoids that.
#@nonl
#@-node:ekr.20041020104517.1:Report
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths):
    
    c = self.c

    self.setEncoding()

    for fileName in paths:

        path, self.fileName = g.os_path_split(fileName)
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        << Write s into newFileName >>
#@nonl
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@nonl
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@nonl
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@-node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20041023055452.1:Report
From Leo User

I forgot to mention that I had this happen twice today:
1. Copy node.
2. Paste Retaining Clone

...seemed to enter endless node creation loop.
#@-node:ekr.20041023055452.1:Report
#@+node:ekr.20041023055452.2:What I did
@killcolor

1. In << recreate tnodesDict >>

    - Set self.tnodesDict ={}
    - Changed all_tnodes_iter to all_unique_tnodes_iter.

2. Set self.forbiddenTnodes in get_vnodes.  Also added reassignIndices keyword param.

3. Raise invalidPaste in get_vnode if the tnode (to be generated later) would be in self.forbiddenTnodes.

3. Fixed bugs:  tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!

4. Report exceptions in getLeoOutline rather than pasteOutline.
#@nonl
#@-node:ekr.20041023055452.2:What I did
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self
    
    if 1:
        # For now, just execute the command.
        return c.pasteOutline(reassignIndices=False)

    else:
        # Paste retaining clones can't be fully undone.  Warn first.
        message = (
            'Are you sure you want to Paste As Clone?\n\n'
            'This operation can not be undone; it will clear the Undo stack.')
        
        response = g.app.gui.runAskYesNoDialog(c,'Paste As Clone?',message=message)
    
        if response == 'yes':
            val = c.pasteOutline(reassignIndices=False)
            c.undoer.clearUndoState()
            g.es('Undo stack cleared',color='red')
            return val
        else:
            return None
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; current = c.currentPosition()
    
    s = g.app.gui.getTextFromClipboard()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)

    if isLeo:
        p = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        p = c.importCommands.convertMoreStringToOutlineAfter(s,current)
        
    if p:
        c.endEditing()
        c.beginUpdate()
        if 1: # inside update...
            c.validateOutline()
            c.selectVnode(p)
            p.setDirty()
            c.setChanged(True)
            # paste as first child if back is expanded.
            back = p.back()
            if back and back.isExpanded():
                p.moveToNthChildOf(back,0)
            c.undoer.setUndoParams("Paste Node",p)
        c.endUpdate()
        c.recolor()
#@nonl
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
# This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []
    
    if not reassignIndices:
        << recreate tnodesDict >>

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("<leo_file>") # <leo_file/> is not valid.
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        v = self.finishPaste(reassignIndices)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@nonl
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)
    else:
        << set current and top positions >>

    self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
    c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@nonl
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@-node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20050101100208:(Fixed Pretty Printer code for Python 2.4)
# The '@' sign is an operator in Python 2.4, not an error token.
#@nonl
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20050101100208:(Fixed Pretty Printer code for Python 2.4)
#@+node:ekr.20050102181816:(Fixed crasher in Import Derived Files command)
#@+node:ekr.20050103111219:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918934
By: ktenney

Current CVS, Win2000
When I select leo.py to import, I get the traceback;

exception executing command
Traceback (most recent call last):
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 161, in
doCommand
    command()
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 811, in
importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\Python23\Lib\site-packages\leo\src\leoImport.py", line 129,
in importDerivedFiles
    junk,read_new,isThin = at.scanHeader(theFile,fileName)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2504,
in scanHeader
    s = at.readLine(theFile)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2469,
in readLine
    u = g.toUnicode(s,self.encoding)
AttributeError: atFile instance has no attribute 'encoding'
#@nonl
#@-node:ekr.20050103111219:Report
#@+node:ekr.20050103163633:Fix
@killcolor

What I did:
    
- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.
#@nonl
#@-node:ekr.20050103163633:Fix
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin
#@nonl
#@-node:ekr.20050103163224:scanHeaderForThin
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent,paths):
    
    c = self.c ; at = c.atFileCommands
    current = c.currentVnode()
    self.tab_width = self.getTabWidth() # New in 4.3.
    c.beginUpdate()
    
    for fileName in paths:
        << set isThin if fileName is a thin derived file >>
        v = parent.insertAfter()
        if isThin:
            v.initHeadString("@thin " + fileName)
            c.undoer.setUndoParams("Import",v,select=current)
            at.read(v,thinFile=True)
        else:
            v.initHeadString("Imported @file " + fileName)
            c.undoer.setUndoParams("Import",v,select=current)
            at.read(v,importFileName=fileName)
        c.selectVnode(v)
        v.expand()

    c.endUpdate()
#@nonl
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@nonl
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@-node:ekr.20050102181816:(Fixed crasher in Import Derived Files command)
#@+node:ekr.20050121082447:(Fixed bug in the code that executes Open With command with spawnv)
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        command = "os.system(%s)" % (arg+shortPath)
        os.system(arg+path)
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {} # 12/11/02
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        if 1: # New code allows args to spawnv.
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:] 
            vtuple.append(path)
            command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
            apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple)) # Bug fix: 1/21/05
        else:
            filename = g.os_path_basename(arg)
            command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
            apply(os.spawnv,(os.P_NOWAIT,arg,(filename,path)))
    else:
        command="bad command:"+str(openType)
    # This seems a bit redundant.
    # g.es(command)
except:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@-node:ekr.20050121082447:(Fixed bug in the code that executes Open With command with spawnv)
#@+node:ekr.20050121074152:(Fix buged: search in hoisted outline can stop outside the hoisted area)
#@+node:ekr.20050121074152.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2934617
By: bwmulder

According to various notes in the Leo documentation, "hoist" should restrict
you a subtree of the outline.

With the version I am using (CVS, a few days old), searching for strings stops
at nodes outside this subtree. The nodes where the string was found remains
invisible.
#@-node:ekr.20050121074152.1:Report
#@+node:ekr.20031218072017.2028:Hoist & dehoist & enablers
def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        c.undoer.setUndoParams("De-Hoist",p)
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        c.undoer.setUndoParams("Hoist",p)
        # New in 4.2: remember expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist & enablers
#@+node:ekr.20031218072017.3081:selectNextVnode
# Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; v = self.v

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyVnode:
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.onlyVnode = v 

    # Start wrapped searches.
    if self.wrapping and not self.wrapVnode:
        assert(self.wrapPos != None)
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.wrapVnode = v 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(v)
        return v

    if self.reverse: v = v.threadBack()
    else:            v = v.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not v:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(v):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not v and self.wrapping and not self.suboutline_only:
        v = c.rootVnode()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while v and v.next():
                v = v.next()
            if v: v = v.lastNode()

    # End wrapped searches.
    if self.wrapping and v and v == self.wrapVnode:
        # g.trace("ending wrapped search")
        v = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyVnode and v and
        (v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
        # g.trace("end outline-only")
        v = None ; self.onlyVnode = None

    # v.copy not needed because the find code never calls p.moveToX.
    # Furthermore, v might be None, so v.copy() would be wrong!
    self.v = v # used in initNextText().
    if v: # select v and set the search point within v.
        self.in_headline = self.search_headline
        self.initNextText()
    return v
#@nonl
#@-node:ekr.20031218072017.3081:selectNextVnode
#@-node:ekr.20050121074152:(Fix buged: search in hoisted outline can stop outside the hoisted area)
#@+node:ekr.20050122122437:(Fixed bugs handling @language & @comment in atFile.scanAllDirectives & g.scanDirectives)
#@+node:ekr.20050122122437.1:Report
@killcolor

Changed scanDirectives and atFile.scanDirectives so they work like tangle.scanAllDirectives.  Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 
 
So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... 
#@-node:ekr.20050122122437.1:Report
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20050122122437:(Fixed bugs handling @language & @comment in atFile.scanAllDirectives & g.scanDirectives)
#@-node:ekr.20050104122244:Commands
#@+node:ekr.20050123151628.1:Distribution
#@+node:ekr.20041022063506:(Fixed file association in leoDist.leo)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2816347
By: osuchw

I have came upon a small bug related to how *.leo files are registered to be
open with windows.

Currently the command looks like.
<pythondir>\pythonw.exe "<leodir>\src\leo.py" %1
and it should be
"<pythondir>\pythonw.exe" "<leodir>\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.
For example rst2.py plugin fails if it is called from a leo file that has spaces
in it is path.
#@-node:ekr.20041022063506:(Fixed file association in leoDist.leo)
#@-node:ekr.20050123151628.1:Distribution
#@+node:ekr.20050104122651:Menus
#@+node:ekr.20050102092149:(Fixed problems with Control-E)
#@+node:ekr.20050104084310: Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918938
By: ktenney

Any idea what might prevent the Control-E shortcut key from working?  Edit -> Execute Script works fine

current cvs, Win2000, Python 2.3
#@nonl
#@-node:ekr.20050104084310: Report
#@+node:ekr.20050104094308.1: What I did
@killcolor

- Restored non Pmw code in resizePanesToRatio.  This code got deleted by mistake.  The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.  It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo.  This overrides the default (Ctrl-E) and thereby prevents the default from overrideing the entry for ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been redefined.  Not sure if this is a wise idea, or indeed if it actually does anything :-)

I am tempted to remove all the default entries entirely.  This would simplify error reporting, but then Leo would hardly work at all if leoSettings.leo were not present.
#@nonl
#@-node:ekr.20050104094308.1: What I did
#@+node:ekr.20031218072017.3811:class nullMenu
class nullMenu(leoMenu):
    
    """A null menu class for testing and batch execution."""
    
    @others
#@nonl
#@+node:ekr.20050104094308:ctor
def __init__ (self,frame):
    
    # Init the base class.
    leoMenu.__init__(self,frame)
#@nonl
#@-node:ekr.20050104094308:ctor
#@+node:ekr.20050104094029:oops
def oops (self):

    g.trace("leoMenu", g.callerName(2))
    pass
#@nonl
#@-node:ekr.20050104094029:oops
#@+node:ekr.20050104093323:Gui-independent menu routines
def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    pass
def createMenuItemsFromTable (self,menuName,table,openWith=False):
    pass
def createMenusFromTables (self):
    pass
def defineMenuTables (self):
    pass
def createNewMenu (self,menuName,parentName="top",before=None):
    pass
def createRecentFilesMenuItems (self):
    pass
def deleteMenu (self,menuName):
    pass
def deleteMenuItem (self,itemName,menuName="top"):
    pass
def destroyMenu (self,menuName):
    pass
def getMenu (self,menuName):
    pass
def setMenu (self,menuName,menu):
    pass
#@nonl
#@-node:ekr.20050104093323:Gui-independent menu routines
#@+node:ekr.20050104092958:Gui-independent menu enablers
def updateAllMenus (self):
    pass
def updateEditMenu (self):
    pass
def updateFileMenu (self):
    pass
def updateOutlineMenu (self):
    pass
#@nonl
#@-node:ekr.20050104092958:Gui-independent menu enablers
#@-node:ekr.20031218072017.3811:class nullMenu
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3752:defineMenuTables
def defineMenuTables (self):
    
    c = self.c ; f = self.frame
    
    # g.trace(c.shortFileName(),self,f)
    
    << define edit menu tables >>
    << define file menu tables >>
    << define outline menu tables >>
    << define window menu tables >>
    << define help menu tables >>
#@nonl
#@+node:ekr.20031218072017.3753:<< define edit menu tables >>
<< define editMenuTopTable >>
<< define editMenuEditBodyTable >>
<< define editMenuEditHeadlineTable >>
<< define editMenuFindMenuTable >>
<< define editMenuTop2Table >>
#@nonl
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
    ("-",None,None),
    ("Cu&t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&y","Ctrl+C",f.OnCopyFromMenu),
    ("&Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&Delete",None,c.delete),
    ("Select &All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
    
# Top-level shortcuts here:  a,d,p,t,u,y,z
# Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
self.editMenuEditBodyTable = (
    ("Extract &Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&lanks",None,c.convertAllBlanks),
    ("Convert All T&abs",None,c.convertAllTabs),
    ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&Indent","Ctrl+]",c.indentBody),
    ("&Unindent","Ctrl+[",c.dedentBody),
    ("&Match Brackets","Ctrl+K",c.findMatchingBracket))
#@nonl
#@-node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
#@+node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
self.editMenuEditHeadlineTable = (
    ("Edit &Headline","Ctrl+H",c.editHeadline),
    ("&End Edit Headline","Escape",f.endEditLabelCommand),
    ("&Abort Edit Headline","Shift+Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))
#@nonl
#@-node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
#@+node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
self.editMenuFindMenuTable = (
    ("&Find Panel","Ctrl+F",c.showFindPanel),
    ("-",None,None),
    ("Find &Next","F3",c.findNext),
    ("Find &Previous","F4",c.findPrevious),
    ("&Replace","Ctrl+=",c.replace),
    ("Replace, &Then Find","Ctrl+-",c.replaceThenFind))
#@nonl
#@-node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
#@+node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&visibles","Show In&visibles")
    
self.editMenuTop2Table = (
    ("&Go To Line Number","Alt+G",c.goToLineNumber),
    ("&Execute Script","Alt+Shift+E",c.executeScript),
    # ("Set Fon&t...",None,c.fontPanel), # To be replaced by general settings dialog.
    # ("Set &Colors...",None,c.colorPanel), # To be replaced by general settings dialog.
    (label,"Alt+V",c.viewAllCharacters),
    # ("-",None,None),
    ("Setti&ngs",None,c.preferences)
)

# Top-level shortcuts earlier: a,d,p,t,u,y,z
# Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
#@-node:ekr.20031218072017.3753:<< define edit menu tables >>
#@+node:ekr.20031218072017.3758:<< define file menu tables >>
<< define fileMenuTopTable >>
<< define fileMenuTop2Table >>
<< define fileMenuReadWriteMenuTable >>
<< define fileMenuTangleMenuTable >>
<< define fileMenuUntangleMenuTable >>
<< define fileMenuImportMenuTable >>
<< define fileMenuExportMenuTable >>
<< define fileMenuTop3MenuTable >>
#@nonl
#@+node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
self.fileMenuTopTable = (
    ("&New","Ctrl+N",c.new),
    ("&Open...","Ctrl+O",c.open))
#@nonl
#@-node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
#@+node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
self.fileMenuTop2Table = (
    ("-",None,None),
    ("&Close","Ctrl+W",c.close),
    ("&Save","Ctrl+S",c.save),
    ("Save &As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &Tangle
    ("Re&vert To Saved",None,c.revert)) # &Read/Write
#@nonl
#@-node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
#@+node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
self.fileMenuReadWriteMenuTable = (
    ("&Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes))
#@nonl
#@-node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
#@+node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
self.fileMenuTangleMenuTable = (
    ("Tangle &All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&Tangle","Shift+Ctrl+T",c.tangle))
#@nonl
#@-node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
#@+node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
self.fileMenuUntangleMenuTable = (
    ("Untangle &All",None,c.untangleAll),
    ("Untangle &Marked",None,c.untangleMarked),
    ("&Untangle","Shift+Ctrl+U",c.untangle))
#@nonl
#@-node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
#@+node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&root",None,c.importAtRoot),
    ("Import &CWEB Files",None,c.importCWEBFiles),
    
    ("Import &noweb Files",None,c.importNowebFiles),
    ("Import Flattened &Outline",None,c.importFlattenedOutline))
#@nonl
#@-node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
#@+node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
self.fileMenuExportMenuTable = [
    ("Export &Headlines",None,c.exportHeadlines),
    ("Outline To &CWEB",None,c.outlineToCWEB),
    ("Outline To &Noweb",None,c.outlineToNoweb),
    ("&Flatten Outline",None,c.flattenOutline),
    ("&Remove Sentinels",None,c.removeSentinels),
    ("&Weave",None,c.weave)]
#@nonl
#@-node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
#@+node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
self.fileMenuTop3MenuTable = (
    ("E&xit","Ctrl+Q",g.app.onQuit),)
#@nonl
#@-node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
#@-node:ekr.20031218072017.3758:<< define file menu tables >>
#@+node:ekr.20031218072017.3767:<< define outline menu tables >>
<< define outlineMenuTopMenuTable >>
<< define outlineMenuCheckOutlineMenuTable >>
<< define outlineMenuExpandContractMenuTable >>
<< define outlineMenuMoveMenuTable >>
<< define outlineMenuMarkMenuTable >>
<< define outlineMenuGoToMenuTable >>
#@nonl
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste Node &As Clone",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,k,m,n,o,p,s,u
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
self.outlineMenuCheckOutlineMenuTable = (

    ("Check &Outline",None,c.checkOutline),
    ("&Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &All Python Code",None,c.checkAllPythonCode),
    ("&Check Python &Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
self.outlineMenuMoveMenuTable = (
    ("Move &Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &Right","Ctrl+R",c.moveOutlineRight),
    ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&Promote","Ctrl+{",c.promote),
    ("&Demote", "Ctrl+}",c.demote))
#@nonl
#@-node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
#@+node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
self.outlineMenuMarkMenuTable = (
    ("&Mark","Ctrl+M",c.markHeadline),
    ("Mark &Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
    ("Mark &Clones","Alt+K",c.markClones),
    ("&Unmark All","Alt+U",c.unmarkAll))
#@nonl
#@-node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
#@+node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&isible","Alt+UpArrow",c.selectVisBack),
    ("Go To Next &Visible","Alt+DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt+Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt+Shift+DnArrow",c.selectThreadNext))
#@nonl
#@-node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
#@-node:ekr.20031218072017.3767:<< define outline menu tables >>
#@+node:ekr.20031218072017.3773:<< define window menu tables >>
self.windowMenuTopTable = (
    ("&Equal Sized Panes","Ctrl+E",f.equalSizedPanes),
    ("Toggle &Active Pane","Ctrl+T",f.toggleActivePane),
    ("Toggle &Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&de",None,f.cascade),
    ("&Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &Compare Window",None,c.openCompareWindow),
    ("Open &Python Window","Alt+P",c.openPythonWindow))
#@nonl
#@-node:ekr.20031218072017.3773:<< define window menu tables >>
#@+node:ekr.20031218072017.3774:<< define help menu tables >>
self.helpMenuTopTable = (
    ("&About Leo...",None,c.about),
    ("Online &Home Page",None,c.leoHome),
    ("Open Online &Tutorial",None,c.leoTutorial),
)
    
self.helpMenuTop2Table = (
    ("Open &Offline Tutorial",None,f.leoHelp),
)
    
self.helpMenuTop3Table = (
    ("-",None,None),
    ("Open Leo&Docs.leo",None,c.leoDocumentation),
    ("Open Leo&Plugins.leo",None,c.leoPlugins),
    ("Open Leo&Settings.leo",None,c.leoConfig),
)
#@nonl
#@-node:ekr.20031218072017.3774:<< define help menu tables >>
#@-node:ekr.20031218072017.3752:defineMenuTables
#@+node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)
    
def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20031218072017.2098:canonicalizeShortcut
@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") >= 0     or s.find("command") >= 0 # 11/18/03
    has_ctrl  = s.find("control") >= 0 or s.find("ctrl") >= 0
    has_alt   = s.find("alt") >= 0
    has_shift = s.find("shift") >= 0   or s.find("shft") >= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    << set the last field, preserving case >>
    << canonicalize the last field >>
    << synthesize the shortcuts from the information >>
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut
#@nonl
#@+node:ekr.20031218072017.2102:<< set the last field, preserving case >>
s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) > 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None
#@nonl
#@-node:ekr.20031218072017.2102:<< set the last field, preserving case >>
#@+node:ekr.20031218072017.2099:<< canonicalize the last field >>
bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        << define dict of Tk bind names >>
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) > 0:
    << define dict of special names >>
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]
#@nonl
#@+node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
# These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "<" : "less",
    "=" : "equal",
    ">" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }
#@nonl
#@-node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
#@+node:ekr.20031218072017.2101:<< define dict of special names >>
# These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20031218072017.2101:<< define dict of special names >>
#@-node:ekr.20031218072017.2099:<< canonicalize the last field >>
#@+node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) > 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "<" + bind_head + bind_last + ">"
menu_shortcut = menu_head + menu_last
#@nonl
#@-node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
#@-node:ekr.20031218072017.2098:canonicalizeShortcut
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                << handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.3784:createMenuItemsFromTable
def createMenuItemsFromTable (self,menuName,table,openWith=False):
    
    try:
        menu = self.getMenu(menuName)
        if menu == None:
            print "menu does not exist: ",menuName
            g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,openWith)
    except:
        s = "exception creating items for %s menu" % menuName
        print s ; g.es(s)
        g.es_exception()
        
    g.app.menuWarningsGiven = True
#@nonl
#@-node:ekr.20031218072017.3784:createMenuItemsFromTable
#@+node:ekr.20031218072017.3785:createMenusFromTables
def createMenusFromTables (self):

    c = self.c
    << create the file menu >>
    << create the edit menu >>
    << create the outline menu >>
    g.doHook("create-optional-menus",c=c)
    << create the window menu >>
    << create the help menu >>
#@nonl
#@+node:ekr.20031218072017.3790:<< create the file menu >>
fileMenu = self.createNewMenu("&File")

self.createMenuEntries(fileMenu,self.fileMenuTopTable,init=True)
self.createNewMenu("Open &With...","File")
self.createMenuEntries(fileMenu,self.fileMenuTop2Table,init=True)
<< create the recent files submenu >>
self.add_separator(fileMenu)
<< create the read/write submenu >>
<< create the tangle submenu >>
<< create the untangle submenu >>
<< create the import submenu >>
<< create the export submenu >>
self.add_separator(fileMenu)
self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable,init=True)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:<< create the file menu >>
#@+node:ekr.20031218072017.3786:<< create the edit menu >>
editMenu = self.createNewMenu("&Edit")

self.createMenuEntries(editMenu,self.editMenuTopTable,init=True)

<< create the edit body submenu >>
<< create the edit headline submenu >>
<< create the find submenu >>

self.createMenuEntries(editMenu,self.editMenuTop2Table,init=True)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:<< create the edit menu >>
#@+node:ekr.20031218072017.3797:<< create the outline menu >>
outlineMenu = self.createNewMenu("&Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable,init=True)

<< create check submenu >>
<< create expand/contract submenu >>
<< create move submenu >>
<< create mark submenu >>
<< create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable,init=True)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("&Expand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:<< create the outline menu >>
#@+node:ekr.20031218072017.3802:<< create the window menu >>
windowMenu = self.createNewMenu("&Window")

self.createMenuEntries(windowMenu,self.windowMenuTopTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3802:<< create the window menu >>
#@+node:ekr.20031218072017.3803:<< create the help menu >>
helpMenu = self.createNewMenu("&Help")

self.createMenuEntries(helpMenu,self.helpMenuTopTable,init=True)

if sys.platform=="win32":
    self.createMenuEntries(helpMenu,self.helpMenuTop2Table,init=True)

self.createMenuEntries(helpMenu,self.helpMenuTop3Table,init=True)
#@nonl
#@-node:ekr.20031218072017.3803:<< create the help menu >>
#@-node:ekr.20031218072017.3785:createMenusFromTables
#@+node:ekr.20031218072017.3804:createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName)
        
        if 0: # 11/13/03: Allow parent to be None.
            if parent == None:
                g.es("unknown parent menu: " + parentName)
                return None

        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.3804:createNewMenu
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):
    
    c = self.c ; frame = c.frame
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name): # 12/9/03
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1
#@nonl
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@+node:ekr.20031218072017.3805:deleteMenu
def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3805:deleteMenu
#@+node:ekr.20031218072017.3806:deleteMenuItem
def deleteMenuItem (self,itemName,menuName="top"):
    
    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3806:deleteMenuItem
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@nonl
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@-node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@nonl
#@-node:ekr.20041228063406:clearAccel
#@-node:ekr.20050102092149:(Fixed problems with Control-E)
#@-node:ekr.20050104122651:Menus
#@+node:ekr.20050104122244.1:Nodes
#@+node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041001075258:Traceback
exception executing command
Traceback (most recent call last):

File "C:\prog\leoCVS\leo\src\leoNodes.py", line 3044, in moveToParent
if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'
#@nonl
#@-node:ekr.20041001075258:Traceback
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p # 10/30/04

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@-node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041215102907:(Removed invalid assert in lastVisible)
# Leo looped after this assert failed.
#@nonl
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    if 0: # This assert is invalid.
        assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@-node:ekr.20041215102907:(Removed invalid assert in lastVisible)
#@-node:ekr.20050104122244.1:Nodes
#@+node:ekr.20050104122244.2:Files
#@+node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041017050700:This file wasn't being read correctly
@language c

/*@+leo-ver=4*/
/*@+node:@file cat.c*/

/*@@language C*/
#ifdef COMMENT
/*@@comment /* */*/
#endif /* COMMENT */
/*@@path C:\Vlib\Src*/
/*@@tabwidth 4*/
/*@@markup wiki*/


/*@+doc*/
/*
 * Copies STDIN to STDOUT.
 * The basis for all filters.
*/
/*@-doc*/
/*@@code*/
/*@<< Header >>*/
/*@+node:<< Header >>*/

#include <stdio.h>
#include <easy.h>

void filecopy(FILE *fp);
/*@-node:<< Header >>*/
/*@nl*/
/*@<< Main >>*/
/*@+node:<< Main >>*/

void main(int argc, char *argv[])
begin
FILE *fp,
    *fopen();

   if(argc == 1) then
      filecopy(stdin);
   orelse
      while(--argc > 0)
      begin
         if((fp = fopen(*++argv, "r")) == NULL) then
            fprintf( stderr,"cat: can't open %s\n", *argv);
            exit(1);
         orelse
            filecopy(fp);
            fclose(fp);
         endif
      endwhile
   endif
   exit(0);
end
/*@-node:<< Main >>*/
/*@nl*/
/*@<< File Copy >>*/
/*@+node:<< File Copy >>*/

void filecopy(FILE *fp)
begin
int c;
   while( (c = getc(fp)) != EOF)
      putc(c, stdout);
end
/*@-node:<< File Copy >>*/
/*@nl*/
/*@-node:@file cat.c*/
/*@-leo*/
#@-node:ekr.20041017050700:This file wasn't being read correctly
#@+node:ekr.20041017094552:Posting re POSSIBLE fix
@nocolor

I think I have found the problem.   The readDirective method is changing the comment delimiters as the result of seeing the sentinels corresponding to @language or @comment directives.

But in general this makes no sense!  Comment delimiters should be set once and for all in the @+leo sentinel: there is no compiler in the world that tolerates mixed comment delimiters.  BTW, the way to set javascript "inner" comments is to use @delims, not @comment.  N.B.  The @language and @comment delimiters _will_ have an effect, and that effect is in the _write_ logic, not the read logic.  The effect is to set the comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective, like this:

@color

if 0: # New in 4.2.1: never change comment delims here...
....if g.match_word(s,i,"@language"):
........<< handle @language >>
....elif g.match_word(s,i,"@comment"):
........<< handle @comment >>

@nocolor

Does anyone have any idea why it may have been useful?

I'm kinda freaked out by this.  The number of file reading and writing options in the various versions of Leo has definitely passed the point at which I can understand them all myself.  Fortunately (I think), the new atFile code has simplified matters.

I just hope that the transition to the new code isn't going to be too painful.  Leo now requires gnx's for all nodes, which is a step in the right direction.  Alas, Leo actually doesn't read thin derived files that were written with gnx's disabled.  My _guess_ is that this has always been a hole in the read logic and that hardly anyone fell into the hole because use_gnx was the default.  The new code plugs this code by making sure all nodes get written with gnx's.

In short, my advice is to comment out the code as shown above and see what happens. This is a _speculative_ fix, although all unit tests pass (so much for unit tests :-)  Please let me know if this "fix" causes problems.  If so, the problems should tell me what, if anything, I was thinking about when I wrote the code above ;-)
#@nonl
#@-node:ekr.20041017094552:Posting re POSSIBLE fix
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019080519:what I did
@killcolor

- Added g.app.failedPlugins list.
- Added moduleName arg to g.cantImport.
- Removed redundant print from cantImport.
- cantImport only writes one failure message per named plugin.
#@nonl
#@-node:ekr.20041019080519:what I did
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@-node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041019085841.1:What I did
@killcolor 

The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding  to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.
#@nonl
#@-node:ekr.20041019085841.1:What I did
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041020101401.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2813280
By: e

@file-nosent has sentinals.

The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.

Like this:

at.initWriteIvars(root,at.targetFileName,
    nosentinels=nosentinels,thinFile=thinFile,
    scriptWrite=scriptWrite,toString=toString)
#@-node:ekr.20041020101401.1:Report
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.4:class atFile
class atFile:
    
    << define class constants >>
    << define sentinelDict >>
    
    """The class implementing the atFile subcommander."""

    @others
#@nonl
#@+node:ekr.20041005105605.5:<< define class constants >>
# These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @<space> or @<newline>
codeDirective	  =  5 # @code
cDirective		    =  6 # @c<space> or @c<newline>
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
endAt			 = 21 # @-at
endBody			 = 22 # @-body
# not used   = 23
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @< < ... > >
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)
#@nonl
#@-node:ekr.20041005105605.5:<< define class constants >>
#@+node:ekr.20041005105605.6:<< define sentinelDict >>
sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}
#@nonl
#@-node:ekr.20041005105605.6:<< define sentinelDict >>
#@+node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.

    << define the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@nonl
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20041005105605.10:initCommonIvars
def initCommonIvars (self):
    
    """Init ivars common to both reading and writing.
    
    The defaults set here may be changed later."""
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    c = self.c
    
    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict

    << set defaults for arguments and options >>
    << init common ivars >>
#@nonl
#@+node:ekr.20041005105605.11:<< set defaults for arguments and options >>
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
#@nonl
#@-node:ekr.20041005105605.11:<< set defaults for arguments and options >>
#@+node:ekr.20041005105605.12:<< init common ivars >>
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
#@nonl
#@-node:ekr.20041005105605.12:<< init common ivars >>
#@-node:ekr.20041005105605.10:initCommonIvars
#@+node:ekr.20041005105605.13:initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    thinFile=False):
        
    importing = importFileName is not None

    self.initCommonIvars()
    
    << init ivars for reading >>
    
    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = thinFile
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.cloneSibCount = 0 # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.out = None
self.outStack = []
self.tnodeList = []
self.tnodeListIndex = 0
self.t = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@-node:ekr.20041005105605.13:initReadIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.18:Reading (top level)
@

All reading happens in the readOpenFile logic, so plugins should need to
override only this method.
#@nonl
#@+node:ekr.20041005105605.19:openFileForReading
def openFileForReading(self,fileName,fromString=False):
    
    at = self
    
    if fromString:
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_join(at.default_directory,fileName)
        fn = g.os_path_normpath(fn)
        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            at.inputFile = self.openForRead(fn,'rb') #bwm
            << warn on read-only file >>
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
#@nonl
#@+node:ekr.20041005105605.20:<< warn on read-only file >>
# os.access() may not exist on all platforms.
try:
    read_only = not os.access(fn,os.W_OK)
except AttributeError:
    read_only = False 
    
if read_only:
    g.es("read only: " + fn,color="red")
#@nonl
#@-node:ekr.20041005105605.20:<< warn on read-only file >>
#@-node:ekr.20041005105605.19:openFileForReading
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.26:readAll
def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20041005105605.26:readAll
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@nonl
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:bwmulder.20041231170726:openForRead
def openForRead(self, *args, **kw):
    """
    Hook for the mod_shadow plugin.
    """
    return open(*args, **kw)
#@nonl
#@-node:bwmulder.20041231170726:openForRead
#@+node:bwmulder.20050101094804:openForWrite
def openForWrite(self, *args, **kw):
    """
    Hook for the mod_shadow plugin
    """
    return open(*args, **kw)

#@-node:bwmulder.20050101094804:openForWrite
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin
#@nonl
#@-node:ekr.20050103163224:scanHeaderForThin
#@-node:ekr.20041005105605.18:Reading (top level)
#@+node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.30:createNthChild3
@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild3(self,n,parent,headline):
    
    """Create the nth child of the parent."""

    at = self
    assert(n > 0)
    
    if at.importing:
        return at.createImportedNode(at.root,at.c,headline)

    # Create any needed dummy children.
    dummies = n - parent.numberOfChildren() - 1
    if dummies > 0:
        if 0: # CVS produces to many errors for this to be useful.
            g.es("dummy created")
        at.errors += 1
    while dummies > 0:
        dummies -= 1
        dummy = parent.insertAsLastChild(leoNodes.tnode())
        # The user should never see this headline.
        dummy.initHeadString("Dummy")

    if n <= parent.numberOfChildren():
        << check the headlines >>
    else:
        # This is using a dummy; we should already have bumped errors.
        result = parent.insertAsLastChild(leoNodes.tnode())
    result.initHeadString(headline)
    
    result.setVisited() # Suppress all other errors for this node.
    result.t.setVisited() # Suppress warnings about unvisited nodes.
    return result
#@nonl
#@+node:ekr.20041005105605.31:<< check the headlines >>
# 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
    start = at.startSentinelComment
    end = at.endSentinelComment
    if end and len(end) > 0:
        # 1/25/03: The kludgy fix.
        # Compare the headlines without the delims.
        h1 =   headline.replace(start,"").replace(end,"")
        h2 = resulthead.replace(start,"").replace(end,"")
        if h1.strip() == h2.strip():
            # 1/25/03: Another kludge: use the headline from the outline, not the derived file.
            headline = resulthead
        else:
            at.errors += 1
    else:
        at.errors += 1
#@-node:ekr.20041005105605.31:<< check the headlines >>
#@-node:ekr.20041005105605.30:createNthChild3
#@+node:ekr.20041005105605.32:handleLinesFollowingSentinel
def handleLinesFollowingSentinel (self,lines,sentinel,comments = True):
    
    """convert lines following a sentinel to a single line"""
    
    at = self
    m = " following" + sentinel + " sentinel"
    start = at.startSentinelComment
    end   = at.endSentinelComment
    
    if len(lines) == 1: # The expected case.
        s = lines[0]
    elif len(lines) == 5:
        at.readError("potential cvs conflict" + m)
        s = lines[1]
        g.es("using " + s)
    else:
        at.readError("unexpected lines" + m)
        g.es(len(lines), " lines" + m)
        s = "bad " + sentinel
        if comments: s = start + ' ' + s

    if comments:
        << remove the comment delims from s >>
        
    # Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
    if start[-1:] == '@':
        s = s.replace('@@','@')

    return s
#@nonl
#@+node:ekr.20041005105605.33:<< remove the comment delims from s >>
# Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if g.match(s,0,comment):
    s = s[len(comment):]
else:
    at.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
    s = string.strip(s[:-1])
else:
    k = s.rfind(end)
    s = string.strip(s[:k]) # works even if k == -1
#@nonl
#@-node:ekr.20041005105605.33:<< remove the comment delims from s >>
#@-node:ekr.20041005105605.32:handleLinesFollowingSentinel
#@+node:ekr.20041005105605.34:readLinesToNextSentinel
# We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,theFile):
    
    """	read lines following multiline sentinels"""
    
    at = self
    lines = []
    start = at.startSentinelComment + '@ '
    nextLine = at.readLine(theFile)
    while nextLine and len(nextLine) > 0:
        if len(lines) == 0:
            lines.append(nextLine)
            nextLine = at.readLine(theFile)
        else:
            # 5/1/03: looser test then calling sentinelKind3.
            s = nextLine ; i = g.skip_ws(s,0)
            if g.match(s,i,start):
                lines.append(nextLine)
                nextLine = at.readLine(theFile)
            else: break

    return nextLine,lines
#@nonl
#@-node:ekr.20041005105605.34:readLinesToNextSentinel
#@+node:ekr.20041005105605.35:scanDoc3
# Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc3(self,theFile,s,i,out,kind):
    
    at = self
    endKind = g.choose(kind ==at.startDoc,at.endDoc,at.endAt)
    single = len(at.endSentinelComment) == 0
    << Skip the opening sentinel >>
    << Skip an opening block delim >>
    nextLine = None ; kind = at.noSentinel
    while len(s) > 0:
        << set kind, nextLine >>
        if kind == endKind: break
        << Skip the leading stuff >>
        << Append s to out >>
        if nextLine:
            s = nextLine ; nextLine = None
        else: s = at.readLine(theFile)
    if kind != endKind:
        at.readError("Missing " + at.sentinelName(endKind) + " sentinel")
    << Remove a closing block delim from out >>
#@nonl
#@+node:ekr.20041005105605.36:<< Skip the opening sentinel >>
assert(g.match(s,i,g.choose(kind == at.startDoc, "+doc", "+at")))

out.append(g.choose(kind == at.startDoc, "@doc", "@"))
s = at.readLine(theFile)
#@-node:ekr.20041005105605.36:<< Skip the opening sentinel >>
#@+node:ekr.20041005105605.37:<< Skip an opening block delim >>
if not single:
    j = g.skip_ws(s,0)
    if g.match(s,j,at.startSentinelComment):
        s = at.readLine(theFile)
#@nonl
#@-node:ekr.20041005105605.37:<< Skip an opening block delim >>
#@+node:ekr.20041005105605.38:<< set kind, nextLine >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    j = g.skip_ws(s,0)
    blankLine = s[j] == '\n'
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
    if blankLine and nextKind == endKind:
        kind = endKind # stop the scan now
#@-node:ekr.20041005105605.38:<< set kind, nextLine >>
#@+node:ekr.20041005105605.39:<< Skip the leading stuff >>
# Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0, at.indent)
#@-node:ekr.20041005105605.39:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.40:<< Append s to out >>
# Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    out.append(line + '\n')
else:
    # trailing whitespace: the newline is not real.
    out.append(line)
#@-node:ekr.20041005105605.40:<< Append s to out >>
#@+node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
# This code will typically only be executed for HTML files.

if not single:

    delim = at.endSentinelComment
    n = len(delim)
    
    # Remove delim and possible a leading newline.
    s = string.join(out,"")
    s = s.rstrip()
    if s[-n:] == delim:
        s = s[:-n]
    if s[-1] == '\n':
        s = s[:-1]
        
    # Rewrite out in place.
    del out[:]
    out.append(s)
#@-node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
#@-node:ekr.20041005105605.35:scanDoc3
#@+node:ekr.20041005105605.42:scanText3
def scanText3 (self,theFile,p,out,endSentinelKind,nextLine=None):
    
    """Scan a 3.x derived file recursively."""

    at = self
    lastLines = [] # The lines after @-leo
    lineIndent = 0 ; linep = 0 # Changed only for sentinels.
    while 1:
        << put the next line into s >>
        << set kind, nextKind >>
        if kind != at.noSentinel:
            << set lineIndent, linep and leading_ws >>
            i = at.skipSentinelStart3(s,0)
        << handle the line in s >>
    << handle unexpected end of text >>
    assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
    return lastLines # We get here only if there are problems.
#@nonl
#@+node:ekr.20041005105605.43:<< put the next line into s >>
if nextLine:
    s = nextLine ; nextLine = None
else:
    s = at.readLine(theFile)
    if len(s) == 0: break
#@nonl
#@-node:ekr.20041005105605.43:<< put the next line into s >>
#@+node:ekr.20041005105605.44:<< set kind, nextKind >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
else:
    nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText3 returns.
#@nonl
#@-node:ekr.20041005105605.44:<< set kind, nextKind >>
#@+node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if at.raw: # 10/15/02
    linep =0
else:
    linep = at.skipIndent(s,0,at.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i < len(s):
    if s[i] == '\t': lineIndent += (abs(at.tab_width) - (lineIndent % abs(at.tab_width)))
    elif s[i] == ' ': lineIndent += 1
    else: break
    i += 1
# g.trace("lineIndent,s:",lineIndent,s)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]
#@nonl
#@-node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
#@+node:ekr.20041005105605.46:<< handle the line in s >>
if kind == at.noSentinel:
    << append non-sentinel line >>
<< handle common sentinels >>
<< handle rare sentinels >>
else:
    << warn about unknown sentinel >>
#@nonl
#@+node:ekr.20041005105605.47:<< append non-sentinel line >>
# We don't output the trailing newline if the next line is a sentinel.
if at.raw: # 10/15/02
    i = 0
else:
    i = at.skipIndent(s,0,at.indent)

assert(nextLine != None)

if nextKind == at.noSentinel:
    line = s[i:]
    out.append(line)
else:
    line = s[i:-1] # don't output the newline
    out.append(line)
#@-node:ekr.20041005105605.47:<< append non-sentinel line >>
#@+node:ekr.20041005105605.48:<< handle common sentinels >>
elif kind in (at.endAt, at.endBody,at.endDoc,at.endLeo,at.endNode,at.endOthers):
        << handle an ending sentinel >>
elif kind == at.startBody:
    << scan @+body >>
elif kind == at.startNode:
    << scan @+node >>
elif kind == at.startRef:
    << scan old ref >>
elif kind == at.startAt:
    << scan @+at >>
elif kind == at.startDoc:
    << scan @+doc >>
elif kind == at.startOthers:
    << scan @+others >>
#@nonl
#@+node:ekr.20041005105605.49:<< handle an ending sentinel >>
# g.trace("end sentinel:", at.sentinelName(kind))

if kind == endSentinelKind:
    if kind == at.endLeo:
        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(theFile)
            if len(s) == 0: break
            lastLines.append(s) # Capture all trailing lines, even if empty.
    elif kind == at.endBody:
        at.raw = False
    # nextLine != None only if we have a non-sentinel line.
    # Therefore, nextLine == None whenever scanText3 returns.
    assert(nextLine==None)
    return lastLines # End the call to scanText3.
else:
    # Tell of the structure error.
    name = at.sentinelName(kind)
    expect = at.sentinelName(endSentinelKind)
    at.readError("Ignoring " + name + " sentinel.  Expecting " + expect)
#@nonl
#@-node:ekr.20041005105605.49:<< handle an ending sentinel >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@nonl
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.51:<< scan @+node >>
assert(g.match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
<< Set childIndex >>
<< Set cloneIndex >>
headline = ""
<< Set headline and ref >>

# print childIndex,headline

if childIndex == 0: # The root node.
    if not at.importing:
        << Check the filename in the sentinel >>
    # Put the text of the root node in the current node.
    at.scanText3(theFile,p,out,at.endNode)
    p.v.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("clone index:",cloneIndex,p)
else:
    # NB: this call to createNthChild3 is the bottleneck!
    child = at.createNthChild3(childIndex,p,headline)
    child.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("cloneIndex,child:"cloneIndex,child)
    at.scanText3(theFile,child,out,at.endNode)

<< look for sentinels that may follow a reference >>
#@nonl
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i] in string.digits:
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@nonl
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20041005105605.53:<< Set cloneIndex >>
while i < len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i < len(s) and s[i] in string.digits:
            i += 1
        if j < i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
#@nonl
#@-node:ekr.20041005105605.53:<< Set cloneIndex >>
#@+node:ekr.20041005105605.54:<< Set headline and ref >>
# Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    # 10/24/02: search from the right, not the left.
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1
    
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')

# Set reference if it exists.
i = g.skip_ws(s,i)

if 0: # no longer used
    if g.match(s,i,"<<"):
        k = s.find(">>",i)
        if k != -1: ref = s[i:k+2]
#@nonl
#@-node:ekr.20041005105605.54:<< Set headline and ref >>
#@+node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
h = headline.strip()

if h[:5] == "@file":
    i,junk,junk = g.scanAtFileOptions(h)
    fileName = string.strip(h[i:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
    fileName = string.strip(h[8:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
else:
    at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
#@+node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
s = at.readLine(theFile)
kind = at.sentinelKind3(s)

if len(s) > 1 and kind == at.startVerbatimAfterRef:
    s = at.readLine(theFile)
    # g.trace("verbatim:",repr(s))
    out.append(s)
elif len(s) > 1 and at.sentinelKind3(s) == at.noSentinel:
    out.append(s)
else:
    nextLine = s # Handle the sentinel or blank line later.

#@-node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
#@-node:ekr.20041005105605.51:<< scan @+node >>
#@+node:ekr.20041005105605.57:<< scan old ref >> (3.0)
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(g.match(s,i,"<<"))

if len(at.endSentinelComment) == 0:
    line = s[i:-1] # No trailing newline
else:
    k = s.find(at.endSentinelComment,i)
    line = s[i:k] # No trailing newline, whatever k is.
        
# 10/30/02: undo cweb hack here
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    line = line.replace('@@','@')

out.append(line)
#@nonl
#@-node:ekr.20041005105605.57:<< scan old ref >> (3.0)
#@+node:ekr.20041005105605.58:<< scan @+at >>
assert(g.match(s,i,"+at"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.58:<< scan @+at >>
#@+node:ekr.20041005105605.59:<< scan @+doc >>
assert(g.match(s,i,"+doc"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.59:<< scan @+doc >>
#@+node:ekr.20041005105605.60:<< scan @+others >>
assert(g.match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

at.scanText3(theFile,p,out,at.endOthers)
#@nonl
#@-node:ekr.20041005105605.60:<< scan @+others >>
#@-node:ekr.20041005105605.48:<< handle common sentinels >>
#@+node:ekr.20041005105605.61:<< handle rare sentinels >>
elif kind == at.startComment:
    << scan @comment >>
elif kind == at.startDelims:
    << scan @delims >>
elif kind == at.startDirective:
    << scan @@ >>
elif kind == at.startLeo:
    << scan @+leo >>
elif kind == at.startVerbatim:
    << scan @verbatim >>
#@nonl
#@+node:ekr.20041005105605.62:<< scan @comment >>
assert(g.match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
#@-node:ekr.20041005105605.62:<< scan @comment >>
#@+node:ekr.20041005105605.63:<< scan @delims >>
assert(g.match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = g.skip_ws(s,i-1+7)
    
# Get the first delim.
j = i
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1

if j < i:
    at.startSentinelComment = s[j:i]
    # print "delim1:", at.startSentinelComment

    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    end = g.choose(j<i,s[j:i],"")
    i2 = g.skip_ws(s,i)
    if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
        at.endSentinelComment = "" # Not really two params.
        line = s[i0:j]
        line = line.rstrip()
        out.append(line+'\n')
    else:
        at.endSentinelComment = end
        # print "delim2:",end
        line = s[i0:i]
        line = line.rstrip()
        out.append(line+'\n')
else:
    at.readError("Bad @delims")
    # Append the bad @delims line to the body text.
    out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.63:<< scan @delims >>
#@+node:ekr.20041005105605.64:<< scan @@ >>
# The first '@' has already been eaten.
assert(g.match(s,i,"@"))

if g.match_word(s,i,"@raw"):
    at.raw = True
elif g.match_word(s,i,"@end_raw"):
    at.raw = False

e = at.endSentinelComment
s2 = s[i:]
if len(e) > 0:
    k = s.rfind(e,i)
    if k != -1:
        s2 = s[i:k] + '\n'
    
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    s2 = s2.replace('@@','@')
out.append(s2)
# g.trace(s2)
#@nonl
#@-node:ekr.20041005105605.64:<< scan @@ >>
#@+node:ekr.20041005105605.65:<< scan @+leo >>
assert(g.match(s,i,"+leo"))
at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.65:<< scan @+leo >>
#@+node:ekr.20041005105605.66:<< scan @verbatim >>
assert(g.match(s,i,"verbatim"))

# Skip the sentinel.
s = at.readLine(theFile) 

# Append the next line to the text.
i = at.skipIndent(s,0,at.indent)
out.append(s[i:])
#@-node:ekr.20041005105605.66:<< scan @verbatim >>
#@-node:ekr.20041005105605.61:<< handle rare sentinels >>
#@+node:ekr.20041005105605.67:<< warn about unknown sentinel >>
j = i
i = g.skip_line(s,i)
line = s[j:i]
at.readError("Unknown sentinel: " + line)
#@nonl
#@-node:ekr.20041005105605.67:<< warn about unknown sentinel >>
#@-node:ekr.20041005105605.46:<< handle the line in s >>
#@+node:ekr.20041005105605.68:<< handle unexpected end of text >>
# Issue the error.
name = at.sentinelName(endSentinelKind)
at.readError("Unexpected end of file. Expecting " + name + "sentinel" )
#@-node:ekr.20041005105605.68:<< handle unexpected end of text >>
#@-node:ekr.20041005105605.42:scanText3
#@+node:ekr.20041005105605.69:sentinelKind3
def sentinelKind3(self,s):

    """This method tells what kind of sentinel appears in line s.
    
    Typically s will be an empty line before the actual sentinel,
    but it is also valid for s to be an actual sentinel line.
    
    Returns (kind, s, emptyFlag), where emptyFlag is True if
    kind == at.noSentinel and s was an empty line on entry."""
    
    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # 10/30/02: locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        # g.trace("found:",key)
        return at.sentinelDict[key]
    else:
        # g.trace("not found:",key)
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.69:sentinelKind3
#@+node:ekr.20041005105605.70:skipSentinelStart3
def skipSentinelStart3(self,s,i):
    
    """Skip the start of a sentinel."""
    
    at = self
    start = at.startSentinelComment
    assert(start and len(start)>0)

    if g.is_nl(s,i): i = g.skip_nl(s,i)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.70:skipSentinelStart3
#@-node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@nonl
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@nonl
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)
#@nonl
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)
#@nonl
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(at.endAll)
#@nonl
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@nonl
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20041005105605.114:sentinelKind4
def sentinelKind4(self,s):
    
    """Return the kind of sentinel at s."""
    
    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')
        
    # 4.0: Look ahead for @[ws]@others and @[ws]<<
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.114:sentinelKind4
#@+node:ekr.20041005105605.115:skipSentinelStart4
def skipSentinelStart4(self,s,i):
    
    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)>0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.115:skipSentinelStart4
#@-node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.116:Reading utils...
#@+node:ekr.20041005105605.117:completeFirstDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@-node:ekr.20041005105605.117:completeFirstDirectives
#@+node:ekr.20041005105605.118:completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@nonl
#@-node:ekr.20041005105605.118:completeLastDirectives
#@+node:ekr.20041005105605.119:createImportedNode
def createImportedNode (self,root,c,headline):
    
    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
        
    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p
#@nonl
#@-node:ekr.20041005105605.119:createImportedNode
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@nonl
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@+node:ekr.20050211111552:test_parseLeoSentinel
def test_parseLeoSentinel (self):
    
    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.
    
    at=c.atFileCommands # Self is a dummy argument.
    
    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20050211111552:test_parseLeoSentinel
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
    
    self.error(message)
    
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20041005105605.131:skipIndent
# Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i < n and ws < width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i
#@nonl
#@-node:ekr.20041005105605.131:skipIndent
#@-node:ekr.20041005105605.116:Reading utils...
#@-node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.134:Don't override in plugins
# Plugins probably should not need to override these methods.
#@nonl
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@nonl
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.136:norefWrite
def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        << write root's tree >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
rawWrite = norefWrite
#@+node:ekr.20041005105605.137:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
    << Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20041005105605.138:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20041005105605.138:<< put all @first lines in root >>
#@+node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)> 0:
            at.putSentinel("@comment " + line)
#@-node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
#@+node:ekr.20041005105605.140:<< Write p's node >>
at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) > 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20041005105605.140:<< Write p's node >>
#@+node:ekr.20041005105605.141:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.141:<< put all @last lines in root >>
#@-node:ekr.20041005105605.137:<< write root's tree >>
#@-node:ekr.20041005105605.136:norefWrite
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None
    
    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName,toString)

    if at.outputFile:
        root.clearOrphan()
    else:
        root.setOrphan()
        root.setDirty()
    
    return at.outputFile is not None
#@nonl
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName,toString):
    
    at = self

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            at.writeError("path does not exist: " + path)
            return
    except:
        at.exception("exception creating path:" + path)
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@nonl
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.147:writeAll
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@nonl
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@nonl
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@nonl
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll
#@+node:ekr.20041005105605.151:writeMissing
def writeMissing(self,p,toString=False):

    at = self
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            missing = False ; valid = True
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = g.os_path_join(self.default_directory,at.targetFileName)
                at.targetFileName = g.os_path_normpath(at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    at.openFileForWriting(p,at.targetFileName,toString)
                    if at.outputFile:
                        << write the @file node >>
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles > 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.
#@nonl
#@+node:ekr.20041005105605.152:<< write the @file node >>
if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True
#@nonl
#@-node:ekr.20041005105605.152:<< write the @file node >>
#@-node:ekr.20041005105605.151:writeMissing
#@-node:ekr.20041005105605.134:Don't override in plugins
#@+node:ekr.20041005105605.153:Override in plugins...
@

All writing eventually goes through the asisWrite or writeOpenFile methods, so
plugins should need only to override these two methods.

In particular, plugins should not need to override the write, writeAll or
writeMissing methods.
#@nonl
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
silentWrite = asisWrite # Compatibility with old scripts.
#@nonl
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@nonl
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.bodyString()

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@nonl
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.

def writeOpenFile(self,root,nosentinels=False,toString=False):

    """Do all writes except asis writes."""
    
    at = self ; c = at.c

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    << put all @first lines in root >>

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    << put all @last lines in root >>
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@+node:ekr.20041005105605.158:<< put all @first lines in root >> (4.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.os(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20041005105605.158:<< put all @first lines in root >> (4.x)
#@+node:ekr.20041005105605.159:<< put all @last lines in root >> (4.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        at.os(line[i:])
#@nonl
#@-node:ekr.20041005105605.159:<< put all @last lines in root >> (4.x)
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20041005105605.153:Override in plugins...
#@-node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used.

def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.166:putAtAllLine
def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.166:putAtAllLine
#@+node:ekr.20041005105605.167:putatAllBody
def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
#@-node:ekr.20041005105605.167:putatAllBody
#@+node:ekr.20041005105605.169:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)
#@nonl
#@-node:ekr.20041005105605.169:putAtAllChild
#@-node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.171:inAtOthers
def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@nonl
#@-node:ekr.20041005105605.171:inAtOthers
#@+node:ekr.20041005105605.172:putAtOthersChild
def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)
#@nonl
#@-node:ekr.20041005105605.172:putAtOthersChild
#@+node:ekr.20041005105605.173:putAtOthersLine
def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.173:putAtOthersLine
#@-node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.174:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20041005105605.174:putCodeLine
#@+node:ekr.20041005105605.175:putRefLine & allies
#@+node:ekr.20041005105605.176:putRefLine
def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
#@-node:ekr.20041005105605.176:putRefLine
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20041005105605.177:putRefAt
#@+node:ekr.20041005105605.178:putAfterLastRef
def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j < len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.178:putAfterLastRef
#@+node:ekr.20041005105605.179:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start < end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.179:putAfterMiddleef
#@-node:ekr.20041005105605.175:putRefLine & allies
#@-node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.180:writing doc lines...
#@+node:ekr.20041005105605.181:putBlankDocLine
def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
#@nonl
#@-node:ekr.20041005105605.181:putBlankDocLine
#@+node:ekr.20041005105605.182:putStartDocLine
def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
#@nonl
#@-node:ekr.20041005105605.182:putStartDocLine
#@+node:ekr.20041005105605.183:putDocLine
def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        << append words to pending line, splitting the line if needed >>
#@+node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i < len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i < len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) >= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)
#@nonl
#@-node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
#@-node:ekr.20041005105605.183:putDocLine
#@+node:ekr.20041005105605.185:putEndDocLine
def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
#@nonl
#@-node:ekr.20041005105605.185:putEndDocLine
#@+node:ekr.20041005105605.186:putPending
def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.186:putPending
#@-node:ekr.20041005105605.180:writing doc lines...
#@-node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.188:nodeSentinelText 4.x
def nodeSentinelText(self,p):
    
    """Return the text of a @+node or @-node sentinel for p."""
    
    at = self ; h = p.headString()
    << remove comment delims from h if necessary >>
    
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h
#@nonl
#@+node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
#@nonl
#@-node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
#@-node:ekr.20041005105605.188:nodeSentinelText 4.x
#@+node:ekr.20041005105605.190:putLeadInSentinel 4.x
def putLeadInSentinel (self,s,i,j,delta):
    
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    
    Set at.leadingWs as needed for @+others and @+<< sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.
#@nonl
#@-node:ekr.20041005105605.190:putLeadInSentinel 4.x
#@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    at = self
    
    s = self.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
#@nonl
#@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
#@+node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):
    
    """Write @+leo sentinel."""

    at = self
    
    if not at.sentinels:
        return # Handle @nosentinelsfile.
        
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    
    at.putSentinel(s)
#@nonl
#@-node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try: 
            at.root.v.t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
# This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."
    
    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    << apply the cweb hack to s >>
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
#@nonl
#@+node:ekr.20041005105605.195:<< apply the cweb hack to s >>
@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
#@nonl
#@-node:ekr.20041005105605.195:<< apply the cweb hack to s >>
#@-node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
#@-node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.196:Writing 4.x utils...
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.198:directiveKind4
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 >= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            at.noDirective,at.atDirective)

    # @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1>= n or s[i+1] not in string.ascii_letters):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@nonl
#@-node:ekr.20041005105605.198:directiveKind4
#@+node:ekr.20041005105605.199:hasSectionName
def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)

    return -1 < n1 < n2, n1, n2
#@nonl
#@-node:ekr.20041005105605.199:hasSectionName
#@+node:ekr.20041005105605.200:isSectionName
# returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"<<"):
        return False, -1
    i = g.find_on_line(s,i,">>")
    if i:
        return True, i + 2
    else:
        return False, -1
#@nonl
#@-node:ekr.20041005105605.200:isSectionName
#@+node:ekr.20041005105605.201:os and allies
# Note:  self.outputFile may be either a fileLikeObject or a real file.

#@+node:ekr.20041005105605.202:oblank, oblanks & otabs
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))
#@nonl
#@-node:ekr.20041005105605.202:oblank, oblanks & otabs
#@+node:ekr.20041005105605.203:onl & onl_sent
def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
#@nonl
#@-node:ekr.20041005105605.203:onl & onl_sent
#@+node:ekr.20041005105605.204:os
def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    at = self
    
    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except:
            at.exception("exception writing:" + s)
#@nonl
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20041005105605.201:os and allies
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    self.os(s.replace('\n',self.output_newline))
#@nonl
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@nonl
#@-node:ekr.20041005105605.210:putIndent
#@+node:ekr.20041005105605.211:putInitialComment
def putInitialComment (self):
    
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)> 0:
                self.putSentinel("@comment " + line)
#@nonl
#@-node:ekr.20041005105605.211:putInitialComment
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):
    
    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.isCloned() and p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())
                
    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()
#@nonl
#@-node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.218:writeException
def writeException (self,root=None):
    
    g.es("exception writing:" + self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None
    
    if self.outputFileName != None:
        try: # Just delete the temp file.
            os.remove(self.outputFileName)
        except:
            g.es("exception deleting:" + self.outputFileName,color="red")
            g.es_exception()

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()
#@nonl
#@-node:ekr.20041005105605.218:writeException
#@-node:ekr.20041005105605.196:Writing 4.x utils...
#@-node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.219:Uilites... (atFile)
#@+node:ekr.20050104131929:file operations...
@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
#@nonl
#@+node:ekr.20050104131820:chmod
def chmod (self,fileName,mode):
    
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
#@nonl
#@-node:ekr.20050104131820:chmod
#@+node:ekr.20050104131929.1:rename & test
<< about os.rename >>

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.
    
    Change the mode of the renamed file if mode is given.
    
    Return True if all went well.'''

    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050104131929.2:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104131929.2:<< about os.rename >>
#@+node:ekr.20050107085710:test_atFile_rename
def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')
    
    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)
    
    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710:test_atFile_rename
#@-node:ekr.20050104131929.1:rename & test
#@+node:ekr.20050104132018:remove & test
def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107090156:test_atFile_remove
def test_atFile_remove(self,**keys):
    
    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not at.remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert at.remove(path)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107090156:test_atFile_remove
#@-node:ekr.20050104132018:remove & test
#@+node:ekr.20050104132026:stat
def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
#@nonl
#@-node:ekr.20050104132026:stat
#@-node:ekr.20050104131929:file operations...
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20050206085258:atFile.printError & test_printError
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_printError(self,**keys):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test_printError
#@+node:ekr.20041005105605.221:exception
def exception (self,message):
    
    self.error(message)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@nonl
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:scanDefaultDirectory
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@nonl
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@nonl
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites... (atFile)
#@-node:ekr.20041005105605.4:class atFile
#@-node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072759:What I did
@killcolor

This method should do noting if at.toString is True.
#@nonl
#@-node:ekr.20041021072759:What I did
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,ignored):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    if 0: # Wrong: must check all parents.
        ignored = ignored or p.isAtIgnoreNode()
    else:
        for p2 in p.self_and_parents_iter():
            if p2.isAtIgnoreNode():
                isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,ignored)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20041231083430:(Fixed crasher with invalid path)
Directory "c:\test" does not exist
exception writing:C:\prog\leoCVS\leo\test
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2756, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3020, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3752, in putOpenLeoSentinel
    if not at.sentinels:
AttributeError: atFile instance has no attribute 'sentinels'
saved: test.leo
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041231083430:(Fixed crasher with invalid path)
#@+node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20041231102453.5:Notes
@killcolor

There is a bug in how Leo writes adjacent @doc parts in @file trees.  This is the first serious bug in the atFile read/write logic reported in several years. As I write this I realize I don't know whether the @thin logic is affected as well.  I suspect it may be.

The bug happens if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo fails to write the closing #@-at sentinel that would finish the first @doc part.  (Another fix would be not to write the second #@+at sentinel.)  As a result of this bug, Leo fails to read the @file node properly and 'reverts' to the version of the code found in the .leo file.
#@nonl
#@-node:ekr.20041231102453.5:Notes
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used.

def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@-node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
@nocolor

c:\python24\lib\pickle.py:202: DeprecationWarning:
    The 'bin' argument to Pickler() is deprecated

@color
#@nonl
#@+node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@-node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            try:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            except TypeError:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)
        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@+node:EKR.20040526204036.1:getUnknownAttribute
def getUnknownAttribute(self,nodeType):
    
    """Parse an unknown attribute in a <v> or <t> element."""
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
#@nonl
#@-node:EKR.20040526204036.1:getUnknownAttribute
#@-node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
#@+node:ekr.20050112100144:(Fixed bug in how Leo writes thin derived files)
# The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.
#@nonl
#@+node:ekr.20050112100144.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2936140
By: nobody

I have recently stumbled two or three times upon an error,
that causes leo to write  @thin files, that cannont be
untangled (I hope its correct to use this term here) later on.
The resulting Problem is really serious, since opening
the leo file in a new session causes leo immediately to hang.
The only way to recover the leo file I found, was to modify
the appropriate leo sentinels in the broken derived file.

Description:

create a file (must be @thin not @file),
which references a section, that is two levels
below the current level.
f.e.
<< current level>>
  reference to << 3. level>>
    << 1.level>>
        << 2.level >>
            << 3.level>>

Leo does not complain while saving.

Close leo. Opening leo now causes leo to hang while untangling the above
generated @thin file.

To make the file readable the *middle* sentinels surrounding the reference must
be removed.
#@nonl
#@-node:ekr.20050112100144.1:Report
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20041005105605.177:putRefAt
#@-node:ekr.20050112100144:(Fixed bug in how Leo writes thin derived files)
#@-node:ekr.20050104122244.2:Files
#@+node:ekr.20050104122244.3:Script bugs
#@+node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041007081134.3:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2792616
By: e

The recursion was happening in nullLog put & write.

EKR:  The problem is that nullLog.write calls print, and if print is redirected we end up calling nullLog.write again.

sys.stdout.write() doesn't work any better than print
but inside g.app.log.disable/enable doesn't error.

redirect_execute_script_output_to_log_pane = 1
is not good in batch mode!

should that should be always zeroed in batch mode?
set to 0 and both sys.stdout.write and print works.
no recursion.
#@-node:ekr.20041007081134.3:Report
#@+node:ekr.20041012082437.6:What I did
@killcolor

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.
#@nonl
#@-node:ekr.20041012082437.6:What I did
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@+node:ekr.20031218072017.3695:leoLog.__init__
def __init__ (self,frame,parentFrame):
    
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.3695:leoLog.__init__
#@+node:ekr.20031218072017.2232:class nullLog
class nullLog (leoLog):
    
    @others
#@nonl
#@+node:ekr.20041012083237:nullLog.__init__
def __init__ (self,frame=None,parentFrame=None):
        
    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)
    self.isNull = True
#@nonl
#@-node:ekr.20041012083237:nullLog.__init__
#@+node:ekr.20041012083237.1:createControl
def createControl (self,parentFrame):
    
    return None
#@nonl
#@-node:ekr.20041012083237.1:createControl
#@+node:ekr.20041012083237.2:oops
def oops(self):

    g.trace("nullLog:", g.callerName(2))
    
#@-node:ekr.20041012083237.2:oops
#@+node:ekr.20041012083237.3:put and putnl (nullLog)
def put (self,s,color=None):
    if self.enabled:
        # g.trace('nullLog',s)
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")
#@nonl
#@-node:ekr.20041012083237.3:put and putnl (nullLog)
#@+node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
def setFontFromConfig (self):
    pass
    
def setColorFromConfig (self):
    pass
#@nonl
#@-node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
#@-node:ekr.20031218072017.2232:class nullLog
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self,*args,**keys):
    pass
    
def lift (self,*args,**keys):
    pass
    
def update (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry(self,w,h,x,y):
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
    
    
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,script=None):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()

    try:
        if script:
            s = script
        else:
            script = ''
            # Allow p not to be the present position.
            if p == c.currentPosition():
                if useSelectedText and c.frame.body.hasTextSelection():
                    # Temporarily replace v's body text with just the selected text.
                    s = c.frame.body.getSelectedText()
                    p.v.setTnodeText(s)
                else:
                    s = c.frame.body.getAllText()
            else:
                s = p.bodyString()
                
        # New in 4.3: Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            # New in 4.3: Selecting text executes _only_ the selected text.
            # This removes some indentation problems, but not all of them.
            if useSelectedText and c.frame.body.hasTextSelection():
                script = s
            else:
                at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
                script = at.stringOutput
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    p.v.setTnodeText(old_body)
    
    # g.trace(repr(c.atFileCommands.output_newline))
    if c.atFileCommands.output_newline == '\r\n':
        return script.replace("\r\n","\n") # 1/11/05
    else:
        return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_returns
def test_g_getScript_strips_returns():

    old_output_newline = c.atFileCommands.output_newline
    c.atFileCommands.output_newline = '\r\n'
    script = g.getScript(c,p)
    c.atFileCommands.output_newline = old_output_newline
    
    assert script.find('\r\n') == -1
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_returns
#@-node:EKR.20040614071102.1:g.getScript & tests
#@-node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
@

The old code assumed that the error is always in the script itself.  Not true!  The error could happen in methods called by the script.

This code works with Python 2.3.4: it may be version dependent.
#@nonl
#@+node:ekr.20041007080346:Report from e
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2792394

I've narrowed down when the IndexError happens,
probably any similar error would be the same.

import leoGlobals as g
c = g.top() 
p = c.currentPosition()
cv = c.currentVnode()
cv.moveOutlineRight()  #error

gives this error
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------

and this  additional traceback from 
leoCommands.py", line 1171, in executeScript
    s = "line %d: %s" % (n,lines[n-1])
IndexError: list index out of range

when run this script inside a def wrapper,

import leoGlobals as g
def x():
....c = g.top() 
....p = c.currentPosition()
....cv = c.currentVnode()  #insert sets the current node
....cv.moveOutlineRight()  #error
x()

all you get is
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------
so it appears the frame in the code that determines the 
line number n is off at least one.
in neither case is the line number of the error correct, so no error line
shows.

maybe getLastTracebackLineNumber needs to check for ValueError?
there is still a piece missing, how to tell what frame your in.

in #@+node: getLastTracebackLineNumber leoGlobals.py
data = traceback.extract_tb(tb, 2) seems like a good idea
and seems to fix the IndexError error shown above.
but now with error inside a def you get the function name
instead of the line the error is on. not good enough.

change to:
data = traceback.extract_tb(tb)
item = data[-2] or data[-1] 

this seems to work w/ error code indented 0 from far left, 
or nested inside a def inside another def or another,
I'll leave it in and see if there are additional problems.
the line number still doesn't match with row,col display.
thats confusing if you don't account for the sentinals.
maybe the line number minus a simple count of sentinal lines?

#@-node:ekr.20041007080346:Report from e
#@+node:ekr.20041007080346.1:Report 2 from e
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2792620

not a trivial simple count after all.
if the error is inside a node then would need to 
start count from the previous +node sentinal.
I didn't attempt to fix that,

lets see if the line number is always right first.

item = data[-2] or data[-1]

isn't fixing all cases.

this works better:

item = data[-1]
if not item[-1] is None:
    item = data[-2]
#@-node:ekr.20041007080346.1:Report 2 from e
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.trace(data)
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@-node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
#@-node:ekr.20050104122244.3:Script bugs
#@+node:ekr.20050104122244.4:Startup
#@+node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20040929100426:Report
@killcolor

When I start leo from the command line (linux) with e.g.

[davides@icarus utilities]$ leodev test.leo

(leodev is an alias to the latest cvs version)

and "test.leo" does not exist, the Log pane says

File not found: /localstore/computer/davides/SW/test/utilities/test.leo

but then I would expect that the current file name were set to "test.leo", so that when I do a save, "test.leo" gets saved. It is set to "untitled" instead, so that in essence in this case Leo ignores my command line argument. I would also change the log message to say something like "New file" or similar. Cf. what happens when you do e.g. "vi newfile.txt" (or "emacs", or even "edit" in ms-dos).

Davide 
#@nonl
#@-node:ekr.20040929100426:Report
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@-node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20041228060059:(Better handling of duplicate menu shortcuts)
@nocolor

The code now clears previous shortcut, and tells what the previous entry was.

What I did:
    - Added init keyword param to createMenuEntries.
    - All calls to createMenuEntries from createMenusFromTables set init = True.
    - Changed << handle bind_shorcut >> in createMenuEntries:
        - Changed menuShortcuts to a dict containing g.Bunch items.
    - Added clearAccel methods to leoMenu and leoTkinterMenu classes.

@color
#@nonl
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@nonl
#@-node:ekr.20041228063406:clearAccel
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                << handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20041228060059:(Better handling of duplicate menu shortcuts)
#@+node:ekr.20050117111810:(Fixed configuration bug)
#@+node:ekr.20050119061300:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2943715
By: nobody

Traceback (most recent call last):
  File "/usr/local/src/leoCVS42/src/leo.py", line 418, in ?
    run()
  File "/usr/local/src/leoCVS42/src/leo.py", line 139, in run
    c,frame = createFrame(fileName)
  File "/usr/local/src/leoCVS42/src/leo.py", line 315, in createFrame
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
  File "/usr/local/src/leoCVS42/src/leoGui.py", line 126, in
newLeoCommanderAndFrame
    c = leoCommands.Commands(frame,fileName)
  File "/usr/local/src/leoCVS42/src/leoCommands.py", line 59, in __init__
    c.importCommands = leoImport.leoImportCommands(c)
  File "/usr/local/src/leoCVS42/src/leoImport.py", line 34, in __init__
    self.output_newline = g.getOutputNewline()
  File "/usr/local/src/leoCVS42/src/leoGlobals.py", line 275,
in getOutputNewline
    s = s.lower()
AttributeError: 'NoneType' object has no attribute 'lower'
#@nonl
#@-node:ekr.20050119061300:Report
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@-node:ekr.20050117111810:(Fixed configuration bug)
#@+node:ekr.20050121075634:(Investigated Control-Q binding)
@nocolor

- It works for me in 4.3.

- fixed crasher:  shortcut entry was not in dispatchDict.

http://sourceforge.net/forum/message.php?msg_id=2944234
By: nobody

I am unable to remap the CTRL+Q keyboard shortcut. It seems to be hardwired
to File > Exit. My attempts to override it have failed.
#@nonl
#@-node:ekr.20050121075634:(Investigated Control-Q binding)
#@-node:ekr.20050104122244.4:Startup
#@+node:ekr.20050123190323:(Simplified and improved shift-click scrolling code)
#@+node:ekr.20050123190323.1:Notes
@killcolor

My attention was brought to this code because pychecker rigthly complained about global vars.

- replaced global way with scrollWay ivar.  This keeps pychecker happy.

- Replaced lambda's with trivial functions.
    - The old code was absurdly and needlessly confusing.

- Disabled code in scrollUpOrDown that returned if find_overlapping was True.
    - The scrolling code works much better without it.
#@nonl
#@-node:ekr.20050123190323.1:Notes
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20050123190323:(Simplified and improved shift-click scrolling code)
#@-node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
@

Replace the try/except code with

    if multiple and g.CheckVersion(sys.version,"2.3") and g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4"):
#@nonl
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@-node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
#@+node:ekr.20040720073339:Removed use_gnx
#@-node:ekr.20040720073339:Removed use_gnx
#@+node:ekr.20040929102351:Removed write_old_format_derived_files
This implies:
    
- Deprecating old-style file formats.
- Removing commands that write old-style formats.
#@nonl
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
#@+node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
def writeNewDerivedFiles (self):
    
    c = self
    autoSave = c.atFileCommands.writeNewDerivedFiles()
    if autoSave:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to preserve tnodeList.
    
def writeOldDerivedFiles (self):
    
    c = self
    c.atFileCommands.writeOldDerivedFiles()
    g.es("auto-saving outline",color="blue")
    c.save() # Must be done to clear tnodeList.
#@nonl
#@-node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
#@-node:ekr.20040929102351:Removed write_old_format_derived_files
#@+node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041005112818.2:What I did
@killcolor

- Made sense of initialization:
    - ctor inits only permanent ivars.
    - All initing for reads and writes happens explicitly.
    - Separate initiing for reads and writes.
    - All non-permanent ivars deleted before all reads and writes (when testing).

- Move all constants into class.  No more module-level constants.

- All code is now in a single class.
    - This is _so_ much clearer than before.
    - There were only a few name conflicts:  resolved by renaming x to x3 or x4.

- Use methods rather than sections where possible.

- Removed unused oneNodeOnly args, except for putBody method.

- Tested reading 3.x files.  This passes simple tests.  I doubt if anyone actually using these old files....

- Added fromString arg to g.fileLikeObject ctor.

- Not much new is needed to support read/write from string.
    - Official methods that plugins can override:
        read, asisWrite, writeOpenFile
#@nonl
#@-node:ekr.20041005112818.2:What I did
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,script=None):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()

    try:
        if script:
            s = script
        else:
            script = ''
            # Allow p not to be the present position.
            if p == c.currentPosition():
                if useSelectedText and c.frame.body.hasTextSelection():
                    # Temporarily replace v's body text with just the selected text.
                    s = c.frame.body.getSelectedText()
                    p.v.setTnodeText(s)
                else:
                    s = c.frame.body.getAllText()
            else:
                s = p.bodyString()
                
        # New in 4.3: Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            # New in 4.3: Selecting text executes _only_ the selected text.
            # This removes some indentation problems, but not all of them.
            if useSelectedText and c.frame.body.hasTextSelection():
                script = s
            else:
                at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
                script = at.stringOutput
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    p.v.setTnodeText(old_body)
    
    # g.trace(repr(c.atFileCommands.output_newline))
    if c.atFileCommands.output_newline == '\r\n':
        return script.replace("\r\n","\n") # 1/11/05
    else:
        return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_returns
def test_g_getScript_strips_returns():

    old_output_newline = c.atFileCommands.output_newline
    c.atFileCommands.output_newline = '\r\n'
    script = g.getScript(c,p)
    c.atFileCommands.output_newline = old_output_newline
    
    assert script.find('\r\n') == -1
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_returns
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):

    self.initCommonIvars()
    << init ivars for writing >>
    
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors: 
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041019125831:Notes
@killcolor

- (to do) doc parts are reformatted improperly.

    - This is going to be even trickier when Python allows '@' characters.
    - The present code make no attempt to discover @doc parts;
      it simply preserves whitespace after @ signs!

- (fixed) doc strings were messed up.

    - The bug was improperly use a as a synonym for self.array.
#@nonl
#@-node:ekr.20041019125831:Notes
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
@ 

Save As & Save To are broken with new .leo files

c.mFileName was '.'  That should never happen.

I recently added code that set

c.mFileName = g.os_path_norm(fileName) in the ctor, but this converts an empty name to '.' (!!)

I removed g.os_path_norm and g.os_path_normabs.  These caused more problems than they solved.
#@+node:ekr.20041216060139:Traceback
exception creating backup file: ..bak
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoFileCommands.py", line 2015, in write_Leo_file
    g.utils_rename(fileName,backupName)
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1604, in utils_rename
    os.rename(src,dst)
OSError: [Errno 13] Permission denied

--------------

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 154, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 626, in saveTo
    defaultextension=".leo")
  File "C:\prog\leoCVS\leo\src\leoTkinterGui.py", line 228, in runSaveFileDialog
    filetypes=filetypes)
  File "c:\python23\lib\lib-tk\tkFileDialog.py", line 131, in asksaveasfilename
    return SaveAs(**options).show()
  File "c:\python23\lib\lib-tk\tkCommonDialog.py", line 52, in show
    s = w.tk.call(self.command, *w._options(self.options))
TclError: invalid filename "."
#@-node:ekr.20041216060139:Traceback
#@-node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
#@+node:ekr.20040701152235:(Fixed shawdow warnings)
@killcolor

The following are all Python global functions:

(done) cmp -> compare
(done) dict -> theDict
(done) dir -> theDir
(done) file -> theFile
(done) id -> theId
(done) type -> theType
(done) input  (suppressed the warning)
(done) iter -> theIter
#@nonl
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20040701152235.2:leoApp (done)
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:209: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:224: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:368: (dir) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:401: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.2:leoApp (done)
#@+node:ekr.20040701152235.3:leoPlugins (done)
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:40: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:53: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:67: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:72: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:74: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.3:leoPlugins (done)
#@+node:ekr.20040701152235.4:leoColor (done)
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:1948: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:2059: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.4:leoColor (done)
#@+node:ekr.20040701152235.5:leoNodes (done)
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:578: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1372: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1394: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1411: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1412: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1419: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1443: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1446: (id) shadows builtin
#@nonl
#@-node:ekr.20040701152235.5:leoNodes (done)
#@+node:ekr.20040701152235.6:leoCompare (done)
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:44: (cmp) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:397: (cmp) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:468: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.6:leoCompare (done)
#@+node:ekr.20040701152235.8:leoFind (done)
(fixed) c:\prog\leoCVS\leo\src\leoFind.py:864: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.8:leoFind (done)
#@+node:ekr.20040701152235.9:leoMenu (done)
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:656: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:700: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.9:leoMenu (done)
#@+node:ekr.20040701152235.10:leoTkinterTree (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:949: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:162: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:167: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:586: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:639: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:783: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:844: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:911: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1390: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1588: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1590: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:883: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:893: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.10:leoTkinterTree (done)
#@+node:ekr.20040701152235.11:leoTkinterFrame (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:807: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:566: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1233: (file) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:522: (type) shadows builtin
#@-node:ekr.20040701152235.11:leoTkinterFrame (done)
#@+node:ekr.20040701152235.12:leoTkinterPrefs (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterPrefs.py:295: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.12:leoTkinterPrefs (done)
#@+node:ekr.20040701152235.13:leoTkinterGui (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterGui.py:78: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.13:leoTkinterGui (done)
#@+node:ekr.20040701152235.14:leoAtFile (done)
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:336: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:490: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2157: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:473: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:549: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:551: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2142: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2278: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2280: (dir) shadows builtin
#@-node:ekr.20040701152235.14:leoAtFile (done)
#@+node:ekr.20040701152235.15:leoFileCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:90: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:866: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1191: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1318: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1756: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:990: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2018: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1228: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1269: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.15:leoFileCommands (done)
#@+node:ekr.20040701152235.16:leoImport (done)
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2792: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:52: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:273: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2348: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2371: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2398: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2426: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2476: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:473: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1626: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1648: (id) shadows builtin
(fixed) :\prog\leoCVS\leo\src\leoImport.py:1650: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2303: (type) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2727: (type) shadows builtin

#@-node:ekr.20040701152235.16:leoImport (done)
#@+node:ekr.20040701152235.17:leoTangle (done)
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:718: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:911: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:924: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3563: (dict) shadows builtin

c:\prog\leoCVS\leo\src\leoTangle.py:540: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:541: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:666: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3656: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3667: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3780: (dir) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:2038: (type) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3865: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.17:leoTangle (done)
#@+node:ekr.20040701152235.18:leoCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:324: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:340: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:346: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:468: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:480: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1677: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1721: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1770: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1800: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:2280: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:465: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:495: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:734: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1238: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.18:leoCommands (done)
#@-node:ekr.20040701152235:(Fixed shawdow warnings)
#@+node:ekr.20050101093544:(Always use os.rename in utils_rename)
#@+node:ekr.20050104110100:Notes
@killcolor

Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.
#@nonl
#@-node:ekr.20050104110100:Notes
#@+node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@+node:ekr.20031218072017.1241:g.update_file_if_changed
# This is part of the tangle code.

def update_file_if_changed(file_name,temp_name):

    """Compares two files.
    
    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(temp_name,file_name)
        
    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")
#@nonl
#@-node:ekr.20031218072017.1241:g.update_file_if_changed
#@+node:ekr.20050104123726.3:g.utils_remove & test
def utils_remove (fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            g.es("exception removing:" + fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107084901:test_utils_remove
def test_utils_remove():

    __pychecker__ = '--no-reimport'
    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@-node:ekr.20050107084901:test_utils_remove
#@-node:ekr.20050104123726.3:g.utils_remove & test
#@+node:ekr.20031218072017.1263:g.utils_rename & test
<< about os.rename >>

def utils_rename(src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''
    
    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
        
    try:
        if 1: # Use rename in all cases.
            os.rename(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True
        else:
            # This isn't a great solution: distutils.file_util may not exist.
            if sys.platform=="win32":
                os.rename(src,dst)
            else:
                from distutils.file_util import move_file
                move_file(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True

    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050104123726.1:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104123726.1:<< about os.rename >>
#@+node:ekr.20050107085710.1:test_utils_rename
def test_utils_rename(**keys):

    __pychecker__ = '--no-reimport '
    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710.1:test_utils_rename
#@-node:ekr.20031218072017.1263:g.utils_rename & test
#@+node:ekr.20050104124903:g.utils_chmod
def utils_chmod (fileName,mode,verbose=True):
    
    if mode is None:
        return

    try:
        os.chmod(fileName,mode)
    except:
        if verbose:
            g.es("exception in os.chmod(%s)" % (fileName))
            g.es_exception()
#@nonl
#@-node:ekr.20050104124903:g.utils_chmod
#@+node:ekr.20050104123726.4:g.utils_stat
def utils_stat (fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    try:
        mode = (os.stat(fileName))[0] & 0777
    except:
        mode = None
        
    return mode
#@nonl
#@-node:ekr.20050104123726.4:g.utils_stat
#@-node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c

    self.assignFileIndices()
    if not outlineOnlyFlag:
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        << create backup file >>
        self.mFileName = fileName
        << create the output file >>
        << put the .leo file >>
    except:
        << report the exception >>
        << erase filename and rename backupName to fileName >>
        return False
    if self.outputFile:
        << close the output file >>
        << delete backup file >>
        return True
    else: # This probably will never happen because errors should raise exceptions.
        << erase filename and rename backupName to fileName >>
        return False
        
write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080359.2:<< create the output file >>
self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
    g.es("can not open " + fileName)
    << delete backup file >>
    return False
#@nonl
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
    try:
        os.remove(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20040324080359.2:<< create the output file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20040324080819.2:<< report the exception >>
g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
    try:
        self.outputFile.close()
        self.outputFile = None
    except:
        g.es("exception closing: " + fileName)
        g.es_exception()
#@nonl
#@-node:ekr.20040324080819.2:<< report the exception >>
#@+node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
    try:
        os.remove(fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting: " + fileName)
            g.es_exception()
    except:
        g.es("exception deleting: " + fileName)
        g.es_exception()
        
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    try:
        g.utils_rename(backupName, fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception renaming " + backupName + " to " + fileName)
            g.es_exception()
    except:
        g.es("exception renaming " + backupName + " to " + fileName)
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
#@+node:ekr.20040324080819.3:<< close the output file >>
try:
    self.outputFile.close()
    self.outputFile = None
except:
    g.es("exception closing: " + fileName)
    g.es_exception()
#@nonl
#@-node:ekr.20040324080819.3:<< close the output file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20041005105605.219:Uilites... (atFile)
#@+node:ekr.20050104131929:file operations...
@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
#@nonl
#@+node:ekr.20050104131820:chmod
def chmod (self,fileName,mode):
    
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
#@nonl
#@-node:ekr.20050104131820:chmod
#@+node:ekr.20050104131929.1:rename & test
<< about os.rename >>

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.
    
    Change the mode of the renamed file if mode is given.
    
    Return True if all went well.'''

    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050104131929.2:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104131929.2:<< about os.rename >>
#@+node:ekr.20050107085710:test_atFile_rename
def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')
    
    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)
    
    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710:test_atFile_rename
#@-node:ekr.20050104131929.1:rename & test
#@+node:ekr.20050104132018:remove & test
def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107090156:test_atFile_remove
def test_atFile_remove(self,**keys):
    
    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not at.remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert at.remove(path)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107090156:test_atFile_remove
#@-node:ekr.20050104132018:remove & test
#@+node:ekr.20050104132026:stat
def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
#@nonl
#@-node:ekr.20050104132026:stat
#@-node:ekr.20050104131929:file operations...
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20050206085258:atFile.printError & test_printError
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_printError(self,**keys):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test_printError
#@+node:ekr.20041005105605.221:exception
def exception (self,message):
    
    self.error(message)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@nonl
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:scanDefaultDirectory
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@nonl
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@nonl
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites... (atFile)
#@-node:ekr.20050101093544:(Always use os.rename in utils_rename)
#@+node:ekr.20050119225135:(Implemented delayed focus scheme)
#@+node:ekr.20050120091434:What I did
@killcolor

The original problem with the UNL plugin not staying on top was that button-1
was bound to OnActivateTree, which called g.app.gui.set_focus.

However, there was another problem, the idle-time code in the status line logic
was also messing with the focus. It turns out that repeatedly calling
g.app.gui.set_focus is a bad idea: it interferes with opening new windows.

To deal with this I basically rewrote all the code that sets focus. The new code
replaces direct calls to g.app.gui.set_focus with calls to frame.bodyWantsFocus,
frame.statusLineWantsFocus, frame.treeWantsFocus and frame.logWantsFocus.
Actually, they all do the same thing, but using different methods improves
traces.

This is an excellent pattern. Rather than setting the focus directly, these
xWantsFocus methods merely signal their intension to set the focus. This allows
very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours to get it
just right. It queues up a 'one-shot' callback. That is, at most one copy of the
callback is ever waiting to be executed. Furthermore, the callback is only
queued for execution at the result of a call to xWantsFocus; it is never run
automatically at idle time. Finally, even when executed, the callback does
nothing if the last requested commander (in the new ivar, g.app.wantedFocus)
does not match the commander to which the callback was bound. These checks allow
the UNL plugin to open a window properly and keep it topmost :-)

This is a big step forward for Leo. Using delayed focus methods ensures that the
body pane always has focus unless the code has a specific, positive reason for
the focus to be elsewhere. This was difficult (or rather impossible) to do with
the old code: there are _many_ Tk calls that can affect the focus. Moreover, it
minimizes calls to g.app.gui.set_focus.

Oh yes, one more thing. All the new methods support a 'tag' keyword argument.
This is typically set to the name of the routine in which the call takes place.
It is a big help in making sense of traces.

More details:
- 'later' keyword arg
- eliminates most calls to g.app.gui.set_focus
- A case could be made for using a single, global one-shot callback in g.app.gui.set_focus.
- Stresses Tk much less.
- A problem with losing data in test.leo.
#@nonl
#@-node:ekr.20050120091434:What I did
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,widget,tag=''):
    
    """Put the focus on the widget."""
    
    # g.trace(tag,widget)
    
    # g.trace(c.frame.top.wm_stackorder())
    
    if widget:
        widget.focus_set()

    if 0: # Causes a weird problem on some machines.
        if c.frame.top:
            focus = c.frame.top.focus_displayof()
            if focus != widget:
                widget.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20050120110418:Activation methods
@

N.B. There is NO WAY to keep track reliably of which window is on top!! Leo must
never ever depend on this knowledge!!
#@+node:ekr.20040803072955.105:OnActivate (tkTree)
def OnActivate (self,p,event=None):

    try:
        c = self.c ; gui = g.app.gui
        # g.trace(c)
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
current = c.currentPosition()

if p == current:
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(self.canvas,later=False,tag='OnActivate')
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='OnActivate')

self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivate (tkTree)
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):

    try:
        frame = self ; c = frame.c ; gui = g.app.gui
        # g.trace(c.shortFileName())
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
        self.bodyWantsFocus(self.bodyCtrl,tag='OnActivateBody')
    except:
        g.es_event_exception("activate body")
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):
    
    # g.trace(self.c.shortFileName())

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")
#@nonl
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):
    
    # g.trace(self.c)

    try:
        frame = self ; c = frame.c ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateTree")
        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            frame.bodyWantsFocus(frame.bodyCtrl,tag='OnActivateTree')
            
    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus(self.logCtrl,tag='onActivateLog')
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@-node:ekr.20050120110418:Activation methods
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    if self.trace and self.verbose:
        g.trace("unselect:",old_p.headString())
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.c.setCurrentPosition(p)
if p != old_p:
    self.setSelectedLabelState(p)
frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,self.c.shortFileName())
    self.set_focus(widget,later=later,tag=tag)
    
def logWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def statusLineWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def treeWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
    
def widgetWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@nonl
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='statusLine.disable')
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.frame.statusLineWantsFocus(t,tag='statusLine.ensable')
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@nonl
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@nonl
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@nonl
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack
#@nonl
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:EKR.20040424154804:setFocus
if 0: # No longer used in 4.3.  Done as the result of statusLineWantsFocus.

    def setFocus (self):
    
        # Force the focus to the icon area.
        t = self.textWidget
        if t:
            t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocus
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@nonl
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update
def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col > 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)
#@nonl
#@-node:ekr.20031218072017.1733:update
#@-node:ekr.20041223104933:class statusLineClass
#@-node:ekr.20050119225135:(Implemented delayed focus scheme)
#@+node:ekr.20050123162958:(Fixed Pychecker warnings)
#@+node:ekr.20050123192629:Real bugs in leoConfig.py
@killcolor

C:\prog\leoCVS\leo\src\leoConfig.py:691: No global (encodingName) found

changed encodingName to ivar.
#@nonl
#@-node:ekr.20050123192629:Real bugs in leoConfig.py
#@+node:ekr.20050123184116:Warnings
@killcolor

(wrong warning)
    C:\prog\leoCVS\leo\src\leoCommands.py:33: Imported module (token) not used

(not a real problem: cant be suppressed)
    C:\prog\leoCVS\leo\src\leo.py:210: No module attribute (leo_config_directory) found

C:\prog\leoCVS\leo\src\leoTkinterFrame.py:320: No class attribute (yview) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:321: No class attribute (yview) found
#@-node:ekr.20050123184116:Warnings
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20050123162958:(Fixed Pychecker warnings)
#@-node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20041115111203:Config...
# 2004
#@nonl
#@+node:ekr.20041124094427.1: What I did
@nocolor

- leo.py:
    - Create nodeIndices early in starup logic.
    - Set g.app.config early in startup logic.
    
- leoCommands.py:
    - Added class configSettings to hold per-commander settings.

- leoFileCommands.py
    - putFindSettings and putPrefs write empty xml elements.
    - getFindPanelSettings and getPrefs ignore whatever settings they see.

@color
#@nonl
#@-node:ekr.20041124094427.1: What I did
#@+node:ekr.20041228053248:Diary
#@+node:ekr.20041118130101:11/17 Prepared for new code
@killcolor

- Disabled ill-fated Apply Settings command.
- Removed call to config.update from leoFileCommands.write code.
- Write only vestigial <find settings/>
- Write only vestigial <preferences/>
    - Will store prefs in @settings trees.
*** NO changes to the read code.  This ensures compatibility.
- Created computeHomeDir, computeGlobalConfig and startupEncoding in leo.py.
- Set g.app.homeDir and g.app.globalConfigDir in leo.py.
- Generalized g.app.setLeoID()
- Called g.app.setLeoID() _before_ loading plugins.
#@nonl
#@-node:ekr.20041118130101:11/17 Prepared for new code
#@+node:ekr.20041118130101.1:11/18 Modified core for new code
@nocolor

- Create configSettings class in leoCommands.py.

This is needed because the old g.app.ivars won't work with per-file settings.  So now each commander has its own settings.

    - c.config now points to a configSettings instance for each commander.
    - The configSettings class has convenience methods to get and set settings.

- Removed config.update.  One reference still exists.

The code accesses config ivar x via c.config.x

- Removed all section-specific getters from Leo's core and leoPlugins.leo.

- Changed g.app.config to c.config in these plugins: FileActions.py, word_export.py, rst.py, rst2.py

- Remove all references to configExists and configExists itself.

- Removed most references to g.app.config.x:  The main remaining refs are:
    g.app.config.use_plugins
#@nonl
#@+node:ekr.20041118135701:Removed old spellings of config getters
getBoolColorsPref = getBool
getBoolComparePref = getBool
getBoolFindPref = getBool
getBoolPref = getBool
getBoolWindowPref = getBool

getIntComparePref = getInt
getIntPref = getInt
getIntWindowPref = getInt

getFloatWindowPref = getFloat

getStringColorsPref = getString
getStringComparePref = getString
getStringFindPref = getString
getStringPref = getString
getStringWindowPref = getString

# Generic prefs are strings too.
getColorsPref = getString
getComparePref = getString
getFindPref = getString
getPref = getString
getWindowPref = getString
#@nonl
#@-node:ekr.20041118135701:Removed old spellings of config getters
#@-node:ekr.20041118130101.1:11/18 Modified core for new code
#@+node:ekr.20041120134118:11/19 Wrote first draft of new code
#@-node:ekr.20041120134118:11/19 Wrote first draft of new code
#@+node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041120160454:Added gui param to fram
Not sure this did anything.  However, using g.app.gui in the code should be replaced by c.frame.gui.
#@nonl
#@-node:ekr.20041120160454:Added gui param to fram
#@+node:ekr.20041120160454.1:Added destroySelf method to nullFram
This allows g.app.destroyWindow to work on nullFrame's.
#@nonl
#@-node:ekr.20041120160454.1:Added destroySelf method to nullFram
#@+node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
use_psyco can no longer be a config param:  it is used too early in the load process.
#@nonl
#@-node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
#@+node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
This is needed because loading .leo files requires g.app.leoID.

To make this work, I had to create an emergency "startup" gui in setLeoID. This in turn creates g.app.root, so I also changed
createNullGuiWithScript so it only creates the Tk root if it doesn't already exist.

Clearly, using g.app.gui is wrong.
#@nonl
#@-node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
#@+node:ekr.20041120160454.4:Removed use_psycho option
#@-node:ekr.20041120160454.4:Removed use_psycho option
#@+node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041121125616.1:11/21 Multiple find panels
@killcolor

- Implemented @if-gui
- Implemented @ratio.
- Fixed bug:  getBool was returning True for both True and False ;-)

- Removed g.app.globalWindows.
- Removed destroyAllGlobalWindows()
- Destroy find panel in frame.destroySelf.
#@nonl
#@-node:ekr.20041121125616.1:11/21 Multiple find panels
#@+node:ekr.20041124094427:11/24 Improved how names get munged
@killcolor

canonicalizeSettingsName (munge) delete whitespace, underscores and '-' in settings names.

dictionary keys are munged names.
#@nonl
#@-node:ekr.20041124094427:11/24 Improved how names get munged
#@+node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@-node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@-node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041123075848:What I did
@killcolor

- Added updateRecentFiles keyword option to newLeoCommanderAndFrame.
    Default is True, but set to false when opening leoSettings.leo files on startup.
    Note: this will be False, then True when opening leoSettings.leo explicitly.

- Removed g.app.config.setRecentFiles.
    All work done in c.config.setRecentFiles.
    moved recentFiles ivar to configParser class.

- Moved call to c.config.setRecentFiles from c.updateRecentFiles to g.openWithFileName.

- settingsRoot, canonicalizeSettingName and findSettingsPosition now defined only in config class.
    These are always accessed via g.app.config.
    These seems better than defining functions in leoGlobals.py
#@nonl
#@-node:ekr.20041123075848:What I did
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    # Finish creating the frame
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    g.doHook("after-create-leo-frame",c=c)
    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@-node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041124081632:(Problems overriding defaults)
@nocolor
Problem 1: a simple blunder in settingsParser.set.

Problem 2: use_plugin didn't get changed until after plugins get loaded.

Solution:  Read .leo files specified on the command line twice:
    
- Once before loading plugins, _without_ loading @file nodes.
- Once after (normal load)

What I did:

- Created completeFileName (does not depend on config).
- Added local file to list of files to be scanned in readSettingsFiles.
- Don't don't scan for settings in local file in createFrame.
    - Added readAtFileNodesFlag keyword arg to openWithFileName.
@color
#@nonl
#@+node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    frame.c.fileCommands.open(theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    theHash = c.hash()
                    d['_hash'] = theHash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[theHash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s" % (g.shortFileName(path)),color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.mFileName)
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    << compute directories >>
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416:<< compute directories >>
g.app.loadDir = computeLoadDir()
    # Depends on g.app.tkEncoding: uses utf-8 for now.

g.app.homeDir = computeHomeDir()

g.app.extensionsDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','extensions'))

g.app.globalConfigDir = computeGlobalConfigDir()

g.app.testDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','test'))
#@nonl
#@-node:ekr.20041219072416:<< compute directories >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)
    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2297:open
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:open
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20041124081632:(Problems overriding defaults)
#@+node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
# The window titel problem was in completeFileName.

# The munging needs was done in doType and settingsParser.set.
#@nonl
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
#@+node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20041126035808:(Problems importing Pmw files)
@

- The Pmw source files contain mixed tabs/spaces, which caused most of the problems.
    - A _single_ blank was spanning two indentations.
    - That is always going to be hard for Leo unless heroic measures are taken.

- Created self.tab_width ivar (set by getTabWidth) so import directives honor @tabwidth directives.
#@nonl
#@+node:ekr.20031218072017.3207:import.__init__
def __init__ (self,c):

    self.c = c
    
    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in < < x methods > > =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline(c=c)
    
    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
#@nonl
#@-node:ekr.20031218072017.3207:import.__init__
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@+node:ekr.20031218072017.2256:Python scanners
#@+node:ekr.20031218072017.2257:scanPythonClass
def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace("self.tab_width",self.tab_width)
    # g.trace(g.get_line(s,i))
    classIndent = self.getLeadingIndent(s,i)
    << set classname and headline, or return i >>
    i = g.skip_line(s,i) # Skip the class line.
    << create class_vnode >>
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=True)
    << create nodes for all defs of the class >>
    << append any other class material >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    classname = s[j:i]
    headline = "class " + classname
else:
    return i
#@nonl
#@-node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
#@+node:ekr.20031218072017.2259:<< create class_vnode  >>
# Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# i points just after the class line.

# Add a docstring to the class node.
docStringSeen = False
j = g.skip_ws_and_nl(s,i)
if g.match(s,j,'"""') or g.match(s,j,"'''"):
    j = g.skip_python_string(s,j)
    if j != len(s): # No scanning error.
        i = j ; docStringSeen = True

body = s[start:i]
body = self.undentBody(body)
if docStringSeen: body = body + '\n'
class_vnode = self.createHeadline(parent,prefix + body,headline)
#@nonl
#@-node:ekr.20031218072017.2259:<< create class_vnode  >>
#@+node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
indent =  self.getLeadingIndent(s,i)
start = i = g.skip_blank_lines(s,i)
parent_vnode = None
# g.trace(classIndent)
while i < len(s) and indent > classIndent:
    progress = i
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        j = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,j)
            if indent > classIndent: i = j
            else: break
        else: i = j
    elif g.match_c_word(s,i,"def"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonDef(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif g.match_c_word(s,i,"class"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonClass(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
    elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@+node:ekr.20031218072017.2261:<< create parent_vnode >>
# This must be done after the declaration reference is generated.
if self.treeType == "@file":
    class_vnode.appendStringToBody("\t@others\n")
else:
    ref = g.angleBrackets(" class " + classname + " methods ")
    class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode
#@nonl
#@-node:ekr.20031218072017.2261:<< create parent_vnode >>
#@-node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
#@+node:ekr.20031218072017.2262:<< append any other class material >>
s2 = s[start:i]
if s2:
    class_vnode.appendStringToBody(s2)
#@nonl
#@-node:ekr.20031218072017.2262:<< append any other class material >>
#@-node:ekr.20031218072017.2257:scanPythonClass
#@+node:ekr.20031218072017.2263:scanPythonDef
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    << skip the Python def >>
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2264:<< set headline or return i >>
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@nonl
#@-node:ekr.20031218072017.2264:<< set headline or return i >>
#@+node:ekr.20031218072017.2265:<< skip the Python def >>
# Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = g.skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
#g.trace(defIndent,indent)
#g.trace(g.get_line(s,i))
while i < len(s) and indent > defIndent:
    progress = i
    ch = s[i]
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        i = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,i)
            if indent <= defIndent:
                break
    elif ch == '#':
        i = g.skip_to_end_of_line(s,i) # 7/29/02
    elif ch == '"' or ch == '\'':
        i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@-node:ekr.20031218072017.2265:<< skip the Python def >>
#@+node:ekr.20031218072017.2266:<< Create def node >>
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20031218072017.2266:<< Create def node >>
#@-node:ekr.20031218072017.2263:scanPythonDef
#@+node:ekr.20031218072017.2267:scanPythonDecls
def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    done = False ; start = i
    while not done and i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent <= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << break on def or class >>
        else: i += 1
        assert(progress < i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j < i:
        << Create a child node for declarations >>
    return i
#@nonl
#@+node:ekr.20031218072017.2268:<< break on def or class >>
if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2268:<< break on def or class >>
#@+node:ekr.20031218072017.2269:<< Create a child node for declarations >>
headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
#@nonl
#@-node:ekr.20031218072017.2269:<< Create a child node for declarations >>
#@-node:ekr.20031218072017.2267:scanPythonDecls
#@+node:ekr.20031218072017.2270:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@nonl
#@+node:ekr.20031218072017.2271:<< handle possible Python function or class >>
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file": # 7/29/02
            parent.appendStringToBody("@others\n") # 7/29/02
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2271:<< handle possible Python function or class >>
#@+node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    parent.appendStringToBody(
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@nonl
#@-node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
#@+node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    parent.appendStringToBody(s[start:])
#@nonl
#@-node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20031218072017.2270:scanPythonText
#@-node:ekr.20031218072017.2256:Python scanners
#@-node:ekr.20041126035808:(Problems importing Pmw files)
#@+node:ekr.20041124164305:(Eliminated alarming warning message)
@

The fix really should be in putDescendentAttributes and putUnknownAttributes.

These methods shouldn't write gnx's that don't exist.
#@nonl
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())

    for theList,tag in ((marks,"marks="),(expanded,"expanded=")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            self.put('\n' + tag)
            self.put_in_dquotes(s)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            try:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            except TypeError:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)
        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:ekr.20041124164305:(Eliminated alarming warning message)
#@+node:ekr.20041127055549:(Don't call plugins for null gui's)
# Added isNullGui ivar to gui classes.
#@nonl
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None

    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
            
    # Get the hook handler function.  Usually this is doPlugins.
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    if 0: # Don't use trace here!
        if 1:
            old_c = keywords.get('old_c')
            if old_c: print 'doHook %24s %s' % (tag,old_c.shortFileName())
        else:
            if tag != "idle": print 'doHook %24s old_c: %s' % (tag,c and c.shortFileName())
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20041127055549:(Don't call plugins for null gui's)
#@+node:ekr.20041127094814:(Mods to drawTopTree)
@

I haven't been able to use the base drawTopTree method.

Don't know just why: some problem with the canvas, probably.
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount,c.rootPosition())

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c ; v = p.v
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t
#@nonl
#@-node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
#@+node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@nonl
#@-node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
#@+node:ekr.20040305171133:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:p.allNodes_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    redraw_flag = False
    
    # g.trace(p)

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20041127094814:(Mods to drawTopTree)
#@+node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self,*args,**keys):
    pass
    
def lift (self,*args,**keys):
    pass
    
def update (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self,*args,**keys):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry(self,w,h,x,y):
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
    
    
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    # initialize the sub-commanders
    self.fileCommands = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20041201075146:(Updated recent files properly)
#@+node:ekr.20041201083311:What I did
@killcolor

- g.openWithFileName now calls:
    frame.c.config.setRecentFiles(g.app.config.recentFiles)

That is, all new files get the global file list.

- Created config.appendToRecentFiles.

- c.ConfigParser.setRecentFiles calls config.appendToRecentFiles.

That is, we never remove files from the recent files list, we only add files.

- Added << update recent files from d >> to config.readSettingsFiles.

This calls config.appendToRecentFiles(files) to actually set the files.
#@nonl
#@-node:ekr.20041201083311:What I did
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041201080436.1:Notes
@killcolor

Leo writes the recent files node correctly, but does not init them correctly.
#@nonl
#@-node:ekr.20041201080436.1:Notes
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20041123092357:config.findSettingsPosition
def findSettingsPosition (self,c,setting):
    
    """Return the position for the setting in the @settings tree for c."""
    
    munge = self.munge
    
    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()
        
    setting = munge(setting)
        
    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()
    
    return c.nullPosition()
#@nonl
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041201080436:config.appendToRecentFiles
def appendToRecentFiles (self,files):
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:config.appendToRecentFiles
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    theHash = c.hash()
                    d['_hash'] = theHash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[theHash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s" % (g.shortFileName(path)),color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@-node:ekr.20041201075146:(Updated recent files properly)
#@-node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041211051934.1:12/11
#@+node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2866490

I've noticed that even if the mod_speling.ini is changed, the language is alway
set as en_US !

to Correct this and being able to launch the correct language, i've changed
he following code :

''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir)

by :
''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir, lang=local_language_code)

..................
This seem to work on my install !

BUT
the hardcodding of the aspell_dir in the plugin code is UGLY !!!

It should also be fine to add a directive or a menu under the plugins_menu"
to change the language and reinitialise the spell_checker for spelling multilingual
documents.....
#@-node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
#@-node:ekr.20041211051934.1:12/11
#@+node:ekr.20041216052925:12/17
#@+node:ekr.20041211043135:(Fix problems with c.ivars)
@

What ivars get changed--local (c) or global(g.app.config) ??

Presently, only g.app.config.page_width and g.app.config.tab_width get changed.
#@nonl
#@+node:ekr.20041211050623:From 4.2
@ignore
#@nonl
#@+node:ekr.20041211050623.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20041211050623.1:defaultsDict
#@+node:ekr.20041211050623.2:initialize ivars that may be set by config options
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False

# TO BE REMOVED:
self.write_old_format_derived_files = False # Use new format if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.2:initialize ivars that may be set by config options
#@+node:ekr.20041211050623.3:set in c.__init__
# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.3:set in c.__init__
#@-node:ekr.20041211050623:From 4.2
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settins class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@+node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    frame.c.fileCommands.open(theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    theHash = c.hash()
                    d['_hash'] = theHash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[theHash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s" % (g.shortFileName(path)),color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.mFileName)
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@-node:ekr.20041211043135:(Fix problems with c.ivars)
#@+node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041213082558.1:parseFont
def parseFont (self,p):
    
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(p,line,d)
        
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
        
    return d
#@nonl
#@-node:ekr.20041213082558.1:parseFont
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,p,line,d):
    
    s = line.strip()
    if not s: return
    
    try:
        s = str(s)
    except UnicodeError:
        pass
    
    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip() ; val = s[i+1:].strip()

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@nonl
#@-node:ekr.20041213082558.2:parseFontLine
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@nonl
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
@ It is essential to retain a link to a font.  Otherwise changes to one font may affect other fonts.

This appears to be a bug in Tk or Tkinter.
#@nonl
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize, tag = "log")

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@+node:ekr.20031218072017.2183:tkBody.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; body = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "body")
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    body.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@nonl
#@-node:ekr.20031218072017.2183:tkBody.setFontFromConfig
#@+node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):
    
    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")
    
    self.setFont(font)
#@nonl
#@-node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041217041016:setFontFromConfig
def setFontFromConfig (self):
    
    c = self.c
    
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold")
    
    if self.bold_font:
        self.bold_font.configure(weight="bold")
    
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer italic")
        
    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")
    
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold italic")
        
    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")
        
    self.color_tags_list = []
    self.image_references = []
#@nonl
#@-node:ekr.20041217041016:setFontFromConfig
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    
    d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        t = Tk.Text(canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)
            t.bind("<Control-t>",self.onControlT)
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # Bug fix 7/31/04:  We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString(),tag="newText")
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # New in 4.2 b3: entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList

    # g.trace(p,t)
    return t
#@nonl
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
#@+node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    theHash = c.hash()
                    d['_hash'] = theHash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[theHash] = d
                        << update recent files from d >>
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s" % (g.shortFileName(path)),color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041217135735.3:(Update all colors immediately)
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20040803072955.30:tkTree.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        self.canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.30:tkTree.setColorFromConfig
#@-node:ekr.20041217135735.3:(Update all colors immediately)
#@-node:ekr.20041216052925:12/17
#@+node:ekr.20041221070525.1:12/18
#@+node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@+node:ekr.20031218072017.3098:class Bunch (object)
@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared > threshold:
        point.isok = True
@c

class Bunch (object):
    
    """A class that represents a colection of things.
    
    Especially useful for representing a collection of related variables."""
    
    def __init__(self,**keywords):
        self.__dict__.update (keywords)
        
    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()
        
    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    if 0:
        def __setitem__ (self,key,value):
            '''Support aBunch[key] = val'''
            return operator.setitem(self.__dict__,key,value)
            
        def __getitem__ (self,key):
            '''Support aBunch[key]'''
            return operator.getitem(self.__dict__,key)
        
bunch = Bunch
#@nonl
#@-node:ekr.20031218072017.3098:class Bunch (object)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@-node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@-node:ekr.20041221070525.1:12/18
#@+node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes(self):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3689:initialRatios
def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","orientation")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@nonl
#@-node:ekr.20031218072017.3689:initialRatios
#@-node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041222092032:(Tried using place to show widgets)
@

This did not work: _tkinter.TclError: can't place

.24597368.24598448.24610776.24610936 relative to
.24597368.24598448.24598768.24599008.24608856.24609096
#@nonl
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@-node:ekr.20041222092032:(Tried using place to show widgets)
#@+node:ekr.20041224100539:(Replacing body pane)
#@+node:ekr.20041223130609:class componentBaseClass
class componentBaseClass:

    @others
#@nonl
#@+node:ekr.20041223154028: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    self.c = c
    self.frame = frame    # The Tk.Frame containing the component.
    self.isVisible = False # True if the component is visible.
    self.name = name      # The component's name: the key for c.frame.componentsDict.
    self.obj = obj        # Optional object (typically not a Tk.Frame.)
    self.packer = packer
    self.unpacker = unpacker

    c.frame.componentsDict[name] = self
#@nonl
#@-node:ekr.20041223154028: ctor
#@+node:ekr.20041223124910:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223124910:__repr__
#@+node:ekr.20041223154028.1:oops
def oops (self):
    
    print ("componentBaseClass oops:",
        g.callerName(2),
        "must be overridden in subclass")
#@-node:ekr.20041223154028.1:oops
#@+node:ekr.20041223154028.2:getters
# Getters...
def getFrame    (self): return self.frame
def getObject   (self): return self.obj
def getPacker   (self): return self.packer
def getUnpacker (self): return self.unpacker
#@-node:ekr.20041223154028.2:getters
#@+node:ekr.20041223154028.3:must be defined in subclasses
def destroy (self):
    self.oops()
#@nonl
#@-node:ekr.20041223154028.3:must be defined in subclasses
#@+node:ekr.20041224072245:show & hide, pack & unpack
# Pack always packs the widget, which can make it visble in two places.
# Show packs a new widget only if it is not visible.

def hide (self):
    if self.isVisible:
        self.isVisible = False
        self.unpack()

def pack (self):
    self.oops()
    
def show (self):
    if not self.isVisible:
        self.isVisible = True
        self.pack()
    
def unpack (self):
    self.oops()
    
#@-node:ekr.20041224072245:show & hide, pack & unpack
#@-node:ekr.20041223130609:class componentBaseClass
#@+node:ekr.20041223095751:class componentClass (componentBaseClass)
class componentClass (leoFrame.componentBaseClass):
    
    '''A class to manage components of Leo windows'''
    
    @others
#@nonl
#@+node:ekr.20041223095751.1: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    # Init the base class.
    leoFrame.componentBaseClass.__init__(
        self,c,name,frame,obj,packer,unpacker)
    
    self.setPacker(packer)
    self.setUnpacker(unpacker)
#@nonl
#@-node:ekr.20041223095751.1: ctor
#@+node:ekr.20041223154028.4:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223154028.4:__repr__
#@+node:ekr.20041223124022:destroy
def destroy (self):
    
    try:
        del c.frame.componentsDict[self.name]
    except KeyError:
        g.es("No component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041223124022:destroy
#@+node:ekr.20041223124022.1:getters & setters
# Setters...
def setPacker (self,packer):
    if not packer: # Define default packer.
        def packer():
            if self.frame:
                self.frame.pack(side='top',expand=1,fill='both')
    self.packer = packer

def setUnpacker (self,unpacker):
    if not unpacker: # Define default unpacker.
        def unpacker():
            if self.frame:
                self.frame.pack_forget()
    self.unpacker = unpacker
#@nonl
#@-node:ekr.20041223124022.1:getters & setters
#@+node:ekr.20041223095751.2:pack & unpack
def pack (self):

    self.packer()
    
def unpack (self):

    self.unpacker()
#@nonl
#@-node:ekr.20041223095751.2:pack & unpack
#@-node:ekr.20041223095751:class componentClass (componentBaseClass)
#@+node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223160653:pane packers
if 0: # placeSplitter and divideAnySplitter.
    << reference code >>

def placePane1(self,verticalFlag,pane1,frac):
    if verticalFlag:
        pane1.place(relx=0.5,rely=0,anchor="n",relwidth=1.0,relheight=frac)
    else:
        pane1.place(rely=0.5,relx=0,anchor="w",relheight=1.0,relwidth=frac)
        
def placePane2(self,verticalFlag,pane2,frac):
    if verticalFlag:
        pane2.place(relx=0.5,rely=1.0,anchor="s",relwidth=1.0,relheight=1-frac)
    else:
        pane2.place(rely=0.5,relx=1.0,anchor="e",relheight=1.0,relwidth=1-frac)

# These are the packers of the corresponding components.
# These are called from, packComponent('body'), etc.
def packBody (self):
    # Pane 2 of primary splitter.
    self.placePane2(self.splitVerticalFlag,self.split1Pane2,self.ratio)
def packLog (self):
    # Pane 2 of secondary splitter.
    self.placePane2(not self.splitVerticalFlag,self.split2Pane2,self.secondary_ratio)
def packTree (self):
    # Pane 1 of secondary splitter.
    self.placePane1(not self.splitVerticalFlag,self.split2Pane1,self.secondary_ratio)
#@nonl
#@+node:ekr.20041223165701:<< reference code >>
@ Reference code.  The placer code is a combination of these...
Most args come from placeSplitter.
The relheight/width args come from divideAnySplitter.
@c

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):
    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)

def placeSplitter (self,bar,pane1,pane2,verticalFlag):
    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@-node:ekr.20041223165701:<< reference code >>
#@-node:ekr.20041223160653:pane packers
#@+node:ekr.20041224102942:pane replacers
#@+node:ekr.20041224105456.1:replaceBodyPaneWithComponent
def replaceBodyPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packBody)
            component.setUnpacker(self.unpackBody)
            self.unpackComponent('body')
            self.split1Pane2 = f
            self.packBody()
#@nonl
#@-node:ekr.20041224105456.1:replaceBodyPaneWithComponent
#@+node:ekr.20041224105456.3:replaceLogPaneWithComponent
def replaceLogPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packLog)
            component.setUnpacker(self.unpackLog)
            self.unpackComponent('log')
            self.split2Pane2 = f
            self.packLog()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.3:replaceLogPaneWithComponent
#@+node:ekr.20041224105456.4:replaceTreePaneWithComponent
def replaceTreePaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packTree)
            component.setUnpacker(self.unpackTree)
            self.unpackComponent('tree')
            self.split2Pane1 = f
            self.packTree()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.4:replaceTreePaneWithComponent
#@-node:ekr.20041224102942:pane replacers
#@+node:ekr.20041223162512:pane unpackers
# These are the packers of the corresponding components.

def unpackBody(self):
    self.split1Pane2.place_forget()
    
def unpackLog(self):
    self.split2Pane2.place_forget()

def unpackTree(self):
    self.split2Pane1.place_forget()
#@nonl
#@-node:ekr.20041223162512:pane unpackers
#@+node:ekr.20041222061439:pack/unpackComponent
# Note: the 'packers' for the 'body', 'log' and 'tree' components are actually placers,
# so packing twice does not duplicate those component.

def packComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.pack()
    elif verbose:
        g.es("packComponent: no component named %s" % name,color='blue')

def unpackComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.unpack()
    elif verbose:
        g.es("unpackComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041222061439:pack/unpackComponent
#@+node:ekr.20041224072631:show/hideComponent
def hideComponent (self,name):
    component = self.component(name)
    if component:
        component.hide()
    else:
        g.es("hideComponent: no component named %s" % name,color='blue')

def showComponent (self,name):
    component = self.component(name)
    if component:
        component.show()
    else:
        g.es("showComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041224072631:show/hideComponent
#@+node:ekr.20041222061331:pack/unpack/FrameWidgets
if 0: # This obscure the generality of components.

    def packFrameWidgets (self):
        for name in ('splitter1','statusLine'):
            component = self.component(name)
            if component:
                component.pack()
                
    def unpackFrameWidgets (self):
        for name in ('splitter1','statusLine'):
            component = self.component(name)
            if component:
                component.unpack()
#@nonl
#@-node:ekr.20041222061331:pack/unpack/FrameWidgets
#@+node:ekr.20041222061331.1:unpackFrameWidgets


#@-node:ekr.20041222061331.1:unpackFrameWidgets
#@-node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@nonl
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='statusLine.disable')
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.frame.statusLineWantsFocus(t,tag='statusLine.ensable')
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@nonl
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@nonl
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@nonl
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack
#@nonl
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:EKR.20040424154804:setFocus
if 0: # No longer used in 4.3.  Done as the result of statusLineWantsFocus.

    def setFocus (self):
    
        # Force the focus to the icon area.
        t = self.textWidget
        if t:
            t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocus
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@nonl
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update
def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col > 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)
#@nonl
#@-node:ekr.20031218072017.1733:update
#@-node:ekr.20041223104933:class statusLineClass
#@+node:ekr.20031218072017.3953:Icon area methods (compatibility)
def getIconBarObject(self):
    component = self.component(self.iconBarComponentName)
    if not component: return g.trace("No iconBar component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.iconBarComponentName))
                
def callIconBar(self,name,*args,**keys):
    obj = self.getIconBarObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.iconBarComponentName,name))

def addIconButton (self,*args,**keys):
    return self.callIconBar('add',*args,**keys)

def clearIconBar (self):
    return self.callIconBar('clear')

def createIconBar (self):
    self.callIconBar('show')
    return self.getIconBarObject() # For compatibility.

def hideIconBar (self):
    return self.callIconBar('hide')
#@nonl
#@-node:ekr.20031218072017.3953:Icon area methods (compatibility)
#@+node:ekr.20041223105114.1:Status line methods (compatibility)
def getStatusObject(self):
    component = self.component(self.statusLineComponentName)
    if not component: return g.trace("No statusLine component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.statusLineComponentName))
                
def callStatus(self,name,*args,**keys):
    obj = self.getStatusObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.statusLineComponentName,name))

def createStatusLine (self):
    self.callStatus('show')
    return self.getStatusObject() # For compatibility.

def clearStatusLine (self):
    return self.callStatus('clear')
    
def disableStatusLine (self,background=None):
    return self.callStatus('disable',background)

def enableStatusLine (self,background="white"):
    return self.callStatus('enable',background)

def getStatusLine (self):
    return self.callStatus('get')
    
def putStatusLine (self,s,color=None):
    return self.callStatus('put',s,color)
    
def setFocusStatusLine (self):
    return self.callStatus('setFocus')

def statusLineIsEnabled(self):
    return self.callStatus('isEnabled')
#@nonl
#@-node:ekr.20041223105114.1:Status line methods (compatibility)
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.revertHeadline = None # Previous headline text for abortEditLabel.
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:ekr.20041224100539:(Replacing body pane)
#@-node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041228052058:12/28
#@+node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20041122094813:<<  class data >>
@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@nonl
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@nonl
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settins class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  class data >>
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,val):
    
    # g.trace(name,val)
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",val)
#@nonl
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041120113848:doShortcut
def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120113848:doShortcut
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    rawKey = key.replace('&','') # Allow '&' in names.
    val = self.get(c,rawKey,"shortcut")
    if val is None:
         return rawKey,None
    else:
        # g.trace(key,val)
        return rawKey,val
#@nonl
#@-node:ekr.20041117062717.14:getShortcut (config)
#@-node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20041227081942:(Made ivars functional)
#@+node:ekr.20041228050029:What I did
@killcolor

- Created setIvarsFromSettings.
    - Called from end of readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init commmander ivars.

- leoPrefs.py and leoTkinterPrefs are no longer used.
#@nonl
#@-node:ekr.20041228050029:What I did
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@-node:ekr.20041227081942:(Made ivars functional)
#@-node:ekr.20041228052058:12/28
#@-node:ekr.20041228053248:Diary
#@+node:ekr.20050121062047:(Added scrollbars to settings outline pane)
#@+node:ekr.20041225073207:When replacing body & tree panes...
#@-node:ekr.20041225073207:When replacing body & tree panes...
#@-node:ekr.20050121062047:(Added scrollbars to settings outline pane)
#@+node:ekr.20050121094515:(Improved appearance of settings panel)
#@+node:ekr.20050121094515.1:What I did
@killcolor

What I did:

- Placed comment and setter widgets in a ScrolledCanvas widget.

This is _far_ better than using two separate scrollers.

- Put label on same line as icons.

- All parts of the canvas now use a common background color.

It's surprisingly hard to pick a good color. Neither 'white' nor dark colors look good.
#@nonl
#@-node:ekr.20050121094515.1:What I did
#@-node:ekr.20050121094515:(Improved appearance of settings panel)
#@+node:ekr.20050122104754:(Clear Recent Files now updates @recent_files node properly)
#@+node:ekr.20050122104857:To do: implement 'Undo Clear Recent Files'
#@-node:ekr.20050122104857:To do: implement 'Undo Clear Recent Files'
#@+node:ekr.20050122104754.1:What I did
@killcolor

- Fixed latent bug in setBodyStringOrPane.

This method now updates the body pane if any clone of the current node changes.

This is important, the settings node found by findSettingsPosition may be a clone of the current node!

- clearRecentFiles now calls c.config.setRecentFiles.
#@nonl
#@-node:ekr.20050122104754.1:What I did
#@+node:ekr.20041122162610:@recent_files
C:\Documents and Settings\Ed\My Documents\ekr.leo
C:\prog\leoCVS\leo\test\test.leo
c:\prog\leoCVS\leo\doc\LeoDocs.leo
C:\prog\leoCVS\leo\src\LeoPy.leo
C:\prog\leoCVS\leo\config\leoSettings.leo
c:\prog\leoCVS\leo\plugins\leoPlugins.leo
C:\prog\Leo Stuff\oldLeoFiles.leo
#@nonl
#@-node:ekr.20041122162610:@recent_files
#@+node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts
#@nonl
#@-node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.mFileName)
    c.config.setRecentFiles(c.recentFiles)
#@nonl
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@-node:ekr.20050122104754:(Clear Recent Files now updates @recent_files node properly)
#@+node:ekr.20041231104531:(Made sure recent files have correct capitalization)
#@+node:ekr.20050122105504:What I did
@killcolor

c.updateRecentFiles now 'munges' all names during the compare, so capitalization difference don't matter:  all files matching the file name get removed.
#@-node:ekr.20050122105504:What I did
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20041231104531:(Made sure recent files have correct capitalization)
#@+node:ekr.20050123143229.1:(Print setting changes to log)
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
                print s ; g.es(s,color='blue')
            else:
                s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
                print s ; g.es(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        elif munge(name) == "recentfiles":
            c.setRecentFiles(val)
        else:
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    #g.trace(root2.c.mFileName)
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind in ('shortcuts','recentfiles'):
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(p,val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,p,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList,tag):
    
    if not changedList: return
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # isLocal = rootDict.get('isLocal')
        if changes:
            self.writeChangesToFile(c,changes,path)
            self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)

    if c.mFileName:
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.mFileName)
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050123143229.1:(Print setting changes to log)
#@+node:ekr.20050123143229:(Disabled all commands while in settings dialog)
#@+node:ekr.20031218072017.2817: doCommand
def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()

    # A horrible kludge: set g.app.log to cover for a possibly missing activate event.
    g.app.setLog(c.frame.log,"doCommand")
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label == "cantredo": label = "redo"
    if label == "cantundo": label = "undo"
    g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            command()
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            c.frame.tree.redrawAfterException() # 1/26/04
    
    c = g.top() # 6/17/04: The command can change the commander.
    if c:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.
#@nonl
#@-node:ekr.20031218072017.2817: doCommand
#@+node:ekr.20041225063637.51:onAnyButton
def onAnyButton(self,name):
    
    c = self.c
    endDialog = name in (None,"OK","Cancel")
    
    # g.trace(name)
    
    dispatchDict = {
        "Apply":    self.writeChangedVars,
        "Cancel":   None, # Do nothing.
        "OK":       self.writeChangedVars,
        "Revert":   self.revert,
    }
    
    f = dispatchDict.get(name)
    if f: f()
        
    if self.replaceBody:
        if endDialog:
            c.frame.replaceTreePaneWithComponent('tree')
            c.frame.replaceBodyPaneWithComponent('body')
            c.disableCommandsMessage = '' # Re-enable all commands.
    else:
        if endDialog:
            self.dialog.destroy()
            c.disableCommandsMessage = '' # Re-enable all commands.
        else:
            self.dialog.withdraw()
            self.dialog.deiconify()
#@nonl
#@-node:ekr.20041225063637.51:onAnyButton
#@-node:ekr.20050123143229:(Disabled all commands while in settings dialog)
#@-node:ekr.20041115111203:Config...
#@+node:ekr.20041228052527.2:New features...
#@+node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
enable(menu,"Expand Or Go Right",hasChildren)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@nonl
#@-node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
 
    if v.hasChildren() and v.isExpanded():
        c.contractNode()
    elif v.hasParent():
        c.goToParent()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
    if not v.hasChildren(): return

    if v.isExpanded():
        c.beginUpdate()
        c.selectVnode(v.firstChild())
        c.endUpdate()
    else:
        c.expandNode()
#@nonl
#@-node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
#@-node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self,fromString=None):
        # New in 4.2.1: allow the file to be inited from string s.
        if fromString: self.list = g.splitLines(fromString) # Must preserve newlines!
        else: self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr < len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)
#@nonl
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041025145856.1:What I did
@killcolor

- Tab toggles between the Search to the Replace areas.
- Control-Tab inserts a tab.
- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  (The Enter key activates the Find button.)
- As usual, Alt-F4 dismisses the Find panel.

To do next:  allow all search settings and commands to be activated from the status line.
#@nonl
#@-node:ekr.20041025145856.1:What I did
#@+node:ekr.20041025152343:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20041025152712:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20041025152712:__init__
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.callback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20041025152717:callback
# The hot key has been hit.  Call the button's command.

def callback (self, event):

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20041025152717:callback
#@-node:ekr.20041025152343:class underlinedTkButton
#@+node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3899:__init__
def __init__(self,c,resizeable=False,title=None):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable)
    
    if g.app.unitTesting:return

    << create the tkinter intVars >>
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20031218072017.3900:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20031218072017.3900:<< create the tkinter intVars >>
#@-node:ekr.20031218072017.3899:__init__
#@+node:ekr.20031218072017.3901:destroySelf
def destroySelf (self):
    
    self.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3901:destroySelf
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("<1>",  self.resetWrap)
        widget.bind("<Key>", self.resetWrap)
        widget.bind("<Control-a>",self.selectAll)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    for widget in (outer, self.find_ctrl, self.change_ctrl):
        widget.bind("<Key-Return>", findButtonCallback)
        widget.bind("<Key-Escape>", self.onCloseWindow)
    
    self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)
<< Bind Tab and control-tab >>

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@+node:ekr.20041026092141:<< Bind Tab and control-tab >>
def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20041026092141:<< Bind Tab and control-tab >>
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&Script Search","script-search")]
checkLists[0] = [
    ("Scrip&t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&Whole Word",  self.dict["whole_word"]),
    ("&Ignore Case", self.dict["ignore_case"]),
    ("Wrap &Around", self.dict["wrap"]),
    ("&Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &Headline Text", self.dict["search_headline"]),
    ("Search &Body Text",     self.dict["search_body"]),
    ("&Mark Finds",           self.dict["mark_finds"]),
    ("Mark &Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None):
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.
findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
#@nonl
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@-node:ekr.20031218072017.3898:Birth & death
#@-node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
@ It's not clear that this support is so useful for debugging scripts...
#@nonl
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
#@+node:ekr.20041107093219:(Added support for Forth)
@nocolor

Forth support by David McNab, <david@freenet.org.nz>.

Changes by EKR:
    
- Look for extension files in plugins folder.
- Moved data structures into leoColor class.
- Suppress message about extra words during unit testing and in batch mode.
- Created this project node.

@color
#@nonl
#@+node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20041107094252:<< extend forth words from files >>
# Associate files with lists: probably no need to edit this.
forth_items = (
    (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
    (self.forth_keywords, "leo-forthwords.txt", "words"),
    (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
    (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
    (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
    (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
)

# Add entries from files (if they exist) and to the corresponding wordlists.
for (lst, path, typ) in forth_items:
    try:
        extras = []
        path = g.os_path_join(g.app.loadDir,"..","plugins",path) # EKR.
        for line in file(path).read().strip().split("\n"):
            line = line.strip()
            if line and line[0] != '\\':
                extras.append(line)
        if extras:
            if 0: # I find this annoying.  YMMV.
                if not g.app.unitTesting and not g.app.batchMode:
                    print "Found extra forth %s" % typ + ": " + " ".join(extras)
            lst.extend(extras)
    except IOError:
        # print "Not found",path
        pass
#@nonl
#@-node:ekr.20041107094252:<< extend forth words from files >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.1896:doNormalState
## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&<>' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&*()_+-={}|[];':\",./<>?")
    ):
        << handle possible keyword >>
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        << handle at keyword >>
    elif g.match(s,i,self.single_comment_start):
        << handle single-line comment >>
    elif g.match(s,i,self.block_comment_start):
        << start block comment >>
    elif ch == '%' and self.language=="cweb":
        << handle latex line >>
    elif self.language=="latex":
        << handle latex normal character >>
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        << handle string >>
    elif ch == '#' and self.has_pp_directives:
        << handle C preprocessor line >>
    elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        << handle special php keywords >>
    elif ch == ' ':
        << handle blank >>
    elif ch == '\t':
        << handle tab >>
    else:
        << handle normal character >>

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress < i)
    return i,state
#@nonl
#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
    << handle possible latex keyword >>
elif self.language == "html":
    << handle possible html keyword >>
elif self.language == "forth":
    << handle possible forth keyword >>
else:
    << handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
    if g.match(s,i,"<!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
    if g.match(s,i,"</"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,">"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@+node:ekr.20041107093219.3:<< handle possible forth keyword >>
j = self.skip_id(s,i+1,chars="`~!@#$%^&*()-_=+[]{};:'\\\",./<>?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
#@nonl
#@-node:ekr.20041107093219.3:<< handle possible forth keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@<"):
        << handle cweb ref or def >>
    else:
        word = self.getCwebWord(s,i)
        if word:
            << Handle cweb control word >>
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@>",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
    j = s.find("@>",i)
    if j > -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
# g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?>"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@-node:ekr.20031218072017.1896:doNormalState
#@-node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v
#@nonl
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@nonl
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041107094641:scanForthText
def scanForthText (self,s,parent):
    
    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    parent.setBodyStringOrPane("@ignore\n" + "@language forth\n" + self.rootLine + s)
#@nonl
#@-node:ekr.20041107094641:scanForthText
#@-node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@-node:ekr.20041107093219:(Added support for Forth)
#@+node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041111100436:Notes
@killcolor

What I did:

- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without this?

- Added sciptFind ivar and related logic to goToLineNumber and it allies.
#@nonl
#@-node:ekr.20041111100436:Notes
#@+node:ekr.20031218072017.3112:es_exception
def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()
    
    full = full or g.app.debugSwitch > 0

    if full: lines = traceback.format_exception(typ,val,tb)
    else:    lines = traceback.format_exception_only(typ,val)
        
    fileName,n = g.getLastTracebackFileAndLineNumber()

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line
            
    if g.app.debugSwitch > 1:
        pdb.set_trace()

    return fileName,n
#@nonl
#@-node:ekr.20031218072017.3112:es_exception
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,script=None):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()

    try:
        if script:
            s = script
        else:
            script = ''
            # Allow p not to be the present position.
            if p == c.currentPosition():
                if useSelectedText and c.frame.body.hasTextSelection():
                    # Temporarily replace v's body text with just the selected text.
                    s = c.frame.body.getSelectedText()
                    p.v.setTnodeText(s)
                else:
                    s = c.frame.body.getAllText()
            else:
                s = p.bodyString()
                
        # New in 4.3: Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            # New in 4.3: Selecting text executes _only_ the selected text.
            # This removes some indentation problems, but not all of them.
            if useSelectedText and c.frame.body.hasTextSelection():
                script = s
            else:
                at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
                script = at.stringOutput
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    p.v.setTnodeText(old_body)
    
    # g.trace(repr(c.atFileCommands.output_newline))
    if c.atFileCommands.output_newline == '\r\n':
        return script.replace("\r\n","\n") # 1/11/05
    else:
        return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_returns
def test_g_getScript_strips_returns():

    old_output_newline = c.atFileCommands.output_newline
    c.atFileCommands.output_newline = '\r\n'
    script = g.getScript(c,p)
    c.atFileCommands.output_newline = old_output_newline
    
    assert script.find('\r\n') == -1
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_returns
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@-node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041111114148.1:What I did
Added the following back:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event

Added documentation for the following:
    


Added leoPlugins.unregisterHandler and getHandlersFor tag for testing.

#@-node:ekr.20041111114148.1:What I did
#@+node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111124831:getHandlersForTag
def getHandlersForTag(tags):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        result = []
        for tag in tags:
            fn = getHandlersForOneTag(tag) 
            result.append((tag,fn),)
        return result
    else:
        return getHandlersForOneTag(tags)

def getHandlersForOneTag (tag):

    global handlers

    bunch = handlers.get(tag)
    return bunch.fn
#@nonl
#@-node:ekr.20041111124831:getHandlersForTag
#@+node:ekr.20041111123313:unregisterHandler
def unregisterHandler(tags,fn):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            unregisterOneHandler(tag,fn)
    else:
        unregisterOneHandler(tags,fn)

def unregisterOneHandler (tag,fn):

    global handlers
    
    if 1: # New code
        bunches = handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.fn != fn]
        handlers[tag] = bunches
    else:
        fn_list = handlers.get(tag)
        if fn_list:
            while fn in fn_list:
                fn_list.remove(fn)
            handlers[tag] = fn_list
            # g.trace(handlers.get(tag))
#@nonl
#@-node:ekr.20041111123313:unregisterHandler
#@-node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111121907:Changed code
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""
    
    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    << set vdrag, childFlag >>
    if c.config.getBool("allow_clone_drags"):
        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
            self.controlDrag = c.frame.controlKeyIsDown

    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")
    
    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
if self.trace and self.verbose:
    g.trace("*** end drag   ***",\
        theId,x,y,p.headString(),vdrag.headString())
if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    if self.trace and self.verbose:
        g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    
    if self.trace and self.verbose: g.trace()
    p = self.eventToPosition(event)
    if not p: return

    if not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        if p.isExpanded(): p.contract()
        else:              p.expand()
        self.active = True
        # Schedule the redraw _before_ calling select.
        # This disables any call that would configure old text widgets.
        self.redraw()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
            
        c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='onClickBoxClick')
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    tree = self ; canvas = tree.canvas
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivate(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@-node:ekr.20041111121907:Changed code
#@-node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041112062558:Added p=p param to all hooks containing v=v
@killcolor

Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",
#@nonl
#@-node:ekr.20041112062558:Added p=p param to all hooks containing v=v
#@+node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041121121900:What I did
@killcolor

- Removed createGlobalsWindows: Leo has no more global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.

- Ignore all find settings in getFindPanelSettings.  leoFind.init gets these from @settings.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, an allie of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.

@color
#@nonl
#@-node:ekr.20041121121900:What I did
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@+node:ekr.20031218072017.1460:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20031218072017.1460:find.update_ivars
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):
    
    if self.getOpenTag("<find_panel_settings"):
        return # <find_panel_settings/> seen.
    
    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag(">"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only <find_string> or <find_string/>
    if self.getOpenTag("<find_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</find_string>")
    # Allow only <change_string> or <change_string/>
    if self.getOpenTag("<change_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</change_string>")
    self.getTag("</find_panel_settings>")
#@nonl
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@-node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041219065925:Notes
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2871977

- (done) created g.app.extensionsDir

- (done) created g.importModule and g.importExtension.

Now you can put Pmw into the extensions directory and have Leo easily import it from there.

Doing so gives you a way to add Pmw easily and any other 3rd party libs Leo ever needs.
#@nonl
#@-node:ekr.20041219065925:Notes
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    << compute directories >>
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416:<< compute directories >>
g.app.loadDir = computeLoadDir()
    # Depends on g.app.tkEncoding: uses utf-8 for now.

g.app.homeDir = computeHomeDir()

g.app.extensionsDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','extensions'))

g.app.globalConfigDir = computeGlobalConfigDir()

g.app.testDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','test'))
#@nonl
#@-node:ekr.20041219072416:<< compute directories >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)
    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@-node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@+node:ekr.20041231112215.1:Original posting
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2915750
By: cmbanker

The HOME environment variable on windows machines is often a referrence to yet
another environment variable.  i.e.  %HOME% --> %USERENVIRONMENT% --> "C:\Documents
and Settings\...."

The fix: Patch computeHomeDir() to test the first retrieval of the %HOME% var and grab
it's results if it is infact another enviroment variable.

@color

def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    
    home = os.getenv('HOME',default=dotDir)
    
    #verify that we've not got an indirect reference to true home
    if (home[0]=='%') and ( home[-1]=='%'):
	    #yep, must be a win32 machine - get this one
	    home = os.getenv(home[1:-1],default=dotDir)


    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@-node:ekr.20041231112215.1:Original posting
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)
    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)
    
    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@+node:ekr.20050111082850:(Changes to plugin handling)
#@+node:ekr.20050111082850.1:What I did
@killcolor

- Used g.Bunch in handlers data structure.
- Use a stack to associate moduleNames with handlers.
    - loadOnePlugin pushes the plugin's short file on the stack.
    - callTagHandler pushes the handler's moduleName on the stack so
      calls to registerHandler, etc. inside handlers get associated with the proper module.

Note: at present unit tests are very difficult to test properly. UnloadOnePlugin
is not enough: simply deactivating all handers is not enough. For example, this
does undo Tk bindings.

- At the least, an 'unload' hook would be required to reverse the effect of the plugin.
- For now, I'll see if having registerHandler do nothing if g.app.unitTesting is in effect suffices.
#@nonl
#@-node:ekr.20050111082850.1:What I did
#@+node:ekr.20050111102926:Bugs fixed
@killcolor

Fixed bug in how iconBar was created that resulted in rowcol plugin working improperly.
#@nonl
#@-node:ekr.20050111102926:Bugs fixed
#@+node:ekr.20031218072017.1318:g.plugin_signon
def plugin_signon(module_name,verbose=False):
    
    # The things we do to keep pychecker happy... 
    m = g.Bunch(__name__='',__version__='')
    
    exec("import %s ; m = %s" % (module_name,module_name))
    
    if verbose: # or g.app.unitTesting:
        g.es("...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))

        print m.__name__, m.__version__
        
    app.loadedPlugins.append(module_name)
#@nonl
#@-node:ekr.20031218072017.1318:g.plugin_signon
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20031218072017.3443:registerHandler
def registerHandler(tags,fn):
    
    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""
    
    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'
    
    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:
        
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)
        
    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items
#@nonl
#@-node:ekr.20031218072017.3443:registerHandler
#@-node:ekr.20050111082850:(Changes to plugin handling)
#@+node:ekr.20050119211822.2:(Added support for Leo-relative files)
#@+node:ekr.20050119211822:@url file:.\..\doc\LeoDocs.leo#Users Guide-->Chapter 8: Customizing Leo
#@-node:ekr.20050119211822:@url file:.\..\doc\LeoDocs.leo#Users Guide-->Chapter 8: Customizing Leo
#@+node:ekr.20050119220219:Notes
@killcolor

Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.  It is never a good idea to use g.top().
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.
#@-node:ekr.20050119220219:Notes
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):
    
    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]
    
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    
    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@nonl
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1264:getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c=None):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) > 0 and g.os_path_isabs(base):
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
#@-node:ekr.20031218072017.1264:getBaseDirectory
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = v.headString().strip()
    if g.match_word(s,0,"@url"):
        if not g.doHook("@url1",c=c,p=v,v=v):
            url = s[4:].strip()
            << stop the url after any whitespace >>
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=v,v=v)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i > -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        g.es("ignoring characters after space in url:"+url[i:])
        g.es("use %20 instead of spaces")
    url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20050119211822.2:(Added support for Leo-relative files)
#@+node:ekr.20050122105757:(Implemented 'Undo Clear Recent Files')
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@-node:ekr.20050122105757:(Implemented 'Undo Clear Recent Files')
#@-node:ekr.20041228052527.2:New features...
#@+node:ekr.20041228052527.3:Plugins...
#@+node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041002160323:What I did
@

Improved status_line.py in leoPlugins.leo
#@nonl
#@-node:ekr.20041002160323:What I did
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.revertHeadline = None # Previous headline text for abortEditLabel.
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self ; c = frame.c
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    c = self.c
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041022083005:(More flexible plugin manager)
# See @button Configurator in test.leo for the motivating example.
#@nonl
#@+node:ekr.20041114113029:getPluginModule
def getPluginModule (moduleName):
    
    global loadedModules
    
    return loadedModules.get(moduleName)
#@nonl
#@-node:ekr.20041114113029:getPluginModule
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            print s ; g.es(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
    
    if verbose:
        if result is None:
            s = 'can not load %s plugin' % moduleName
            print s ; g.es(s,color="blue")
        else:
            s = 'loaded %s plugin' % moduleName
            print s ; g.es(s,color="blue")
    
    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20041022083005:(More flexible plugin manager)
#@+node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101065403.1:What I did
@killcolor

*** Alas, using g.importExtension does not seem to work properly with Tkinter.

- plugins_menu.py now checks at runtime to see if the plugin has been successfully loaded before calling the topLevelMenu() function.

- Added pluginName keyword arg to g.importX functions.

    - All such functions now have pluginName and verbose keyword args.

- Used g.cantImport to print all messages in g.importX functions.
#@nonl
#@-node:ekr.20050101065403.1:What I did
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@-node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1930, in doHook
    return None # No return value
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 34, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 135, in doHandlersForTag
    ret = handle_fn(tag,keywords)
  File "C:\prog\leoCVS\leo\plugins\at_view.py", line 97, in icondclick2
    hs = self.current.headString()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 5110, in currentPosition
    if c._currentPosition:
AttributeError: Commands instance has no attribute '_currentPosition'
#@nonl
#@+node:ekr.20050101144712:Notes
@killcolor

Created callTagHandler.

This checks 'idle' hooks to make sure that any commander referenced by the 'c','new_c' or 'old_c' keywords still exists.
#@-node:ekr.20050101144712:Notes
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName
    
    if tag == 'idle':

        # Make sure all commanders exist.
        for key in ('c','old_c','new_c'):
            c = keywords.get(key)
            if c:
                try:
                    if c.frame not in g.app.windowList:
                        return None # c has (or will be) destroyed.
                except AttributeError:
                    # c has been destroyed: c.frame ivar does not exist.
                    return None
                    
    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch.fn,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()

    return doHandlersForTag(tag,keywords)
#@nonl
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None

    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
            
    # Get the hook handler function.  Usually this is doPlugins.
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    if 0: # Don't use trace here!
        if 1:
            old_c = keywords.get('old_c')
            if old_c: print 'doHook %24s %s' % (tag,old_c.shortFileName())
        else:
            if tag != "idle": print 'doHook %24s old_c: %s' % (tag,c and c.shortFileName())
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
#@+node:ekr.20041201072431:(Fixed several plugin bugs)
#@+node:ekr.20050104062535:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2876473

I'm using 4.2 final, build 1.173, on Linux, and experience intermittent lockups
exactly as described here.

I've turned off almost all plugins, except for mod_tempfname, nodenavigator,
plugin_manager, and plugins_menu. It seems that I never experience the lockups
if I disable the hoist plugin, but that I do sometimes experience the lockups
if I enable hoist. Maybe a quick review of hoist might be in order to see if
anything looks suspicious. I believe hoist uses an idle handler, which I vaguely
feel might be able to lead to lockups of this sort.

Anyway, I'm not sure about this, but it is kind of frustrating to have leo lock
up totally, so hopefully this small data tidbit will help flush out this bug.
#@nonl
#@-node:ekr.20050104062535:Report
#@+node:ekr.20050104080957:Fixes
@killcolor

- leoPlugins.registerOneHandler wasn't working properly at all.  In effect, only the last registered hook was ever being remembered!

- leoPlugins.doHandlersForTag now executes the list of hook handlers for a particular tag (hook name) until one of the handlers returns a non-None result.  doHandersForTag no longer tries to "sort" handlers, so the order that the handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks interfering with each other.  If two handlers try to return a non-None result only one of them will ever execute.  doHandlersForTag can't do much about this: a better solution would require more conceptual framework.  Not now...

3.  g.idleTimeHookHandler works for me as it stands.  N.B.  It may have changed since 4.2.  At present the code calls g.doHook('idle',...), which in turn calls doHandlersForTag('idle').  The code then queues itself up for re-execution after a nominal delay of at least 100 msec.  This queuing is done (eventually) by the Tk call g.app.root.after  This works for me on XP.  However, g.app.root.after_idle does tend to hang on XP.
#@-node:ekr.20050104080957:Fixes
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None

    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
            
    # Get the hook handler function.  Usually this is doPlugins.
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    if 0: # Don't use trace here!
        if 1:
            old_c = keywords.get('old_c')
            if old_c: print 'doHook %24s %s' % (tag,old_c.shortFileName())
        else:
            if tag != "idle": print 'doHook %24s old_c: %s' % (tag,c and c.shortFileName())
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler,*args,**keys):
    
    # g.trace(idleTimeHookHandler,self.root)

    if self.root:
        self.root.after_idle(idleTimeHookHandler,*args,**keys)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # New in 4.2 Beta 3. Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after 100 msec.  Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.app.idleTimeDelay,g.idleTimeHookHandler)
        # g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName
    
    if tag == 'idle':

        # Make sure all commanders exist.
        for key in ('c','old_c','new_c'):
            c = keywords.get(key)
            if c:
                try:
                    if c.frame not in g.app.windowList:
                        return None # c has (or will be) destroyed.
                except AttributeError:
                    # c has been destroyed: c.frame ivar does not exist.
                    return None
                    
    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()

    return doHandlersForTag(tag,keywords)
#@nonl
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch.fn,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20031218072017.3443:registerHandler
def registerHandler(tags,fn):
    
    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""
    
    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'
    
    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:
        
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)
        
    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items
#@nonl
#@-node:ekr.20031218072017.3443:registerHandler
#@-node:ekr.20041201072431:(Fixed several plugin bugs)
#@+node:ekr.20050121163053:Fixed bug in Plugins Manager plugin: only triple-double quotes work in docstrings
#@-node:ekr.20050121163053:Fixed bug in Plugins Manager plugin: only triple-double quotes work in docstrings
#@+node:ekr.20050119190016.1:(Fixed conflict between settings panel conflicts and chapters plugin)
@
#@nonl
#@+node:ekr.20050121070708:Notes
@killcolor

With the latest CVS on Linux, attempting to access the preferences dialog when
the chapters plugin is enabled causes a blank window to appear in the Leo outline
pane.

Fix:
    
chapters.py requires that the canvas have a name ivar, so 
    
<< replace tree pane with settings tree >> now sets treeCanvas.name = '1'
#@nonl
#@-node:ekr.20050121070708:Notes
#@+node:ekr.20041225090725:<< replace tree pane with settings tree >>
tree = c.frame.component('tree')

# The new frame must be a child of splitter2Frame.
splitter2Frame = c.frame.component('splitter2Frame').getFrame()

# Create a Pmw scrolled canvas.
scrolledTreeCanvas = Pmw.ScrolledCanvas(splitter2Frame,
    hscrollmode='none',borderframe=3)

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Set canvas.name ivar for chapters.py plugin.
# This must be a tab number.  The number '1' should work well enough.
treeCanvas.name = '1'

# Create the settingsTree component.
c.frame.componentClass(c,'settingsTree',scrolledTreeCanvas,self,
    tree.getPacker(),tree.getUnpacker())

c.frame.replaceTreePaneWithComponent('settingsTree')

self.tree = settingsTree(c,c.frame,treeCanvas,self)
self.tree.setColorFromConfig()
#@nonl
#@-node:ekr.20041225090725:<< replace tree pane with settings tree >>
#@-node:ekr.20050119190016.1:(Fixed conflict between settings panel conflicts and chapters plugin)
#@-node:ekr.20041228052527.3:Plugins...
#@-node:ekr.20040929081120:4.3 a1 projects
#@+node:ekr.20050125203059:4.3 a2 projects
#@+node:ekr.20050129112109: (Removed unused files)
#@+node:ekr.20050129112109.1:What I did
@killcolor

- Removed following files and corresponding imports.
    - leoColorPanel.py
    - leoFontPanel.py
    - leoPrefs.py
    - leoTkinterColorPanels.py
    - leoTkinterFontPanel.py
    - leoTkinterPrefs.py

- moved colorNamesList from leoTkinterColorPanels.py to leoConfig.py

- Removed unused code from gui.Tkinter panels.
#@nonl
#@-node:ekr.20050129112109.1:What I did
#@-node:ekr.20050129112109: (Removed unused files)
#@+node:ekr.20050125203059.1:Bugs
#@+node:ekr.20050125202008:(Fixed very old bug in Undo Insert Node )
#@+node:ekr.20041011092930:Report
http://sourceforge.net/forum/message.php?msg_id=2795653

By: Paul Paterson - paulpaterson
Bug: minor asymmetry with undo insert node  
2004-10-08 13:49
Very minor hangnail,

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc commands don't work until you click on something with the mouse

In an ideal world, after #3 it should be as if #2 never happened.

----------------

http://sourceforge.net/forum/message.php?msg_id=2795656
By: paulpaterson

Hmm, there's something interesting here after all.

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory
lives on ...
#@-node:ekr.20041011092930:Report
#@+node:ekr.20031218072017.1761:c.insertHeadline
# Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Node"):

    c = self ; p = c.currentPosition()
    hasChildren = p.hasChildren()
    isExpanded  = p.isExpanded()
    if not p: return

    c.beginUpdate()
    if 1: # inside update...
        old_p = p.copy()
        if (
            # 1/31/04: Make sure new node is visible when hoisting.
            (hasChildren and isExpanded) or
            (c.hoistStack and p == c.hoistStack[-1].p)
        ):
            p = p.insertAsNthChild(0)
        else:
            p = p.insertAfter()
        c.undoer.setUndoParams(op_name,p,select=old_p)
            # Bug fix!!: 1/25/05 (was: select=p)
        c.selectVnode(p)
        c.editPosition(p)
        p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:EKR.20040526084140:undoInsertNodes
def undoInsertNodes (self):
    
    u = self ; c = u.c
    
    if 0: # Paste retaining clones can't be undone!
        # Remember the previous headline.
        old = c.currentPosition().headString()
    
    c.selectVnode(u.p)
    c.deleteOutline()

    if u.select:
        c.selectVnode(u.select)
        
    # New in 4.3: Support for Paste As Clone.
    if 0: # Paste retaining clones can't be undone!
        if u.headString:
            new = u.headString
            g.trace('old',old,'new',new)
            u.p.setHeadStringOrHeadline(new)
            u.headString=old
#@nonl
#@-node:EKR.20040526084140:undoInsertNodes
#@-node:ekr.20050125202008:(Fixed very old bug in Undo Insert Node )
#@+node:ekr.20050127090959:(Made sure to remove duplicates from recent files)
#@+node:ekr.20041201080436:config.appendToRecentFiles
def appendToRecentFiles (self,files):
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:config.appendToRecentFiles
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20050127090959:(Made sure to remove duplicates from recent files)
#@+node:ekr.20050127090442:Fixed indentation problems in leoTkinterFind.py
@killcolor

> leo\src\leoTkinterFind.py:  
inconsistent use of tabs and spaces in indentation.
 
much of PMW has inconsistent use of tabs and spaces in indentation in various files .py 
#@nonl
#@-node:ekr.20050127090442:Fixed indentation problems in leoTkinterFind.py
#@+node:ekr.20050127091201:(Changed Help menu & related code to handle leoSettings.leo instead of leoConfig.leo)
#@+node:ekr.20041219072416:<< compute directories >>
g.app.loadDir = computeLoadDir()
    # Depends on g.app.tkEncoding: uses utf-8 for now.

g.app.homeDir = computeHomeDir()

g.app.extensionsDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','extensions'))

g.app.globalConfigDir = computeGlobalConfigDir()

g.app.testDir = g.os_path_abspath(
    g.os_path_join(g.app.loadDir,'..','test'))
#@nonl
#@-node:ekr.20041219072416:<< compute directories >>
#@+node:ekr.20031218072017.2943:leoConfig
def leoConfig (self):

    c = self
    name = 'leoSettings.leo'
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@nonl
#@-node:ekr.20031218072017.2943:leoConfig
#@-node:ekr.20050127091201:(Changed Help menu & related code to handle leoSettings.leo instead of leoConfig.leo)
#@+node:ekr.20050129114601.1:(Investigated recent files problems)
#@+node:ekr.20050130101623:Report
http://sourceforge.net/forum/message.php?msg_id=2966541
By: jasonic

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

With chapters 0.66 enabled -- same behavior. 

Jason
#@nonl
#@-node:ekr.20050130101623:Report
#@+node:ekr.20050130101623.1:Added to @recentfile documentation
Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.
#@nonl
#@-node:ekr.20050130101623.1:Added to @recentfile documentation
#@+node:ekr.20041118084146:Setters
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041118084241:setString
def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)
#@nonl
#@-node:ekr.20041118084241:setString
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041201080436:config.appendToRecentFiles
def appendToRecentFiles (self,files):
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:config.appendToRecentFiles
#@-node:ekr.20041118084146:Setters
#@-node:ekr.20050129114601.1:(Investigated recent files problems)
#@+node:ekr.20050126102846.2:(Improved queuing of log messages)
#@+node:ekr.20050130113848.2:What I did
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.
#@-node:ekr.20050130113848.2:What I did
#@+node:ekr.20050130134313:es & related logic...
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self):

    if self.log:
        for s,color in self.logWaiting:
            g.es(s,color=color,newline=0) # The caller must write the newlines.
        self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
#@nonl
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@-node:ekr.20050130134313:es & related logic...
#@+node:ekr.20050130133731:Added silent keyword to severl methods
#@+node:ekr.20031218072017.2297:open
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:open
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20050130133731:Added silent keyword to severl methods
#@-node:ekr.20050126102846.2:(Improved queuing of log messages)
#@+node:ekr.20050130171901:(Fixed crasher in Change All command)
#@-node:ekr.20050130171901:(Fixed crasher in Change All command)
#@+node:ekr.20050201174750:(Fixed crasher in script button)
#@+node:ekr.20050202052911:Traceback
@killcolor

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write        
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write    
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)
    
AttributeError: 'tnode' object has no attribute 'tnodeList'
#@nonl
#@-node:ekr.20050202052911:Traceback
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try: 
            at.root.v.t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:ekr.20050201174750:(Fixed crasher in script button)
#@+node:ekr.20050202062110:(Fixed print problems on the Mac)
# The button callback just calls c.executeScript
#@nonl
#@+node:ekr.20050202063852:What I did
@killcolor

The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.
#@nonl
#@-node:ekr.20050202063852:What I did
#@+node:ekr.20050201175325:(g.es called print on the Mac)
# The problem was simply some extra print statements. No idea why they were there.
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:ekr.20041012083237.3:put and putnl (nullLog)
def put (self,s,color=None):
    if self.enabled:
        # g.trace('nullLog',s)
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")
#@nonl
#@-node:ekr.20041012083237.3:put and putnl (nullLog)
#@+node:ekr.20041225063637.11:class logClass
class logClass:
    
    def __init__ (self,textWidget):
        self.textWidget = textWidget
        self.colorTags = []
        
    def put(self,s,color=None):
        w = self.textWidget
        << put s to w >>
        
    def putnl (self):
        w = self.textWidget
        if sys.platform == "darwin": print
        w.insert("end",'\n')
        w.see("end")
        w.update_idletasks()
#@nonl
#@+node:ekr.20041225063637.12:<< put s to w >>
if type(s) == type(u""):
    s = g.toEncodedString(s,g.app.tkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        w.tag_config("black",foreground="black")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see("end")
w.update_idletasks()
#@nonl
#@-node:ekr.20041225063637.12:<< put s to w >>
#@-node:ekr.20041225063637.11:class logClass
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050201175325:(g.es called print on the Mac)
#@-node:ekr.20050202062110:(Fixed print problems on the Mac)
#@+node:ekr.20050202092849:leoTest.runTests now makes copies of all positions
@killcolor

This makes the test more robust in case of failure.
#@nonl
#@-node:ekr.20050202092849:leoTest.runTests now makes copies of all positions
#@+node:ekr.20050202080802:Fixed problems with unit test file paths
@killcolor

Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass.
#@nonl
#@-node:ekr.20050202080802:Fixed problems with unit test file paths
#@+node:ekr.20050202063852.1:(Made local config settings work again)
#@+node:ekr.20050203084346:Notes
@killcolor

*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.
#@nonl
#@-node:ekr.20050203084346:Notes
#@+node:ekr.20041122094813:<<  class data >>
@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@nonl
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@nonl
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settins class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  class data >>
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles(self.c)

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (configSettings)
def setRecentFiles (self,files):
    
    c = self.c
    
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
    
    # Do nothing if there is no @settings tree or no @recent-files node.
    p = g.app.config.findSettingsPosition(c,"@recent-files")
    if not p:
        # g.trace("no @recent-files node for ",c.mFileName)
        return

    # g.trace("updating @recent-files for ",c.mFileName)
    
    # Update the @recent-files entry, leaving c's changed status untouched.
    oldText = p.bodyString()
    changed = c.isChanged()
    newText = '\n'.join(files)
    p.setBodyStringOrPane(newText,encoding=g.app.tkEncoding)
    c.setChanged(changed)
    c.undoer.setUndoTypingParams(p,'Clear Recent Files',
        oldText,newText,oldSel=None,newSel=None)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@-node:ekr.20050202063852.1:(Made local config settings work again)
#@+node:ekr.20050127090442.1:(Investigated redirection from scripts.  All appears well.)
redirect script IO to log pane setting isn't working, 
#@nonl
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@-node:ekr.20050127090442.1:(Investigated redirection from scripts.  All appears well.)
#@+node:ekr.20050127083933:(Fix url problems)
#@+node:ekr.20050206045723:Note: it just ran slowly & silently
#@-node:ekr.20050206045723:Note: it just ran slowly & silently
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = v.headString().strip()
    if g.match_word(s,0,"@url"):
        if not g.doHook("@url1",c=c,p=v,v=v):
            url = s[4:].strip()
            << stop the url after any whitespace >>
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=v,v=v)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i > -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        g.es("ignoring characters after space in url:"+url[i:])
        g.es("use %20 instead of spaces")
    url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
#@nonl
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; t = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    while 1:
        pos, newpos = self.findNextMatch()
        if pos:
            # g.trace(pos,newpos,self.v.headString())
            count += 1
            line = gui.getLineContainingIndex(t,pos)
            self.printLine(line,allFlag=True)
        else: break
    c.endUpdate()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@nonl
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    v = self.v
    while v:
        pos, newpos = self.search()
        if pos:
            if self.mark_finds:
                v.setMarked()
                c.frame.tree.drawIcon(v) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            v = self.v = self.selectNextVnode()
    return None, None
#@nonl
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3081:selectNextVnode
# Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; v = self.v

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyVnode:
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.onlyVnode = v 

    # Start wrapped searches.
    if self.wrapping and not self.wrapVnode:
        assert(self.wrapPos != None)
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.wrapVnode = v 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(v)
        return v

    if self.reverse: v = v.threadBack()
    else:            v = v.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not v:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(v):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not v and self.wrapping and not self.suboutline_only:
        v = c.rootVnode()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while v and v.next():
                v = v.next()
            if v: v = v.lastNode()

    # End wrapped searches.
    if self.wrapping and v and v == self.wrapVnode:
        # g.trace("ending wrapped search")
        v = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyVnode and v and
        (v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
        # g.trace("end outline-only")
        v = None ; self.onlyVnode = None

    # v.copy not needed because the find code never calls p.moveToX.
    # Furthermore, v might be None, so v.copy() would be wrong!
    self.v = v # used in initNextText().
    if v: # select v and set the search point within v.
        self.in_headline = self.search_headline
        self.initNextText()
    return v
#@nonl
#@-node:ekr.20031218072017.3081:selectNextVnode
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050127083933:(Fix url problems)
#@+node:ekr.20050128081226:Buttons no longer work in toolbars when settings dialog is open
#@-node:ekr.20050128081226:Buttons no longer work in toolbars when settings dialog is open
#@+node:ekr.20050206120754.1:(Fixed bug: Focus shifted from body to headline
#@+node:ekr.20050206140101:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.
#@nonl
#@-node:ekr.20050206140101:Report
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050206120754.1:(Fixed bug: Focus shifted from body to headline
#@+node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050206150004:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file & tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!
#@nonl
#@-node:ekr.20050206150004:Report
#@+node:ekr.20050206152211:What I did
@killcolor

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in << put up a dialog requiring a valid id >>.
- Improved signon message.
- Better error handling and reporting. 
#@nonl
#@-node:ekr.20050206152211:What I did
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    try:
        fn = g.os_path_join(theDir,tag)
        f = open(fn,'r')
        s = f.readline()
        f.close()
        if s and len(s) > 0:
            g.app.leoID = s
            if verbose:
                g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
            return
        elif verbose:
            g.es("empty %s (in %s)" % (tag,theDir), color = "red")
    except IOError:
        g.app.leoID = None
    except Exception:
        g.app.leoID = None
        g.es('Unexpected exception in app.setLeoID',color='red')
        g.es_esception()
        
dirs = []

for theDir in (globalConfigDir,homeDir):
    if theDir not in dirs:
        dirs.append(theDir)

g.es("%s not found in %s" % (tag,repr(dirs)),color="red")
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
dirs = []

for theDir in (homeDir,globalConfigDir,loadDir):
    cant = "can not create %s in %s" % (tag,theDir)
    try:
        fn = g.os_path_join(theDir,tag)
        f = open(fn,'w')
        if f:
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es("created %s in %s" % (tag,theDir), color="red")
                return
            else:
                g.es(cant,color='red')
    except IOError:
        g.es(cant,color='red')

    if theDir not in dirs:
        dirs.append(theDir)
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050206201921:(Leo now prints unicode characters properly in the log pane)
# This now works: g.es('ﺻﺱ',color='red')
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050206201921:(Leo now prints unicode characters properly in the log pane)
#@+node:ekr.20050208051804:(Fixed various problems with Unicode filenames)
#@+node:ekr.20050208054635:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2983923
By: tyndal

I tried again with the a2 cvs and it still isnt working correctly, the "reduced"
leo window is still showing up, however the error messages are different:

---------------

Leo Log Window...
Leo 4.3 alpha 2, build  1.217 , January 30, 2005
Python 2.3.4, Tk 8.4.3, win32

exception executing command
Traceback (most recent call last):
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 170,
in doCommand
    command()
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 328, in open
    ok, frame = g.openWithFileName(fileName,c)
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoGlobals.py", line 637,
in openWithFileName
    g.es("exceptions opening: %s" % g.toEncodedString(fileName),color="red")
TypeError: toEncodedString() takes at least 2 arguments (1 given)

---------------

However, opening a regular file after failing to open a file now seems to work
correctly.

-Tyndal

#@-node:ekr.20050208054635:Report
#@+node:ekr.20050206085258:atFile.printError & test_printError
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_printError(self,**keys):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test_printError
#@+node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.1499:isUnicode
def isUnicode(s):
    
    return s is None or type(s) == type(u' ')
#@nonl
#@-node:ekr.20031218072017.1499:isUnicode
#@+node:ekr.20031218072017.1500:isValidEncoding
def isValidEncoding (encoding):
    
    try:
        if len(encoding) == 0:
            return False
        unicode("a",encoding)
        return True
    except:
        return False
#@-node:ekr.20031218072017.1500:isValidEncoding
#@+node:ekr.20031218072017.1501:reportBadChars
def reportBadChars (s,encoding):
    
    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except: errors += 1
        if errors:
            # traceback.print_stack()
            g.es("%d errors converting %s to %s" % 
                (errors, s.encode(encoding,"replace"),encoding))

    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % 
                (errors, unicode(s,encoding,"replace"),encoding)) # 10/23/03
#@nonl
#@-node:ekr.20031218072017.1501:reportBadChars
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20050208093903:toEncodedStringWithErrorCode
def toEncodedStringWithErrorCode (s,encoding):
    
    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208093903:toEncodedStringWithErrorCode
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
    
#@-node:ekr.20050208093800.1:toUnicode
#@+node:ekr.20050208095723:toUnicodeWithErrorCode
def toUnicodeWithErrorCode (s,encoding):
    
    ok = True
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208095723:toUnicodeWithErrorCode
#@+node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
def test_round_trip_toUnicode_toEncodedString ():
   
    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('äöü',  'utf-8'),
        ('äöü',  'mbcs'),
        ('炰',   'utf-8'),
        ('炰',   'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s
#@nonl
#@-node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
#@+node:ekr.20050208112123:test_failure_with_ascii_encodings
def test_failure_with_ascii_encodings():

    encoding = 'ascii'
    
    s = '炰'
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = u'炰'
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@nonl
#@-node:ekr.20050208112123:test_failure_with_ascii_encodings
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
# Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        << define getpreferredencoding using _locale >>
    else:
        << define getpreferredencoding for *nix >>
        
__pychecker__ = '--reuseattr'
#@+node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
# On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
#@+node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
# On Unix, if CODESET is available, use that.

__pychecker__ = '--no-noeffect' # Note: this is at the top level!

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
#@-node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
#@-node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@nonl
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):
    
    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@nonl
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@nonl
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@nonl
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@nonl
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@nonl
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):
    
    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]
    
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    
    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@nonl
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2155:os_path_norm NOT USED
if 0:  # A bad idea.
    
    def os_path_norm(path,encoding=None):
    
        """Normalize both the path and the case."""
    
        path = g.toUnicodeFileEncoding(path,encoding)
    
        path = os.path.normcase(path)
        path = os.path.normpath(path)
        
        path = g.toUnicodeFileEncoding(path,encoding)
        
        return path
#@nonl
#@-node:ekr.20031218072017.2155:os_path_norm NOT USED
#@+node:ekr.20041115103456:os_path_normabs NOT USED
if 0: # A bad idea.

    def os_path_normabs (path,encoding=None):
    
        """Convert the file name to a fully normalized absolute path.
        
        There is no exact analog to this in os.path"""
        
        path = g.os_path_abspath(path,encoding = encoding)
        path = g.os_path_norm(path,encoding = encoding)
    
        return path
#@nonl
#@-node:ekr.20041115103456:os_path_normabs NOT USED
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):
    
    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):
    
    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):
    
    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@nonl
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@nonl
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if not encoding:
        if sys.platform == "win32":
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@nonl
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2618:app.setEncoding
@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        #(locale.getdefaultlocale()[1],"locale"),
        (g.getpreferredencoding(),"locale"),
        (sys.getdefaultencoding(),"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding): # 3/22/03
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding and len(encoding) > 0:
            g.trace("ignoring invalid ",src," encoding: ",encoding)
            
    color = g.choose(self.tkEncoding=="ascii","red","blue")
#@nonl
#@-node:ekr.20031218072017.2618:app.setEncoding
#@-node:ekr.20050208051804:(Fixed various problems with Unicode filenames)
#@+node:ekr.20050208133438.1:(Fixed unicode problems on the Mac)
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050208133438.1:(Fixed unicode problems on the Mac)
#@+node:ekr.20050210080438:(Made sure Go To Line Number dialog is brought to the front)
#@+node:ekr.20050210080438.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2987569
By: e

goto linenumber popup gets hidden behind the leo.

EKR: This happens when focus is in body pane.

Arrrrrgh.  The delayed focus logic requires a commander to work.

What I did:

- Added a c argument to all dialogs except runAskLeoIDDialog.
- Added tk.gui.widget_wants_focus.
- Added unit tests to test ctors for all dialogs and panels.
    - All dialog ctors return after initing the base class when unit testing.
#@-node:ekr.20050210080438.1:Report
#@+node:ekr.20050210084744:Added c to all dialog ctors!
#@+node:ekr.20031218072017.3730:app.gui dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3730:app.gui dialogs
#@+node:ekr.20031218072017.3744:dialogs (unitTestGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")
    
def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)
    
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
#@nonl
#@-node:ekr.20031218072017.3744:dialogs (unitTestGui)
#@+node:ekr.20031218072017.4056:app.gui.Tkinter dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)
#@nonl
#@-node:ekr.20031218072017.4056:app.gui.Tkinter dialogs
#@-node:ekr.20050210084744:Added c to all dialog ctors!
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):
    
    """Run a leoTkinterDialog."""
    
    if g.app.unitTesting: return None

    c = self.c
    self.modal = modal
    
    self.center() # Do this after all packing complete.
    self.top.lift() # 7/31/04

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        if self.focus_widget == None:
            self.focus_widget = self.top
            
        self.focus_widget.focus_set() # Get all keystrokes.
        if c:
             g.app.gui.widget_wants_focus(c,self.focus_widget)
           
        self.root.wait_window(self.top)
        return self.answer
    else:
        self.root.wait_window(self.top)
        return None
#@nonl
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@+node:ekr.20050210082320:widget_wants_focus (tk.gui)
def widget_wants_focus(self,c,widget,tag=''):

    """Indicate that a widget want to get focus."""
    
    if c:
        c.frame.widgetWantsFocus(widget,True,tag=tag)
        
widgetWantsFocus = widget_wants_focus
#@nonl
#@-node:ekr.20050210082320:widget_wants_focus (tk.gui)
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,self.c.shortFileName())
    self.set_focus(widget,later=later,tag=tag)
    
def logWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def statusLineWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def treeWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
    
def widgetWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@-node:ekr.20050210080438:(Made sure Go To Line Number dialog is brought to the front)
#@+node:ekr.20050211095957:(Fixed newline bug in g.getScript)
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,script=None):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()

    try:
        if script:
            s = script
        else:
            script = ''
            # Allow p not to be the present position.
            if p == c.currentPosition():
                if useSelectedText and c.frame.body.hasTextSelection():
                    # Temporarily replace v's body text with just the selected text.
                    s = c.frame.body.getSelectedText()
                    p.v.setTnodeText(s)
                else:
                    s = c.frame.body.getAllText()
            else:
                s = p.bodyString()
                
        # New in 4.3: Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            # New in 4.3: Selecting text executes _only_ the selected text.
            # This removes some indentation problems, but not all of them.
            if useSelectedText and c.frame.body.hasTextSelection():
                script = s
            else:
                at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
                script = at.stringOutput
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    p.v.setTnodeText(old_body)
    
    # g.trace(repr(c.atFileCommands.output_newline))
    if c.atFileCommands.output_newline == '\r\n':
        return script.replace("\r\n","\n") # 1/11/05
    else:
        return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_returns
def test_g_getScript_strips_returns():

    old_output_newline = c.atFileCommands.output_newline
    c.atFileCommands.output_newline = '\r\n'
    script = g.getScript(c,p)
    c.atFileCommands.output_newline = old_output_newline
    
    assert script.find('\r\n') == -1
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_returns
#@-node:EKR.20040614071102.1:g.getScript & tests
#@-node:ekr.20050211095957:(Fixed newline bug in g.getScript)
#@+node:ekr.20050211111552.1:(Fixed bug involving encoding field in derived files)
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@nonl
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@+node:ekr.20050211111552:test_parseLeoSentinel
def test_parseLeoSentinel (self):
    
    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.
    
    at=c.atFileCommands # Self is a dummy argument.
    
    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20050211111552:test_parseLeoSentinel
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@-node:ekr.20050211111552.1:(Fixed bug involving encoding field in derived files)
#@+node:ekr.20050212144125:Fixed problems found by pychecker
# Bugs fixed 2/12/05
1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.
    
2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found
    
    # Local --> locale
    # Might cause getpreferredencoding to fail on *nix.
    
3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.
    
4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)
        
5. (removed code) from << create a node p for  kind & root2 >>
    - last_p is None at first, so last_p.insertAfter does not make sense.
#@nonl
#@-node:ekr.20050212144125:Fixed problems found by pychecker
#@+node:ekr.20050212155600:Rewrote ctor of settingsController to eliminate pychecker warnings
@killcolor

Apparantly pychecker was confused by the complexity of the code in settingsController.__init__.

Created replaceBodyWithDialog and createStandAloneDialog helpers, and this eliminated the warnings(!)
#@nonl
#@-node:ekr.20050212155600:Rewrote ctor of settingsController to eliminate pychecker warnings
#@+node:ekr.20050213065340:(Fixed can't happen message in updateOneNode)
#@+node:ekr.20050213072437:What I did
@killcolor

The problem was with a change I made in createSettingsTree in response to a pychecker complaint.
This change altered the local settings tree...

In spite of what pychecker may say, last_p IS defined properly when it is used.
#@nonl
#@-node:ekr.20050213072437:What I did
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    #g.trace(root2.c.mFileName)
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind in ('shortcuts','recentfiles'):
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(p,val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,p,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.56:findCorrespondingNode
def findCorrespondingNode (self,root1,root2,p1):
    
    """Return the node corresponding to p1 (in root1) in the root2's tree."""
    
    if p1 == root1: return root2

    # Go up tree 1, computing child indices.
    childIndices = []
    for p in p1.self_and_parents_iter():
        #g.trace(p)
        if p == root1: break
        childIndices.append(p.childIndex())
        
    childIndices.reverse()
    # g.trace(childIndices)
    
    # Go down tree 2, moving to the n'th child.
    p2 = root2.copy()
    for n in childIndices:
        # g.trace(p2)
        p2.moveToNthChild(n)

    # g.trace(p2)
    return p2
#@nonl
#@-node:ekr.20041225063637.56:findCorrespondingNode
#@-node:ekr.20050213065340:(Fixed can't happen message in updateOneNode)
#@+node:ekr.20050213072437.1:(Note: local setting for use_plugins can not overriding global setting)
@nocolor

It is surprisingly difficult to give a warning that only the global setting applies.

I added some more documentation to the setting in leoSettings.leo and removed the confusing entry from test.leo.

@color
#@nonl
#@+node:ekr.20041120094940.9:set (parseBaseClass)
# p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20050213072437.1:(Note: local setting for use_plugins can not overriding global setting)
#@-node:ekr.20050125203059.1:Bugs
#@+node:ekr.20050125203059.2:New features...
#@+node:ekr.20050125170349:(Added new undo granularities & undo_granularity setting)
#@+node:ekr.20050126095917:Notes
@killcolor

Up until Leo 4.3, Leo's undo-typing mechanism was character-by-character. This
was clunky, to say the least.

leoSettings.leo now contains an 'undo_granularity' setting. There are four
possible value for this setting:

node: start a new undo unit when typing moves to a new node.
line: start a new undo unit when typing moves to new line.
word: start a new undo unit when typing starts a new word.
char: start a new undo unit for each character typed.

'line' granularity is the default used if no valid setting is specified. 'char'
granularity is not recommened: it wastes lots of computer memory.

The definitions of 'node', 'line' and 'char' granularities are straightforward.
However, recognizing the start of a word for the purposes of undo is something
people may want to play with. Therefore, setUndoTypingParams calls the
recognizeStartOfTypingWord helper method to do this.

recognizeStartOfTypingWord is potentially user-modifiable method that should
return True if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity.
    
setUndoTypingParams calls this method only when the typing could possibly
continue a previous word. In other words, undo will work safely regardless of
the value returned. See the actual code for recognizeStartOfTypingWord for more
details.
#@nonl
#@-node:ekr.20050126095917:Notes
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):
    
    u = self ; u.c = c

    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.

    u.granularity = c.config.getString('undo_granularity')
    if u.granularity: u.granularity = u.granularity.lower()
    if u.granularity not in ('node','line','word','char'):
        u.granularity = 'line'
    # g.trace('undoer',u.granularity)

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    << Define optional ivars >>
    << define redoDispatchDict >>
    << define undoDispatchDict >>
    u.updateSetChangedFlag = True
    u.redrawFlag = True
#@nonl
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.
    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@nonl
#@-node:ekr.20031218072017.3607:clearIvars
#@+node:ekr.20031218072017.3604:<< Define optional ivars >>
# New in 4.2: this is now an ivar, not a global, and it's a list, not a tuple.

u.optionalIvars = [
    "lastChild",
    "parent","oldParent",
    "back","oldBack",
    "n","oldN","oldV",
    "oldText","newText",
    "oldSel","newSel",
    "sort","select",
    "oldTree","newTree", # Added newTree 10/14/03
    "yview",
    # For incremental undo typing...
    "leading","trailing",
    "oldMiddleLines","newMiddleLines",
    "oldNewlines","newNewlines",
]
#@nonl
#@-node:ekr.20031218072017.3604:<< Define optional ivars >>
#@+node:EKR.20040526072519:<< define redoDispatchDict >>
u.redoDispatchDict = {
    "Change":             u.redoTyping,
    "Change All":         u.redoChangeAll,
    "Change Headline":    u.redoChangeHeadline,
    'Clear Recent Files': u.redoTyping,
    "Clone Node":         u.redoClone,
    "Convert All Blanks": u.redoReplaceNodesContents,
    "Convert All Tabs":   u.redoReplaceNodesContents,
    "Convert Blanks":     u.redoTyping,
    "Convert Tabs":       u.redoTyping,
    "Cut":                u.redoTyping,
    "Cut Node":           u.redoDeleteNode,
    "De-Hoist":           u.redoDehoist,
    "Delete":             u.redoTyping,
    "Delete Node":        u.redoDeleteNode,
    "Demote":             u.redoDemote,
    "Drag":               u.redoMoveNode,
    "Drag & Clone":       u.redoClone,
    "Extract":            u.redoReplaceNodes,
    "Extract Names":      u.redoReplaceNodes,
    "Extract Section":    u.redoReplaceNodes,
    "Hoist":              u.redoHoist,
    "Import":             u.redoInsertNodes,
    "Indent":             u.redoTyping,
    "Insert Node":        u.redoInsertNodes,
    "Move Down":          u.redoMoveNode,
    "Move Left":          u.redoMoveNode,
    "Move Right":         u.redoMoveNode,
    "Move Up":            u.redoMoveNode,
    "Paste":              u.redoTyping,
    "Paste Node":         u.redoInsertNodes,
    "Pretty Print":       u.redoChangeAll,
    "Promote":            u.redoPromote,
    "Read @file Nodes":   u.redoReplaceNodes,
    "Reformat Paragraph": u.redoTyping,
    "Sort Children":      u.redoSortChildren,
    "Sort Siblings":      u.redoSortSiblings,
    "Sort Top Level":     u.redoSortTopLevel,
    "Typing":             u.redoTyping,
    "Undent":             u.redoTyping }
#@nonl
#@-node:EKR.20040526072519:<< define redoDispatchDict >>
#@+node:EKR.20040526075238:<< define undoDispatchDict >>
u.undoDispatchDict = {
    "Change":             u.undoTyping,
    "Change All":         u.undoChangeAll,
    "Change Headline":    u.undoChangeHeadline,
    'Clear Recent Files': u.undoTyping,
    "Clone Node":         u.undoClone,
    "Convert All Blanks": u.undoReplaceNodesContents,
    "Convert All Tabs":   u.undoReplaceNodesContents,
    "Convert Blanks":     u.undoTyping,
    "Convert Tabs":       u.undoTyping,
    "Cut":                u.undoTyping,
    "Cut Node":           u.undoDeleteNode,
    "De-Hoist":           u.undoDehoist,
    "Delete":             u.undoTyping,
    "Delete Node":        u.undoDeleteNode,
    "Demote":             u.undoDemote,
    "Drag":               u.undoMoveNode,
    "Drag & Clone":       u.undoDragClone, # redo uses redoClone.
    "Extract":            u.undoReplaceNodes,
    "Extract Names":      u.undoReplaceNodes,
    "Extract Section":    u.undoReplaceNodes,
    "Hoist":              u.undoHoist,
    "Import":             u.undoInsertNodes,
    "Indent":             u.undoTyping,
    "Insert Node":        u.undoInsertNodes,
    "Move Down":          u.undoMoveNode,
    "Move Left":          u.undoMoveNode,
    "Move Right":         u.undoMoveNode,
    "Move Up":            u.undoMoveNode,
    "Paste":              u.undoTyping,
    "Paste Node":         u.undoInsertNodes,
    "Pretty Print":       u.undoChangeAll,
    "Promote":            u.undoPromote,
    "Read @file Nodes":   u.undoReplaceNodes,
    "Reformat Paragraph": u.undoTyping,
    "Sort Children":      u.undoSortChildren,
    "Sort Siblings":      u.undoSortSiblings,
    "Sort Top Level":     u.undoSortTopLevel,
    "Typing":             u.undoTyping,
    "Undent":             u.undoTyping }
#@nonl
#@-node:EKR.20040526075238:<< define undoDispatchDict >>
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20031218072017.3612:getBead, peekBead, makeBeadDict
#@+node:EKR.20040526150818:getBeed
def getBead (self,n):
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None

    d = u.beads[n]
    # g.trace(n,len(u.beads),d)
    self.clearIvars()
    u.p = d["v"]
    u.undoType = d["undoType"]

    for ivar in u.optionalIvars:
        val = d.get(ivar,None)
        setattr(u,ivar,val)

    return d
#@nonl
#@-node:EKR.20040526150818:getBeed
#@+node:EKR.20040526150818.1:peekBeed
def peekBead (self,n):
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None
    d = u.beads[n]
    # g.trace(n,len(u.beads),d)
    return d
#@nonl
#@-node:EKR.20040526150818.1:peekBeed
#@+node:EKR.20040526150818.2:makeBeadDict
def makeBeadDict (self,keywords=None):
    
    '''Create a new bead dictionary from the undo ivars and optional keywords.'''

    u = self ; d = {}
    d["undoType"]=u.undoType
    d["v"]=u.p

    # Only enter significant entries into the dictionary.
    # This is an important space optimization for typing.
    for ivar in u.optionalIvars:
        if getattr(u,ivar) != None:
            d[ivar] = getattr(u,ivar)

    # Copy all optional keywords to d.
    if keywords:
        for key in keywords.keys():
            if keywords[key] != None:
                d[key] = keywords[key]

    # g.trace(d)
    return d
#@nonl
#@-node:EKR.20040526150818.2:makeBeadDict
#@-node:ekr.20031218072017.3612:getBead, peekBead, makeBeadDict
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()

    # selectVnode causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectVnode(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
        
    u.redrawFlag = (current != u.p)
#@nonl
#@-node:EKR.20040526075238.5:redoTyping
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()

    # g.trace(u.undoType,u.p)

    # selectVnode causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectVnode(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
        
    u.redrawFlag = (current != u.p)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    if self.trace and self.verbose:
        g.trace("unselect:",old_p.headString())
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.c.setCurrentPosition(p)
if p != old_p:
    self.setSelectedLabelState(p)
frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    << Incrementally update the Tk.Text widget >>
    << Compute the result using v's body text >>
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@clone 2
#@+node:ekr.20031218072017.1490:setUndoTypingParams & recognizeStartOfTypingWord
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    # g.trace(undo_type,p,"old:",oldText,"new:",newText)
    u = self ; c = u.c
    << return if there is nothing to do >>
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return d
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    return None

if oldText == newText:
    # g.trace("no change")
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    g.trace()
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('v')

<< set newBead if we can't share the previous bead >>
if newBead:
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    d = u.makeBeadDict()
    u.beads[u.bead:] = [d]
else:
    # Replace all the information in the old bead with the new info.
    old_d['leading'] = u.leading
    old_d['trailing'] = u.trailing
    old_d['newNewlines'] = u.newNewlines
    old_d['newMiddleLines'] = u.newMiddleLines
    old_d['newSel'] = u.newSel
    old_d['yview']  = u.yview
    d = old_d
    u.beads[u.bead:] = [d]
    
# g.trace(newBead,'u.bead',u.bead,undo_type,old_p)
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
if (
    not old_d or
    old_d.get('v') != p or
    old_d.get('undoType') != undo_type
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading')  != u.leading or 
        old_d.get('trailing') != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    #g.trace(old_row,old_col,len(old_lines))
    #g.trace(new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col-new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        old_ch = old_s[old_col-1]
        new_ch = new_s[new_col-1]
        # g.trace(repr(old_ch),repr(new_ch))
        newBead = self.recognizeStartOfTypingWord(
            old_lines,old_row,old_col,old_ch,
            new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    ws = string.whitespace
    word_chars = string.letters + string.digits + '_'

    if 1: # This seems like the best way.
        # Start a word if new_ch begins whitespace + word
        return old_ch not in ws and new_ch in ws

    if 0: # Problems with punctuation within words.
        return old_ch in ws and new_ch not in ws

    if 0: # Problems with punctuation within words.
        return new_ch in word_chars and not old_ch in word_chars
        
    else: return False # Keeps Pychecker happy.
#@nonl
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@-node:ekr.20031218072017.1490:setUndoTypingParams & recognizeStartOfTypingWord
#@-node:ekr.20050125170349:(Added new undo granularities & undo_granularity setting)
#@+node:ekr.20050127120924:(Plugins manager attempts to call init functions in plugins)
#@+node:ekr.20050128095935:Request
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2963175
By: bwmulder

There have been some postings a while ago about using pydoc to browse Leo source
code.

It seems that pydoc imports modules. Pydoc, at that time, failed on some modules
because of setup code which was executed in some plugins, and which did not
work when some things were not setup.

I am wondering if it would be better to factor out setup code in plugins so
that the setup part (reading config file, etc) will be done only as part of
a function call. This way, imports of the module would always work.

You can currently test leoGlobals.app and such, but it seems to me that this
is more of a hack.

I realize that this would be a change in the plugin interface, but you can not
have improvements without some pain.

[Another lesson I learned recently is to avoid module level variables, and use
classes instead. You can always create new instances, but its hard to create
new instances of modules].

I was just thinking of adding a function in my mock module which would import
a module to figure out what modules are imported in that module. By replacing
the real modules with mock modules, one can be assured to control the total
environment of that module.
#@-node:ekr.20050128095935:Request
#@+node:ekr.20050128091841:Ahas
@killcolor

I just had two Aha's regarding this proposal:

1. The init function can return True if the plugin was, in fact, loaded correctly.  This is information that up until now has not been available, and it is very useful.  For example, the code in the '@button Check spelling...' node would be much simplified if leoPlugins.loadOnePlugin only returned properly inited plugins.

2. There is no need to change all plugins all at once.  The plugin manager can try calling plugin's init code, but can 'guess' that the plugin was correctly loaded if the init method does not exist.  In this way, we can add the init code to plugins that would really benefit from having it, without having to add init functions to all plugins.
#@nonl
#@-node:ekr.20050128091841:Ahas
#@+node:ekr.20050128111043:What I did
@killcolor

The code attempts to call the init method when importing the plugin. If the
top-level init function exits, the plugin manager will record the plugin as
having been loaded successfully only if init returns True (or equivalent). If
the top-level init function does not exist, the plugin manager considers that
the plugin was loaded successfully. This guess is needed for compatibility with
old plugins.

Other changes:

- Added init to the spellpyx plugin.
- Changed the scripts in the '@button Check spelling...' nodes in test.leo and leoPy.leo and leoPyRef.leo.

Edward
#@nonl
#@-node:ekr.20050128111043:What I did
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            print s ; g.es(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
    
    if verbose:
        if result is None:
            s = 'can not load %s plugin' % moduleName
            print s ; g.es(s,color="blue")
        else:
            s = 'loaded %s plugin' % moduleName
            print s ; g.es(s,color="blue")
    
    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20050127120924:(Plugins manager attempts to call init functions in plugins)
#@+node:ekr.20050128081422:(Changed name of Paste Retaining Clones to Paste Node As Clone)
@killcolor

https://sourceforge.net/forum/message.php?msg_id=2963461
By: ktenney

Howdy,

I only just now realized that
Outline -> Paste Retaining Clone
would _create_ a clone from any node on the clipboard.
It's name led me to believe that I had to create a clone, copy it, and use 'Paste
Retaining Clones'

It would make more sense to me if it was called
"Paste As Clone" 
Maybe it could be given a hotkey, such as Shft+Ctrl+Z
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste Node &As Clone",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,k,m,n,o,p,s,u
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040131171020:<< enable top level outline menu >>
menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Paste Node As Clone",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())
#@nonl
#@-node:ekr.20040131171020:<< enable top level outline menu >>
#@-node:ekr.20050128081422:(Changed name of Paste Retaining Clones to Paste Node As Clone)
#@+node:ekr.20050130152008.1:(Added leoPlugins.leo to Help menu)
#@-node:ekr.20050130152008.1:(Added leoPlugins.leo to Help menu)
#@+node:ekr.20050202074304:Script buttons can request to be removed
@killcolor

A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True.
#@nonl
#@-node:ekr.20050202074304:Script buttons can request to be removed
#@+node:ekr.20050206120754:Improved documentation in leoSettings.leo
@killcolor

Documentation problem in "Leo\config\leoSettings.leo"

- (done) The body text shows 1: & 0: as selections, not True/False.
    - @bool write_strips_blank_lines = True
    - @bool allow_clone_drags = False"
    - @bool enable_drag_messages = False"

- (done) @bool script_change = None
    What's a 'script change'?
    All the nodes under "Checkboxes" could use descriptions.

- (done) @page Syntax colors & options

    It would be nice if there were spaces before & after the "=" to allow easier
    double-click selection of just the colors.
#@nonl
#@-node:ekr.20050206120754:Improved documentation in leoSettings.leo
#@+node:ekr.20050208134526:(Added define_g=True param in executeScript)
#@+node:ekr.20050208133438.2:g.app did not exist during scripts!
#@-node:ekr.20050208133438.2:g.app did not exist during scripts!
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20050208134526:(Added define_g=True param in executeScript)
#@+node:ekr.20050209112556:Changed Preferences to Settings in menu, leoSettings.leo & documentation
#@-node:ekr.20050209112556:Changed Preferences to Settings in menu, leoSettings.leo & documentation
#@+node:ekr.20050211105710:Removed definitions of c, g & p from all test routines
@killcolor

These are now defined in the calling environment.

See testRoutineTestCase.runTest in test.leo.
#@-node:ekr.20050211105710:Removed definitions of c, g & p from all test routines
#@+node:ekr.20050211124103:(Several scripting improvements)
#@+node:ekr.20050211134923:What I did
@killcolor

1.  g.getScript calls the new g.removeExtraLws function to remove extra indentation.

This is required to keep Python happy.

2.  g.getScript does not call at.write if there is, in fact, a selection.

This disables handling of directives and section references, but it handles indentation.

This should be improved further, but that would require some hacks to at.write.

N.B. The primary usage of this is to execute test routines immediately by
selecting the text without the def. This eliminates the need to use this
pattern:

def test_whatever():
    stuff

if 0: test_whatever()

BTW, I played around with using:

if g.app.inScript:
    test_whatever()

But there are several problems with this idea. First, it is much more work than
just selecting the body of test_whatever. Worse, it can not be used in
leoGlobals.py because g.app will be None in the initial import of leoGlobals.
This bad special case doomed the entire idea.

3. g.executeScript now just adds a trailing newline to the script.

In particular, it does not call strip!
#@nonl
#@-node:ekr.20050211134923:What I did
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    # New in 4.3: Don't touch the script once it has been set, except to add a trailing newline.
    if script.strip():
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            p = c.currentPosition()
            d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
            exec script in d # Use {} to get a pristine environment!
            << unredirect output >>
            if not script1:
                g.es("end of script",color="purple")
        except Exception:
            << unredirect output >>
            g.es("exception executing script ")
            if 0:
                print 'script...'
                for line in g.splitLines(script):
                    print repr(line)
            fileName,n = g.es_exception(full=False,c=c)
            if fileName not in (None,"<string>"):
                g.es("exception in file %s, line: %d" % (fileName,n))
            if p and not script1 and fileName == "<string>":
                c.goToScriptLineNumber(p,script,n)
            else:
                << dump the lines near the error >>
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        << unredirect output >>
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,script=None):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()

    try:
        if script:
            s = script
        else:
            script = ''
            # Allow p not to be the present position.
            if p == c.currentPosition():
                if useSelectedText and c.frame.body.hasTextSelection():
                    # Temporarily replace v's body text with just the selected text.
                    s = c.frame.body.getSelectedText()
                    p.v.setTnodeText(s)
                else:
                    s = c.frame.body.getAllText()
            else:
                s = p.bodyString()
                
        # New in 4.3: Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            at = c.atFileCommands
            # New in 4.3: Selecting text executes _only_ the selected text.
            # This removes some indentation problems, but not all of them.
            if useSelectedText and c.frame.body.hasTextSelection():
                script = s
            else:
                at.write(p.copy(),nosentinels=False,toString=True,scriptWrite=True)
                script = at.stringOutput
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    p.v.setTnodeText(old_body)
    
    # g.trace(repr(c.atFileCommands.output_newline))
    if c.atFileCommands.output_newline == '\r\n':
        return script.replace("\r\n","\n") # 1/11/05
    else:
        return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_returns
def test_g_getScript_strips_returns():

    old_output_newline = c.atFileCommands.output_newline
    c.atFileCommands.output_newline = '\r\n'
    script = g.getScript(c,p)
    c.atFileCommands.output_newline = old_output_newline
    
    assert script.find('\r\n') == -1
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_returns
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20050211120242.2:g.removeExtraLws & tests
def removeExtraLws (s,tab_width):
    
    '''Remove extra indentation from one or more lines.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    
    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result
#@nonl
#@+node:ekr.20050211120837:test_g_removeExtraLws
def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@nonl
#@-node:ekr.20050211120837:test_g_removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & tests
#@-node:ekr.20050211124103:(Several scripting improvements)
#@-node:ekr.20050125203059.2:New features...
#@-node:ekr.20050125203059:4.3 a2 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
