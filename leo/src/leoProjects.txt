#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    g.app.scanErrors = 0
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:g.scanDirectives
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:g.scanDirectives
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ãƒ
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row > len(lines) or col > len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050710102922:get/setPythonInsertionPoint
def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
#@nonl
#@-node:ekr.20050710102922:get/setPythonInsertionPoint
#@+node:ekr.20050710104804:getPythonTextSelection
def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
#@nonl
#@-node:ekr.20050710104804:getPythonTextSelection
#@+node:ekr.20050710104804.1:setPythonTextSelection
def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
#@nonl
#@-node:ekr.20050710104804.1:setPythonTextSelection
#@+node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3174:escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 >= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
#@nonl
#@-node:ekr.20031218072017.3174:escaped
#@+node:ekr.20031218072017.3175:find_line_start
def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
#@nonl
#@-node:ekr.20031218072017.3175:find_line_start
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k > -1: return k
    else: return None
#@nonl
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3178:is_nl
def is_nl(s,i):

    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@nonl
#@-node:ekr.20031218072017.3178:is_nl
#@+node:ekr.20031218072017.3179:is_special
# We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i < len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
#@nonl
#@-node:ekr.20031218072017.3179:is_special
#@+node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i < len(s) and g.is_ws(s[i]))
#@nonl
#@-node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
#@+node:ekr.20031218072017.3181:match
# Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
#@nonl
#@-node:ekr.20031218072017.3181:match
#@+node:ekr.20031218072017.3182:match_c_word
def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
#@nonl
#@-node:ekr.20031218072017.3182:match_c_word
#@+node:ekr.20031218072017.3183:match_ignoring_case
def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
#@nonl
#@-node:ekr.20031218072017.3183:match_ignoring_case
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')
#@nonl
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3185:skip_blank_lines
def skip_blank_lines(s,i):

    while i < len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3185:skip_blank_lines
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    n = len(s)
    while i < n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
#@nonl
#@-node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i < n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3189:skip_matching_delims
def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)
#@nonl
#@-node:ekr.20031218072017.3189:skip_matching_delims
#@+node:ekr.20031218072017.3190:skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
#@nonl
#@-node:ekr.20031218072017.3190:skip_nl
#@+node:ekr.20031218072017.3191:skip_non_ws
def skip_non_ws (s,i):

    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3191:skip_non_ws
#@+node:ekr.20031218072017.3192:skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
#@nonl
#@-node:ekr.20031218072017.3192:skip_pascal_braces
#@+node:ekr.20031218072017.3193:skip_to_char
def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
#@-node:ekr.20031218072017.3193:skip_to_char
#@+node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
def skip_ws(s,i):

    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
#@-node:ekr.20031218072017.3173:Scanners: no error messages
#@-node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20051029070945:Pychecker report
# None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found
#@nonl
#@-node:ekr.20051029070945:Pychecker report
#@+node:ekr.20060117091600:4.4b2 projects
#@+node:ekr.20060117091430.1:Fixed crasher in Save button
@nocolor

Must check for c.exists in c.executeScript after executing the script.
#@nonl
#@-node:ekr.20060117091430.1:Fixed crasher in Save button
#@+node:ekr.20060117201349.1:Made modes work
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.keysym_numberDict = {}
    # Keys are keysym_num's.  Values are strokes.
self.keysym_numberInverseDict = {}
    # Keys are strokes, values are keysym_num's.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
#@nonl
#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0

# For modes
self.modeBunch = None
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20051001051355:Dispatching...
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and event.state
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '<Key>'
    interesting = not special
    
    if trace and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%4x' % state,'ch:',repr(ch),'keysym:',repr(keysym),'\n',
            'stroke2:',c.frame.menu.convertEventToStroke(event),
            'widget:',w and g.app.gui.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if k.inState():
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-func': return 'break'
        g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)

    if name.startswith('body') or name.startswith('head'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    # elif name.startswith('head'):
        # g.trace("can't happen: %s" % (name),color='red')
        # c.frame.tree.updateHead(event,w)
        # return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@nonl
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@-node:ekr.20051001051355:Dispatching...
#@+node:ekr.20060104154937:addModeCommands
def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
#@nonl
#@-node:ekr.20060104154937:addModeCommands
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = nextMode = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
    
    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]
        if not nextMode.strip(): nextMode = 'none'
    else: nextMode = 'none'
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@nonl
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = '<%s>' % shortcut.lstrip('<').rstrip('>')
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        # shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@+node:ekr.20051022094136:bindKeyHelper
def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the <Key>+ binding.
    if shortcut == '<Key>':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    else:
        # Put *everything* in a bindtag set specific to this commander.
        if 0: # Support plain-key bindings.
            tag = k.plainKeyTag()
            body.bind_class(tag,shortcut,callback)
        
        # Put everything *except* plain keys in a normal binding.
        if not k.isPlainKey(shortcut):
            for w in widgets:
                w.bind(shortcut,callback)
            # Get rid of the default binding in the menu. (E.g., Alt-f)
            menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:bindKeyHelper
#@+node:ekr.20060120082630:plainKeyTag
def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())
#@nonl
#@-node:ekr.20060120082630:plainKeyTag
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051008135051.1:bindOpenWith
def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)
    
    if c.simple_bindings:
        return k.bindKey('all',shortcut,openWithCallback,'open-with')
    else:
    
        bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
        def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
            return k.masterCommand(event,func,stroke)
                
        return k.bindKey('all',bind_shortcut,keyCallback,'open-with')
#@nonl
#@-node:ekr.20051008135051.1:bindOpenWith
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)
    
    # if k.isPlainKey(shortcut):
        # g.trace('Ignoring plain key binding of %s to %s' % (shortcut,commandName))
        # return

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        
        # g.trace(commandName,shortcut,g.callers())

        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20060119063223.1:computeKeysym_numDicts
def computeKeysym_numDicts (self,shortcut):
    
    k = self
    
    if shortcut == '<Key>': return
    
    n = k.keysym_numberInverseDict.get(shortcut)
    if n is not None:
        # print 'keysym_num for %s = %d' % (shortcut,n)
        return
        
    def callback (event,shortcut=shortcut):
        n = event.keysym_num
        # Trace causes problems.
        print '%5d = %s' % (n,shortcut)
        k.keysym_numberDict [n] = shortcut
        k.keysym_numberInverseDict [shortcut] = n
        
    if 0:  # This causes all sorts of problems.
        t = Tk.Text(k.c.frame.outerFrame)
        t = k.c.frame.body.bodyCtrl
        t.bind(shortcut,callback)
        t.event_generate(shortcut)
        # t.update()
        # t.unbind(shortcut)
#@nonl
#@-node:ekr.20060119063223.1:computeKeysym_numDicts
#@+node:ekr.20051023182326:k.copyBindingsToWidget & helper
def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w),g.callers())

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        # Do not copy plain key bindings.
        if not k.isPlainKey(shortcut):
            shortcutsBunchList = []
            for pane in panes:
                old_panes = bindings.get(shortcut,[])
                assert(type(old_panes)==type([]))
                if old_panes and pane in old_panes:
                    # This should have been caught earlier, but another check doesn't hurt.
                    g.trace('*** redefining %s in %s' % (shortcut,pane))
                else:
                    bunchList = d.get(shortcut,[])
                    for bunch in bunchList:
                        if bunch.pane == pane:
                            shortcutsBunchList.append(bunch)
                            old_panes.append(pane)
                            bindings [shortcut] = old_panes
            # Create bindings for the shortcut in all panes.
            if shortcutsBunchList:
                self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='<Key>',commandName=None)

    w.bind('<Key>',generalTextKeyCallback)
#@nonl
#@+node:ekr.20060113062832.1:copyBindingsHelper
def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)
#@nonl
#@-node:ekr.20060113062832.1:copyBindingsHelper
#@-node:ekr.20051023182326:k.copyBindingsToWidget & helper
#@+node:ekr.20060120071949:isPlainKey
def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut = shortcut or ''
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('<'):   shortcut = shortcut[1:]
    if shortcut.endswith('>'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]
    
    # if len(shortcut) == 1:
        # g.trace(shortcut1)

    return len(shortcut) == 1
#@nonl
#@-node:ekr.20060120071949:isPlainKey
#@+node:ekr.20051007080058:makeAllBindings
def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    if k.useTextWidget:
        k.copyBindingsToWidget(['text','mini','all'],c.miniBufferWidget)
    k.checkBindings()
    
    if 0:
        # Print the keysym_num dicts.
        d = k.keysym_numberInverseDict
        keys = d.keys() ; keys.sort()
        for key in key():
            n = d.get(key)
            # print 'keysym_num for %s = %d' % (key,n)
#@nonl
#@-node:ekr.20051007080058:makeAllBindings
#@+node:ekr.20060104154937:addModeCommands
def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
#@nonl
#@-node:ekr.20060104154937:addModeCommands
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@+node:ekr.20051220083410:makeSpecialBinding
def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)
#@nonl
#@-node:ekr.20051220083410:makeSpecialBinding
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@+node:ekr.20051008134059:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)
#@nonl
#@-node:ekr.20051008134059:makeBindingsFromCommandsDict
#@-node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20060115103349:Modes & input states
#@+node:ekr.20060102135349.2:enterNamedMode
def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20060102135349.2:enterNamedMode
#@+node:ekr.20060121104301:exitNamedMode
def exitNamedMode (self,event):
    
    k = self

    if k.inState():
        k.endMode(event)
    
    k.showStateAndMode()
#@-node:ekr.20060121104301:exitNamedMode
#@+node:ekr.20060104164523:modeHelp
def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c
    
    c.endEditing(restoreFocus=True)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    # else:
        # k.printBindings(event,brief=True)

    return 'break'
#@nonl
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@-node:ekr.20060104164523:modeHelp
#@+node:ekr.20060104110233:generalModeHandler & helpers
def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    w = g.app.gui.get_focus(c.frame)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.deleteTab('Mode')
            c.frame.widgetWantsFocus(w)
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if trace: g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@nonl
#@+node:ekr.20060117202916:badMode
def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@nonl
#@-node:ekr.20060117202916:badMode
#@+node:ekr.20060119150624:createModeBindings
def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    << define modeCallback >>
        else:
            g.trace('No such command: %s' % commandName)

    << define modeHelpCallback >>
#@nonl
#@+node:ekr.20060118181341:<< define modeCallback >>
# g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)
#@nonl
#@-node:ekr.20060118181341:<< define modeCallback >>
#@+node:ekr.20060119145631:<< define modeHelpCallback >>
def modeHelpCallback (event,k=k):
    
    if event and event.char != '':
        return k.modeHelp(event)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'<Key>',modeHelpCallback,'+')
#@nonl
#@-node:ekr.20060119145631:<< define modeHelpCallback >>
#@-node:ekr.20060119150624:createModeBindings
#@+node:ekr.20060117202916.1:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c
    
    if not modeName:
        g.trace('No mode name')
        return

    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return

    t = k.modeWidget = g.app.gui.get_focus(c.frame)        
    # t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    # Do *not* change the focus here!
#@nonl
#@-node:ekr.20060117202916.1:initMode
#@+node:ekr.20060117202916.2:endMode
def endMode(self,event):
    
    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)

    # Restore the bind tags.
    # t = c.frame.body.bodyCtrl
    t = k.modeWidget
    t.bindtags(k.savedBindtags)
    k.savedBindtags = None
    
    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()

    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060117202916.2:endMode
#@-node:ekr.20060104110233:generalModeHandler & helpers
#@+node:ekr.20060105132013:set-xxx-State & setInputState
def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

#@+node:ekr.20060120200818:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)
    
    if 0: # Support for plain-key bindings.
        tag = k.plainKeyTag()
                   
        try: # Will fail for nullBody.
            # t = c.frame.top
            t = c.frame.body.bodyCtrl
            tags = list(t.bindtags())
            
        except AttributeError:
            tags = [] ; t = w = None

        if tags:
            if state == 'ignore':
                if tag not in tags:
                    tags.insert(0,tag)
                    t.bindtags(tuple(tags))
            else:
                if tag in tags:
                    tags.remove(tag)
                    t.bindtags(tuple(tags))

        g.trace('%s-state' % (state),'plain key functions are',
            g.choose(tag in tags,'enabled','disabled')) # ,tags)

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060120200818:setInputState
#@-node:ekr.20060105132013:set-xxx-State & setInputState
#@+node:ekr.20060120193743:showStateAndMode
def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
#@-node:ekr.20060120193743:showStateAndMode
#@+node:ekr.20050923172809:State...
#@+node:ekr.20050923172814.1:clearState
def clearState (self):
    
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@nonl
#@-node:ekr.20050923172814.1:clearState
#@+node:ekr.20050923172814.2:getState
def getState (self,kind):
    
    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@nonl
#@-node:ekr.20050923172814.2:getState
#@+node:ekr.20050923172814.5:getStateKind
def getStateKind (self):

    return self.state.kind
    
#@nonl
#@-node:ekr.20050923172814.5:getStateKind
#@+node:ekr.20050923172814.3:inState
def inState (self,kind=None):
    
    k = self
    
    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@nonl
#@-node:ekr.20050923172814.3:inState
#@+node:ekr.20050923172814.4:setState
def setState (self,kind,n,handler=None):
    
    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
        
    # k.showStateAndMode()
#@-node:ekr.20050923172814.4:setState
#@-node:ekr.20050923172809:State...
#@-node:ekr.20060115103349:Modes & input states
#@-node:ekr.20060117201349.1:Made modes work
#@+node:ekr.20060119201356:Disabled plain-key bindings in insert/overwrite modes
#@+node:ekr.20060105132013:set-xxx-State & setInputState
def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

#@+node:ekr.20060120200818:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)
    
    if 0: # Support for plain-key bindings.
        tag = k.plainKeyTag()
                   
        try: # Will fail for nullBody.
            # t = c.frame.top
            t = c.frame.body.bodyCtrl
            tags = list(t.bindtags())
            
        except AttributeError:
            tags = [] ; t = w = None

        if tags:
            if state == 'ignore':
                if tag not in tags:
                    tags.insert(0,tag)
                    t.bindtags(tuple(tags))
            else:
                if tag in tags:
                    tags.remove(tag)
                    t.bindtags(tuple(tags))

        g.trace('%s-state' % (state),'plain key functions are',
            g.choose(tag in tags,'enabled','disabled')) # ,tags)

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060120200818:setInputState
#@-node:ekr.20060105132013:set-xxx-State & setInputState
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = '<%s>' % shortcut.lstrip('<').rstrip('>')
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        # shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@+node:ekr.20051022094136:bindKeyHelper
def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the <Key>+ binding.
    if shortcut == '<Key>':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    else:
        # Put *everything* in a bindtag set specific to this commander.
        if 0: # Support plain-key bindings.
            tag = k.plainKeyTag()
            body.bind_class(tag,shortcut,callback)
        
        # Put everything *except* plain keys in a normal binding.
        if not k.isPlainKey(shortcut):
            for w in widgets:
                w.bind(shortcut,callback)
            # Get rid of the default binding in the menu. (E.g., Alt-f)
            menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:bindKeyHelper
#@+node:ekr.20060120082630:plainKeyTag
def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())
#@nonl
#@-node:ekr.20060120082630:plainKeyTag
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051008135051.1:bindOpenWith
def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)
    
    if c.simple_bindings:
        return k.bindKey('all',shortcut,openWithCallback,'open-with')
    else:
    
        bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
        def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
            return k.masterCommand(event,func,stroke)
                
        return k.bindKey('all',bind_shortcut,keyCallback,'open-with')
#@nonl
#@-node:ekr.20051008135051.1:bindOpenWith
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)
    
    # if k.isPlainKey(shortcut):
        # g.trace('Ignoring plain key binding of %s to %s' % (shortcut,commandName))
        # return

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        
        # g.trace(commandName,shortcut,g.callers())

        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20060119063223.1:computeKeysym_numDicts
def computeKeysym_numDicts (self,shortcut):
    
    k = self
    
    if shortcut == '<Key>': return
    
    n = k.keysym_numberInverseDict.get(shortcut)
    if n is not None:
        # print 'keysym_num for %s = %d' % (shortcut,n)
        return
        
    def callback (event,shortcut=shortcut):
        n = event.keysym_num
        # Trace causes problems.
        print '%5d = %s' % (n,shortcut)
        k.keysym_numberDict [n] = shortcut
        k.keysym_numberInverseDict [shortcut] = n
        
    if 0:  # This causes all sorts of problems.
        t = Tk.Text(k.c.frame.outerFrame)
        t = k.c.frame.body.bodyCtrl
        t.bind(shortcut,callback)
        t.event_generate(shortcut)
        # t.update()
        # t.unbind(shortcut)
#@nonl
#@-node:ekr.20060119063223.1:computeKeysym_numDicts
#@+node:ekr.20051023182326:k.copyBindingsToWidget & helper
def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w),g.callers())

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        # Do not copy plain key bindings.
        if not k.isPlainKey(shortcut):
            shortcutsBunchList = []
            for pane in panes:
                old_panes = bindings.get(shortcut,[])
                assert(type(old_panes)==type([]))
                if old_panes and pane in old_panes:
                    # This should have been caught earlier, but another check doesn't hurt.
                    g.trace('*** redefining %s in %s' % (shortcut,pane))
                else:
                    bunchList = d.get(shortcut,[])
                    for bunch in bunchList:
                        if bunch.pane == pane:
                            shortcutsBunchList.append(bunch)
                            old_panes.append(pane)
                            bindings [shortcut] = old_panes
            # Create bindings for the shortcut in all panes.
            if shortcutsBunchList:
                self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='<Key>',commandName=None)

    w.bind('<Key>',generalTextKeyCallback)
#@nonl
#@+node:ekr.20060113062832.1:copyBindingsHelper
def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)
#@nonl
#@-node:ekr.20060113062832.1:copyBindingsHelper
#@-node:ekr.20051023182326:k.copyBindingsToWidget & helper
#@+node:ekr.20060120071949:isPlainKey
def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut = shortcut or ''
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('<'):   shortcut = shortcut[1:]
    if shortcut.endswith('>'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]
    
    # if len(shortcut) == 1:
        # g.trace(shortcut1)

    return len(shortcut) == 1
#@nonl
#@-node:ekr.20060120071949:isPlainKey
#@+node:ekr.20051007080058:makeAllBindings
def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    if k.useTextWidget:
        k.copyBindingsToWidget(['text','mini','all'],c.miniBufferWidget)
    k.checkBindings()
    
    if 0:
        # Print the keysym_num dicts.
        d = k.keysym_numberInverseDict
        keys = d.keys() ; keys.sort()
        for key in key():
            n = d.get(key)
            # print 'keysym_num for %s = %d' % (key,n)
#@nonl
#@-node:ekr.20051007080058:makeAllBindings
#@+node:ekr.20060104154937:addModeCommands
def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
#@nonl
#@-node:ekr.20060104154937:addModeCommands
#@+node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')

    k.bindKey('all','<Key>',allKeysCallback,'master-command')
#@nonl
#@+node:ekr.20051220083410:makeSpecialBinding
def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)
#@nonl
#@-node:ekr.20051220083410:makeSpecialBinding
#@-node:ekr.20051008152134:makeSpecialBindings (also binds to 'Key')
#@+node:ekr.20051008134059:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)
#@nonl
#@-node:ekr.20051008134059:makeBindingsFromCommandsDict
#@-node:ekr.20051006125633:Binding (keyHandler)
#@-node:ekr.20060119201356:Disabled plain-key bindings in insert/overwrite modes
#@+node:ekr.20060120105247:Fixed minor bugs & made minor improvements
@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings & mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaings the headline editing state.

@color
#@+node:ekr.20060120110341:Fixed two annoying headline glitches
@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color") or 'white'
    selbg = c.config.getColor("headline_text_editing_selection_background_color") or 'black'
    
    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; p1 = c.currentPosition()
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20060120110341:Fixed two annoying headline glitches
#@+node:ekr.20060120103549:Insert headline didn't redraw headline properly in vim mode
@nocolor

What I did:
    
- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color
#@nonl
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
                s1 = k.prettyPrintKey(key) + pane
                s2 = b.commandName
                n = max(n,len(s1))
                data.append((s1,s2),)
    
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and event.state
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '<Key>'
    interesting = not special
    
    if trace and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%4x' % state,'ch:',repr(ch),'keysym:',repr(keysym),'\n',
            'stroke2:',c.frame.menu.convertEventToStroke(event),
            'widget:',w and g.app.gui.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if k.inState():
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-func': return 'break'
        g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)

    if name.startswith('body') or name.startswith('head'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    # elif name.startswith('head'):
        # g.trace("can't happen: %s" % (name),color='red')
        # c.frame.tree.updateHead(event,w)
        # return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20060115103349:Modes & input states
#@+node:ekr.20060102135349.2:enterNamedMode
def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20060102135349.2:enterNamedMode
#@+node:ekr.20060121104301:exitNamedMode
def exitNamedMode (self,event):
    
    k = self

    if k.inState():
        k.endMode(event)
    
    k.showStateAndMode()
#@-node:ekr.20060121104301:exitNamedMode
#@+node:ekr.20060104164523:modeHelp
def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c
    
    c.endEditing(restoreFocus=True)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    # else:
        # k.printBindings(event,brief=True)

    return 'break'
#@nonl
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@-node:ekr.20060104164523:modeHelp
#@+node:ekr.20060104110233:generalModeHandler & helpers
def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    w = g.app.gui.get_focus(c.frame)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.deleteTab('Mode')
            c.frame.widgetWantsFocus(w)
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if trace: g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@nonl
#@+node:ekr.20060117202916:badMode
def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@nonl
#@-node:ekr.20060117202916:badMode
#@+node:ekr.20060119150624:createModeBindings
def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    << define modeCallback >>
        else:
            g.trace('No such command: %s' % commandName)

    << define modeHelpCallback >>
#@nonl
#@+node:ekr.20060118181341:<< define modeCallback >>
# g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)
#@nonl
#@-node:ekr.20060118181341:<< define modeCallback >>
#@+node:ekr.20060119145631:<< define modeHelpCallback >>
def modeHelpCallback (event,k=k):
    
    if event and event.char != '':
        return k.modeHelp(event)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'<Key>',modeHelpCallback,'+')
#@nonl
#@-node:ekr.20060119145631:<< define modeHelpCallback >>
#@-node:ekr.20060119150624:createModeBindings
#@+node:ekr.20060117202916.1:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c
    
    if not modeName:
        g.trace('No mode name')
        return

    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return

    t = k.modeWidget = g.app.gui.get_focus(c.frame)        
    # t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    # Do *not* change the focus here!
#@nonl
#@-node:ekr.20060117202916.1:initMode
#@+node:ekr.20060117202916.2:endMode
def endMode(self,event):
    
    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)

    # Restore the bind tags.
    # t = c.frame.body.bodyCtrl
    t = k.modeWidget
    t.bindtags(k.savedBindtags)
    k.savedBindtags = None
    
    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()

    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060117202916.2:endMode
#@-node:ekr.20060104110233:generalModeHandler & helpers
#@+node:ekr.20060105132013:set-xxx-State & setInputState
def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

#@+node:ekr.20060120200818:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)
    
    if 0: # Support for plain-key bindings.
        tag = k.plainKeyTag()
                   
        try: # Will fail for nullBody.
            # t = c.frame.top
            t = c.frame.body.bodyCtrl
            tags = list(t.bindtags())
            
        except AttributeError:
            tags = [] ; t = w = None

        if tags:
            if state == 'ignore':
                if tag not in tags:
                    tags.insert(0,tag)
                    t.bindtags(tuple(tags))
            else:
                if tag in tags:
                    tags.remove(tag)
                    t.bindtags(tuple(tags))

        g.trace('%s-state' % (state),'plain key functions are',
            g.choose(tag in tags,'enabled','disabled')) # ,tags)

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060120200818:setInputState
#@-node:ekr.20060105132013:set-xxx-State & setInputState
#@+node:ekr.20060120193743:showStateAndMode
def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
#@-node:ekr.20060120193743:showStateAndMode
#@+node:ekr.20050923172809:State...
#@+node:ekr.20050923172814.1:clearState
def clearState (self):
    
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@nonl
#@-node:ekr.20050923172814.1:clearState
#@+node:ekr.20050923172814.2:getState
def getState (self,kind):
    
    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@nonl
#@-node:ekr.20050923172814.2:getState
#@+node:ekr.20050923172814.5:getStateKind
def getStateKind (self):

    return self.state.kind
    
#@nonl
#@-node:ekr.20050923172814.5:getStateKind
#@+node:ekr.20050923172814.3:inState
def inState (self,kind=None):
    
    k = self
    
    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@nonl
#@-node:ekr.20050923172814.3:inState
#@+node:ekr.20050923172814.4:setState
def setState (self,kind,n,handler=None):
    
    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
        
    # k.showStateAndMode()
#@-node:ekr.20050923172814.4:setState
#@-node:ekr.20050923172809:State...
#@-node:ekr.20060115103349:Modes & input states
#@-node:ekr.20060120103549:Insert headline didn't redraw headline properly in vim mode
#@+node:ekr.20060119201657:Improved printBindings, printCommands & modeHelp
#@+node:ekr.20050920085536.32:Externally visible commands
#@+node:ekr.20050930080419:digitArgument & universalArgument
def universalArgument (self,event):
    
    '''Begin a numeric argument for the following command.'''
    
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)
    
def digitArgument (self,event):

    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
#@nonl
#@-node:ekr.20050930080419:digitArgument & universalArgument
#@+node:ekr.20051014170754:k.help
def help (self,event):
    
    k = self ; c = k.c
    commands = (
        k.fullCommand,
        k.quickCommand,
        k.universalArgument,
        k.keyboardQuit,
        # negative-argument
        # repeat-complex-command
    )
    shortcuts = [
        k.getShortcutForCommand(command)
        for command in commands]

    # A bug in Leo: triple quotes puts indentation before each line.
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

%s: Just like Emacs Alt-x: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit <Return> to execute the command. Tab completion
works, but not for file names.

%s: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

%s: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

%s: Just like Emacs Ctrl-g: Closes the mini-buffer.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])
    g.es_print(s)
#@nonl
#@-node:ekr.20051014170754:k.help
#@+node:ekr.20051014155551:k.show/hide/toggleMinibuffer
def hideMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.hideMinibuffer()
    
    g.es('Minibuffer hidden',color='red')

    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))
    
    
def showMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.showMinibuffer()
    
def toggleMinibuffer (self,event):
    
    k = self ; c = k.c
    
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)
#@nonl
#@-node:ekr.20051014155551:k.show/hide/toggleMinibuffer
#@+node:ekr.20050920085536.68:negativeArgument (redo?)
def negativeArgument (self,event):

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'
#@nonl
#@-node:ekr.20050920085536.68:negativeArgument (redo?)
#@+node:ekr.20050920085536.77:numberCommand
def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget

    k.universalDispatcher(event)
    w.event_generate('<Key>',keysym=number)

    return 'break'

def numberCommand0 (self,event): return self.numberCommand (event,None,0)
def numberCommand1 (self,event): return self.numberCommand (event,None,1)
def numberCommand2 (self,event): return self.numberCommand (event,None,2)
def numberCommand3 (self,event): return self.numberCommand (event,None,3)
def numberCommand4 (self,event): return self.numberCommand (event,None,4)
def numberCommand5 (self,event): return self.numberCommand (event,None,5)
def numberCommand6 (self,event): return self.numberCommand (event,None,6)
def numberCommand7 (self,event): return self.numberCommand (event,None,7)
def numberCommand8 (self,event): return self.numberCommand (event,None,8)
def numberCommand9 (self,event): return self.numberCommand (event,None,9)
#@nonl
#@-node:ekr.20050920085536.77:numberCommand
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
                s1 = k.prettyPrintKey(key) + pane
                s2 = b.commandName
                n = max(n,len(s1))
                data.append((s1,s2),)
    
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051014061332:printCommands
def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n = 20
    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            s1 = commandName
            s2 = k.prettyPrintKey(shortcut)
            n = max(n,len(s1))
            data.append((s1,s2),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
#@-node:ekr.20051014061332:printCommands
#@+node:ekr.20050920085536.48:repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    k = self

    if k.mb_history:
        k.setState('last-full-command',1,handler=k.doLastAltX)
        k.setLabelBlue("Redo: %s" % k.mb_history[0])
    return 'break'
    
def doLastAltX (self,event):
    
    k = self ; c = k.c

    if event.keysym == 'Return' and k.mb_history:
        last = k.mb_history [0]
        c.commandsDict [last](event)
        return 'break'
    else:
        return k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920085536.48:repeatComplexCommand & helper
#@-node:ekr.20050920085536.32:Externally visible commands
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
                s1 = k.prettyPrintKey(key) + pane
                s2 = b.commandName
                n = max(n,len(s1))
                data.append((s1,s2),)
    
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051014061332:printCommands
def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n = 20
    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            s1 = commandName
            s2 = k.prettyPrintKey(shortcut)
            n = max(n,len(s1))
            data.append((s1,s2),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
#@-node:ekr.20051014061332:printCommands
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@+node:ekr.20060104164523:modeHelp
def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c
    
    c.endEditing(restoreFocus=True)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    # else:
        # k.printBindings(event,brief=True)

    return 'break'
#@nonl
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@-node:ekr.20060104164523:modeHelp
#@-node:ekr.20060119201657:Improved printBindings, printCommands & modeHelp
#@-node:ekr.20060120105247:Fixed minor bugs & made minor improvements
#@+node:ekr.20060122183449:Disabled auto-scrolling in outline pane on clicks
The outline jumps around too much when expanding/contracting nodes
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    g.collectGarbage()
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@-node:ekr.20060122183449:Disabled auto-scrolling in outline pane on clicks
#@+node:ekr.20060122191111.1:Fixed crasher re BackSpace in log window
Error: 1
TclError Exception in Tk callback
  Function: <function textOrTreeKeyCallback at 0x0175EE30> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x01758738>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 541, in textOrTreeKeyCallback
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 408, in keyCallback2
    return k.masterCommand(event,func,stroke,commandName=commandName)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 771, in masterCommand
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 811, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1054, in generalModeHandler
    c.frame.widgetWantsFocus(w)
  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 2147, in widgetWantsFocus
    self.set_focus(w)
  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 2164, in set_focus
    g.app.gui.set_focus(c,w)
  File "C:\prog\leoCVS\leo\src\leoTkinterGui.py", line 446, in set_focus
    w.focus_set()
  File "c:\python24\lib\lib-tk\Tkinter.py", line 399, in focus_set
    self.tk.call('focus', self._w)
TclError: bad window path name ".19703448.22376360.22417776.22417856.22418216.22418376.22511008.24514648.log-3"

================================================
  Event contents:
    char: 
    delta: 8
    height: ??
    keycode: 8
    keysym: BackSpace
    keysym_num: 65288
    num: ??
    serial: 5130
    state: 8
    time: 36484812
    type: 2
    widget: .19703448.22376360.22417776.22417856.22418216.22418376.22511008.24514648.log-3
    width: ??
    x: 246
    x_root: 1215
    y: 85
    y_root: 303

#@-node:ekr.20060122191111.1:Fixed crasher re BackSpace in log window
#@+node:ekr.20060123062147:move-outline and find commands force a screen scroll
# This is required now that scrolling is disabled by default.
#@nonl
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20060123062147:move-outline and find commands force a screen scroll
#@+node:ekr.20060124091545:Fixed crashers in cut/copy/paste commands
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 250, in doCommand
    val = command() # Call legacy command

  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1777, in cutText
    oldText = w.get('1.0','end')

AttributeError: Canvas instance has no attribute 'get'
#@nonl
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w or not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w or not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20060124091545:Fixed crashers in cut/copy/paste commands
#@+node:ekr.20060127052111:(Limited undo)
# Added max_undo_stack_size setting.
#@nonl
#@+node:ekr.20031218072017.3605:class undoer
class baseUndoer:
    """The base class of the undoer class."""
    @others
    
class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass
#@nonl
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):
    
    u = self ; u.c = c

    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.

    u.granularity = c.config.getString('undo_granularity')
    if u.granularity: u.granularity = u.granularity.lower()
    if u.granularity not in ('node','line','word','char'):
        u.granularity = 'line'
    # g.trace('undoer',u.granularity)
    
    u.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    u.optionalIvars = []
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@nonl
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):
    
    # This logic is odious.  Instead, we should treat groups as single beads.
    
    u = self ; n = u.max_undo_stack_size
    
    if n > 0 and u.bead >= n:
        u.beads = u.beads[-n:]
        u.bead = n-1
        g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
#@nonl
#@-node:ekr.20060127052111.1:cutStack
#@+node:EKR.20040526150818:getBeed
def getBead (self,n):
    
    '''Set undoer ivars from the bunch at the top of the undo stack.'''
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)
    
    return bunch
#@nonl
#@-node:EKR.20040526150818:getBeed
#@+node:EKR.20040526150818.1:peekBeed
def peekBead (self,n):
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@nonl
#@-node:EKR.20040526150818.1:peekBeed
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):
    
    u = self

    u.clearIvars()

    if 0: # Debugging.
        print '-' * 40
        keys = bunch.keys()
        keys.sort()
        for key in keys:
            g.trace(key,bunch.get(key))
        print '-' * 20

    for key in bunch.keys():
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@nonl
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    ws = string.whitespace

    if 1: # This seems like the best way.
        # Start a word if new_ch begins whitespace + word
        return old_ch not in ws and new_ch in ws

    if 0: # Problems with punctuation within words.
        return old_ch in ws and new_ch not in ws

    if 0: # Problems with punctuation within words.
        word_chars = string.letters + string.digits + '_'
        return new_ch in word_chars and not old_ch in word_chars
        
    else: return False # Keeps Pychecker happy.
#@nonl
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@nonl
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType, setUndoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@nonl
#@-node:ekr.20031218072017.3614:setRedoType, setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):
    
    u = self
    
    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
    
    u.cutStack()
#@nonl
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):
    
    """Use the tree info to restore all vnode and tnode data,
    including all links."""
    
    u = self
    
    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@nonl
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):
    
    """Restore all ivars saved in the bunch."""
    
    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
#@nonl
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):
    
    t = bunch.t

    t.headString  = bunch.headString
    t.bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    t._firstChild = bunch.firstChild
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
#@nonl
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):
    
    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@nonl
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):
    
    """Create a bunch containing all info needed to recreate a vnode for undo."""
    
    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )
    
    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@nonl
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,t):
    
    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t.headString,
        bodyString = t.bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        firstChild = t._firstChild,
    )
    
    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
#@nonl
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):
    
    ivars = ('kind','undoType')
    
    for ivar in ivars:
        print ivar, getattr(self,ivar)
    
#@nonl
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):
    
    '''Update dirty and marked bits.'''
    
    u = self
    
    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()
        
    if marked:  u.p.setMarked()
    else:       u.p.clearMarked()

    u.c.setChanged(changed)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,command,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return
    
    if 1: # New code in 4.4b2: just change the kind of the bunch from 'beforeGroup' to 'endGroup'

        bunch =  u.beads[u.bead]
        if bunch.kind == 'beforeGroup':
            bunch.kind = 'afterGroup'
        else:
            g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)
        
    else:
        # Must use a _separate_ bunch than that created by beforeChangeGroup.
        # (To allow separate bunch.kind fields.
        bunch = u.createCommonBunch(p)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup ### Was None
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newP = p.copy()
    bunch.newSel = body.getTextSelection()
    
    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag
    
    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
    
    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@nonl
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.bodyString()
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.headString()
    bunch.newMarked = p.isMarked()
    bunch.newSel = body.getTextSelection()
    
    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.beads[u.bead]
    if bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

        # Recalculate the menu labels.
        u.setUndoTypes()
#@nonl
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return
    
    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = body.getTextSelection()
    bunch.newText = body.getAllText()
    bunch.newTree = u.saveTree(p)

    # Push the bunch, not a dict.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):
    
    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]
    
    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles
    
    # Push the bunch, not a dict.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    return bunch
#@nonl
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):
    
    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    
    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newBack   = p.back()
    bunch.newN = p.childIndex()
    bunch.newParent = p.parent()
    
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050410110343:afterMoveNode
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)
    
    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command
    
    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup ## None
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@nonl
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):
    
    '''Return data that gets passed to afterChangeNode'''
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBody = oldBody or p.bodyString()
    bunch.oldHead = oldHead or p.headString()

    return bunch
#@nonl
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):
    
    # g.trace(p.headString())
    
    u = self ; body = u.c.frame.body

    bunch = u.createCommonBunch(p)

    bunch.oldSel = body.getTextSelection()
    bunch.oldText = body.getAllText()
    bunch.oldTree = u.saveTree(p)
    
    return bunch
#@nonl
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):
    
    u = self ; p = u.c.currentPosition()
    
    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@nonl
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@nonl
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()
    
    return bunch
#@nonl
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    
    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    
    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@nonl
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command
    
    return bunch
#@nonl
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldN = p.childIndex()
    bunch.oldParent = p.parent()

    return bunch
#@nonl
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):
    
    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''
    
    u = self ; c = u.c ; body = c.frame.body
    
    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = body.getTextSelection(),
        p = p.copy(),
    )
#@nonl
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self
    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self
    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.
    
    All non-undoable commands should call this method."""
    
    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@nonl
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame
    
    menu = frame.menu.getMenu("Edit")
    frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
    frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20050525151217:getMark & rollbackToMark
def getMark (self):
    
    __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.
    
    return self.bead
    
def rollbackToMark (self,n):
    
    u = self

    u.bead = n
    u.beads = u.beads[:n+1]
    u.setUndoTypes()
    
rollBackToMark = rollbackToMark
#@nonl
#@-node:ekr.20050525151217:getMark & rollbackToMark
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    << return if there is nothing to do >>
    # g.trace(undo_type,g.callers(7))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return bunch
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
else:
    bunch = old_d

bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview

u.beads[u.bead:] = [bunch]
    
# g.trace(u.bead,len(u.beads))
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self):

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead')
        return
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        if u.redoHelper:
            u.redoHelper()
        else:
            g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
        c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
        # So we always request a redraw.
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@nonl
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)
            
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.hoist()
    
def redoDehoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.dehoist()
#@nonl
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    for z in bunch.items:
        self.setIvarsFromBunch(z)
        if z.redoHelper:
            z.redoHelper() ; count += 1
        else:
            g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@nonl
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20050526125801:redoMark
def redoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)
        
    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
#@nonl
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self):

    """Undo the operation described by the undo parmaters."""
    
    u = self ; c = u.c
    # g.trace(g.callers(7))

    c.endEditing() # Capture the headline *before* checking for undo.
    
    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead')
        return # Sets ivars.
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)

    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        if u.undoHelper:
            u.undoHelper()
        else:
            g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
        c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
        # So we always request a redraw.
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()

    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    for z in bunch.items:
        self.setIvarsFromBunch(z)
        if z.undoHelper:
            z.undoHelper() ; count += 1
        else:
            g.trace('oops: no undo helper for %s' % u.undoType)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
    
def undoDehoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@nonl
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@nonl
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
#@nonl
#@-node:ekr.20050318085713.2:undoTree
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):
    
    '''Replace p and its subtree using old_data during undo.'''
    
    # Same as undoReplace except uses g.Bunch.

    u = self
    
    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    p.setBodyStringOrPane(p.bodyString())
    
    return p # Nothing really changes.
#@nonl
#@-node:ekr.20050408100042:undoRedoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; body = c.frame.body
    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0:
            << print mismatch trace >>
        p.setBodyStringOrPane(result)
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):
    
    # This logic is odious.  Instead, we should treat groups as single beads.
    
    u = self ; n = u.max_undo_stack_size
    
    if n > 0 and u.bead >= n:
        u.beads = u.beads[-n:]
        u.bead = n-1
        g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
#@nonl
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    for z in bunch.items:
        self.setIvarsFromBunch(z)
        if z.undoHelper:
            z.undoHelper() ; count += 1
        else:
            g.trace('oops: no undo helper for %s' % u.undoType)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    for z in bunch.items:
        self.setIvarsFromBunch(z)
        if z.redoHelper:
            z.redoHelper() ; count += 1
        else:
            g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)
    
    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command
    
    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup ## None
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@nonl
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,command,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return
    
    if 1: # New code in 4.4b2: just change the kind of the bunch from 'beforeGroup' to 'endGroup'

        bunch =  u.beads[u.bead]
        if bunch.kind == 'beforeGroup':
            bunch.kind = 'afterGroup'
        else:
            g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)
        
    else:
        # Must use a _separate_ bunch than that created by beforeChangeGroup.
        # (To allow separate bunch.kind fields.
        bunch = u.createCommonBunch(p)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup ### Was None
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newP = p.copy()
    bunch.newSel = body.getTextSelection()
    
    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag
    
    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
    
    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@nonl
#@-node:ekr.20050315134017.4:afterChangeGroup
#@-node:ekr.20060127052111:(Limited undo)
#@+node:ekr.20060120105605.1:(Modes project)
#@+node:ekr.20060120200529:What I did
@nocolor

- Made insert mode the default, even for vim-like bindings.

- Eliminated plain-key bindings from leoSettings.leo.
    - It's far easier to define a Command-mode.

** Eliminates the effect of all plain-key bindings.
    - setInputState never uses the bindtags bindings.

- bindKeyHelper copies *all* bindings to the bindtag set.
  This prevents control-i from matching the <i> binding.  Sheesh.

- bindKeyHelper makes widget bindings for all bindings *except* plain key bindings.

- copyBindingsToWidget does not copy plain key bindings.

- k.setMode and k.setInputState call k.showInputState, so the state and mode are alway updated.

- k.showStateAndMode just clears the status if state and mode are empty.
    k.setInputState now takes a showState arg that if true forces a call to k.showStateAndMode.

- Changed canonicalizeShortcut so it returns a single character for plain characters.
  This change had no effect one way or the other.
#@nonl
#@-node:ekr.20060120200529:What I did
#@+node:ekr.20031218072017.2098:canonicalizeShortcut
@ This code "canonicalizes" both the shortcuts that appear in menus and the
arguments to bind, mostly ignoring case and the order in which special keys are
specified.

For example, Ctrl+Shift+a is the same as Shift+Control+A. Each generates
Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") >= 0     or s.find("command") >= 0 # 11/18/03
    has_ctrl  = s.find("control") >= 0 or s.find("ctrl") >= 0
    has_alt   = s.find("alt") >= 0
    has_shift = s.find("shift") >= 0   or s.find("shft") >= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    << set the last field, preserving case >>
    << canonicalize the last field >>
    << synthesize the shortcuts from the information >>
    # print repr(shortcut),repr(bind_shortcut),repr(menu_shortcut)
    return bind_shortcut,menu_shortcut
#@nonl
#@+node:ekr.20031218072017.2102:<< set the last field, preserving case >>
s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) > 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None
#@nonl
#@-node:ekr.20031218072017.2102:<< set the last field, preserving case >>
#@+node:ekr.20031218072017.2099:<< canonicalize the last field >>
bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        << define dict of Tk bind names >>
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) > 0:
    << define dict of special names >>
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]
#@nonl
#@+node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
# These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "<" : "less",
    "=" : "equal",
    ">" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }
#@nonl
#@-node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
#@+node:ekr.20031218072017.2101:<< define dict of special names >>
# These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@nonl
#@-node:ekr.20031218072017.2101:<< define dict of special names >>
#@-node:ekr.20031218072017.2099:<< canonicalize the last field >>
#@+node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
bind_head = menu_head = ""

if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
if has_shift:
    menu_head = menu_head + "Shift+"
    if len(last) > 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = bind_head + "Shift-"

# New in 4.4b2:
if not bind_head and bind_last and len(bind_last) == 1:
    bind_shortcut = '<Key-%s>' % bind_last
    # g.trace(bind_shortcut)
    "<" + bind_head + bind_last + ">"
    # bind_shortcut = bind_last # Just return the actual character.
    menu_shortcut = menu_head + menu_last
else:
    bind_shortcut = "<" + bind_head + bind_last + ">"
    menu_shortcut = menu_head + menu_last
#@nonl
#@-node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
#@-node:ekr.20031218072017.2098:canonicalizeShortcut
#@+node:ekr.20051014170754.1:getShortcutForCommand/Name (should return lists)
def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return '<%s>' % key.lstrip('<').rstrip('>')
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                     return '<%s>' % key.lstrip('<').rstrip('>')
    return ''
#@nonl
#@-node:ekr.20051014170754.1:getShortcutForCommand/Name (should return lists)
#@+node:ekr.20060122191605:KeyHandler
#@+node:ekr.20051122104219:prettyPrintKey
def prettyPrintKey (self,key):
    
    '''Print a shortcut in a pleasing way.'''
    
    s = self.c.frame.menu.canonicalizeShortcut(key)[1] or ''
    
    return len(s) == 1 and 'Key+' + s or s
#@nonl
#@-node:ekr.20051122104219:prettyPrintKey
#@+node:ekr.20060121101953:Dispatching
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and event.state
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '<Key>'
    interesting = not special
    
    if trace and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%4x' % state,'ch:',repr(ch),'keysym:',repr(keysym),'\n',
            'stroke2:',c.frame.menu.convertEventToStroke(event),
            'widget:',w and g.app.gui.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if k.inState():
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-func': return 'break'
        g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)

    if name.startswith('body') or name.startswith('head'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    # elif name.startswith('head'):
        # g.trace("can't happen: %s" % (name),color='red')
        # c.frame.tree.updateHead(event,w)
        # return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@-node:ekr.20060121101953:Dispatching
#@+node:ekr.20060121095848.2:Binding...
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)
    
    # if k.isPlainKey(shortcut):
        # g.trace('Ignoring plain key binding of %s to %s' % (shortcut,commandName))
        # return

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        
        # g.trace(commandName,shortcut,g.callers())

        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = '<%s>' % shortcut.lstrip('<').rstrip('>')
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        # shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@+node:ekr.20051022094136:bindKeyHelper
def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the <Key>+ binding.
    if shortcut == '<Key>':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    else:
        # Put *everything* in a bindtag set specific to this commander.
        if 0: # Support plain-key bindings.
            tag = k.plainKeyTag()
            body.bind_class(tag,shortcut,callback)
        
        # Put everything *except* plain keys in a normal binding.
        if not k.isPlainKey(shortcut):
            for w in widgets:
                w.bind(shortcut,callback)
            # Get rid of the default binding in the menu. (E.g., Alt-f)
            menu.bind(shortcut,lambda e: 'break')
#@nonl
#@-node:ekr.20051022094136:bindKeyHelper
#@+node:ekr.20060120082630:plainKeyTag
def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())
#@nonl
#@-node:ekr.20060120082630:plainKeyTag
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051023182326:k.copyBindingsToWidget & helper
def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w),g.callers())

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        # Do not copy plain key bindings.
        if not k.isPlainKey(shortcut):
            shortcutsBunchList = []
            for pane in panes:
                old_panes = bindings.get(shortcut,[])
                assert(type(old_panes)==type([]))
                if old_panes and pane in old_panes:
                    # This should have been caught earlier, but another check doesn't hurt.
                    g.trace('*** redefining %s in %s' % (shortcut,pane))
                else:
                    bunchList = d.get(shortcut,[])
                    for bunch in bunchList:
                        if bunch.pane == pane:
                            shortcutsBunchList.append(bunch)
                            old_panes.append(pane)
                            bindings [shortcut] = old_panes
            # Create bindings for the shortcut in all panes.
            if shortcutsBunchList:
                self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='<Key>',commandName=None)

    w.bind('<Key>',generalTextKeyCallback)
#@nonl
#@+node:ekr.20060113062832.1:copyBindingsHelper
def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)
#@nonl
#@-node:ekr.20060113062832.1:copyBindingsHelper
#@-node:ekr.20051023182326:k.copyBindingsToWidget & helper
#@-node:ekr.20060121095848.2:Binding...
#@+node:ekr.20050920085536.63:keyboardQuit
def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    
    # Completely clear the mode.
    if k.inputModeName:
        k.endMode()

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
        
    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.63:keyboardQuit
#@-node:ekr.20060122191605:KeyHandler
#@+node:ekr.20060121095848:Commands
#@+node:ekr.20050920085536.63:keyboardQuit
def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    
    # Completely clear the mode.
    if k.inputModeName:
        k.endMode()

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
        
    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.63:keyboardQuit
#@+node:ekr.20031218072017.2886:editHeadline
def editHeadline(self):
    
    c = self ; k = c.keyHandler ; tree = c.frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()

    tree.editLabel(c.currentPosition())
#@nonl
#@-node:ekr.20031218072017.2886:editHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p):

    c = self ; k = self.keyHandler

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p)
        
        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
#@nonl
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self,restoreFocus=False):
    
    c = self ; tree = c.frame.tree
    
    if restoreFocus:
        w = g.app.gui.get_focus(c.frame)
        tree.endEditLabel()
        c.frame.widgetWantsFocus(w)
    else:
        tree.endEditLabel()
#@nonl
#@-node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
                s1 = k.prettyPrintKey(key) + pane
                s2 = b.commandName
                n = max(n,len(s1))
                data.append((s1,s2),)
    
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051014061332:printCommands
def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n = 20
    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            s1 = commandName
            s2 = k.prettyPrintKey(shortcut)
            n = max(n,len(s1))
            data.append((s1,s2),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
#@-node:ekr.20051014061332:printCommands
#@-node:ekr.20060121095848:Commands
#@+node:ekr.20060121095848.3:Tree...
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.keyHandler ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@+node:ekr.20040803072955.20:tkTree.createPermanentBindings
def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('<Button-1>',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','<Button-1>', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','<Button-1>',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','<Button-1>', self.onIconBoxClick)

    canvas.tag_bind('iconBox','<Double-1>', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','<Button-3>', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','<B1-Motion>',            self.onDrag)
    canvas.tag_bind('iconBox','<Any-ButtonRelease-1>',  self.onEndDrag)
    
    def headKeyCallback (event,self=self):
        return self.c.keyHandler.masterCommand(event,
            func=None,stroke='<Key>',commandName=None)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("<Button-1>", self.onHeadlineClick, '+')
        t.bind("<Button-3>", self.onHeadlineRightClick, '+')
        # There must be only one general key handler.
        if 0:
            # Warning: k.selfInsertCommand only handles body text at present.
            t.bind('<Key>', headKeyCallback)
        else:
            t.bind("<Key>", self.onHeadlineKey)
                

        if 0: # This does not appear necessary in 4.4.
            t.bind("<Control-t>",self.onControlT)
#@nonl
#@-node:ekr.20040803072955.20:tkTree.createPermanentBindings
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget(['text','all'],t) # Text *must* be in the list.
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("<Control-t>",self.onControlT)

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
    t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
    t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("<Button-4>", PropagateButton4)
    t.bind("<Button-5>", PropagateButton5)
    t.bind("<MouseWheel>", PropagateMouseWheel)

#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20060121095848.3:Tree...
#@+node:ekr.20060115103349:Modes & input states
#@+node:ekr.20060102135349.2:enterNamedMode
def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20060102135349.2:enterNamedMode
#@+node:ekr.20060121104301:exitNamedMode
def exitNamedMode (self,event):
    
    k = self

    if k.inState():
        k.endMode(event)
    
    k.showStateAndMode()
#@-node:ekr.20060121104301:exitNamedMode
#@+node:ekr.20060104164523:modeHelp
def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c
    
    c.endEditing(restoreFocus=True)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    # else:
        # k.printBindings(event,brief=True)

    return 'break'
#@nonl
#@+node:ekr.20060104125946:modeHelpHelper
def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)
#@nonl
#@-node:ekr.20060104125946:modeHelpHelper
#@-node:ekr.20060104164523:modeHelp
#@+node:ekr.20060104110233:generalModeHandler & helpers
def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    w = g.app.gui.get_focus(c.frame)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.deleteTab('Mode')
            c.frame.widgetWantsFocus(w)
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if trace: g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
#@nonl
#@+node:ekr.20060117202916:badMode
def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@nonl
#@-node:ekr.20060117202916:badMode
#@+node:ekr.20060119150624:createModeBindings
def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    << define modeCallback >>
        else:
            g.trace('No such command: %s' % commandName)

    << define modeHelpCallback >>
#@nonl
#@+node:ekr.20060118181341:<< define modeCallback >>
# g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)
#@nonl
#@-node:ekr.20060118181341:<< define modeCallback >>
#@+node:ekr.20060119145631:<< define modeHelpCallback >>
def modeHelpCallback (event,k=k):
    
    if event and event.char != '':
        return k.modeHelp(event)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'<Key>',modeHelpCallback,'+')
#@nonl
#@-node:ekr.20060119145631:<< define modeHelpCallback >>
#@-node:ekr.20060119150624:createModeBindings
#@+node:ekr.20060117202916.1:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c
    
    if not modeName:
        g.trace('No mode name')
        return

    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return

    t = k.modeWidget = g.app.gui.get_focus(c.frame)        
    # t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    # Do *not* change the focus here!
#@nonl
#@-node:ekr.20060117202916.1:initMode
#@+node:ekr.20060117202916.2:endMode
def endMode(self,event):
    
    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)

    # Restore the bind tags.
    # t = c.frame.body.bodyCtrl
    t = k.modeWidget
    t.bindtags(k.savedBindtags)
    k.savedBindtags = None
    
    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()

    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060117202916.2:endMode
#@-node:ekr.20060104110233:generalModeHandler & helpers
#@+node:ekr.20060105132013:set-xxx-State & setInputState
def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

#@+node:ekr.20060120200818:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)
    
    if 0: # Support for plain-key bindings.
        tag = k.plainKeyTag()
                   
        try: # Will fail for nullBody.
            # t = c.frame.top
            t = c.frame.body.bodyCtrl
            tags = list(t.bindtags())
            
        except AttributeError:
            tags = [] ; t = w = None

        if tags:
            if state == 'ignore':
                if tag not in tags:
                    tags.insert(0,tag)
                    t.bindtags(tuple(tags))
            else:
                if tag in tags:
                    tags.remove(tag)
                    t.bindtags(tuple(tags))

        g.trace('%s-state' % (state),'plain key functions are',
            g.choose(tag in tags,'enabled','disabled')) # ,tags)

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20060120200818:setInputState
#@-node:ekr.20060105132013:set-xxx-State & setInputState
#@+node:ekr.20060120193743:showStateAndMode
def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
#@-node:ekr.20060120193743:showStateAndMode
#@+node:ekr.20050923172809:State...
#@+node:ekr.20050923172814.1:clearState
def clearState (self):
    
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@nonl
#@-node:ekr.20050923172814.1:clearState
#@+node:ekr.20050923172814.2:getState
def getState (self,kind):
    
    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@nonl
#@-node:ekr.20050923172814.2:getState
#@+node:ekr.20050923172814.5:getStateKind
def getStateKind (self):

    return self.state.kind
    
#@nonl
#@-node:ekr.20050923172814.5:getStateKind
#@+node:ekr.20050923172814.3:inState
def inState (self,kind=None):
    
    k = self
    
    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@nonl
#@-node:ekr.20050923172814.3:inState
#@+node:ekr.20050923172814.4:setState
def setState (self,kind,n,handler=None):
    
    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
        
    # k.showStateAndMode()
#@-node:ekr.20050923172814.4:setState
#@-node:ekr.20050923172809:State...
#@-node:ekr.20060115103349:Modes & input states
#@-node:ekr.20060120105605.1:(Modes project)
#@-node:ekr.20060117091600:4.4b2 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
