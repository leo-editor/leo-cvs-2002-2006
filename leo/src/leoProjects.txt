#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ãƒ
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row > len(lines) or col > len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050710102922:get/setPythonInsertionPoint
def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
#@nonl
#@-node:ekr.20050710102922:get/setPythonInsertionPoint
#@+node:ekr.20050710104804:getPythonTextSelection
def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
#@nonl
#@-node:ekr.20050710104804:getPythonTextSelection
#@+node:ekr.20050710104804.1:setPythonTextSelection
def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
#@nonl
#@-node:ekr.20050710104804.1:setPythonTextSelection
#@+node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3174:escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 >= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
#@nonl
#@-node:ekr.20031218072017.3174:escaped
#@+node:ekr.20031218072017.3175:find_line_start
def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
#@nonl
#@-node:ekr.20031218072017.3175:find_line_start
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k > -1: return k
    else: return None
#@nonl
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3178:is_nl
def is_nl(s,i):

    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@nonl
#@-node:ekr.20031218072017.3178:is_nl
#@+node:ekr.20031218072017.3179:is_special
# We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i < len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
#@nonl
#@-node:ekr.20031218072017.3179:is_special
#@+node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i < len(s) and g.is_ws(s[i]))
#@nonl
#@-node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
#@+node:ekr.20031218072017.3181:match
# Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
#@nonl
#@-node:ekr.20031218072017.3181:match
#@+node:ekr.20031218072017.3182:match_c_word
def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
#@nonl
#@-node:ekr.20031218072017.3182:match_c_word
#@+node:ekr.20031218072017.3183:match_ignoring_case
def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
#@nonl
#@-node:ekr.20031218072017.3183:match_ignoring_case
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')
#@nonl
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3185:skip_blank_lines
def skip_blank_lines(s,i):

    while i < len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3185:skip_blank_lines
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    n = len(s)
    while i < n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
#@nonl
#@-node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i < n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3189:skip_matching_delims
def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)
#@nonl
#@-node:ekr.20031218072017.3189:skip_matching_delims
#@+node:ekr.20031218072017.3190:skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
#@nonl
#@-node:ekr.20031218072017.3190:skip_nl
#@+node:ekr.20031218072017.3191:skip_non_ws
def skip_non_ws (s,i):

    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3191:skip_non_ws
#@+node:ekr.20031218072017.3192:skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
#@nonl
#@-node:ekr.20031218072017.3192:skip_pascal_braces
#@+node:ekr.20031218072017.3193:skip_to_char
def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
#@-node:ekr.20031218072017.3193:skip_to_char
#@+node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
def skip_ws(s,i):

    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
#@-node:ekr.20031218072017.3173:Scanners: no error messages
#@-node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20051029070945:Pychecker report
# None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found
#@nonl
#@-node:ekr.20051029070945:Pychecker report
#@+node:ekr.20051010062551.1:(key dicts)
@

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.
    
inverseBindingsDict (computed by computeInverseBindingDict)
    keys are emacs command names, values are shortcuts.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are g.bunch(func,name,warningGiven)
#@-node:ekr.20051010062551.1:(key dicts)
#@+node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = False
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        c.keyHandler.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.funcReturn = None # For k.simulateCommand
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        c.keyHandler.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("<Activate>",f.OnActivateLeoEvent)
    f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label
#@nonl
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            return self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'close-find-dialog':    c.dismissFindPanel, # Deprecated.
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'find-dialog-change':       c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':   c.replaceAll,           # Deprecated.
    'find-dialog-find-next':    c.findNext,             # Deprecated.
    'find-dialog-find-previous':c.findPrevious,         # Deprecated.
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent-region':            c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-find-dialog':          c.showFindPanel, # Deprecated.
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@-node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20051210070744:Statistics
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.wantedCommander = None # Used by tkFrame.set_focus.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.3133:Statistics
#@+node:ekr.20031218072017.3134:clear_stats
def clear_stats():
    
    g.trace()
    
    g.app.statsDict = {}

clearStats = clear_stats
#@-node:ekr.20031218072017.3134:clear_stats
#@+node:ekr.20031218072017.3135:print_stats
def print_stats (name=None):

    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g.callerName(n=2) # Get caller name 2 levels back.

    g.printDict(g.app.statsDict,tag='statistics at %s' % name)

printStats = print_stats
#@nonl
#@-node:ekr.20031218072017.3135:print_stats
#@+node:ekr.20031218072017.3136:stat
def stat (name=None):

    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """
    
    d = g.app.statsDict
    
    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g.callerName(n=2) # Get caller name 2 levels back.
        
    # g.trace(name)

    d [name] = 1 + d.get(name,0)
#@nonl
#@-node:ekr.20031218072017.3136:stat
#@-node:ekr.20031218072017.3133:Statistics
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):
    
    """Split s into lines, preserving the number of lines and the ending of the last line."""

    # g.stat()
    
    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):
    
    return ''.join(aList)
    
joinlines = joinLines
#@nonl
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20051210070744:Statistics
#@+node:ekr.20051110101524:4.4a4 projects
#@+node:ekr.20051103114520.2:(The New World Order)
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.wantedCommander = None # Used by tkFrame.set_focus.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20050210082320:widget_wants_focus (tk.gui)
def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus
#@nonl
#@-node:ekr.20050210082320:widget_wants_focus (tk.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):

    return t.index("insert")
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange (to be deleted?)
def getSelectionRange (self,t):

    return t.tag_ranges("sel")
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange (to be deleted?)
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, ">", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20051029065806:Commands
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; tree = frame.tree
    p = c.currentPosition() ; w = p.edit_widget()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return
        
    # g.trace(p == tree.editPosition(),repr(tree.revertHeadline))
        
    if w and p == tree.editPosition():
        # Revert the headline text.
        w.delete("1.0","end")
        w.insert("end",tree.revertHeadline)
        p.initHeadString(tree.revertHeadline)
        c.beginUpdate()
        try:
	        c.endEditing()
	        c.selectPosition(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3983:insertHeadlineTime
def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')
#@nonl
#@-node:ekr.20031218072017.3983:insertHeadlineTime
#@+node:ekr.20051022142249:focus (editCommandsClass)
#@+node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()
#@nonl
#@-node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@-node:ekr.20051022142249:focus (editCommandsClass)
#@-node:ekr.20051029065806:Commands
#@+node:ekr.20051106103835:Drawing
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    c.setFocusHelper()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now()
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@-node:ekr.20051106103835:Drawing
#@+node:ekr.20051105090649:Event handlers
# Body events can not cause the tree to be redrawn.
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    g.app.closeLeoWindow(self)
#@nonl
#@-node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
#@+node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
def OnControlKeyDown (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    self.controlKeyIsDown = True
    
def OnControlKeyUp (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.controlKeyIsDown = False
#@nonl
#@-node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):
    
    '''Handle a click anywhere in the Leo window.'''
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c
    # g.trace(g.callers(5))

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
        c.setFocusHelper() # Try to guess the best possible focus.
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")
#@nonl
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self
        g.app.setLog(frame.log,"OnActivateTree")
        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            frame.bodyWantsFocus()
            
    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyclick1",c=c,p=v,v=v,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=v,v=v,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyrclick1",c=c,p=v,v=v,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=v,v=v,event=event)
    except:
        g.es_event_exception("iconrclick")
#@nonl
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodydclick1",c=c,p=v,v=v,event=event):
            if event: # 8/4/02: prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked.
                event.widget.tag_add('sel', 'insert wordstart', 'insert wordend')
            body = self.bodyCtrl
            start = body.index(index + " wordstart")
            end = body.index(index + " wordend")
            self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=v,v=v,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.
#@nonl
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
# Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

    try:
        if event.delta < 1:
            self.canvas.yview(Tk.SCROLL, 1, Tk.UNITS)
        else:
            self.canvas.yview(Tk.SCROLL, -1, Tk.UNITS)
    except:
        g.es_event_exception("scroll wheel")

    return "break"
#@nonl
#@-node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
#@-node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.72:checkWidgetList
def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True
#@nonl
#@-node:ekr.20040803072955.72:checkWidgetList
#@+node:ekr.20040803072955.73:dumpWidgetList
def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t
#@nonl
#@-node:ekr.20040803072955.73:dumpWidgetList
#@+node:ekr.20040803072955.75:edit_widget
def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.
#@nonl
#@-node:ekr.20040803072955.75:edit_widget
#@+node:ekr.20040803072955.74:eventToPosition
def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    # 7/28/04: Not doing this translation was the real bug.
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId: return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None
#@nonl
#@-node:ekr.20040803072955.74:eventToPosition
#@+node:ekr.20040803072955.76:findEditWidget
# Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if p and c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None
#@nonl
#@-node:ekr.20040803072955.76:findEditWidget
#@+node:ekr.20040803072955.109:findVnodeWithIconId
def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
        
    
#@-node:ekr.20040803072955.109:findVnodeWithIconId
#@+node:ekr.20040803072955.117:tree.moveUpDown (not used)
def OnUpKey   (self,event=None):
    __pychecker__ = '--no-argsused' # event not used.
    return self.moveUpDown("up")
def OnDownKey (self,event=None):
    __pychecker__ = '--no-argsused' # event not used.
    return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if upOrDown == "up":
        if y <= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y >= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x > newx + width/2:
        x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    # g.trace("entry:  %s.%s" % (lines,char))
    # g.trace("result:",result)
    # g.trace("insert:",body.index("insert"))
    return "break" # Inhibit further bindings.
#@nonl
#@-node:ekr.20040803072955.117:tree.moveUpDown (not used)
#@-node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
	    << set vdrag, childFlag >>
	    if c.config.getBool("allow_clone_drags"):
	        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
	            self.controlDrag = c.frame.controlKeyIsDown
	
	    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
	        << drag p to vdrag >>
	    elif self.trace and self.verbose:
	        g.trace("Cancel drag")
	    
	    # Reset the old cursor by brute force.
	    self.canvas['cursor'] = "arrow"
	    self.dragging = False
	    self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@nonl
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    # g.trace(self.drag_p)
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus()
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20051022141020:onTreeClick
def onTreeClick (self,event=None):
    
    c = self.c
    
    self.frame.treeWantsFocus()

    return 'break'
#@nonl
#@-node:ekr.20051022141020:onTreeClick
#@+node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.85:configureTextState
def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20040803072955.85:configureTextState
#@+node:ekr.20040803072955.86:onCtontrolT
# This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"
#@nonl
#@-node:ekr.20040803072955.86:onCtontrolT
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")

    return "continue"
#@nonl
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.108:tree.OnDeactivate (caused double-click problem)
def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        c.beginUpdate()
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        finally:
            c.endUpdate(False)
#@nonl
#@-node:ekr.20040803072955.108:tree.OnDeactivate (caused double-click problem)
#@+node:ekr.20040803072955.110:tree.OnPopup & allies
def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@nonl
#@+node:ekr.20040803072955.111:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()
#@nonl
#@-node:ekr.20040803072955.111:OnPopupFocusLost
#@+node:ekr.20040803072955.112:createPopupMenu
def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    << Create the menu table >>
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
#@nonl
#@+node:ekr.20040803072955.113:<< Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
#@nonl
#@-node:ekr.20040803072955.113:<< Create the menu table >>
#@-node:ekr.20040803072955.112:createPopupMenu
#@+node:ekr.20040803072955.114:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())
#@nonl
#@+node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True
#@nonl
#@-node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20040803072955.114:enablePopupMenuItems
#@+node:ekr.20040803072955.116:showPopupMenu
def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("<FocusOut>",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.frame.widgetWantsFocus(menu)
#@nonl
#@-node:ekr.20040803072955.116:showPopupMenu
#@-node:ekr.20040803072955.110:tree.OnPopup & allies
#@-node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.128:tree.select
@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
#@nonl
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@-node:ekr.20051105090649:Event handlers
#@+node:ekr.20051022152427:Focus
#@clone 2
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        # Do an update to force the focus to the body pane.
        self.c.frame.body.bodyCtrl.update()
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
# New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '<no name>'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20051022152427:Focus
#@+node:ekr.20051104100739:Idle Time
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        # Do an update to force the focus to the body pane.
        self.c.frame.body.bodyCtrl.update()
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
# New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '<no name>'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@+node:ekr.20051025150224:onIdleTime
def onIdleTime (self):
    
    '''Set the focus to the body pane if the focus is in limbo.
    
    We must allow dialogs and the outer window frame to retain focus.'''
    
    k = self ; c = k.c
    if g.app.quitting: return # Essential.
    
    w = g.app.gui.get_focus(c.frame)
    if w:
        # Allow clicks in enclosing window frame or in dialogs.
        name = hasattr(w,'_name') and w._name or ''
        ok = (
            name and name[0] in string.letters # A known Leo frame.
            or w == c.frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
            # or isinstance(w,Tk.Button)
        )
        if not ok:
            # Not a name created by Leo.
             g.trace(self.idleCount,name,w)
             c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20051025150224:onIdleTime
#@-node:ekr.20051104100739:Idle Time
#@+node:ekr.20051104100657:keyHandler
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
            c.setFocusHelper()
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        # forceFocus = func.__name__ != 'leoCallback'
        # if forceFocus: c.frame.bodyWantsFocus()
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        c.setFocusHelper()
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        c.setFocusHelper()
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@-node:ekr.20051104100657:keyHandler
#@+node:ekr.20051105073439.1:Traces
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    c.setFocusHelper()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20051105100804:keyHandler
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
            c.setFocusHelper()
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        # forceFocus = func.__name__ != 'leoCallback'
        # if forceFocus: c.frame.bodyWantsFocus()
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        c.setFocusHelper()
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        c.setFocusHelper()
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@-node:ekr.20051105100804:keyHandler
#@+node:ekr.20051105100804.1:Tree
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now()
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):
    
    '''Handle a click anywhere in the Leo window.'''
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c
    # g.trace(g.callers(5))

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
        c.setFocusHelper() # Try to guess the best possible focus.
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")
#@nonl
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@-node:ekr.20051105100804.1:Tree
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
# New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '<no name>'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20051105073439.1:Traces
#@-node:ekr.20051103114520.2:(The New World Order)
#@+node:ekr.20051109040029:(The Newer World Order)
@

- begin/endUpdate did, in fact, suppress redraws.

- Eliminated multiple redraws with special-case code.
#@nonl
#@+node:ekr.20051107102734:About the Newer World Order
@nocolor

A Newer World Order?

The New World Order is that redrawing typically happens at the end of event handlers as the result of earlier requests for redraws.  (It can also happen as the result of calls to c.redraw_now.) Today I realized that a further simplification is possible: there is now nothing to prevent commands from doing the redraw immediately.

If I am not mistaken this is in line with LeoUser's earlier comment to the same effect re how jyLeo does redraws.

Advantages:

- It's always clear where redraws happen.

- There is no need for specific redraw points in the event managers.  In particular, this simplifies script buttons: they can't call c.redraw_now because the redraw for the open command must be a redraw for the *new* commander.

Disadvantages:

- Commands should ensure that exactly one redraw happens.  This doesn't happen automatically anymore.  OTOH, this is not likely ever to be a big problem (or even a small problem, for that matter).

So the entire queuing apparatus would disappear.  One further simplification: we could eliminate all calls to xWantsFocus calls by adding a focus arg in c.redraw_now.  A value of None would trigger the logic that moves focus out of limbo.
#@nonl
#@-node:ekr.20051107102734:About the Newer World Order
#@+node:ekr.20051109094502:Detecting multiple redraw
# This isn't so easy to initialize, so it's probably more work that is useful.
n1 = c.startRedrawCount ; n2 = c.frame.tree.redrawCount
if n2 > n1 + 1:
    g.trace('Warning: multiple redraws %d %d' % (n2,n1))
    c.startRedrawCount = c.frame.tree.redrawCount # Suppress further warnings.
#@nonl
#@-node:ekr.20051109094502:Detecting multiple redraw
#@+node:ekr.20051106103835:Drawing
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    c.setFocusHelper()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now()
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@-node:ekr.20051106103835:Drawing
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
            c.setFocusHelper()
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        # forceFocus = func.__name__ != 'leoCallback'
        # if forceFocus: c.frame.bodyWantsFocus()
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        c.setFocusHelper()
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        c.setFocusHelper()
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20051109090037:Special cases
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    c.beginUpdate()
    try:
	    copiedBunchList = []
	    if pasteAsClone:
	        << put only needed info in copiedBunchList >>
	    undoData = u.beforeInsertNode(current,
	    pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
	    c.endEditing()
	    c.validateOutline()
	    c.selectPosition(pasted)
	    pasted.setDirty()
	    c.setChanged(True)
	    # paste as first child if back is expanded.
	    back = pasted.back()
	    if back and back.isExpanded():
	        pasted.moveToNthChildOf(back,0)
	    u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
#@nonl
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@nonl
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@nonl
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1557:finishPaste
def finishPaste(self,reassignIndices=True):
    
    """Finish pasting an outline from the clipboard.
    
    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        << reassign tnode indices >>
    c.selectPosition(current)
    return current
#@nonl
#@+node:ekr.20031218072017.1558:<< reassign tnode indices >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        self.maxTnodeIndex += 1
        t.setFileIndex(self.maxTnodeIndex)
#@nonl
#@-node:ekr.20031218072017.1558:<< reassign tnode indices >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303163330:p.setDirty
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@-node:ekr.20051109090037:Special cases
#@-node:ekr.20051109040029:(The Newer World Order)
#@+node:ekr.20051125110301:(Refactored key handling)
#@+node:ekr.20051122133732: Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3436900
By: nobody

>'Undo delete char'
another can of worms.
select a char, hit del key.
same with shift del
it deletes, but no undo.
^X puts Undo Cut as the event.
Edit->delete puts undo delete
I said undo delete char to make it clearer.

I realize the granularity and exact method
some of which don't generate an undo event
all interact to make things hard to reproduce.
I have the default granularity as delivered.

too much flexibility is sometimes a curse.
redo delete should not still be available
after you click on it.
it seems then to be rewinding past the last event.
I didn't verify ^Z acts correctly in all cases.

e
#@nonl
#@-node:ekr.20051122133732: Report
#@+node:ekr.20051023182326:copyBindingsToWidget & textBindingsRedirectionCallback
def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('<Key>',k.onTextWidgetKey)
#@nonl
#@-node:ekr.20051023182326:copyBindingsToWidget & textBindingsRedirectionCallback
#@+node:ekr.20051001051355:Dispatching...
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
            c.setFocusHelper()
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        # forceFocus = func.__name__ != 'leoCallback'
        # if forceFocus: c.frame.bodyWantsFocus()
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        c.setFocusHelper()
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        c.setFocusHelper()
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'

#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@+node:ekr.20050920085536.58:quickCommand  (ctrl-c) & helpers
def quickCommand (self,event):
    
    '''Handle 'quick-command' (control-c) mode.'''
    
    k = self ; stroke = k.stroke ; state = k.getState('quick-command')
    
    if state == 0:
        k.setState('quick-command',1,handler=k.quickCommand)
        k.setLabelBlue('quick command: ',protect=True)
    else:
        k.previous.insert(0,event.keysym)
        if len(k.previous) > 10: k.previous.pop()
        
        # g.trace('stroke',stroke,event.keysym)
        if stroke == '<Key>' and event.keysym == 'r':
            k.rCommand(event)
        elif stroke in ('<Key>','<Escape>'):
            if k.processKey(event): # Weird command-specific stuff.
                k.clearState()
        elif stroke in k.xcommands:
            k.clearState()
            k.xcommands [stroke](event)

        k.endCommand(event,stroke)
        
    return 'break'
#@nonl
#@+node:ekr.20051004102314:rCommand
def rCommand (self,event):
    
    k = self ; state = k.getState('r-command') ; ch = event.keysym
    if state == 0:
        k.setLabel ('quick-command r: ',protect=True)
        k.setState('r-command',1,k.rCommand)
    elif ch in ('Control_L','Alt_L','Shift_L'):
        return
    else:
        k.clearState()
        
        # g.trace(repr(ch))
        func = k.rCommandDict.get(ch)
        if func:
            k.commandName = 'quick-command r: '
            k.resetLabel()
            func(event)
        else:
            k.setLabelGrey('Unknown r command: %s' % repr(ch))
#@nonl
#@-node:ekr.20051004102314:rCommand
#@+node:ekr.20050923183943.4:processKey
def processKey (self,event):
    
    '''Handle special keys in quickCommand mode.
    Return True if we should exit quickCommand mode.'''

    k = self ; c = k.c ; previous = k.previous
    
    if event.keysym in ('Shift_L','Shift_R'): return False
    # g.trace(event.keysym)

    func = k.variety_commands.get(event.keysym)
    if func:
        k.keyboardQuit(event)
        func(event)
        return True

    if event.keysym in ('a','i','e'):
        if k.processAbbreviation(event):
            return False # 'a e' or 'a i e' typed.
        
    if event.keysym == 'g': # Execute the abbreviation in the minibuffer.
        s = k.getLabel(ignorePrompt=True)
        if k.abbreviationFuncDict.has_key(s):
            k.clearState()
            k.keyboardQuit(event)
            k.abbreviationFuncDict [s](event)
            return True
    
    if event.keysym == 'e': # Execute the last macro.
        k.keyboardQuit(event)
        c.macroCommands.callLastKeyboardMacro(event)
        return True

    if event.keysym == 'x' and previous [1] not in ('Control_L','Control_R'):
        event.keysym = 's'
        k.setState('quick-command',1)
        c.registerCommands.setNextRegister(event)
        return True

    if event.keysym == 'Escape' and len(previous) > 1 and previous [1] == 'Escape':
        k.repeatComplexCommand(event)
        return True
        
    else:
        return False
#@nonl
#@+node:ekr.20050923183943.6:processAbbreviation
def processAbbreviation (self,event):
    
    '''Handle a e or a i e.
    Return True when the 'e' has been seen.'''
    
    k = self ; char = event.char

    if k.getLabel() != 'a' and event.keysym == 'a':
        k.setLabel('a')
        return False

    elif k.getLabel() == 'a':

        if char == 'i':
            k.setLabel('a i')
            return False
        elif char == 'e':
            event.char = ''
            k.expandAbbrev(event)
            return True
            
    return False
#@nonl
#@-node:ekr.20050923183943.6:processAbbreviation
#@-node:ekr.20050923183943.4:processKey
#@-node:ekr.20050920085536.58:quickCommand  (ctrl-c) & helpers
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@-node:ekr.20051001051355:Dispatching...
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; body = c.frame.body
    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0:
            << print mismatch trace >>
        p.setBodyStringOrPane(result)
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
  
    if name.startswith('body'):
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        if i != j:
            w.delete(i,j)
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        c.frame.body.onBodyChanged(undoType='Typing',
            oldSel=oldSel,oldText=oldText,oldYview=None)
    else:
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
#@+node:ekr.20050920084036.87:deleteNextChar (ok)
def deleteNextChar (self,event):

    c = self.c ; w = event.widget

    g.trace(g.app.gui.widget_name(w))
    
    self.beginCommand('delete-char')
    
    i,j = g.app.gui.getTextSelection(w)

    if i != j:
        w.delete(i,j)
    else:
        w.delete(i)
        
    self.endCommand()
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar (ok)
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)
#@nonl
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20050920084036.138:insertNewLine (not undoable)
def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (not undoable)
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)
#@nonl
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
#@nonl
#@-node:ekr.20050920084036.139:insertParentheses
#@-node:ekr.20050920084036.85:insert & delete...
#@-node:ekr.20051125110301:(Refactored key handling)
#@+node:ekr.20051110104922:(Completed transition to Newer World Order)
#@+node:ekr.20051110145620:What I did
@nocolor

- Changed c.redraw to c.redraw_now.
- Changed c.force_redraw to c.redraw_now
- Changed c.redrawAfterException to c.redraw_now.
- Remove requestRedrawFlag
- Changed c.updateScreen to c.redraw_now or removed the call entirely.

To do

- remove draw_icon?
- remove Redraw = repaint = Repaint
#@nonl
#@-node:ekr.20051110145620:What I did
#@+node:ekr.20051110104922.1:Notes
@nocolor

This will complete the transition to the Newer World Order.

There are very few calls to c.reqestRedraw. Eliminate them, make tests, and the rest is just removing the no-longer-used code.

**Important**: tree.redraw also calls requestRedraw, so we must investigate those calls too.

**Note**: c.redraw = c.Redraw = c.repaint = c.Repaint are all presently equivalent to c.requestRedraw.
#@nonl
#@-node:ekr.20051110104922.1:Notes
#@+node:ekr.20051106103835:Drawing
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    c.setFocusHelper()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
#@nonl
#@-node:ekr.20051001050607:endCommand
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now()
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@-node:ekr.20051106103835:Drawing
#@+node:ekr.20051110104922.2:Calls to c.requestRedraw
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self):

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead')
        return
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
	    if u.redoHelper:
	        u.redoHelper()
	    else:
	        g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
	    c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
	    # So we always request a redraw.
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@nonl
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)
            
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.hoist()
    
def redoDehoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.dehoist()
#@nonl
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self ; c = u.c ; count = 0
    u.groupCount += 1
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1) # sets ivars, including u.p.
        if not d:
            s = "Undo stack overrun for %s" % u.undoType
            g.es_trace(s, color="red")
            break
        elif u.kind == 'afterGroup':
            break
        elif u.redoHelper:
            count += 1
            u.redoHelper()
        else:
            s = "No group redo helper for %s" % u.undoType
            g.es_trace(s,color="red")
    u.groupCount -= 1
    
    if u.dirtyVnodeList: # May be None instead of [].
        for v in u.dirtyVnodeList:
            v.t.setDirty()

    if u.reportFlag:
        g.es("redo %d instances" % count)
        
    c.selectPosition(u.p)
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@nonl
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20050526125801:redoMark
def redoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)
        
    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
#@nonl
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self):

    """Undo the operation described by the undo parmaters."""
    
    u = self ; c = u.c
    # g.trace(g.callers(7))

    c.endEditing() # Capture the headline *before* checking for undo.
    
    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead')
        return # Sets ivars.
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)

    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
	    if u.undoHelper:
	        u.undoHelper()
	    else:
	        g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
	    c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
	    # So we always request a redraw.
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()

    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
	c.deleteOutline()
	c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self ; c = u.c ; count = 0
    reportFlag = u.reportFlag
    u.groupCount += 1

    while 1:
        u.bead -= 1
        d = u.getBead(u.bead) # sets ivars, including u.p.
        if not d:
            s = "Undo stack underrun for %s" % u.undoType
            g.es_trace(s,color="red")
            break
        elif u.kind == 'beforeGroup':
            break
        elif u.undoHelper:
            count += 1
            u.undoHelper()
        else:
            s = "No group undo helper for %s" % u.undoType
            g.es_trace(s, color="red")
           
    if u.dirtyVnodeList: # May be None instead of [].
        for v in u.dirtyVnodeList:
            v.t.clearDirty()

    u.groupCount -= 1
    if reportFlag:
        g.es("undo %d instances" % count)

    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
    
def undoDehoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@nonl
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@nonl
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
#@nonl
#@-node:ekr.20050318085713.2:undoTree
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):
    
    '''Replace p and its subtree using old_data during undo.'''
    
    # Same as undoReplace except uses g.Bunch.

    u = self
    
    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    p.setBodyStringOrPane(p.bodyString())
    
    return p # Nothing really changes.
#@nonl
#@-node:ekr.20050408100042:undoRedoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; body = c.frame.body
    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0:
            << print mismatch trace >>
        p.setBodyStringOrPane(result)
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20031218072017.2039:undo & helpers...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20051110104922.2:Calls to c.requestRedraw
#@+node:ekr.20051110104922.3:Calls to c/tree.redraw
Changed all the following methods
#@nonl
#@+node:ekr.20031218072017.3030:readOutlineOnly
def readOutlineOnly (self,theFile,fileName):

    c = self.c
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    c.beginUpdate()
    try:
        ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=False)
    finally:
        c.endUpdate()
    c.frame.deiconify()
    vflag,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)
    if 0: # 1/30/04: this is useless.
        # This should be done after the pane size has been set.
        if self.topPosition:
            c.frame.tree.setTopPosition(self.topPosition)
            c.redraw_now()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.3030:readOutlineOnly
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
	        p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    c.beginUpdate()
    try:
	    while v and v != last:
	        v.expand()
	        v = v.threadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()
    
    c.beginUpdate()
    try:
	    c.atFileCommands.readAll(p,partialFlag=True)
    finally:
        c.endUpdate()
    
    # Force an update of the body pane.
    p.setBodyStringOrPane(p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@nonl
#@-node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20041221122440.1:togglePmwSplitDirection
@ Alas, there seems to be is no way to
a) change the orientation of a Pmw.PanedWidget, or
b) change the parent of a widget.
Therefore, we must recreate all widgets to toggle the orientation!
@c

def togglePmwSplitDirection (self,verticalFlag):
    
    __pychecker__ = '--no-argsused' # verticalFlag not used.
    
    frame = self ; c = self.c ; p = c.currentPosition()
    
    for name in ('splitter1','splitter2'):
        splitter = self.component(name).getObject()
        splitter.pack_forget()

    # Remember the contents of the log, including most tags.
    d = self.log.saveAllState()

    # Recreate everything: similar to code in finishCreate.
    self.createLeoSplitters(self.outerFrame)
    frame.canvas = self.createCanvas(self.split2Pane1) # Also packs canvas
    frame.tree  = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
    frame.log   = leoTkinterLog(frame,self.split2Pane2)
    frame.body  = leoTkinterBody(frame,self.split1Pane2)
    
    # A kludge: reset this "official" ivar.
    frame.bodyCtrl = frame.body.bodyCtrl

    # Configure: similar to code in finishCreate.
    frame.setTabWidth(c.tab_width)
    frame.tree.setColorFromConfig()
    self.reconfigurePanes()
    self.body.setFontFromConfig()
    self.body.setColorFromConfig()

    # Restore everything.
    g.app.setLog(self.log)
    frame.log.restoreAllState(d)
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20041221122440.1:togglePmwSplitDirection
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""
    
    p = self ; c = p.c
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
	            c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.beginUpdate()
        try:
            c.fileCommands.save(c.fileName())
        finally:
            c.endUpdate()
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; tree = frame.tree
    p = c.currentPosition() ; w = p.edit_widget()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return
        
    # g.trace(p == tree.editPosition(),repr(tree.revertHeadline))
        
    if w and p == tree.editPosition():
        # Revert the headline text.
        w.delete("1.0","end")
        w.insert("end",tree.revertHeadline)
        p.initHeadString(tree.revertHeadline)
        c.beginUpdate()
        try:
	        c.endEditing()
	        c.selectPosition(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@+node:ekr.20031218072017.2246:reconfigureFromConfig
def reconfigureFromConfig (self):
    
    frame = self ; c = frame.c
    
    frame.tree.setFontFromConfig()
    frame.tree.setColorFromConfig()
    
    frame.configureBarsFromConfig()
    
    frame.body.setFontFromConfig()
    frame.body.setColorFromConfigt()
    
    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@nonl
#@-node:ekr.20031218072017.2246:reconfigureFromConfig
#@+node:ekr.20041225063637.66:updateConfig (settingsController)
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw_now()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig (settingsController)
#@-node:ekr.20051110104922.3:Calls to c/tree.redraw
#@-node:ekr.20051110104922:(Completed transition to Newer World Order)
#@+node:ekr.20051111065016:(Moving focus out of limbo)
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
            c.setFocusHelper()
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        # forceFocus = func.__name__ != 'leoCallback'
        # if forceFocus: c.frame.bodyWantsFocus()
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        c.setFocusHelper()
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        c.setFocusHelper()
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20051022152427:Focus
#@clone 2
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        # Do an update to force the focus to the body pane.
        self.c.frame.body.bodyCtrl.update()
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
# New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '<no name>'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20051022152427:Focus
#@+node:ekr.20051113080509:Find methods
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        c.frame.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20051113080509:Find methods
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others
#@nonl
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@nonl
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@nonl
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@nonl
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@nonl
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@nonl
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@nonl
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@nonl
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    << bind a tab-specific pop-up menu to the tab >>
    << Create the tab's text widget >>
    self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('<Button-1>',tabMenuClickCallback)
tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("<Button-1>",self.onActivateLog)
textWidget.tag_config('black',foreground='black')
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        return

    if tabName in ('Find','Spell'):
        self.selectTab('Log')
        return
    
    if tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):
    
    return self.tabName
#@nonl
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    
def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            self.c.frame.widgetWantsFocus(logCtrl)
#@nonl
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@-node:ekr.20051111065016:(Moving focus out of limbo)
#@+node:ekr.20051110111821:Moved all scripts into scripts.leo
#@-node:ekr.20051110111821:Moved all scripts into scripts.leo
#@+node:ekr.20051112081213:Changed scripting plugin so files opened with buttons stay in front
@nocolor

The plugin can not call bodyWantsFocus.
#@nonl
#@-node:ekr.20051112081213:Changed scripting plugin so files opened with buttons stay in front
#@+node:ekr.20051113080509.1:Removed later arg from c.frame.xWantsFocus
@nocolor

Later may never come in the Newer World Order, so everything must happen immediately.
#@nonl
#@-node:ekr.20051113080509.1:Removed later arg from c.frame.xWantsFocus
#@+node:ekr.20051113082305:Replace log with text widget when getting tab name
@nocolor

This ensures that the widget is always visible.
#@nonl
#@-node:ekr.20051113082305:Replace log with text widget when getting tab name
#@+node:ekr.20051113090322.1:(Improved spell tab)
#@+node:ekr.20051025071455.22:createSpellTab
def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    << Create the outer frames >>
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("<Double-Button-1>",self.onChangeThenFindButton)
    self.listBox.bind("<Button-1>",self.onSelectListBox)
    self.listBox.bind("<Map>",self.onMap)
#@nonl
#@+node:ekr.20051113090322:<< Create the outer frames >>
self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
#@nonl
#@-node:ekr.20051113090322:<< Create the outer frames >>
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@nonl
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@nonl
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20051025071455.22:createSpellTab
#@-node:ekr.20051113090322.1:(Improved spell tab)
#@+node:ekr.20051113061206:(Added Clone-find)
#@+node:ekr.20051022152427:Focus
#@clone 2
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        # Do an update to force the focus to the body pane.
        self.c.frame.body.bodyCtrl.update()
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
# New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '<no name>'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20051022152427:Focus
#@+node:ekr.20051113061206.1:Patch
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3425070
By: rogererens

These changes will have the effect that every time you press the "Find All"
button in the Find tab, a new root node called Found: <your search pattern>
is created holding clones of the nodes that contain the search pattern.
It is your own responsibility to navigate to this Found: node and cleaning it
up when it's no longer needed.
#@nonl
#@-node:ekr.20051113061206.1:Patch
#@+node:ekr.20031218072017.1762:c.clone
def clone (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; t = self.s_ctrl ; u = c.undoer
    gui = g.app.gui ; undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if not pos: break
        count += 1
        line = gui.getLineContainingIndex(t,pos)
        self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            if not clones:
                << create the found node and begin the undo group >>
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setChanged(True)
        u.afterChangeGroup(c.currentPosition(),undoType,reportFlag=True)   
    c.redraw()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@nonl
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)
undoData = u.beforeInsertNode(c.currentPosition())
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
found.setHeadString('Found: ' + self.find_text)
u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@nonl
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone(self.p)
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@nonl
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
	   c.endEditing() # Make sure we capture the headline for Undo.
	   undoData = u.beforeDeleteNode(p)
	   dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
	   p.doDelete()
	   c.selectPosition(newNode)
	   c.setChanged(True)
	   u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@nonl
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
	    undoData = c.undoer.beforeInsertNode(current)
	    # Make sure the new node is visible when hoisting.
	    if ((current.hasChildren() and current.isExpanded()) or
	        (c.hoistStack and current == c.hoistStack[-1].p)):
	        p = current.insertAsNthChild(0)
	    else:
	        p = current.insertAfter()
	    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
	    c.setChanged(True)
	    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
	    c.endEditing() # Bug fix: 11/28/05.
        c.editPosition(p)
    finally:
        c.endUpdate()

    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):
    
    """Select a new position."""

    c = self

    c.frame.tree.select(p,updateBeadList)

selectVnode = selectPosition
#@nonl
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20040803072955.128:tree.select
@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self):

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead')
        return
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
	    if u.redoHelper:
	        u.redoHelper()
	    else:
	        g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
	    c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
	    # So we always request a redraw.
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@nonl
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)
            
    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.hoist()
    
def redoDehoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.dehoist()
#@nonl
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self ; c = u.c ; count = 0
    u.groupCount += 1
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1) # sets ivars, including u.p.
        if not d:
            s = "Undo stack overrun for %s" % u.undoType
            g.es_trace(s, color="red")
            break
        elif u.kind == 'afterGroup':
            break
        elif u.redoHelper:
            count += 1
            u.redoHelper()
        else:
            s = "No group redo helper for %s" % u.undoType
            g.es_trace(s,color="red")
    u.groupCount -= 1
    
    if u.dirtyVnodeList: # May be None instead of [].
        for v in u.dirtyVnodeList:
            v.t.setDirty()

    if u.reportFlag:
        g.es("redo %d instances" % count)
        
    c.selectPosition(u.p)
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@nonl
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20050526125801:redoMark
def redoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)
        
    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
#@nonl
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self):

    """Undo the operation described by the undo parmaters."""
    
    u = self ; c = u.c
    # g.trace(g.callers(7))

    c.endEditing() # Capture the headline *before* checking for undo.
    
    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead')
        return # Sets ivars.
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)

    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
	    if u.undoHelper:
	        u.undoHelper()
	    else:
	        g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
	    c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
	    # So we always request a redraw.
        c.endUpdate()
        c.recolor_now()
        c.frame.bodyWantsFocus()

    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
	c.deleteOutline()
	c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self ; c = u.c ; count = 0
    reportFlag = u.reportFlag
    u.groupCount += 1

    while 1:
        u.bead -= 1
        d = u.getBead(u.bead) # sets ivars, including u.p.
        if not d:
            s = "Undo stack underrun for %s" % u.undoType
            g.es_trace(s,color="red")
            break
        elif u.kind == 'beforeGroup':
            break
        elif u.undoHelper:
            count += 1
            u.undoHelper()
        else:
            s = "No group undo helper for %s" % u.undoType
            g.es_trace(s, color="red")
           
    if u.dirtyVnodeList: # May be None instead of [].
        for v in u.dirtyVnodeList:
            v.t.clearDirty()

    u.groupCount -= 1
    if reportFlag:
        g.es("undo %d instances" % count)

    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
    
def undoDehoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@nonl
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@nonl
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
#@nonl
#@-node:ekr.20050318085713.2:undoTree
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):
    
    '''Replace p and its subtree using old_data during undo.'''
    
    # Same as undoReplace except uses g.Bunch.

    u = self
    
    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    p.setBodyStringOrPane(p.bodyString())
    
    return p # Nothing really changes.
#@nonl
#@-node:ekr.20050408100042:undoRedoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.frame.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; body = c.frame.body
    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0:
            << print mismatch trace >>
        p.setBodyStringOrPane(result)
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20051113061206:(Added Clone-find)
#@+node:ekr.20051113082305.1:(Improved find tab)
#@+node:ekr.20051020120306.13:createFrame (findTab)
def createFrame (self,parentFrame):
    
    c = self.c
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    << Create two columns of buttons >>
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)

    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.frame.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap &Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ('Clone Find All',  self.dict['clone_find_all']),
    ("Mark Finds",      self.dict["mark_finds"]),
    ("Mark &Changes",   self.dict["mark_changes"]),
    ('Show Context',    self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (findTab)
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051113082305.1:(Improved find tab)
#@+node:ekr.20051119113109:(Fixed undo/redo bugs)
#@+node:ekr.20051120114748:What I did
@nocolor

- Added calls to c.frame.body.onBodyChanged in cut/paste handlers.

- Added call to c.selectPosition(c.currentPosition()) in undo/redo.
    This is essential because previous calls to c.selectPosition may have had redraw_flag = False.
#@nonl
#@-node:ekr.20051120114748:What I did
#@+node:ekr.20051119113109.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3434727
By: nobody

Leo 4.4 alpha 3, build  1.336 , November 10, 2005
wincvs finally updated from earlier today.
paste and insert headline, maybe other things
out of synch with undo/redo.
paste, undo, no redo, undo still available.
undo another time, and another a few times 
then neither undo or redo is available.
often nothing changes in response.
these all from Edit or Outline menu.
from scripts, depending on if they use 
begin/end update or on*changed they may fail.
this can be some trouble for plugins or scripts.
order of operations seems to be more important.

insert of headline, then redo can hang Leo.
I quit python after a few minutes, it may return?
sometimes only redo is visable after an operation.
checked it twice on fresh start.

p.setHeadString('test') now works 
but doesn't generate an undo event by itself
I would swear it did in previous versions.
ok either way, if its consistant.
e
#@nonl
#@-node:ekr.20051119113109.1:Report
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20051119113109:(Fixed undo/redo bugs)
#@+node:ekr.20051120085459:(Fixed focus problem with tab completion)
@nocolor

What I did:
    
- set k.completionFocusWidget at start of k. fullCommand.
- set focus to k.completionFocusWidget in k.fullCommand when <return> seen.

@color
#@nonl
#@-node:ekr.20051120085459:(Fixed focus problem with tab completion)
#@+node:ekr.20051119100154:Fixed minor Save bug
#@+node:ekr.20051119100154.1:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3425967
By: yarkot

When creating a new Leo outline (no leo file created yet), the following menu
operation:

File > Save As

With file name given "Test4.3"  (expecting automatic extension of ".leo")  results
in the following file created:

Test4.leo
#@nonl
#@-node:ekr.20051119100154.1:Report
#@+node:ekr.20031218072017.3118:ensure_extension
def ensure_extension (name, ext):

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name # don't add to an empty name.
    elif old_ext and old_ext == ext:
        return name
    else:
        return name + ext
#@nonl
#@-node:ekr.20031218072017.3118:ensure_extension
#@-node:ekr.20051119100154:Fixed minor Save bug
#@+node:ekr.20051121090533:Inserted tcl trace code in f.finishCreate
import Pmw
def tracewidget(event):
....Pmw.tracetk(event.widget, 1)

def untracewidget(event):
....Pmw.tracetk(event.widget,0)

# c.frame.bar1 arbitrarily chosen--just needed
# an object with bind_all method
c.frame.bar1.bind_all("<Control-1>", tracewidget)
c.frame.bar1.bind_all("<Control-Shift-1>", untracewidget)
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("<Activate>",f.OnActivateLeoEvent)
    f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label
#@nonl
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@-node:ekr.20051121090533:Inserted tcl trace code in f.finishCreate
#@+node:ekr.20051121103830:Fixed bugs in rst3
#@+node:ekr.20051121103830.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3427809

My Firefox V1.7 don't respond to my css-File when finding an absolute Path in
href like:

<link rel="stylesheet" href="c:\mydir\LeoRstDoku\default.css" type="text/css"
/>

I don't know why, IE works right.
With a relative href-path my stylesheet works as expected. 

But with existing rst3-plugin-code it is not possible to produce a 
relative href-path like:
<link rel="stylesheet" href="..\LeoRstDoku\default.css" type="text/css" />

because writeToDocutils-node  always using g.os_path_abspath ( bla ).


My Workaround is
path = g.os_path_join(stylesheet_path,self.getOption('stylesheet_name'))
  

May be I'm wrong, but I see a discrpance between using "g.os_path_abspath"
and the comment 
  # Make the stylesheet path relative to the directory containing the output
file.


Hope for clarification - Thank you
Manfred
#@nonl
#@-node:ekr.20051121103830.1:Report
#@+node:ekr.20051121103830.2:Report2
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3433717
By: ktenney

The rst3 doc mentions the default_path option;
http://webpages.charter.net/edreamleo/rstplugin3.html#options
The path to be prepended to filenames given in root nodes.

The rst3 plugin currently in CVS doesn't offer that option.

I also seem to remember (maybe I imagined it)
that selecting 'Write Restructured Text'
while the focus was on the child of a 
@rst3 <filename> node
would traverse up the tree and find the @rst3 ... node

Current CVS says No "@rst nodes in selected tree"
if focus is on a child.

Thanks,
Kent



#@-node:ekr.20051121103830.2:Report2
#@-node:ekr.20051121103830:Fixed bugs in rst3
#@+node:ekr.20051122084756:(Eliminated w.update in g.app.gui.set_focus)
#@+node:ekr.20051122094909:Notes
@nocolor

- The focusIn/Out trace is a great tool.

- I'm going to eliminate w.update from g.app.gui.set_focus and just call it in
those places where it is truly essential, such as in k.doTabCompletion and
wherever else it might be required. This is a reasonable compromise, IMO.

- Temporary bindings to focusIn are not good engineering, IMO. The assumption
that we know when the corresponding focusOut event will happen is false. In
effect, we are creating a hidden state. Things are complex enough already :-)

- Pmw.Notebook does a *lot* when it switches panes (e.g., the _layout method)
and potentially any of the things it does could result in focus shifting to
widget. Rather than trying to make sense of it all, Leo will simply call
w.update as necessary to force completion of the Pmw.Notebook work before trying
to set focus.

- Eliminated call to selectTab. This never should have been needed, and does not
seem needed now.
#@nonl
#@-node:ekr.20051122094909:Notes
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others
#@nonl
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@nonl
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@nonl
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@nonl
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@nonl
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@nonl
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@nonl
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl
#@nonl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@nonl
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')
#@nonl
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    << bind a tab-specific pop-up menu to the tab >>
    << Create the tab's text widget >>
    self.setTabBindings(tabName)
#@nonl
#@+node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('<Button-1>',tabMenuClickCallback)
tab.bind('<Button-3>',tabMenuRightClickCallback)
#@nonl
#@-node:ekr.20051020075416:<< bind a tab-specific pop-up menu to the tab >>
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("<Button-1>",self.onActivateLog)
textWidget.tag_config('black',foreground='black')
#@nonl
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName):
    
    if tabName == 'Log':
        return

    if tabName in ('Find','Spell'):
        self.selectTab('Log')
        return
    
    if tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
#@nonl
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):
    
    return self.tabName
#@nonl
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    
def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            self.c.frame.widgetWantsFocus(logCtrl)
#@nonl
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@nonl
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    return tabFrame
#@nonl
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)
#@nonl
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)
#@nonl
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)
#@nonl
#@-node:ekr.20051019140004.1:newTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@nonl
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('<Return>',getNameCallback)
#@nonl
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("<Activate>",f.OnActivateLeoEvent)
    f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label
#@nonl
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20050920085536.44:doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        k.computeCompletionList(defaultTabList,backspace=False)
        
    self.widget.update() # Complete all log drawing so we can change focus.
    c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.44:doTabCompletion
#@-node:ekr.20051122084756:(Eliminated w.update in g.app.gui.set_focus)
#@+node:ekr.20051122132238:Removed call to w.update in g.app.gui.set_focus
@nocolor

doTabCompletion now calls w.update before calling bodyWantsFocus.
#@nonl
#@-node:ekr.20051122132238:Removed call to w.update in g.app.gui.set_focus
#@+node:ekr.20051122104941:Improved formatting of shortcuts in print-commands and print-bindings
#@+node:ekr.20051122104219:prettyPrintKey
def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    if not key:
        return ''
        
    ch = key[-2]

    if ch in string.ascii_uppercase:
        return '%sShift-%s>' % (key[:-2],ch.lower())
    else:
        return key
#@nonl
#@-node:ekr.20051122104219:prettyPrintKey
#@-node:ekr.20051122104941:Improved formatting of shortcuts in print-commands and print-bindings
#@+node:ekr.20051123083338:Added setting for vim plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3440420
By: yarkot

I keep needing to change the vim.py plugin on my XP machine.

Vim 6.3, and now vim 6.4 installs this way.  Here's what I end up changing to
(all the time):

if sys.platform == 'win32':
    # Works on XP with vim in the folder indicated.
    _vim_cmd = r"c:\Program Files\vim\vim64\gvim --servername LEO"
    _vim_exe = r"c:\Program Files\vim\vim64\gvim"

If this is consistent w/ what other's are experiencing, could we get it updated
in CVS too?
#@nonl
#@-node:ekr.20051123083338:Added setting for vim plugin
#@+node:ekr.20051126091101:(Put up a dialog if can't import Pmw)
#@+node:ekr.20051126095038:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3436726
By: tfer

From as simple as adding, "Remember to place a copy of PMW in the Extension
Directory, (can be copied from a current distribution)" in your calls to Pls
test cvs, to a 'try' plus a dimissable dialog containing info to that effect.

Probably should also add how to get and setup TortoiseCVS to retrieve CVS copies
for those interested, took a bit of playing around with it as I remeber.

Tom
#@nonl
#@-node:ekr.20051126095038:Report
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    frame.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2610:app.createTkGui
def createTkGui (self,fileName=None):
    
    # Do NOT omit fileName param: it is used in plugin code.
    __pychecker__ = '--no-argsused'
    
    """A convenience routines for plugins to create the default Tk gui class."""
    
    import leoTkinterGui # Do this import after app module is fully imported.

    g.app.gui = leoTkinterGui.tkinterGui()
    g.app.root = g.app.gui.createRootWindow()
    
    # Show a dialog and exit immediately if Pmw can not be imported.
    g.importExtension("Pmw",pluginName="Leo's core",verbose=False,required=True)
    g.app.gui.finishCreate()
    
    if 0:
        if fileName:
            print "Tk gui created in", g.shortFileName(fileName)



#@-node:ekr.20031218072017.2610:app.createTkGui
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)
            
        if not module and required:
            << put up a dialog and exit immediately >>

    return module
#@nonl
#@+node:ekr.20051126094757:<< put up a dialog and exit immediately >>
# g.trace(moduleName,pluginName,g.callers())

import leoTkinterDialog
message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

d = leoTkinterDialog.tkinterAskOk(
    c=None,title='Can not import %s' %(moduleName),
    message=message)
d.run(modal=True)

# Exit immeditely without raising SystemExit.
try:
    import os ; os._exit(1) # May not be available on all platforms.
except Exception:
    import sys ; sys.exit(1)
#@nonl
#@-node:ekr.20051126094757:<< put up a dialog and exit immediately >>
#@-node:ekr.20041219071407:g.importExtension
#@-node:ekr.20051126091101:(Put up a dialog if can't import Pmw)
#@+node:ekr.20051121135652:Bound <Return> to end-edit-headline
#@+node:ekr.20051126095411:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3437089
By: ktenney

My hope was to associate the command 'end-edit-headline' with the keystroke
'Return' when in the tree pane.
#@nonl
#@-node:ekr.20051126095411:Request
#@-node:ekr.20051121135652:Bound <Return> to end-edit-headline
#@+node:ekr.20051127135301:(Fixed problem with Plugins Manager plugin)
@nocolor

This was not, in fact, a problem with the plugins manager plugin at all.

- Always init Pmw in Leo's core when Tk.Tk created.
  This removes the necessity for Plugins to do this.

- The bug was in << put up a dialog requiring a valid id >> in app.setLeoID.
  For unknown reasons after the call to runAskLeoIDDialog the code set g.app.gui = None (!!!)

@color
#@nonl
#@+node:ekr.20051127140029:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3442064
By: yarkot

Deleting the line in .leoID.txt (leaving an empty file) results in prompt to
enter leoID;
After this startup, going right to the plugin manager again results in this
(cvs snapshot current as of today).   Any suggestions on what else I can do
to help trace this down?  (Run / trace this in Komodo?)

Regards,
Yarko
--------------------

Leo Log Window...
Leo 4.4 alpha 3, build  1.338 , November 10, 2005
Python 2.4.2, Tk 8.4.7
Windows 5, 1, 2600, 2, Service Pack 1

empty .leoID.txt (in C:\Workspace\Leo\leo\config)
leoID = 'abc'
.leoID.txt created in C:\Workspace\Leo\leo\config
global config dir: C:\Workspace\Leo\leo\config
home dir: None
reading settings in C:\Workspace\Leo\leo\config\leoSettings.leo
7 plugins loaded
exception executing command
Traceback (most recent call last):
  File "C:\Workspace\Leo\leo\src\leoCommands.py", line 240, in doCommand
    val = command()
  File "C:\Workspace\Leo\leo\plugins\plugins_menu.py", line 548, in callback
    p.hastoplevel()
  File "C:\Workspace\Leo\leo\plugins\plugin_manager.py", line 227,
in topLevelMenu
    dlg = ManagerDialog(True)
  File "C:\Workspace\Leo\leo\plugins\plugin_manager.py", line 847, in __init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\Workspace\Leo\leo\plugins\plugin_manager.py", line 345, in __init__
    label_text = 'Name:',
  File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py", line
73, in __init__
    sequences = root.bind_class(tag)
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 958, in bind_class
    return self._bind(('bind', className), sequence, func, add, 0)
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 893, in _bind
    return self.tk.splitlist(self.tk.call(what))
TclError: bad window path name
".33481312.33579536.33579496.33579416.33579576.33599816.33599896"
#@nonl
#@-node:ekr.20051127140029:Report
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20051128101558:Always init Pmw
#@+node:ekr.20050328133058:g.createStandAloneApp
def createStandAloneApp(pluginName=''):
    
    '''Create a version of the g.app object for 'stand-alone' plugins.'''
    
    if not g.app:
        Tk  = g.importExtension('Tkinter',pluginName=pluginName,verbose=True)
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('<stand-alone app gui>')
            g.computeStandardDirectories()
    return g.app
#@nonl
#@-node:ekr.20050328133058:g.createStandAloneApp
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        # g.trace('Pmw.init')
        self.root = root = Tk.Tk()
        Pmw.initialise(self.root)

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20051128101558:Always init Pmw
#@-node:ekr.20051127135301:(Fixed problem with Plugins Manager plugin)
#@+node:ekr.20051128140833:(Fixed 2 outline editing bugs)
#@+node:ekr.20051128140833.1:1: Outline not marked dirty during editing
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3447570
By: ktenney

Current CVS, W2k

After editing headline text, the file is not 
marked as changed until focus leaves the headline.

If you only edit a headline and exit, the change
will be lost.
#@nonl
#@-node:ekr.20051128140833.1:1: Outline not marked dirty during editing
#@+node:ekr.20051128140833.2:2: Inserting a headline didn't save previous edits of headlines
#@-node:ekr.20051128140833.2:2: Inserting a headline didn't save previous edits of headlines
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
	    undoData = c.undoer.beforeInsertNode(current)
	    # Make sure the new node is visible when hoisting.
	    if ((current.hasChildren() and current.isExpanded()) or
	        (c.hoistStack and current == c.hoistStack[-1].p)):
	        p = current.insertAsNthChild(0)
	    else:
	        p = current.insertAfter()
	    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
	    c.setChanged(True)
	    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
	    c.endEditing() # Bug fix: 11/28/05.
        c.editPosition(p)
    finally:
        c.endUpdate()

    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@-node:ekr.20051128140833:(Fixed 2 outline editing bugs)
#@+node:ekr.20051129063549:Fixed crasher in deleteNextChar
#@+node:ekr.20051129063549.1:Report
@nocolor

I was writing (gag - Leo's good for this) structured poetry (not! code); 
 
I know I was in the headlines / nodes; 
I was probably doing something on arrow keys (but when in creative mode, my fingers can barely keep up w/ what my mind wants out - I can't really be aware of what I hit). 
 
This came up in a Tk window titled "Error in background function": 
------- 
 
Error: 1 
AttributeError Exception in Tk callback 
Function: <function keyCallback2 at 0x0192BF70> (type: <type 'function'>) 
Args: (<Tkinter.Event instance at 0x01A763C8>,) 
Event type: KeyPress (type num: 2) 
Traceback (innermost last): 
File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__ 
return apply(self.func, args) 
File "C:\Workspace\Leo\leo\src\leoKeys.py", line 814, in keyCallback2 
return k.masterCommand(event,func,stroke) 
File "C:\Workspace\Leo\leo\src\leoKeys.py", line 1139, in masterCommand 
val = func(event) 
File "C:\Workspace\Leo\leo\src\leoKeys.py", line 811, in menuFuncCallback 
return command(event) 
File "C:\Workspace\Leo\leo\src\leoEditCommands.py", line 2261, in deleteNextChar 
oldText = w.get('1.0','end') 
AttributeError: Canvas instance has no attribute 'get' 
 
================================================ 
Event contents: 
char:  
delta: 46 
height: ?? 
keycode: 46 
keysym: Delete 
keysym_num: 65535 
num: ?? 
serial: 80307 
state: 0 
time: 84674104 
type: 2 
widget: .16395480.26093408.26093808.26093888.26094248.26094368.canvas 
width: ?? 
x: 192 
x_root: 216 
y: 119 
y_root: 223 
--------------------- 
 
Cheers, 
 
Yarko 
#@-node:ekr.20051129063549.1:Report
#@+node:ekr.20050920084036.87:deleteNextChar (ok)
def deleteNextChar (self,event):

    c = self.c ; w = event.widget

    g.trace(g.app.gui.widget_name(w))
    
    self.beginCommand('delete-char')
    
    i,j = g.app.gui.getTextSelection(w)

    if i != j:
        w.delete(i,j)
    else:
        w.delete(i)
        
    self.endCommand()
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar (ok)
#@-node:ekr.20051129063549:Fixed crasher in deleteNextChar
#@+node:ekr.20051130075337:Fixed new headline bug
#@+node:ekr.20051130075337.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3450435
By: ktenney

1. select headline text
2. paste new headline text
3. select the headline (click on icon)

The headline text reverts to original.

EKR: step 2 not needed.
#@nonl
#@-node:ekr.20051130075337.1:Report
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@-node:ekr.20051130075337:Fixed new headline bug
#@+node:ekr.20051103093034:Fix problems applying settings
#@+node:ekr.20051103093034.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3389810
By: vpe

There is still a problem with applying in-file settings when opening outline
with a @settings from another outline.
These file specific settings are not applied when the outline is opened from
another outline for the first time. They are now applied when the file is opened
2nd time from the same outline.

The settings I tested are:
@language target_language = plain
@color body_text_background_color = pink

Leo 4.4 alpha 1, build  1.303 , October 15, 2005
Python 2.4.2, Tk 8.4.7, win32
#@nonl
#@-node:ekr.20051103093034.1:Report
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)
    
    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@nonl
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):
    
    c = self.c
    
    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            s = 'skipping settings in %s' % p.headString()
            g.es_print(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
            
    return self.settingsDict
#@nonl
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120074536:settingsRoot
def settingsRoot (self,c):
    
    # g.trace(c,c.rootPosition())

    for p in c.allNodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
#@nonl
#@-node:ekr.20041120074536:settingsRoot
#@+node:ekr.20051201111822.1:(refactored newLeoCommanderAndFrame)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = False
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        c.keyHandler.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    app = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
        
    frame.finishCreate(c)
    c.finishCreate()
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)
        
    # g.trace(c,frame)

    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@-node:ekr.20051201111822.1:(refactored newLeoCommanderAndFrame)
#@+node:ekr.20051201111822.2:Calls to newLeoCommanderAndFrame
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1623:new
def new (self):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
	    frame.setInitialWindowGeometry()
	    frame.deiconify()
	    frame.lift()
	    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
	    t = leoNodes.tnode()
	    v = leoNodes.vnode(c,t)
	    p = leoNodes.position(v,[])
	    v.initHeadString("NewHeadline")
	    v.moveToRoot()
	    c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2839:readOutlineOnly
def readOutlineOnly (self):

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        c,frame = g.app.newLeoCommanderAndFrame(fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:" + fileName)
#@nonl
#@-node:ekr.20031218072017.2839:readOutlineOnly
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.trace('Already open',fileName)
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                app.setLog(frame.log,"openWithFileName")
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            frame.bodyWantsFocus()
            c.endUpdate()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@-node:ekr.20051201111822.2:Calls to newLeoCommanderAndFrame
#@-node:ekr.20051103093034:Fix problems applying settings
#@+node:ekr.20051204093712:Fixed bugs in rst3 plugin
#@+node:ekr.20051204075330:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3456419

V1.6 report:

my options are:
@ @rst-options
default_path=C:\tmp
stylesheet_path=C:\Program Files\key\stuff\rststylesheet_name=html4css1.css
write_intermediate_file=True
generate_rst = True
@c

IF this doc part is in the body of the 
@rst test-rst.html
node, the log pane shows;
wrote: C:\Documents and Settings\ktenney\Desktop\test-rst.html.txt
wrote: C:\tmp\test-rst.html
done

IE: the default_path works for the html file,
the intermediate file goes to my desktop (?)

If the options are in a parent node of the 
@rst test-rst.html
node, the log pane shows;
stylesheet does not exist: default.css
wrote: C:\Program Files\key\stuff\test-rst.html
done

IE: the options are not getting picked up.

According to the 'Setting Defaults' section of
http://webpages.charter.net/edreamleo/rstplugin3.html
it seems they should work if put in an ancestor node.

#@-node:ekr.20051204075330:Report
#@-node:ekr.20051204093712:Fixed bugs in rst3 plugin
#@-node:ekr.20051110101524:4.4a4 projects
#@+node:ekr.20051206111317:4.4a5 projects
#@+node:ekr.20051208102436:Bugs fixed
#@+node:ekr.20051206082343:Made sure focus doesn't go to log during tab completion or after writes to log
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@-node:ekr.20051206082343:Made sure focus doesn't go to log during tab completion or after writes to log
#@+node:ekr.20051208091305:Fixed problem with getScript in batch mode
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@-node:ekr.20051208091305:Fixed problem with getScript in batch mode
#@+node:ekr.20051207180807:Select text box in goto-line-number command
#@+node:ekr.20051208102107:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3464874
By: davidmcnab

* The 'goto line number' dialog pops up without the text field active, so I'm
forced into a Compulsory Mouse Click to activate the field before I can type
in the line number (I'm one who regards unnecessary Compulsory Mouse Clicks as bugs).
#@nonl
#@-node:ekr.20051208102107:Report
#@+node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    f = self.frame
    
    lab = Tk.Label(f,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = t = Tk.Entry(f,width=20)
    t.pack(side="left")
    
    g.app.gui.set_focus(self.c,t)
#@nonl
#@-node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
#@-node:ekr.20051207180807:Select text box in goto-line-number command
#@+node:ekr.20051209081445.2:Restored headkey hooks
@

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headling, and ch is always '\r', regardless of
platform.
#@nonl
#@+node:ekr.20051209083903:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3466412
By: ktenney

>Use the read_only_nodes plugin. 

It has a great feature list, but I can't get it to
update after the file changes on the filesystem.

I then looked at at_view.py, and the @view node
plugin. (which I worked on way back when :-])

It also doesn't work.
I put a g.es(..) at the top of the icondclick2 method which is registered in
the onCreate method
of at_view.py;

leoPlugins.registerHandler("icondclick2", myView.icondclick2)

It seems that the method does not get called
when the icon is doubleclicked.

Could this behaviour be related to recent changes
in Leo?
#@-node:ekr.20051209083903:Report
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@-node:ekr.20051209081445.2:Restored headkey hooks
#@+node:ekr.20051209085227:Restored bodykey hooks
#@+node:ekr.20051209085227.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3462294
By: nobody

apparently the bodykey hooks are no longer used
is why trace_keys plugin doesn't work.
in leoKeys.py I see this trace can be turned on:
.   if c.config.getBool('trace_masterCommand'):
#@nonl
#@-node:ekr.20051209085227.1:Report
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@-node:ekr.20051209085227:Restored bodykey hooks
#@+node:ekr.20051209081445:Fixed ancient bug in read error logic that hung Leo
#@+node:ekr.20051209081445.1:Report & what I did
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3467558
By: ktenney

Current CVS, W2K

I open a small Leo file, and from File->Open, select
..\src\LeoPyRef.py. the log pane shows;

----- error reading @file: ../doc/leoToDo.txt
Ignoring @-node sentinel. Expecting @-all

At this point Leo locks up tight, must kill process.

What I did:

** atFile.readError delete's root's entire subtree.
** atFile.read only warns about unvisited node if there is no error.
#@-node:ekr.20051209081445.1:Report & what I did
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
        
    # g.trace(self.root,g.callers())
    
    self.error(message)
    
    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None
    
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)
#@nonl
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@nonl
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)
#@nonl
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)
#@nonl
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)
#@nonl
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@nonl
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20051209081445:Fixed ancient bug in read error logic that hung Leo
#@+node:ekr.20051213060647.1:Fixed minor headline problems
#@+node:ekr.20051206082304.1:Report
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3461068
By: vpe

1) Strange behaviour after pasting in headlines:
Start editing a headline in outline pane. Let's say it's 'Settings and
buttons'.
Select all text and copy (ctrl+c).
Place cursor at the end and paste (ctrl+v). What I see is 'Settings and
buttonsSetti'. That is text area does not expand to accomodate new text length.
And I cannot move beyond that point.
If I move to another headline I see that pasting was done correctly. 

2) (done) I always make these changes without any problems:
Code-->Gui Tkinter classes-->@thin leoTkinterTree.py-->Config
& Measuring...-->headWidth & widthInPixels
return max(self.minimum_headline_width,5 + len(s))  ##change to 1

Code-->Gui Tkinter classes-->@thin leoTkinterTree.py--> Birth...
(tkTree)-->__init__--><< define drawing constants >>
self.minimum_headline_width = 20 # In characters. ##change to 2


Leo 4.4 alpha 4, build  1.346 , December 5, 2005
Python 2.4.2, Tk 8.4.7, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4    <--- nice!
#@-node:ekr.20051206082304.1:Report
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20051213060647.1:Fixed minor headline problems
#@+node:ekr.20051216114320:Fixed problem in reformatParagraph
@nocolor

The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.
#@nonl
#@-node:ekr.20051216114320:Fixed problem in reformatParagraph
#@+node:ekr.20051217091236:Investigated secondary ratio problems
#@+node:ekr.20051217112605:Notes
@nocolor

I've just investigated how Leo handles pane settings, and I believe all is
working as intended. This is somewhat confusing, but there has been no change in
this code for a long time: it has nothing whatever to do with the 4.4 code
base.

The so-called 'primary' ratio is the ratio between the body pane and the pane
containing the other two panes. The so-called secondary ratio is the ratio
between sizes of the log pane and the outline pane.

The thing to keep in mind is that Leo saves *only* the primary ratio in .leo
files. Leo does not save the so-called 'secondary' ratio in .leo files, because
doing so would change Leo's file format.

Because Leo **does** save the primary ratio in .leo files, Leo will open a file
with the same primary ratio that you had when you last saved the file.

Because Leo does **not** save the secondary ratio in the .leo file Leo
determines the relative sizes of the log and outline panes from settings in
leoSettings.leo. One of the two settings is used:

- initial_horizontal_secondary_ratio or

- initial_vertical_secondary_ratio

Which one is used depends on the initial_splitter_orientation setting.

**Important** If you change these settings you must restart Leo for them to take effect.

I have been able to set the secondary ratio as I please from leoSettings.leo,
and have observed that Leo properly saves and restores the primary ratio in .leo
files.

In short, everything works as it should.
#@nonl
#@-node:ekr.20051217112605:Notes
#@+node:ekr.20031218072017.3689:initialRatios
def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@nonl
#@-node:ekr.20031218072017.3689:initialRatios
#@-node:ekr.20051217091236:Investigated secondary ratio problems
#@+node:ekr.20051216170531:Installed LeoUsers patch for the Read @file Nodes command
# From Brian re Read @file nodes w/o creating copy of root node
#@nonl
#@+node:ekr.20051218102312:What I did
@nocolor

- self._forcedGnxPositionList = [] in ctor.

- 
#@nonl
#@-node:ekr.20051218102312:What I did
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.
    
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    << define the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@nonl
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@nonl
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20051218100605.1:atFile.__init__ and initIvars NEW
def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    leoBaseAtFile.__init__( self )
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self._forcedGnxPositionList = [] #This has to be here, puttin it in initReadIvars renders it useless

    c.checksums = {}
    self.md5 = None
    @others
#@nonl
#@+node:ekr.20051218100605.2: define the dispatch dictionary used by scanText4
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@nonl
#@-node:ekr.20051218100605.2: define the dispatch dictionary used by scanText4
#@-node:ekr.20051218100605.1:atFile.__init__ and initIvars NEW
#@+node:ekr.20051218100605.3:createThinChild4 NEW
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
        
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@nonl
#@-node:ekr.20051218100605.3:createThinChild4 NEW
#@-node:ekr.20051216170531:Installed LeoUsers patch for the Read @file Nodes command
#@+node:ekr.20051219090231:Fixed bug: clicking in the expand/contract box didn't save the headline
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@-node:ekr.20051219090231:Fixed bug: clicking in the expand/contract box didn't save the headline
#@-node:ekr.20051208102436:Bugs fixed
#@+node:ekr.20051208102436.1:New features
#@+node:ekr.20051208091816:created ut.leo, ut.py and ut.bat
#@-node:ekr.20051208091816:created ut.leo, ut.py and ut.bat
#@+node:ekr.20051207120838.1:Added modes/*.xml to distribution
#@-node:ekr.20051207120838.1:Added modes/*.xml to distribution
#@+node:ekr.20051216110817:Added 'insert' keyword to setTextSelection methods
@
The change was logical, but it caused problems.

The new 'insert' keyword arg must have the value 'sel.end' for compatibility with old code.
#@nonl
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, ">", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20051216110817:Added 'insert' keyword to setTextSelection methods
#@+node:ekr.20051217135340:(Revised cursor movement commands and added selection-extension commands)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=True)
        spot = w.index(spot) # Capture initial value.
        ins = w.index('insert')
        w.mark_set('insert',spot)
        if extend or self.extendMode:
            if w.compare(spot,'<=',i):
                g.app.gui.setTextSelection (w,spot,j,insert=None)
            else:
                g.app.gui.setTextSelection (w,i,spot,insert=None)
        w.see(spot)
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        if forward:
             ind = w.search('\w','insert',stopindex='end',regexp=True)
             if ind: nind = '%s wordend' % ind
             else:   nind = 'end'
        else:
             ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
             if ind: nind = '%s wordstart' % ind
             else:   nind = '1.0'
        self.moveToHelper(event,nind,extend)
    except Exception:
        pass # w might not be a text widget.
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('(','insert',backwards=True,stopindex='1.0')
        if '' == i: return
    
        icheck = w.search(')','insert',backwards=True,stopindex='1.0')
        if icheck:
            ic = w.compare(i,'<',icheck)
            if ic: return
    
        i2 = w.search(')','insert',stopindex='end')
        if '' == i2: return
    
        i2check = w.search('(','insert',stopindex='end')
        if i2check:
            ic2 = w.compare(i2,'>',i2check)
            if ic2: return
        
        ins = '%s+1c' % i2
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if i:
            i2 = w.search('.',i,backwards=True,stopindex='1.0')
            if i2:
                ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
            else:
                ins = '1.0'
        else:
            ins = '1.0'
        if ins:
            self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        ins = w.index('insert')
        sel_i,sel_j = g.app.gui.getTextSelection(w)
        i = w.search('.','insert',stopindex='end')
        ins = i and '%s +1c' % i or 'end'
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                i = w.index('%s + 1 lines' % i)
                if w.index('%s linestart' % i) == w.index('end'):
                    i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                    i = '%s + 1c' % i
                    break
            else:
                i = w.search(r'\w',i,regexp=True,stopindex='end')
                i = '%s' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            s = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if s:
                i = w.index('%s - 1 lines' % i)
                if w.index('%s linestart' % i) == '1.0':
                    i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                    break
            else:
                i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
                i = '%s +1c' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=False)
        if i != j:
            ins = w.index('insert')
            ins = g.choose(ins==i,j,i)
            g.app.gui.setInsertPoint(w,ins)
            g.app.gui.setTextSelection(w,i,j,insert=None)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@-node:ekr.20051217135340:(Revised cursor movement commands and added selection-extension commands)
#@-node:ekr.20051208102436.1:New features
#@+node:ekr.20051217102943:Code changes
#@+node:ekr.20051214125834:(Rewrote cut/copy/paste code)
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20051214125834:(Rewrote cut/copy/paste code)
#@+node:ekr.20051214113546.2:(Revised headline handlers)
#@+node:ekr.20051214125235: What I did
@nocolor

- As before, tree.select always sets tree.revertHeadline.  This is the revert point.

- endEditLabel now simply unselects the widget.  It has *no* responsibility for keeping the headline in synch with p.headString.  This is a major advance in reliability.

- tree.onHeadChanged sets changed = s != oldRevert.  This is more reliable than previously.
#@nonl
#@+node:ekr.20051216085517:Replaced calls to onHeadChanged by calls to c.endEditing
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20050920084036.43:renameBuffer
def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.frame.tree.editLabel(p)
        w = p.edit_widget()
        if w:
            w.delete("1.0","end")
            w.insert("1.0",name)
            c.endEditing()
            ### c.frame.tree.onHeadChanged(p,'rename-buffer %s' % p.headString())
#@nonl
#@-node:ekr.20050920084036.43:renameBuffer
#@-node:ekr.20051216085517:Replaced calls to onHeadChanged by calls to c.endEditing
#@-node:ekr.20051214125235: What I did
#@+node:ekr.20051216084926:Notes
@nocolor

Bug 1: OnActivateBody *must* call onHeadChanged: select is not always called!

But 2: c.endEditing and tree.endEditLabel **must** call tree.onHeadChanged.
#@nonl
#@-node:ekr.20051216084926:Notes
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.128:tree.select
@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
#@nonl
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@nonl
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@nonl
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20051216083932:Calls to tree.endEditLabel
#@+node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):

    self.frame.tree.endEditLabel()
#@-node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20051216083932:Calls to tree.endEditLabel
#@+node:ekr.20051216080913.1:Calls to onHeadChanged
#@+node:ekr.20031218072017.2290:toggleAngleBrackets
def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "<<"
        or s[-2:] == ">>"): # Must be on separate line.
        if s[0:2] == "<<": s = s[2:]
        if s[-2:] == ">>": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')
#@nonl
#@-node:ekr.20031218072017.2290:toggleAngleBrackets
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3983:insertHeadlineTime
def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')
#@nonl
#@-node:ekr.20031218072017.3983:insertHeadlineTime
#@-node:ekr.20051216080913.1:Calls to onHeadChanged
#@+node:ekr.20051216081742:Should *not* call onHeadChanged
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20051216081742:Should *not* call onHeadChanged
#@+node:ekr.20051216125001:(Restored c.begin/endUpdate)
#@+node:ekr.20051216160935:What I did
@nocolor

To do:

- Test abortEditLabelCommand.

- c.redraw() redraws conditionally.
- Create c.xxx methods that call the corresponding c.frame.tree methods.

** Find is not selecting headlines properly.
- Test drags.

What I did:

- Made c.begin/endUpdate and tree.begin/endUpdate functional again.
- Created a script to add c.begin/endUpdate().
- Removed redraw_flag from deleteOutline.
- Tested undo/redo delete node.
- Removed redraw_flag from insertHeadline.
- Removed redraw_flag from onBodyChanged.
- c.redraw_now() redraws undconditionally: it is used seldom.
- Replaced c.redraw_now by c.redraw or c.begin/endUpdate.
- Removed redraw_flag from c.selectPosition, tree.select, tree.onHeadChanged, body.onBodyChanged.

#@-node:ekr.20051216160935:What I did
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2951:c.bringToFront
def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2951:c.bringToFront
#@+node:ekr.20031218072017.2953:c.recolor & requestRecolor
def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True
#@nonl
#@-node:ekr.20031218072017.2953:c.recolor & requestRecolor
#@+node:ekr.20051216171520:c.recolor_now
def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)
#@nonl
#@-node:ekr.20051216171520:c.recolor_now
#@+node:ekr.20031218072017.2954:c.redraw_now
def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    c.setFocusHelper()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw_now
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount <= 0:
        if flag:
            self.redraw_now()
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount")
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            << change the appearance of headlines >>
#@nonl
#@+node:ekr.20040803072955.38:<< change the appearance of headlines >>

# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.38:<< change the appearance of headlines >>
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        << highlight text widget on enter events >>
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@+node:ekr.20040803072955.45:<< highlight text widget on enter events >>
# t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040803072955.45:<< highlight text widget on enter events >>
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155029:@@button insert begin/endUpdate
u = c.undoer ; w = c.frame.body.bodyCtrl

s1 = '''\
    c.beginUpdate()
    try:'''
s2 = '''\
    finally:
        c.endUpdate()'''

b = u.beforeChangeNodeContents(p)

i, j = g.app.gui.getTextSelection(w)
if i != j:
    s = w.get(i,j)
    s = ''.join(['\t'+line for line in g.splitLines(s)])
    w.delete(i,j)
    w.insert(i,s1+'\n'+s+'\n'+s2)
else:
    w.insert(i,s1+'\n\t\t\n'+s2)

c.recolor()
u.afterChangeNodeContents(p,'add-begin/endUpdate',b)
#@nonl
#@-node:ekr.20051216155029:@@button insert begin/endUpdate
#@-node:ekr.20051216125001:(Restored c.begin/endUpdate)
#@-node:ekr.20051214113546.2:(Revised headline handlers)
#@+node:ekr.20051212135654:(Revised key binding code)
No change was actually needed, just new bindings.

What I did:
    
- fixed a bug in copyBindingsToWidget
- textBindingsRedirectionCallback now returns 'break', not None.
#@nonl
#@+node:ekr.20051214082024:Notes
@nocolor

Key bindings

Leo must have commands to do what Tk text widgets do for all their standard bindings.  This is the only way I know of to allow users to choose different bindings for those actions.

Therefore, Leo should pass *no* key events to Tk for 'default' handling.  That is, all of Leo's key handlers will return 'break', not None.  In particular, all text widgets must have something like selfInsertCommand so they can handle ordinary keystrokes.

Typing in headlines *still* does not always stick.  The present event handlers for headlines have way too many paths through them.  The problems are caused in large part by the abort-edit-headline command: it requires state info.  I may add a beginEditHeadline command that will remember the state.  This will allow Leo to save the headline text on *every* keystroke, rather than only at the end.  This is *much* safer than trying to ensure that endEditHeadline gets called on every path.  The new endEditHeadline will have no responsibility for state except to clear the info set by beginEditHeadline.  Nothing much bad will ever happen if endEditHeadline doesn't get called once in a while.

I hope to get all the necessary bindings and commands done this week.

Undo

Undo is well defined only for headlines and body text.  There is little or no use, alas, for event.widget in leoEditCommands.py.  Brian's suggestion of having beginUndo/endUndo markers makes a lot of sense: such markers simplify the code and hide implementation and policy details that should be hidden.

Focus

Getting focus exactly right is crucial: some of the present commands in leoEditCommands.py don't work if they are invoked by their long name rather than from a keystroke.

In short, the combination of bindings, undo and focus creates a lot of problems that must be handled with extreme care.  It's frustrating to rewrite essentially every line of Brian's temacs code, but I believe it must be done.

And we are not done yet.  Leo creates an environment different from Emacs:  incremental search must be expanded to move from node to node, the notion of the 'mark' must be generalized (in some, but not all situations), etc.  Sometimes, though, the generalization is also a simplification: as I have said before, Leo's nodes can and should be treated as exactly synonymous with Emacs's buffers.

Edward
#@+node:ekr.20051213073224:Create commands for all Tk defaults key
#@-node:ekr.20051213073224:Create commands for all Tk defaults key
#@+node:ekr.20051207140933:Create selection mode
#@+node:ekr.20051207140933.1:Posting
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3464605
leouser

You really need to think about using Ctrl-Space for starting selection mode.
Its a wonderful thing.  Once in selection mode you just move around with your
arrows and things get selected.  Or if you want to move quickly you can do stuff
like Ctrl-a or Ctrl-e or Ctrl-< or Ctrl->.  Combining selection mode and fast
movement keystrokes is good...
#@nonl
#@-node:ekr.20051207140933.1:Posting
#@-node:ekr.20051207140933:Create selection mode
#@+node:ekr.20051214075028:Problems
#@+node:ekr.20051213100651:forward-sentence-extend-selection doesn't work when invoked by long name
#@-node:ekr.20051213100651:forward-sentence-extend-selection doesn't work when invoked by long name
#@+node:ekr.20051213100651.1:Backspace  deletes 2 chars everywhere
#@-node:ekr.20051213100651.1:Backspace  deletes 2 chars everywhere
#@-node:ekr.20051214075028:Problems
#@+node:ekr.20051214082024.1:Make arrow keys work properly both in the canvas and in headlines
make the default bindings work differently when editing
the headline as opposed to when traversing the tree with the arrow keys.
#@nonl
#@-node:ekr.20051214082024.1:Make arrow keys work properly both in the canvas and in headlines
#@-node:ekr.20051214082024:Notes
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20050210082320:widget_wants_focus (tk.gui)
def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus
#@nonl
#@-node:ekr.20050210082320:widget_wants_focus (tk.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):

    return t.index("insert")
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange (to be deleted?)
def getSelectionRange (self,t):

    return t.tag_ranges("sel")
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange (to be deleted?)
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, ">", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20050920084036.53:class editCommandsClass
class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others
#@nonl
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.
#@nonl
#@-node:ekr.20050920084036.54: ctor
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')
#@nonl
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,-1)

    if stroke == '<Alt-c>':
        self.capitalizeWord(event)
    elif stroke == '<Alt-u>':
         self.upCaseWord(event)
    elif stroke == '<Alt-l>':
        self.downCaseWord(event)

    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.145:changePreviousWord
#@+node:ekr.20051015114221.1:capitalizeHelper
def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
#@-node:ekr.20051015114221.1:capitalizeHelper
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    << define colors >>
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@nonl
#@-node:ekr.20051019183105.2:<< define colors >>
#@+node:ekr.20051019183105.3:createColorPicker
def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@nonl
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@nonl
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@-node:ekr.20051019183105.3:createColorPicker
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:show-fonts & helpers
def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)
#@nonl
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
#@nonl
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@nonl
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)
#@nonl
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@nonl
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@nonl
#@-node:ekr.20051019201809.7:setFont
#@-node:ekr.20051019201809:show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn
def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 < c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 >= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')
#@nonl
#@-node:ekr.20050920084036.134:indentToCommentColumn
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion
#@+node:ekr.20050920084036.60:dynamicExpansion2
def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@nonl
#@-node:ekr.20050920084036.60:dynamicExpansion2
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@nonl
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@nonl
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@nonl
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20051022142249:focus (editCommandsClass)
#@+node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()
#@nonl
#@-node:ekr.20051022144825:focusToBody/Log/Tree/Minibuffer
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@-node:ekr.20051022142249:focus (editCommandsClass)
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others
#@nonl
#@+node:ekr.20050920084036.67:centerLine
def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) >= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)
#@nonl
#@-node:ekr.20050920084036.67:centerLine
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@nonl
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex <= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) >= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1
#@nonl
#@-node:ekr.20050920084036.69:centerRegion
#@+node:ekr.20050920084036.70:setFillPrefix
def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt
#@nonl
#@-node:ekr.20050920084036.70:setFillPrefix
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@nonl
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20050920084036.74:indent... (To do: undo)
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)
#@nonl
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20050920084036.76:deleteIndentation
def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.76:deleteIndentation
#@+node:ekr.20050920084036.77:insertNewLineIndent
def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
#@-node:ekr.20050920084036.77:insertNewLineIndent
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 < 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) <= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent... (To do: undo)
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
  
    if name.startswith('body'):
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        if i != j:
            w.delete(i,j)
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        c.frame.body.onBodyChanged(undoType='Typing',
            oldSel=oldSel,oldText=oldText,oldYview=None)
    else:
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
#@+node:ekr.20050920084036.87:deleteNextChar (ok)
def deleteNextChar (self,event):

    c = self.c ; w = event.widget

    g.trace(g.app.gui.widget_name(w))
    
    self.beginCommand('delete-char')
    
    i,j = g.app.gui.getTextSelection(w)

    if i != j:
        w.delete(i,j)
    else:
        w.delete(i)
        
    self.endCommand()
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar (ok)
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)
#@nonl
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20050920084036.138:insertNewLine (not undoable)
def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (not undoable)
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)
#@nonl
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
#@nonl
#@-node:ekr.20050920084036.139:insertParentheses
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@nonl
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))
#@nonl
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)
#@nonl
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)
#@nonl
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@nonl
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@nonl
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)
#@nonl
#@-node:ekr.20050920084036.92:linesHelper
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@nonl
#@-node:ekr.20050920084036.147:measure
#@+node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=True)
        spot = w.index(spot) # Capture initial value.
        ins = w.index('insert')
        w.mark_set('insert',spot)
        if extend or self.extendMode:
            if w.compare(spot,'<=',i):
                g.app.gui.setTextSelection (w,spot,j,insert=None)
            else:
                g.app.gui.setTextSelection (w,i,spot,insert=None)
        w.see(spot)
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        if forward:
             ind = w.search('\w','insert',stopindex='end',regexp=True)
             if ind: nind = '%s wordend' % ind
             else:   nind = 'end'
        else:
             ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
             if ind: nind = '%s wordstart' % ind
             else:   nind = '1.0'
        self.moveToHelper(event,nind,extend)
    except Exception:
        pass # w might not be a text widget.
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('(','insert',backwards=True,stopindex='1.0')
        if '' == i: return
    
        icheck = w.search(')','insert',backwards=True,stopindex='1.0')
        if icheck:
            ic = w.compare(i,'<',icheck)
            if ic: return
    
        i2 = w.search(')','insert',stopindex='end')
        if '' == i2: return
    
        i2check = w.search('(','insert',stopindex='end')
        if i2check:
            ic2 = w.compare(i2,'>',i2check)
            if ic2: return
        
        ins = '%s+1c' % i2
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if i:
            i2 = w.search('.',i,backwards=True,stopindex='1.0')
            if i2:
                ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
            else:
                ins = '1.0'
        else:
            ins = '1.0'
        if ins:
            self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        ins = w.index('insert')
        sel_i,sel_j = g.app.gui.getTextSelection(w)
        i = w.search('.','insert',stopindex='end')
        ins = i and '%s +1c' % i or 'end'
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                i = w.index('%s + 1 lines' % i)
                if w.index('%s linestart' % i) == w.index('end'):
                    i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                    i = '%s + 1c' % i
                    break
            else:
                i = w.search(r'\w',i,regexp=True,stopindex='end')
                i = '%s' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            s = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if s:
                i = w.index('%s - 1 lines' % i)
                if w.index('%s linestart' % i) == '1.0':
                    i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                    break
            else:
                i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
                i = '%s +1c' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=False)
        if i != j:
            ins = w.index('insert')
            ins = g.choose(ins==i,j,i)
            g.app.gui.setInsertPoint(w,ins)
            g.app.gui.setTextSelection(w,i,j,insert=None)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@nonl
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()
#@nonl
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
#@nonl
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','>',s2):
            break
        self.fillParagraph(event)
#@nonl
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)
#@nonl
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.98:killParagraph (Test)
def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()
#@nonl
#@-node:ekr.20050920084036.98:killParagraph (Test)
#@+node:ekr.20050920084036.96:selectParagraph & helper
def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break
#@nonl
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)
#@nonl
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:selectParagraph & helper
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@nonl
#@+node:ekr.20050920084036.106:setRegion
def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('<Right>',extend,'+')
    w.bind('<Left>',truncate,'+')
    w.bind('<Up>',up,'+')
    w.bind('<Down>',down,'+')

    return 'break'
#@nonl
#@+node:ekr.20051002102410:down
def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'
#@nonl
#@-node:ekr.20051002102410:down
#@+node:ekr.20051002102410.1:extend
def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

#@-node:ekr.20051002102410.1:extend
#@+node:ekr.20051002102410.2:truncate
def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'
#@nonl
#@-node:ekr.20051002102410.2:truncate
#@+node:ekr.20051002102410.3:up
def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'
#@nonl
#@-node:ekr.20051002102410.3:up
#@-node:ekr.20050920084036.106:setRegion
#@+node:ekr.20050920084036.107:indentRegion
def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('<Key>')
        ### w.update_idletasks()
    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion
#@+node:ekr.20050920084036.108:tabIndentRegion
def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
#@nonl
#@-node:ekr.20050920084036.108:tabIndentRegion
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@nonl
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
#@nonl
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20050920084036.112:replace...
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    prompt = 'Replace ' + g.choose(self._useRegex,'Regex','String')

    if state == 0:
        self.widget = event.widget
        self._sString = self._rpString = ''
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        self._rpString = k.arg ; w = self.widget
        << do the replace >>
        k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
        self._useRegex = False
#@nonl
#@+node:ekr.20050920084036.114:<< do the replace >>
# g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)
#@nonl
#@-node:ekr.20050920084036.114:<< do the replace >>
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20050920084036.115:activateReplaceRegex
def activateReplaceRegex( self ):
    
    '''This method turns regex replace on for replaceString'''

    self._useRegex = True
    return True
#@nonl
#@-node:ekr.20050920084036.115:activateReplaceRegex
#@-node:ekr.20050920084036.112:replace...
#@+node:ekr.20050920084036.116:scrollUp/Down
def scrollDown (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) + chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')

def scrollUp (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) - chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')
#@nonl
#@-node:ekr.20050920084036.116:scrollUp/Down
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i <= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
#@nonl
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.122:transposeLines
def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')
#@nonl
#@-node:ekr.20050920084036.122:transposeLines
#@+node:ekr.20050920084036.123:swapWords & transposeWords
def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'>',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'<',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20050920084036.123:swapWords & transposeWords
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters
#@nonl
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)
#@nonl
#@-node:ekr.20050920084036.126:tabify & untabify
#@-node:ekr.20050920084036.53:class editCommandsClass
#@+node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=True)
        spot = w.index(spot) # Capture initial value.
        ins = w.index('insert')
        w.mark_set('insert',spot)
        if extend or self.extendMode:
            if w.compare(spot,'<=',i):
                g.app.gui.setTextSelection (w,spot,j,insert=None)
            else:
                g.app.gui.setTextSelection (w,i,spot,insert=None)
        w.see(spot)
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        if forward:
             ind = w.search('\w','insert',stopindex='end',regexp=True)
             if ind: nind = '%s wordend' % ind
             else:   nind = 'end'
        else:
             ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
             if ind: nind = '%s wordstart' % ind
             else:   nind = '1.0'
        self.moveToHelper(event,nind,extend)
    except Exception:
        pass # w might not be a text widget.
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('(','insert',backwards=True,stopindex='1.0')
        if '' == i: return
    
        icheck = w.search(')','insert',backwards=True,stopindex='1.0')
        if icheck:
            ic = w.compare(i,'<',icheck)
            if ic: return
    
        i2 = w.search(')','insert',stopindex='end')
        if '' == i2: return
    
        i2check = w.search('(','insert',stopindex='end')
        if i2check:
            ic2 = w.compare(i2,'>',i2check)
            if ic2: return
        
        ins = '%s+1c' % i2
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if i:
            i2 = w.search('.',i,backwards=True,stopindex='1.0')
            if i2:
                ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
            else:
                ins = '1.0'
        else:
            ins = '1.0'
        if ins:
            self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        ins = w.index('insert')
        sel_i,sel_j = g.app.gui.getTextSelection(w)
        i = w.search('.','insert',stopindex='end')
        ins = i and '%s +1c' % i or 'end'
        self.moveToHelper(event,ins,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                i = w.index('%s + 1 lines' % i)
                if w.index('%s linestart' % i) == w.index('end'):
                    i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                    i = '%s + 1c' % i
                    break
            else:
                i = w.search(r'\w',i,regexp=True,stopindex='end')
                i = '%s' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i = w.index('insert')
        while 1:
            s = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if s:
                i = w.index('%s - 1 lines' % i)
                if w.index('%s linestart' % i) == '1.0':
                    i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                    break
            else:
                i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
                i = '%s +1c' % i
                break
        if i:
            self.moveToHelper(event,i,extend)
    except Exception:
        pass  #  w might not be a text widget.
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    try:
        c = self.c ; w = event.widget
        w.update() ; c.frame.widgetWantsFocus(w)
        i,j = g.app.gui.getTextSelection(w,sort=False)
        if i != j:
            ins = w.index('insert')
            ins = g.choose(ins==i,j,i)
            g.app.gui.setInsertPoint(w,ins)
            g.app.gui.setTextSelection(w,i,j,insert=None)
    except Exception:
        pass # w may not be a text widget.
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    w.update() ; c.frame.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move... (leoEditCommands) (ok)
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
  
    if name.startswith('body'):
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        if i != j:
            w.delete(i,j)
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        c.frame.body.onBodyChanged(undoType='Typing',
            oldSel=oldSel,oldText=oldText,oldYview=None)
    else:
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter (ok)
#@+node:ekr.20050920084036.87:deleteNextChar (ok)
def deleteNextChar (self,event):

    c = self.c ; w = event.widget

    g.trace(g.app.gui.widget_name(w))
    
    self.beginCommand('delete-char')
    
    i,j = g.app.gui.getTextSelection(w)

    if i != j:
        w.delete(i,j)
    else:
        w.delete(i)
        
    self.endCommand()
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar (ok)
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)
#@nonl
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20050920084036.138:insertNewLine (not undoable)
def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (not undoable)
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)
#@nonl
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
#@nonl
#@-node:ekr.20050920084036.139:insertParentheses
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20051024102724:tkTtree.setBindings
# New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()
#@nonl
#@-node:ekr.20051024102724:tkTtree.setBindings
#@-node:ekr.20051212135654:(Revised key binding code)
#@+node:ekr.20051214115158:(Revised general text widget handlers)
#@+node:ekr.20051023182326:copyBindingsToWidget & textBindingsRedirectionCallback
def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('<Key>',k.onTextWidgetKey)
#@nonl
#@-node:ekr.20051023182326:copyBindingsToWidget & textBindingsRedirectionCallback
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20051214113546.1:k.onTextWidgetKey & insertString
def onTextWidgetKey (self,event):
    
    '''This is the default key handler for all text widgets.
    It should never be called for keys bound to any command.'''

    ch = event and event.char or ''
    w  = event and event.widget

    if w and ch:
        i,j = g.app.gui.getTextSelection(w)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)

    return 'break'
#@nonl
#@-node:ekr.20051214113546.1:k.onTextWidgetKey & insertString
#@-node:ekr.20051214115158:(Revised general text widget handlers)
#@+node:ekr.20051215111121:(fixed focus problems, again)
@ c.frame.minibufferWantsFocus now does c.frame.body.bodyCtrl.update to force the focus to the body pane.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        # Do an update to force the focus to the body pane.
        self.c.frame.body.bodyCtrl.update()
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'

#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,returnKind=None,returnState=None,handler=None,prefix=None,tabList=None):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        if tabList: k.argTabList = tabList[:]
        else:       k.argTabList = []
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        bodyCtrl.update() # Essential to move focus out of the log pane.
        c.frame.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        if handler: handler(event)
        c.frame.widgetWantsFocus(k.afterArgWidget)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList)
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()

    return 'break'
#@+node:ekr.20050928092516:<< init altX vars >>
# Clear the list, any other character besides tab indicates that a new prefix is in effect.
k.mb_tabList = []

if prefix:
    k.mb_tabListPrefix = prefix
    k.mb_prefix = prefix
    k.mb_prompt = prefix
else:
    k.mb_tabListPrefix = k.mb_prefix = k.getLabel()
    k.mb_prompt = ''
#@nonl
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # But it slows down unit tests and is generally undesirable.
            # Rather than calling update here, we shall call update only when essential.
            w.update() 

        w.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20051215111121:(fixed focus problems, again)
#@+node:ekr.20051217074031:(Moved headline coloring code out of endEditLabel and into select)
#@+node:ekr.20051217082130:What I did
@nocolor

- << unselect the old node >> in tree.select now calls
    self.setUnselectedLabelState(old_p)

- tree.endEditLabel no longer calls setUnselectedLabelState.
    (This is important)
#@nonl
#@-node:ekr.20051217082130:What I did
#@+node:ekr.20040803072955.128:tree.select
@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@-node:ekr.20051217074031:(Moved headline coloring code out of endEditLabel and into select)
#@-node:ekr.20051217102943:Code changes
#@-node:ekr.20051206111317:4.4a5 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
